<h1>Extras</h1>

<div class="anchor-navi-container">
  <div *ngFor="let mainButton of anchorButtons" class="btn-group">
    <button type="button" class="btn btn-primary btn-sm anchor" (click)="scrollToAnchor(mainButton?.anchor)">
      {{ mainButton.title }}
    </button>
    <button *ngIf="mainButton?.subtitles?.length" type="button"
      class="btn btn-primary dropdown-toggle dropdown-toggle-split btn-sm anchor" data-bs-toggle="dropdown"
      aria-expanded="false">
    </button>
    <ul *ngIf="mainButton.subtitles?.length" class="dropdown-menu dropdown-menu-dark">
      <li>
        <button *ngFor="let subButton of mainButton?.subtitles" class="dropdown-item"
          (click)="scrollToAnchor(subButton?.anchor)">
          {{ subButton?.title }}
        </button>
      </li>
    </ul>
  </div>
</div>

<div>
  <h3 #scrollpositionrestoration data-anchor="scrollpositionrestoration">scrollPositionRestoration</h3>
  <ul>
    <li>Navigálás közben, ha nem akarjuk, hogy minden oldalon az oldal tetejére ugorjunk, akkor az
      app-routingmodulets
      fájlban szükséges a scrollPositionRestoration: 'enabled'-re állítani
      <pre>
  @NgModule(&#123;
    imports: [RouterModuleforRoot(routes, &#123;
      scrollPositionRestoration: 'enabled'
    &#125;)],
    exports: [RouterModule]
  &#125;)
      </pre>
    </li>
  </ul>
</div>

<div>
  <h3 #dependencyinjection data-anchor="dependencyinjection">Dependency Injection (private/public/protected)</h3>
  <ul>
    <li>Külső forrásból injektált objektum, amit az osztály használni tud</li>
    <li>private/public/protected
      <ul>
        <li>private
          <ul>
            <li>Az injektált szolgáltatás csak az osztályon belül érhető el</li>
            <li>Osztályon kívül, pl más osztályban, vagy a sablonban (html) nem elérhető</li>
          </ul>
        </li>
        <li>public
          <ul>
            <li>Az injektált szolgáltatás nem csak az osztályon belül érhető el</li>
            <li>Osztályon kívül, pl más osztályban, vagy a sablonban (html) is elérhető</li>
          </ul>
        </li>
        <li>protected
          <ul>
            <li>Az injektált szolgáltatás az osztályon belül és az osztály leszármazottai (al-osztályok) számára
              érhető el
            </li>
            <li>A sablonban (html), és más, nem leszármazott osztályokban nem elérhető</li>
            <pre>
  export class DerivedComponent extends BaseComponent implements OnInit &#123;
  serviceMessage: string;

  ngOnInit() &#123;
      thisserviceMessage = thisgetServiceMessage();
    &#125;
  &#125;
            </pre>
          </ul>
        </li>
        <li>A fentieket egyébként access modifier-nek hívják</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #modulewithrouting data-anchor="modulewithrouting">Create module with routing</h3>
  <ul>
    <li>ng g m module-name --routing</li>
    <li>Route in parent module</li>
    <pre>
  &#123;
    path: 'spa',
    loadChildren: () => import('/single-page-app/single-page-appmodule')then(m => mSinglePageAppModule)
  &#125;,
    </pre>
    <li>Route in new module</li>
    <pre>
  const routes: Routes = [
      &#123;path: '', component: SinglePageAppComponent&#125;,
  ];
    </pre>
  </ul>
</div>

<div>
  <h3 #functioninputoutputtypes data-anchor="functioninputoutputtypes">Function input-output type declaration</h3>
  <ul>
    <li>
      <pre>
  scroll(target: HTMLElement): any &#123; // A zárójelben a bemeneti típus, utána a visszatérési érték típusa
    consolelog(target);
    return targetscrollIntoView(&#123;behavior: 'smooth'});
  }
      </pre>
    </li>
  </ul>
</div>

<div>
  <h3 #ngiffunctioncall data-anchor="ngiffunctioncall">ngIf function call</h3>
  <ul>
    <li>Ha feltételben meghívunk egy függvényt, aminek van visszatérési értéke, akkor az 'as &#60;variable> opcióval
      kiírhatjuk a visszatérési értéket, értékeket</li>
    <pre>
  &#60;div *ngIf="testFunction('ABC', '123') as obj">
    &#123; &#123; objvariable1 }} / &#123; &#123; objvariable2 }}
  &#60;/div>

  testFunction(variable1: string, variable2: string) &#123;
    return &#123;variable1, variable2};
  }
      </pre>
  </ul>
</div>

<div>
  <h3 #ngswitchnote data-anchor="ngswitchnote">ngSwitch note</h3>
  <ul>
    <li>Amennyiben az ngSwitch attribútum direktívának nem boolean mezőt adunk, úgy a lenti (helyes) működéshez át kell
      alakítanunk boolean értékre:
    </li>
    <pre>
  &#60;div [ngSwitch]="!!hasText">
    &#60;div *ngSwitchCase="true">
      A változó tartalmaz szöveget
    &#60;/div>
    &#60;div *ngSwitchCase="false">
      A változó nem tartalmaz szöveget
    &#60;/div>
&#60;/div>
    </pre>
  </ul>
</div>

<div>
  <h3 #prtoceduralvsreactivethinking data-anchor="prtoceduralvsreactivethinking">Procedural vs reactive thinking</h3>
  <div
    style="background-color: floralwhite; border: 2px solid saddlebrown; border-radius: 5px;color: black; padding: 10px; overflow: auto">
    <small>Procedural</small>
    <ng-container>
      <div *ngIf="isLoading; else list"
        style="background-color: rgba(100, 100, 100, 0.5);display: flex;align-items: center;justify-content: center">
        LOADING
      </div>
      <ng-template #list>
        <div style="display: flex; align-items: center; gap: 20px; justify-content: space-between">
          <h4 *ngIf="elems.length > 0; else noElems">{{ elems.length }} elem(s) exist(s)</h4>
          <span>
            <button [disabled]="elemLocalDeletion" (click)="elemLocalDeletion = !elemLocalDeletion">
              Local delete
            </button>
            <button [disabled]="!elemLocalDeletion" (click)="elemLocalDeletion = !elemLocalDeletion">
              API delete
            </button>
          </span>
        </div>

        <div *ngFor=" let elem of elems; let last=last; let i=index" style="display: flex;gap: 10px;">
          <span>
            {{ i + 1 }}. {{ elem }}
          </span>
          <span class="trash" (click)="elemLocalDeletion ? removeElem(i) : removeAPIelem(i)"></span>
          <hr *ngIf="!last">
        </div>

        <form *ngIf="elems.length < 5; else elemsLengthReachedMax"
          (submit)="elemLocalDeletion ? newElem($event) : newAPIElem($event)">
          <input #formInput name="title" value="" ngModel placeholder="New elem">
          <button type="submit" [disabled]="formInput.value === ''">Send</button>
        </form>

      </ng-template>
    </ng-container>
  </div>

  <ng-template #elemsLengthReachedMax>
    <h5>Max length of elems reached!</h5>
  </ng-template>

  <ng-template #noElems>
    <h4>Create an elem!</h4>
  </ng-template>

  <br>

  <!--ng-container *ngIf="isLoadingReactive$ | async as isLoadingReactive"-->
  <div *ngIf="elemsReactive$ | async as elemsReactive"
    style="background-color: floralwhite; border: 2px solid saddlebrown; border-radius: 5px;color: black; padding: 10px; overflow: auto">
    <small>Reactive</small>
    <ng-container *ngIf="isLoadingReactive$ | async; else listAlt">
      <div style="background-color: rgba(100, 100, 100, 0.5);display: flex;align-items: center;justify-content: center">
        LOADING
      </div>
    </ng-container>

    <ng-template #listAlt>
      <div style="display: flex; align-items: center; gap: 20px; justify-content: space-between">
        <h4 *ngIf="elemsReactive.length > 0; else noElemsReactive">
          {{ elemsReactive.length }} elem(s) exist(s)
        </h4>
        <span>
          <button [disabled]="true">
            API delete
          </button>
        </span>
      </div>

      <div *ngFor="let elem of elemsReactive; let last=last; let i=index" style="display: flex;gap: 10px;">
        <span>
          {{ i + 1 }}. {{ elem }}
        </span>
        <span class="trash" (click)="removeElemReactive(i)"></span>
        <hr *ngIf="!last">
      </div>

      <form *ngIf="elems.length < 5; else elemsLengthReachedMaxReactive" (submit)="newElemReactive($event)">
        <input #formInput name="title" value="" ngModel placeholder="New elem">
        <button type="submit" [disabled]="formInput.value === ''">Send</button>
      </form>
    </ng-template>
  </div>
  <!--/ng-container-->

  <ng-template #elemsLengthReachedMaxReactive>
    <h5>Max length of elems reached!</h5>
  </ng-template>

  <ng-template #noElemsReactive>
    <h4>Create an elem!</h4>
  </ng-template>

  <br>

  <h5>Procedural</h5>
  <pre>
  &#60;ng-container>
    &#60;div *ngIf="isLoading; else list">
      LOADING
    &#60;/div>

    &#60;ng-template #list>
      &#60;div>
        &#60;h4 *ngIf="elems.length > 0; else noElems">&#123; &#123; elems.length }} elem(s) exist(s)&#60;/h4>
        &#60;span>
          &#60;button [disabled]="elemLocalDeletion" (click)="elemLocalDeletion = !elemLocalDeletion">
            Local delete
          &#60;/button>
          &#60;button [disabled]="!elemLocalDeletion" (click)="elemLocalDeletion = !elemLocalDeletion">
            API delete
          &#60;/button>
        &#60;/span>
      &#60;/div>

      &#60;div *ngFor=" let elem of elems; let last=last; let i=index" style="display: flex;gap: 10px;">
        &#60;span>
          &#123; &#123; i + 1 }}. &#123; &#123; elem }}
        &#60;/span>
        &#60;span class="trash" (click)="elemLocalDeletion ? removeElem(i) : removeAPIelem(i)">&#60;/span>
        &#60;hr *ngIf="!last">
      &#60;/div>

      &#60;form *ngIf="elems.length &#60; 5; else elemsLengthReachedMax"
        (submit)="elemLocalDeletion ? newElem($event) : newAPIElem($event)">
        &#60;input #formInput name="title" value="" ngModel placeholder="New elem">
        &#60;button type="submit" [disabled]="formInput.value === ''">Send&#60;/button>
      &#60;/form>
    &#60;/ng-template>

  &#60;/ng-container>

  &#60;ng-template #elemsLengthReachedMaxReactive>
    &#60;h5>Max length of elems reached!&#60;/h5>
  &#60;/ng-template>

  &#60;ng-template #noElemsReactive>
    &#60;h4>Create an elem!&#60;/h4>
  &#60;/ng-template>

  elems: string[] = [];

  ngOnInit() &#123;
    this.getContent();
  }

  getContent() &#123;
    this.isLoading = true;
    fetch('https://kodbazis.hu/api/cimek')
      .then(res => res)
      .then(data => &#123;
        console.log(data);
        return data.json();
      })
      .then(content => &#123;
        console.log(content);
        this.elems = content;
      })
      .catch(error => &#123;
        console.error('Hiba történt:', error);
      })
      .finally(() => &#123;
        this.isLoading = false;
      });
  }

  newElem(event: any) &#123;
    event.preventDefault();
    console.log(event.target.elements.title.value);
    const newElem = event.target.elements.title.value;
    this.elems.push(newElem);
    event.target.reset();
  }

  newAPIElem(event: any) &#123;
    event.preventDefault();
    this.isLoading = true;
    console.log(event.target.elements.title.value);
    const newElem = event.target.elements.title.value;
    fetch('https://kodbazis.hu/api/cimek', &#123;
      method: 'POST',
      body: JSON.stringify(&#123;cim: (newElem)})
    })
      .then(() => &#123;
        this.getContent();
      });
    event.target.reset();
  }

  removeElem(index: number) &#123;
    this.elems.splice(index, 1);
  }

  removeAPIelem(index: number) &#123;
    this.isLoading = true;
    fetch('https://kodbazis.hu/api/cimek/' + index, &#123;method: 'DELETE'})
      .then(() => &#123;
        this.getContent();
      });
  }
</pre>

  <br>

  <h5>Reactive</h5>
  <pre>
  &#60;div *ngIf="elemsReactive$ | async as elemsReactive">
    &#60;small>REAKTÍV&#60;/small>
    &#60;ng-container *ngIf="isLoadingReactive$ | async; else listAlt">
      &#60;div>
        LOADING
      &#60;/div>
    &#60;/ng-container>

    &#60;ng-template #listAlt>
      &#60;div>
        &#60;h4 *ngIf="elemsReactive.length > 0; else noElemsReactive">
          &#123; &#123; elemsReactive.length }} elem(s) exist(s)
        &#60;/h4>
        &#60;span>
          &#60;button [disabled]="true">
            API delete
          &#60;/button>
        &#60;/span>
      &#60;/div>

      &#60;div *ngFor="let elem of elemsReactive; let last=last; let i=index">
        &#60;span>
          &#123; &#123; i + 1 }}. &#123; &#123; elem }}
        &#60;/span>
        &#60;span class="trash" (click)="removeElemReactive(i)">&#60;/span>
        &#60;hr *ngIf="!last">
      &#60;/div>

      &#60;form *ngIf="elems.length &#60; 5; else elemsLengthReachedMaxReactive" (submit)="newElemReactive($event)">
        &#60;input #formInput name="title" value="" ngModel placeholder="New elem">
        &#60;button type="submit" [disabled]="formInput.value === ''">Send&#60;/button>
      &#60;/form>
    &#60;/ng-template>
  &#60;/div>

  &#60;ng-template #elemsLengthReachedMaxReactive>
    &#60;h5>Max length of elems reached!&#60;/h5>
  &#60;/ng-template>

  &#60;ng-template #noElemsReactive>
    &#60;h4>Create an elem!&#60;/h4>
  &#60;/ng-template>

  isLoadingReactive$ = new BehaviorSubject&#60;boolean>(true);

  refresh$ = new Subject().pipe(
    tap(() => &#123;
      this.isLoadingReactive$.next(true);
    }),
    switchMap(() => this.http.get('https://kodbazis.hu/api/cimek')),
    catchError((err) => of([])),
    tap((response) => &#123;
      this.isLoadingReactive$.next(false);
      this.elemsReactive$.next(response as string[]);
      console.log('http: ', response);
    })
  );

  delete$ = new Subject().pipe(
    tap(() => &#123;
      this.isLoadingReactive$.next(true);
    }),
    switchMap(index => this.http.delete(`https://kodbazis.hu/api/cimek/$&#123;index}`)),
    tap(() => &#123;
        // @ts-ignore
        this.refresh$.next("");
      }
    )
  );

  create$ = new Subject().pipe(
    tap(() => &#123;
      this.isLoadingReactive$.next(true);
    }),
    switchMap((input) => this.http.post(`https://kodbazis.hu/api/cimek`, &#123;cim: input})),
    tap(() => &#123;
        // @ts-ignore
        this.refresh$.next("");
      }
    )
  )

  subscriptions: Subscription[] = [];

  ngAfterViewInit() &#123; // ngOnInit helyett
    const refreshSub = this.refresh$.subscribe();
    const deleteSub = this.delete$.subscribe();
    const createSub = this.create$.subscribe();
    this.subscriptions = [...this.subscriptions, refreshSub, deleteSub, createSub];
    // @ts-ignore
    this.refresh$.next();
  }

  removeElemReactive(index: number) &#123;
    // @ts-ignore
    this.delete$.next(index);
  }

  newElemReactive(e: any) &#123;
    e.preventDefault();
    const newValue = e.target.elements.title.value;
    // @ts-ignore
    this.create$.next(newValue);
  }

  ngOnDestroy() &#123;
    for (let subscription of this.subscriptions) &#123;
      subscription.unsubscribe();
    }
  }
</pre>
</div>

<div>
  <h3 #locale data-anchor="locale">Locale</h3>
  <ul>
    <pre>
  <b>// settings.service.ts</b>
  @Injectable(&#123;
    providedIn: 'root'
  })
  export class SettingsService &#123;
  
      setLocale(language: string) &#123;
          localStorage.setItem('language', language);
          window.location.reload();
      }
  
      getLocale(): string &#123;
          return localStorage.getItem('language') || 'hu-HU';
      }
  }

  <b>// app.module.ts</b>
  import localeHu from '@angular/common/locales/hu';

  registerLocaleData(localeHu);

  @NgModule(&#123;
    ...
    providers: [
    &#123;
        provide: LOCALE_ID,
        deps: [SettingsService],
        useFactory: (settingsService: SettingsService) => settingsService.getLocale()
      }
    ],
  })
    </pre>
    <li>A LOCALE_ID-val központi locale-t állíthatunk be az egész alkalmazásra
      <ul>
        <li>Lokalizációs azonosító, ami a formátumok (dátum, számok, pénznemek stb.) helyi szabványainak beállítására
          szolgál az alkalmazás szintjén.</li>
        <li>A LOCALE_ID használatával az Angular megérti, hogy milyen lokalizációs beállításokat alkalmazzon az egész
          alkalmazásban</li>
        <li>a különböző formátumokat, például dátumokat, számokat és pénznemeket az adott LOCALE_ID alapján állítja be,
          és az Angular pipe-ok(DatePipe, CurrencyPipe, stb.) automatikusan a megadott locale-nak megfelelő formátumot
          fogják használni.</li>
      </ul>
    </li>
    <li>A fenti példakódban egy szolgáltatáson keresztül határozzuk meg a locale értékét</li>
    <li>Locale frissítéséhez újra kell tölteni az alkalmazást</li>
    <li>Akkor érdemes használni, ha többnyelvű alkalmazást fejlesztünk
      <ul>
        <li>Vagy mondjuk csak simán a saját lokációnkra szeretnénk szabni a formázásokat</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #restandspreadoperator data-anchor="restandspreadoperator">Rest operator</h3>
  <ul>
    <li>Ugyanúgy a ... szintaxissal használjuk őket, de eltérő módon</li>
    <li>Rest operator
      <ul>
        <li>A rest operátor (...) több értéket gyűjt össze egyetlen tömbbe vagy objektumba
          <ul>
            <li>Egy függvénynek több paramétert adunk át, illetve amikor egy objektum vagy tömb elemeit szeretnénk egy
              egységes struktúrába foglalni</li>
            <li>Különösen akkor hasznos, ha nem tudjuk előre a paraméterek számát, vagy csak bizonyos elemeket akarunk
              kiválasztani egy összetettebb struktúrából</li>
          </ul>
        </li>
        <li>A rest operátort gyakran használják függvények paraméterlistájában, ahol a paraméterek fennmaradó részét egy
          tömbbe gyűjti össze</li>
        <pre>
  function sum(...numbers) &#123;
    return numbers.reduce((total, num) => total + num, 0);
  }
  
  console.log(sum(1, 2, 3, 4)); // 10      
        </pre>
        <li>A rest operátorral objektumok és tömbök részeit különválaszthatjuk egy változónak, míg a többi elemet egy
          másik
          változóban gyűjtjük össze</li>
        <pre>
  <b>// object</b>
  const person = &#123; name: "Alice", age: 30, city: "Paris" };
  const &#123; name, ...rest } = person;

  console.log(name); // "Alice"
  console.log(rest); // &#123; age: 30, city: "Paris" }

  <b>// array</b>
  const numbers = [1, 2, 3, 4, 5];
  const [first, second, ...rest] = numbers;

  console.log(first);  // 1
  console.log(second); // 2
  console.log(rest);   // [3, 4, 5]
        </pre>
      </ul>
    </li>
    <li>Spread operator
      <ul>
        <li>Egy tömb vagy objektum elemeinek kiterjesztésére szolgál
          <ul>
            <li>egyes elemeket különálló elemekként "teríti ki"</li>
          </ul>
        </li>
        <li>Másolatok készítéséhez, elemek összefűzéséhez használjuk</li>
        <pre>
  <b>// tömb egyesítés</b>
  const array1 = [1, 2];
  const array2 = [3, 4];
  const combined = [...array1, ...array2];
  console.log(combined); // [1, 2, 3, 4]

  <b>// objektum másolás és egyesítés</b>
  const obj1 = &#123; a: 1, b: 2 };
  const obj2 = &#123; c: 3 };
  const combinedObj = &#123; ...obj1, ...obj2 };
  console.log(combinedObj); // &#123; a: 1, b: 2, c: 3 }
        </pre>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #shallowanddeepcopy data-anchor="shallowanddeepcopy">Shallow and deep copy</h3>
  <ul>
    <li>Objektumok másolásának két különböző módja, amelyek abban különböznek, hogy milyen mélységig másolják le az
      objektum struktúráját és annak beágyazott elemeit
      <ul>
        <li>A tömbök is objektumok JavaScript-ben</li>
      </ul>
    </li>
  </ul>
  <ol>
    <li>Shallow copy
      <ul>
        <li>Egy objektum első szintjét másolja le, de nem hoz létre külön példányokat a beágyazott objektumokról vagy
          tömbökről
          <ul>
            <li>Az eredeti objektum és a másolat is ugyanazokra a beágyazott objektumokra mutat</li>
            <li>Ha a beágyazott objektumokat vagy tömböket módosítjuk, akkor ezek a változások mind az eredeti, mind a
              másolatban megjelennek</li>
          </ul>
        </li>
        <li>Az Object.assign() metódus, illetve a spread operátor (...), amikor csak az első szinten történik másolás
        </li>
        <pre>
  const original = &#123; a: 1, b: &#123; c: 2 } };
  const shallowCopy = &#123; ...original };

  shallowCopy.b.c = 3;
  console.log(original.b.c); // 3, mert a másolatban lévő `b` objektum az eredetire mutat
        </pre>
      </ul>
    </li>
    <li>Deep copy
      <ul>
        <li>Az objektum minden szintjét lemásolja, tehát az eredeti objektumtól független, teljesen új példányokat hoz
          létre minden beágyazott objektumról és tömbről is
          <ul>
            <li>Az eredeti és a másolat egymástól teljesen függetlenek lesznek, így a másolat módosítása nem fogja
              befolyásolni az eredeti objektumot</li>
          </ul>
        </li>
        <li>Használhatjuk a structuredClone() metódust, illetve könyvtárakat, mint például a lodash (cloneDeep
          metódus)</li>
        <li>Alternatívaként JSON-alapú deep copy is használható</li>
        <pre>
  const original = &#123; a: 1, b: &#123; c: 2 } };
  const deepCopy = JSON.parse(JSON.stringify(original)); // JSON-alapú deep copy

  deepCopy.b.c = 3;
  console.log(original.b.c); // 2, mert a deep copy független másolatot hozott létre
        </pre>
      </ul>
    </li>
  </ol>
  <ul>
    <li>Ha csak egy egyszerű, nem beágyazott objektumot másolunk, a shallow copy általában elegendő</li>
  </ul>
</div>

<div>
  <h3 #datamodel data-anchor="datamodel">Data model</h3>
  <ul>
    <li>Az alábbi két class lényegében ugyanaz
      <ul>
        <li>Mindkettő ugyanazokat a mezőket és konstruktorparamétereket definiálja</li>
      </ul>
    </li>
    <pre>
  <b>// Class 1</b>
  export class Task &#123;
    name: string = '';
    description: string = '';
    user: string = '';
    date: string = '';
    priority: string = '';
    status: string = '';

    constructor(name: string, description: string, user: string, date: string, priority: string, status: string) &#123;
        this.name = name;
        this.description = description;
        this.user = user;
        this.date = date;
        this.priority = priority;
        this.status = status;
    }
  }

  <b>// Class 2</b>
  export class Task &#123;
    constructor(
        public name: string,
        public description: string,
        public user: string,
        public date: string,
        public priority: string,
        public status: string
    ) &#123;}
  }
    </pre>
    <li>Class 1
      <ul>
        <li>Külön deklarálja a property-ket az osztályon belül</li>
        <li>A property-k alapértelmezett értékeket kapnak (üres string), mielőtt a konstruktorban felülírnánk őket</li>
        <li>Hosszabb, de explicitebb, könnyebben érthető</li>
        <li>Amennyiben szükséges alapértelmezett deklaráció, ezt érdemes használni</li>
      </ul>
    </li>
    <li>Class 2
      <ul>
        <li>A public módosítóval a konstruktor paraméterei automatikusan az osztály property-jeivé válnak</li>
        <li>Rövidebb</li>
        <li>Kevésbé részletes, de kompaktabb, elegánsabb</li>
        <li>Amennyiben nem szükséges alapértelmezett deklaráció, ezt érdemes használni</li>
      </ul>
    </li>
    <li>Az osztály egyszerre szolgál típusként, és példányosítható konstrukcióként, az interfészt kizárólag
      típusdefinícióként használjuk
      <ul>
        <li>Objektumokat hozhatunk létre a new kulcsszóval</li>
        <pre>
  const newTask = new Task(
    'Example Task',
    'This is a description.',
    'John Doe',
    '2024-12-01',
    'high',
    'open'
  )
        </pre>
        <li>Típusellenőrzésre is alkalmazható</li>
        <pre>
  printTask(task: Task): void &#123;
    console.log(task.name);
  }
        </pre>
      </ul>
    </li>
    <li>Az interfészt csak típusdefinícióra használjuk
      <ul>
        <li>Nem példányosítható</li>
        <pre>
  interface Task &#123;
    name: string;
    description: string;
    user: string;
    date: string;
    priority: string;
    status: string;
  }

  function printTask(task: Task): void &#123;
    console.log(task.name);
  }
        </pre>
      </ul>
    </li>
    <li>Lehetőség szerint ne használjunk osztály abban az esetben, ha csak típusdefinícióra van szükségünk
      <ul>
        <li>A TypeScript fordító a JavaScript kimenetbe belegenerálja az osztályt</li>
        <li>Interfész használatakor viszont ez nem történik meg</li>
      </ul>
    </li>
    <li>Opcionális definiálhatóság</li>
    <pre>
  <b>// class</b>
  export class Task &#123;
    constructor(
        public name: string,
        public description: string,
        public user: string,
        public date: string,
        public priority: string,
        public status: string,
        public id?: string) &#123; // az id opcionális
    }
  }

  // Új példány létrehozása:
  const task1 = new Task('New Task', 'This is a description', 'John Doe', '2024-12-01', 'high', 'open');
  const task2 = new Task('Another Task', 'Another description', 'Jane Doe', '2024-12-02', 'medium', 'in progress', '12345');

  <b>// interface</b>
  export interface Task &#123;
      id?: string; // opcionális
      name: string;
      description: string;
      user: string;
      date: string;
      priority: string;
      status: string;
  }
    </pre>
    <li>A Javascript és a Typescript class eltér egymástól
      <ul>
        <li>Javascript class
          <ul>
            <li>"Csak" egy eszköz objektumok létrehozására</li>
            <pre>
  class Task &#123;
    constructor(name) &#123;
      this.name = name;
    }
  }

  const firstTask = new Task(""); // létrehoztunk egy objektumot
  console.log(firstTask.name);

  ↓↓↓↓↓

  "Kivinni a szemetet"

  let taskType = Task; // Ez egy változó, ami az osztályra mutat, de nem "típus"
            </pre>
            <li>JavaScript-ben nincs statikus típusellenőrzés, így a következő is gond nélkül lefut</li>
            <pre>
  let firstTask = Task; // a firstTask a Task konstruktorra mutat

  const taskInstance = new firstTask("Felporszívózni"); // teljesen megegyezik a new Task("Felporszívózni") kóddal

  firstTask = "Nem fogunk hibát kapni!";

  console.log(firstTask);

  ↓↓↓↓↓

  "Nem fogunk hibát kapni!"
            </pre>
            <li>JavaScript-ben minden osztály egy konstruktorfüggvény a háttérben</li>
          </ul>
        </li>
        <br>
        <li>Typescript class
          <ul>
            <li>Objektum létrehozásán kívül típusként is funkcionál</li>
            <pre>
              class Task &#123;
                name: string;
                constructor(name: string) &#123;
                  this.name = name;
                }
              }

              const firstTask = new Task("Meglocsolni a növényeket); // létrehoztunk egy objektumot
              let secondTask: Task; // típust definiáltunk, nem példányosítottunk

              secondTask = &#123; name: "Elmosogatni" }; // megfelelünk a Task típusnak
              secondTask = &#123; title: "Port törölni" }; // hibát kapunk, mert name helyett a title kulcsot használjuk
            </pre>
            <li>Azzal, hogy típust adunk a változónak, a Task osztály referenciáját eltároljuk a secondTask változóban
              <ul>
                <li>A Task egy osztály, ami JavaScript-ben valójában egy függvény a háttérben</li>
                <li>A secondTask változó innentől kezdve a Task osztályra mutat, tehát használhatjuk
                  (például) példányosításra
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #environment data-anchor="environment">Environment</h3>
  <ul>
    <li>Környezeti változók kezelésére szolgál</li>
    <li>A környezeti beállításokat általában az alkalmazás különböző futtatási környezetekhez, például fejlesztési,
      tesztelési vagy éles környezetekhez igazítják</li>
    <li>Az Angular projektben az environment fájlok segítségével könnyen kezelhetjük ezeket a változókat</li>
    <li>Az alapértelmezetten két környezeti fájl
      <ol>
        <li>environment.ts
          <ul>
            <li>Fejlesztési környezethez használatos fájl, amelyet a fejlesztési ciklus során használunk</li>
            <pre>
  export const environment = &#123;
    production: false,
    apiUrl: 'https://dev-api.page.com'
  };              
            </pre>
          </ul>
        </li>
        <li>environment.prod.ts
          <ul>
            <li>Éles környezethez használatos fájl, amelyet a produkciós build során alkalmazunk</li>
            <pre>
  export const environment = &#123;
    production: true,
    apiUrl: 'https://api.page.com'
  };              
            </pre>
          </ul>
        </li>
      </ol>
    </li>
    <li>A fájlok a src/environments/ mappában találhatóak</li>
    <li>Használata
      <ul>
        <pre>
  import &#123; environment } from '../environments/environment';

  console.log(environment.apiUrl);
        </pre>
        <li>Fejlesztési környezetben 'https://dev-api.page.com', éles környezetben pedig 'https://api.example.com'</li>
      </ul>
    </li>
    <li>Az Angular CLI automatikusan cseréli a környezeti fájlokat a build folyamat során
      <ul>
        <li>Prod build (ng build --prod) esetében az environment.prod.ts fájlt fogja használni az environment.ts helyett
        </li>
      </ul>
    </li>
    <li>Nem titkos adat, mivel a környezeti fájlok a végső JavaScript kódban is elérhetők lesznek
      <ul>
        <li>Az érzékeny adatokat backend oldalon tároljuk</li>
      </ul>
    </li>
    <li>A környezeti fájlokban meg kell egyezniük a kulcsoknak (például production, apiUrl) az egyes fájlokban</li>
  </ul>
</div>

<div>
  <h3 #authenticationandauthorization data-anchor="authenticationandauthorization">Authentication & authorization</h3>
  <ul>
    <li>Authentication
      <ul>
        <li>Hitelesítés</li>
        <li>Ellenőrzése, hogy valaki valóban az, akinek mondja magát</li>
        <li>Az első lépés egy rendszerhez való hozzáférés biztosításakor</li>
        <li>Pl. bejelentkezés egy weboldalra felhasználónévvel, és jelszóval</li>
      </ul>
    </li>
    <li>Authorization
      <ul>
        <li>Engedélyezés</li>
        <li>Célja annak meghatározása, hogy egy hitelesített felhasználónak milyen jogosultságai vannak az adott
          rendszerben</li>
        <li>Pl. a felhasználó hozzáférhet bizonyos oldalakhoz, másokhoz pedig nem</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #throwerror data-anchor="throwerror">throwError</h3>
  <ul>
    <pre>
  API.CALL
  .pipe(
    catchError((err) => &#123;
      return throwError(() => 'Email address already registered.');
    })
  );

  FUNCTION.CALL
  .subscribe(&#123;
    next: (val) => &#123; },
    error: (err) => &#123;
      console.log(err); // Email address already registered.
    }
  });
    </pre>
    <li>Közvetlenül egy string-et vagy más típusú értéket ad vissza</li>
    <li>Abban az esetben jő megoldás, ha pl. stringet szeretnénk feldoolgozni</li>
    <pre>
  API.CALL
  .pipe(
    catchError((err) => &#123;
      return throwError(() => new Error('Email address already registered.'));
    })
  );

  FUNCTION.CALL
  .subscribe(&#123;
    next: (val) => &#123; },
    error: (err) => &#123;
      console.log(err); // Error: Email address already registered. at auth-firebase.service.ts:46:34
      console.log(err.message); // Email address already registered.
    }
  });
    </pre>
    <li>Error objektumot hoz létre, amiben van egy message kulcs is</li>
    <li>szabványosabb megoldás JavaScript-ben/TypeScript-ben, különösen akkor, ha a hiba továbbadása során az Error
      objektumok mezőit (pl. name, stack, vagy message) szeretnénk használni</li>
    <li>Az Error objektum segít az egyértelmű hibakezelésben, különösen komplex alkalmazásokban</li>
  </ul>
</div>

<div>
  <h3 #angularperformanceincrease data-anchor="angularperformanceincrease">Angular performance increase</h3>
  <ol>
    <li>Tree Shaking
      <ul>
        <li>Csak azokat a kódokat tartalmazza a build, amelyeket ténylegesen használnak</li>
        <li>Az Angular CLI automatikusan támogatja a tree shaking-et, ha az alkalmazás modulárisan van felépítve
        </li>
        <li>Ne importáljunk teljes modulokat, ha csak egy részükre van szükség</li>
        <pre>
  // Rossz
  import * as _ from 'lodash';

  // Jó
  import &#123; debounce } from 'lodash';
        </pre>
        <li>Érdemes a szükségtelen, le nem futó kódokat kiszedni</li>
        <li>Csak azokat a könyvtárakat telepítsük és importáljuk, amelyekre ténylegesen szükség van</li>
        <li>Ne húzzunk be nagy könyvtárakat, ha csak egy kis részüket használjuk</li>
      </ul>
    </li>
    <li>Feature Module-ok használata
      <ul>
        <li>A nagyobb modulokat bontsd kisebb, funkcióalapú modulokra</li>
      </ul>
    </li>
    <li>SharedModule helyes használata
      <ul>
        <li>Csak azokat a komponenseket, direktívákat és pipe-okat oszd meg, amelyek valóban szükségesek több helyen
        </li>
      </ul>
    </li>
    <li>OnPush Change Detection
      <ul>
        <li>Alapértelmezésben az Angular minden változásra lefuttatja a teljes change detection ciklust</li>
        <li>Az ChangeDetectionStrategy.OnPush beállítása azt mondja az Angularnak, hogy csak akkor végezzen
          változásfigyelést, ha az input értékei megváltoznak</li>
      </ul>
    </li>
    <li>TrackBy használata *ngFor esetén
      <ul>
        <li>Nagy listák esetén az ngFor-hoz adjunk meg egy trackBy függvényt, hogy az Angular csak a változott
          elemeket
          renderelje újra</li>
      </ul>
    </li>
    <li>Component-Level Lazy Loading
      <ul>
        <li>Nem csak modulokat, hanem egyes komponenseket is betölthetünk aszinkron módon a loadComponent
          segítségével</li>
        <pre>
  @Component(&#123;
    selector: 'app-root',
    template: '&#60;ng-container *ngComponentOutlet="lazyComponent">&#60;/ng-container>',
  })
  export class AppComponent &#123;
    lazyComponent = () => import('./lazy/lazy.component').then(m => m.LazyComponent);
  }
              </pre>
      </ul>
    </li>
    <li>PreloadingStrategy használata
      <ul>
        <li>Az Angular PreloadAllModules vagy egyedi preload stratégiával előre betölthet modulokat alacsonyabb
          prioritású háttérfolyamatként</li>
      </ul>
    </li>
    <li>Service Workers
      <ul>
        <li>Használjunk Angular PWA támogatást, hogy az alkalmazás gyorsabbá váljon azáltal, hogy az erőforrásokat
          előre cache-eli a böngészőben</li>
      </ul>
    </li>
    <li>Lazy Loading képek és médiafájlok esetén
      <ul>
        <li>Használjunk loading="lazy" attribútumot az &#60;img> tageknél</li>
      </ul>
    </li>
    <li>SVG helyett ikonkészlet használata
      <ul>
        <li>Inline SVG-k vagy harmadik fél által nyújtott ikonlibek gyorsítják az oldalak renderelését</li>
      </ul>
    </li>
    <li>CSS és JS Minifikáció
      <ul>
        <li>Az Angular CLI automatikusan minifikálja a buildelt fájlokat, de érdemes ellenőrizni az alkalmazott
          eszközök megfelelő konfigurációját</li>
      </ul>
    </li>
    <li>RxJS és optimalizált adatfolyamok
      <ul>
        <li>Használjunk megfelelő operátorokat, például debounceTime, distinctUntilChanged, hogy csökkentsd a
          felesleges API-hívásokat</li>
      </ul>
    </li>
    <li>NgRx vagy egyéb state management használata
      <ul>
        <li>Csökkenti az állapotfrissítésekkel kapcsolatos overhead-et és tisztább kódot biztosít</li>
      </ul>
    </li>
    <li>HTTP Caching
      <ul>
        <li>Az Angular HttpClient-et kombinálva cache-eléssel csökkenthetjük a hálózati kérések számát</li>
      </ul>
    </li>
    <li>Lazy Loaded Fonts
      <ul>
        <li>Használjunk modern betűkészleteket, és lazy loadingot a betűkészletek betöltéséhez</li>
      </ul>
    </li>
    <li>CDN használata
      <ul>
        <li>Tároljunk statikus erőforrásokat CDN-en keresztül a gyorsabb betöltés érdekében</li>
      </ul>
    </li>
    <li>Angular DevTools
      <ul>
        <li>Használj eszközöket, mint az Angular DevTools, hogy diagnosztizáld az esetleges teljesítményproblémákat
        </li>
      </ul>
    </li>
  </ol>
</div>

<div>
  <h3 #mutablevsimmutable data-anchor="mutablevsimmutable">Mutable vs immutable type</h3>
  <ul>
    <li>Az objektumok és adatok kezelésére vonatkoznak a programozásban</li>
    <br>
    <li>Mutable (módosítható)
      <ul>
        <li>Az objektum tartalma módosítható, ami hatással van az eredeti példányra</li>
        <li>Értéke közvetlenül módosítható; az eredeti objektum maga módosul</li>
        <li>Ilyenek például a tömbök vagy objektumok a JavaScript-ben</li>
        <li>Példa
          <ul>
            <li>Tömbök: Egy tömbhöz új elemeket adhatunk hozzá anélkül, hogy új tömböt hoznánk létre</li>
            <li>Objektumok: Egy objektum kulcsait vagy értékeit módosíthatjuk anélkül, hogy új példányt hoznánk
              létre</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Immutable (nem módosítható)
      <ul>
        <li>Olyan objektumokat jelentenek, amelyek értéke nem módosítható</li>
        <li>A módosítások mindig új objektumot hoznak létre, az eredeti érintetlen marad</li>
        <li>Tehát, ha mondjuk egy szám értékét 5-ről 6-ra változtatjuk, akkor az 5 kitörlődik a memóriából, és új
          címen létrejön a 6-os szám, amire mutat a változó</li>
        <li>Példa
          <ul>
            <li>Primitív típusok: Mint például a számok, stringek, logikai értékek, amelyek mind immutable típusok
              JavaScript-ben</li>
            <li>Immutable könyvtárak: Ilyen például az Immutable.js, amely segít biztosítani az adatstruktúrák
              immutable jellegét</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <table style="width:100%; table-layout: fixed;">
      <thead>
        <tr>
          <th>Tulajdonság</th>
          <th>Mutable</th>
          <th>Immutable</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Jelentés</td>
          <td>Az érték módosítható</td>
          <td>Az érték nem módosítható, csak új hozható létre</td>
        </tr>
        <tr>
          <td>Módosítás</td>
          <td>Az eredeti objektum módosítható</td>
          <td>Minden módosítás új objektumot eredményez</td>
        </tr>
        <tr>
          <td>Példák</td>
          <td>JavaScript objektumok, tömbök (<code>Array</code>, <code>Object</code>)</td>
          <td>JavaScript primitívek (<code>String</code>, <code>Number</code>, <code>Boolean</code>), és olyan
            könyvtárak, mint az <code>Immutable.js</code>
          </td>
        </tr>
        <tr>
          <td>Előnyök</td>
          <td>Gyorsabb változtatás (nincs új példány)</td>
          <td>Biztonságosabb, könnyebb hibakeresés</td>
        </tr>
        <tr>
          <td>Hátrányok</td>
          <td>Könnyebb hibázni, nehéz követni a változásokat</td>
          <td>Több memóriát használhat, lassabb másolás</td>
        </tr>
        <tr>
          <td>Példa kódban</td>
          <td>
            <ul>
              <li>const mutableArray = [1, 2, 3];</li>
              <li>mutableArray.push(4); // Az eredeti tömb módosul</li>
              <li>console.log(mutableArray); // [1, 2, 3, 4]</li>
            </ul>
          </td>
          <td>
            <ul>
              <li>const immutableArray = [1, 2, 3];</li>
              <li>const newArray = [...immutableArray, 4]; // Új tömböt hozunk létre</li>
              <li>console.log(immutableArray); // [1, 2, 3] (változatlan marad)</li>
              <li>console.log(newArray); // [1, 2, 3, 4]</li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
  </ul>
</div>

<div>
  <h3 #arrayobjectdestructuring data-anchor="arrayobjectdestructuring">Array/Object destructuring</h3>
  <h5 #arraydestructuring data-anchor="arraydestructuring">Array destructuring</h5>
  <ul>
    <li>Lehetővé teszi, hogy egy tömb elemeit egyszerű módon külön változókba bontsuk</li>
    <pre>
  const array = [1, 2, 3];

  // Alapvető használat
  const [a, b, c] = array;
  console.log(a); // 1
  console.log(b); // 2
  console.log(c); // 3

  // Értékek kihagyása
  const [a, , b] = array;
  console.log(a); // 1
  console.log(b); // 3

  // Alapértelmezett értékek
  const array = [1];

  const [a, b = 5] = array;
  console.log(a); // 1
  console.log(b); // 5

  // Maradék elemek kezelése
  const array = [1, 2, 3, 4, 5];

  const [a, b, ...rest] = array;
  console.log(a); // 1
  console.log(b); // 2
  console.log(rest); // [3, 4, 5]

  // Tömbök beágyazása
  const nestedArray = &#91; &#91;1, 2&#93;, &#91;3, 4&#93;, &#91;5, 6&#93; &#93;;
  const &#91; &#91;first, second&#93;, &#91;third, fourth&#93; &#93; = nestedArray;

  console.log(first);   // 1
  console.log(second);  // 2
  console.log(third);   // 3
  console.log(fourth);  // 4
    </pre>
  </ul>
  <br>
  <h5 #objectdestructuring data-anchor="objectdestructuring">Object destructuring</h5>
  <ul>
    <li>Lehetővé teszi az objektumok tulajdonságainak egyszerű, és hatékony kinyerését és hozzárendelését változókhoz
    </li>
    <pre>
  const user = &#123;
      name: 'John Doe',
      age: 30,
      email: 'john.doe@example.com'
  &#125;;

  // Alapvető használat
  const &#123; name, age, email &#125; = user;
  console.log(name);  // John Doe
  console.log(age);   // 30
  console.log(email); // john.doe@example.com

  // Átnevezés
  const &#123; name: userName, age: userAge, email: userEmail &#125; = user;
  console.log(userName);  // John Doe
  console.log(userAge);   // 30
  console.log(userEmail); // john.doe@example.com

  // Alapértelmezett érték
  const &#123; name, age, email, gender = 'male' &#125; = user;

  // Beágyazott objektum
  const user = &#123;
      name: 'John Doe',
      address: &#123;
          city: 'New York',
          country: 'USA'
      &#125;
  &#125;;
  const &#123; name, address: &#123; city, country &#125; &#125; = user;

  console.log(name);   // John Doe
  console.log(city);   // New York
  console.log(country); // USA
    </pre>
  </ul>
</div>

<div>
  <h3 #consolecoloring data-anchor="consolecoloring">Console coloring</h3>
  <ul>
    <li>Console log színezés
      <ul>
        <li>Érdekesség, hogy a console.log képes a megadott színnel megjeleníteni a szöveget
          <ul>
            <pre>
  console.log('%c ' + color, 'color: ' + color);
            </pre>
            <li>Az első rész a szöveg: '%c ' + color</li>
            <li>A második rész a szín: 'color: ' + color</li>
            <li>A fenti esetben maga a szín, és a szín neve megegyezik</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #nullishcoalescing data-anchor="nullishcoalescing">Nullish coalescing</h3>
  <ul>
    <li>Logikai operátor, ami a jobb oldalt adja vissza, ha a bal oldal értéke null, vagy undefined</li>
    <pre>
  let myValue = someVariable ?? "default value";
    </pre>
    <li>Abban különbözik a logikai vagy ( || ) operátortól, hogy ha a bal oldal 0, üres string, vagy false, akkor anem a
      jobb oldal fog érvényesülni</li>
  </ul>
  <br>
  <h5 #nullishcoalescingvsor data-anchor="nullishcoalescingvsor">Nullish Coalescing vs OR</h5>
  <ul>
    <pre>
  const user = JSON.parse(localStorage.getItem('user') || 'null');
  const user = JSON.parse(localStorage.getItem('user') ?? 'null');
    </pre>
    <ol>
      <li>OR operator
        <ul>
          <li>||</li>
          <li>Ha a localStorage.getItem('user') null, undefined, false, 0, vagy NaN, akkor az érték null lesz</li>
          <li>A null fallback érték</li>
        </ul>
      </li>
      <li>Nullish coalescing operator
        <ul>
          <li>??</li>
          <li>Csak akkor alkalmazza a fallback értéket (null), ha az első operandus null, vagy undefined</li>
        </ul>
      </li>
    </ol>
    <li>Az || operátor többféle "falsy" értékre is reagál, míg a ?? operátor csakis kizárólag null és undefined esetén
    </li>
  </ul>
</div>

<div>
  <h3 #voidtype data-anchor="voidtype">Void type</h3>
  <ul>
    <li>a TypeScript-ben egy speciális típus, amelyet általában függvények visszatérési értékeként használUNK, amikor a
      függvény nem ad vissza semmilyen értéket</li>
    <pre>
  function logMessage(message: string): void &#123;
    console.log(message);
  }
  
  logMessage("Hello, World!"); // nincs visszatérési érték        
      </pre>
    <li>A void nem engedi meg, hogy bármilyen értéket visszaadjon a függvény</li>
    <li>A null és az undefined, mint visszatérési érték különbözik tőle
      <ul>
        <li>A függvénynek ezeket az értékeket vissza kell adnia</li>
        <pre>
  function returnNull(): null &#123;
    // logika
    return null; // visszaadhatjuk a null-t
  }
  
  function returnUndefined(): undefined &#123;
    // logika
    return undefined; // visszaadhatjuk az undefined-ot
  }
  
  function noReturn(): void &#123;
    // logika
    // nem ad vissza semmit
  }          
        </pre>
      </ul>
    </li>
    <li>Ha egy aszinkron függvény void típusú, akkor azt jelenti, hogy a függvény nem ad vissza semmilyen értéket a
      Promise-on keresztül sem, és nem várunk tőle konkrét értéket sem</li>
    <pre>
  function doSomethingAsync(): Promise&#60;void> &#123;
    return new Promise((resolve, reject) => &#123;
      setTimeout(() => &#123;
        console.log("Something done!");
        resolve(); // a függvény nem ad vissza semmilyen értéket
      }, 1000);
    });
  }
  
  doSomethingAsync();  // Nincs visszatérő érték
    </pre>
  </ul>
</div>

<div>
  <h3 #asyncawait data-anchor="asyncawait">Async/Await</h3>
  <ul>
    <li>Amikor egy függvény async kulcsszóval van deklarálva, az azt jelenti, hogy a függvény mindig egy Promise-t
      ad vissza
      <ul>
        <li>A kulcsszóval aszinkron működést viszünk véghez</li>
      </ul>
    </li>
    <li>Az await kulcsszó a Promise-ok aszinkron kezelésére szolgál, megállítja a futást addig, amíg a Promise nem
      teljesül
      <ul>
        <li>Vagy hibát nem dob</li>
      </ul>
    </li>
    <li>A két kulcsszó kéz a kézben jár, együtt használandó
      <ul>
        <pre>
          // async/await
          let getCountryInfo1 = async function () &#123;
            let response = await fetch('https://api.restful-api.dev/objects/1');
            let data = await response.json();
            console.log(data);
          };
          // A fetch és a response.json() hívások szinkron módon történnek, tehát a kód sorban végigfut, és a await megvárja, hogy a fetch és a JSON átalakítás befejeződjön, mielőtt továbbhaladna
          
          // then
          let getCountryInfo2 = async function () &#123;
            fetch('https://api.restful-api.dev/objects/1')
              .then(resp => resp.json())
              .then(obj => &#123;
                console.log(obj);
              });
          };
          // A then segítségével láncoljuk a két aszinkron műveletet
          // A fetch visszaad egy Promise-ot, és a válasz objektumot (resp) a then láncolatban dolgozzuk fel 
          
          getCountryInfo1();
          getCountryInfo2();
      </pre>
        <li>Tehát async-kel ellátott függvény esetében 2 dologban lehetünk biztosak
          <ol>
            <li>Aszinkron fut</li>
            <li>Promise-szal tér vissza</li>
          </ol>
        </li>
        <li>Async/await esetében a response változóba egy, resolved/rejected Promise-t szeretnénk tárolni
          <ul>
            <li>Ehhez meg kell várnunk a fetch API feloldását
              <ul>
                <li>Ezt az await kulcsszó használatával tudjuk megtenni</li>
                <li>Az await blokkolja a következő kódsor futását</li>
                <li>A fős szálat nem blokkolja, csak az async függvényen belüli kódsorokat</li>
              </ul>
            </li>
            <li>Egyszerűbb a használata, mint a then metódusnak</li>
          </ul>
        </li>
      </ul>
    </li>
    <pre>
  async function testFunction() &#123;
    let result = await someAsyncFunction();
    console.log(result); // csak akkor fut le, ha a someAsyncFunction() Promise teljesült
  }
    </pre>
    <li>A then() egy Promise metódus, amely lehetővé teszi, hogy egy callback függvényt adjunk hozzá a Promise
      befejezéséhez, és ha a Promise teljesült, a then() által meghívott függvény lefut</li>
    <pre>
  someAsyncFunction().then(result => &#123;
    console.log(result); // akkor fut le, ha a someAsyncFunction() Promise teljesült
  });
    </pre>
    <li>Az async/await és a then() egymással kompatibilis, mivel mindkettő Promise-okkal dolgozik</li>
    <li>Ha az await egy Promise-t vár, akkor a Promise teljesülése után a futás folytatódik, és az eredmény
      közvetlenül visszatér (ez a Promise eredménye)</li>
    <li>Ha await-et használunk, akkor nem szükséges then()-t használni, de az is működni fog, mert az await egy
      befejezett Promise értéket ad vissza, amit a then() callback-eként is kezelhetünk</li>
  </ul>
</div>

<div>
  <h3 #generictype data-anchor="generictype">Generic type</h3>
  <ul>
    <li>Olyan típus, amelyet paraméterezni lehet más típusokkal</li>
    <li>Azzal a céllal használjuk, hogy rugalmasabbá és újrahasználhatóbbá tegyük a kódot, anélkül, hogy konkrét
      típusokat kellene előre meghatározni</li>
    <li>Előnyei közé tartozik a típusbiztonság, és az újra felhasználhatóság</li>
    <li>Generikus függvény
      <ul>
        <pre>
  function identity&#60;T>(arg: T): T &#123;
    return arg;
  }
  
  let result1 = identity(42);       // result1: number
  let result2 = identity("hello");  // result2: string
        </pre>
        <li> T egy generikus típusparaméter, amelyet a függvény használ</li>
        <li>Amikor meghívjuk a identity függvényt, TypeScript automatikusan kitalálja a típusát a bemeneti értékek
          alapján</li>
      </ul>
    </li>
    <li>Generikus osztály
      <ul>
        <pre>
  class Box&#60;T> &#123;
    content: T;
    
    constructor(value: T) &#123;
      this.content = value;
    }
    
    getContent(): T &#123;
      return this.content;
    }
  }
  
  let numberBox = new Box&#60;number>(123);  // Box típusa: number
  let stringBox = new Box&#60;string>("hello"); // Box típusa: string          
        </pre>
        <li>A Box osztály generikus, és bármit tárolhat a content változóban (pl. számot vagy sztringet)</li>
      </ul>
    </li>
    <li>Generikus interface
      <ul>
        <pre>
  interface Pair&#60;T, U> &#123;
    first: T;
    second: U;
  }
  
  let pair: Pair&#60;string, number> = &#123; first: "hello", second: 42 };
        </pre>
        <li>Két típusparamétert használ: T és U</li>
        <li>Az első elem egy T típusú, a második elem pedig egy U típusú</li>
      </ul>
    </li>
    <li>Típuskorlátozás
      <ul>
        <li>Type constraint segítségével érhető el</li>
        <pre>
  function merge&#60;T extends &#123; name: string }>(obj1: T, obj2: T): T &#123;
    return &#123; ...obj1, ...obj2 };
  }
  
  const result = merge(&#123; name: "Alice", age: 25 }, &#123; name: "Bob", age: 30 });
  // A típus T itt olyan típus lesz, ami tartalmaz egy 'name' tulajdonságot.          
        </pre>
        <li>A T típus csak olyan típusokkal működik, amelyek rendelkeznek egy name nevű tulajdonsággal</li>
      </ul>
    </li>
    <li>Type constraint
      <ul>
        <li>Avagy típus korlátozás</li>
        <li>Biztosíthatja, hogy a generikus típus csak bizonyos típusokkal legyen használható, és hogy a
          típusparaméterek megfeleljenek egy adott szerkezetnek, vagy tulajdonságoknak</li>
        <li>A type constraint az extends kulcsszóval valósul meg TypeScript-ben</li>
        <pre>
  function logLength&#60;T extends &#123; length: number }>(item: T): void &#123;
    console.log(item.length);
  }
  
  logLength("Hello, World!");  // Működik, mivel a stringnek van 'length' tulajdonsága
  logLength([1, 2, 3]);        // Működik, mivel az arraynek is van 'length' tulajdonsága
  logLength(42);               // Hiba: Az 'number' típusnak nincs 'length' tulajdonsága          
        </pre>
        <li>A logLength függvény csak olyan típusokkal hívható meg, amelyek rendelkeznek length tulajdonsággal</li>
        <li>Több típusra is lehetséges a korlátozás</li>
        <pre>
  function merge&#60;T extends &#123; name: string }, U extends &#123; age: number }>(obj1: T, obj2: U): T & U &#123;
    return &#123; ...obj1, ...obj2 };
  }
  
  const mergedObj = merge(&#123; name: "Alice" }, &#123; age: 30 });
  // mergedObj típusa: &#123; name: string } & &#123; age: number }
  
  console.log(mergedObj);  // &#123; name: "Alice", age: 30 }          
        </pre>
        <li>A T típusú objektumnak rendelkeznie kell name, az U típusú objektumnak pedig age nevű tulajdonsággal</li>
        <li>Alapértelmezett típuskorlátozás
          <ul>
            <pre>
  interface Person &#123;
    name: string;
    age: number;
  }
  
  function greet&#60;T extends Person>(person: T): string &#123; // a person: T egy T típusú bemeneti paraméter
    return `Hello, $&#123;person.name}!`;
  }
  
  const person = &#123; name: "John", age: 25 };
  const message = greet(person);  // Hello, John!
            </pre>
            <li>A greet függvény olyan generikus típusparamétert használ, amely a Person interfészre van korlátozva</li>
            <li>A függvény csak olyan típusokkal hívható meg, amelyek rendelkeznek name és age tulajdonságokkal</li>
          </ul>
        </li>
        <li>Típuskorlátozás osztályokkal
          <ul>
            <pre>
  class Animal &#123;
    name: string;
    constructor(name: string) &#123;
      this.name = name;
    }
  }
  
  class Dog extends Animal &#123;
    breed: string;
    constructor(name: string, breed: string) &#123;
      super(name);
      this.breed = breed;
    }
  }
  
  function createAnimal&#60;T extends Animal>(animalClass: new (name: string) => T, name: string): T &#123;
    return new animalClass(name);
  }
  
  const dog = createAnimal(Dog, "Buddy");
  console.log(dog.name);  // Buddy
  console.log(dog.breed); // undefined (mivel a Dog típus nem lett teljesen inicializálva)
            </pre>
            <li>A createAnimal függvény olyan generikus típusparamétert használ, amely csak Animal típusú objektumokkal
              működik, vagy azok leszármazottjaival (például Dog)</li>
            <li>A Dog konstruktorában a name azért van jelen, mert a Dog osztály leszármazik az Animal osztályból</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #packagejsonscripts data-anchor="packagejsonscripts">package.json scripts</h3>
  <ul>
    <pre>
  "scripts": &#123;
    "&#60;kulcs>": "&#60;parancs>"
  }
    </pre>
    <li>A &#60;kulcs> az a név, amit használni fogunk az npm run után</li>
    <li>Az &#60;parancs> az a tényleges parancs, amit futtatni szeretnénk</li>
    <pre>
  "scripts": &#123;
    ...
    "hello": "echo 'Hello, world!'" // a terminálba kiírjuk, hogy Hello, world! az npm run hello paranccsal
  },
    </pre>
    <ul>
      <li>npm
        <ul>
          <li>Node Package Manager</li>
          <li>Az npm a Node.js csomagkezelője, és a scripts szekcióban meghatározott parancsokat tudja futtatni</li>
        </ul>
      </li>
      <li>ng
        <ul>
          <li>Az ng parancsok az Angular CLI (Command Line Interface) által biztosított parancsok</li>
          <li>Az Angular CLI telepítése után az ng parancsot használhatjuk különféle Angular-specifikus feladatokra
          </li>
          <li>Az ng parancsok önállóan is futtathatók a terminálban, feltéve, hogy az Angular CLI telepítve van</li>
        </ul>
      </li>
    </ul>
  </ul>
</div>

<div>
  <h3 #importexport data-anchor="importexport">import/export</h3>
  <ul>
    <li>Az import és export kulcsszavak az ES6 (ECMAScript 2015) szintaxis részei, és a modern JavaScript-ben
      elterjedt módszerek a modulok kezelésére</li>
    <li>A default export akkor praktikus, ha csak egy fő elem van, amit exportálni szeretnénk, míg a named export
      jobb, ha több, különböző elemet exportálunk</li>
  </ul>
  <br>
  <ol>
    <li>Named export-import
      <ul>
        <li>A fájlban több dolgot is exportálhatunk külön-külön</li>
        <li>Az importáláskor minden egyes elemet név szerint importálunk</li>
        <li>Importáláskor kapcsos zárójelbe kell tenni az exportált neveket</li>
        <pre>
  export const square = (num: number): number => &#123;
    return num * num;
  }

  export const range = (start: number, end: number): number[] => &#123;
    ...
    return result;
  }

  import &#123; square, range } from './utils';
            </pre>
      </ul>
    </li>
    <li>Default export-import
      <ul>
        <li>Lehetővé teszi, hogy egy fájlból csak egyetlen dolgot exportáljunk</li>
        <li>Nem kell pontosan ugyanazzal a névvel rendelkeznie</li>
        <li>A default export egy bármilyen néven importálható elem</li>
        <li>Nem lehet több default export egy fájlban, csak egy
          <ul>
            <li>Ellenkező esetben SyntaxError-t fogunk kapni</li>
          </ul>
        </li>
        <pre>
  export default function range(start: number, end: number): number[] &#123; // nem arrow function, így szükség van a 'function' szóra is
    ...
    return result;
  }

  import range from './utils';
            </pre>
      </ul>
    </li>
    <br>
    <table style="width: 100%; table-layout: fixed">
      <thead>
        <tr>
          <th></th>
          <th>Kód</th>
          <th>Jellemzők</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Első változat</td>
          <td>
            <pre>
  class ParagraphDemo extends Component &#123;}
  export default ParagraphDemo;
                </pre>
          </td>
          <td>
            <ul>
              <li>Az osztály külön van definiálva</li>
              <li>Az exportálás egy külön sorban történik</li>
              <li>Hasznos, ha több dolgot szeretnél exportálni a fájlból</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>Második változat</td>
          <td>
            <pre>
  export default class ParagraphDemo extends Component &#123;}
                </pre>
          </td>
          <td>
            <ul>
              <li>Tömörebb megoldá</li>
              <li>Az osztály definiálása és exportálása egy lépésben történik</li>
              <li>Egyszerűbb, ha csak egy dolgot exportálsz</li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>

    <br>
    <li>Alias
      <ul>
        <li>Ha szükség van arra, hogy átnevezzük az importált elemeket, használhatjuk az 'as' kulcsszót</li>
        <li>Különösen akkor hasznos, ha több exportált elem közül az egyiket más néven kívánjuk használni a kódban
        </li>
        <pre>
  export const square = (num: number): number => &#123;
    return num * num;
  }

  export const range = (start: number, end: number): number[] => &#123;
    ...
    return result;
  }

  import &#123; square as mySquare, range as myRange } from './utils';
            </pre>
      </ul>
    </li>
    <li>Import all
      <ul>
        <li>Ha egy fájl összes exportált elemét importálni szeretnénk, akkor használhatjuk a '* as' szintaxist,
          amely összesíti az összes exportált elemet egy objektumba</li>
        <pre>
  export const square = (num: number): number => &#123;
    return num * num;
  };

  export const range = (start: number, end: number): number[] => &#123;
    ...
    return result;
  }

  import * as utils from './utils';

  const second = utils.square(2);
            </pre>
      </ul>
    </li>
    <li>Re-export
      <ul>
        <li>Az export és import kombinálása lehetővé teszi, hogy egy fájlban egy másik fájl exportált elemeit újra
          exportáljuk</li>
        <pre>
  <b>// utils.ts</b>
    export const square = (num: number): number => &#123;
      return num * num;
    }

    export const range = (start: number, end: number): number[] => &#123;
      ...
      return result;
    }

  <b>// index.ts</b>
    export &#123; range } from './utils';

  <b>// file.ts</b>
    import &#123; range } from './index';
            </pre>
      </ul>
    </li>
    <li>Import all - Select one
      <ul>
        <li>Ha az egész modult importáljuk, de csak egy részt használjuk belőle, használhatjuk a destructuring-ot
        </li>
        <pre>
  import * as utils from './utils';

  const &#123; range } = utils;
            </pre>
      </ul>
    </li>
  </ol>
</div>

<div>
  <h3 #optionalchainingoperator data-anchor="optionalchainingoperator">Optional chaining operator</h3>
  <ul>
    <li>Feltételes láncolás operátor / Null-szűrés operátor</li>
    <li>Hasznos, ha egy objektum tulajdonságaihoz vagy mélyen beágyazott értékekhez szeretnénk hozzáférni, de nem
      vagyunk biztosak benne, hogy az objektum (vagy annak egy része) létezik</li>
    <li>Ha a bal oldali operandus null, vagy undefined, akkor az egész kifejezés undefined-dal ad vissza,
      ahelyett, hogy hibát kapnánk</li>
    <pre>
  const user = &#123;
    profile: &#123;
      name: "John",
    },
  };
  
  console.log(user?.profile?.name); // "John"
  console.log(user?.address?.city); // undefined, de nem dob hibát
          </pre>
  </ul>
</div>

<div>
  <h3 #functiondeclarations data-anchor="functiondeclarations">Function declarations</h3>
  <ol>
    <li>Normál függvény deklaráció
      <ul>
        <pre>
  export function square(num: number): number &#123;
    return num * num;
  }

  export default function range(start: number, end: number): number[] => &#123;
    ...
    return result;
  }

  import range, &#123; square } from './utils';
            </pre>
      </ul>
    </li>
    <li>Anonym függvény deklaráció (arrow function)
      <ul>
        <pre>
  export const square = (num: number): number => &#123;
    return num * num;
  }

  const range = (start: number, end: number): number[] => &#123;
    ...
    return result;
  }

  export default range;

  import range, &#123; square } from './utils';
            </pre>
      </ul>
    </li>
  </ol>
</div>

<div>
  <h3 #functioninputs data-anchor="functioninputs">Function inputs</h3>
  <ul>
    <li>Paraméter
      <ul>
        <li>Helyfoglaló név</li>
        <li>Változó, amit a függvény deklarációjában definiálunk</li>
        <li>Jelzi, hogy a függvény vár valamilyen adatot, de a konkrét érték még nem ismert</li>
        <pre>
  function greet(name) &#123; // a name egy paraméter
    console.log(`Hello, $&#123;name}!`);
  }
            </pre>
      </ul>
    </li>
    <li>Argomentum
      <ul>
        <li>Konkrét érték</li>
        <li>Érték, amit a függvény hívásakor átadunk a paraméternek</li>
        <pre>
  greet("John");
        </pre>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #nameconventionsandcases data-anchor="nameconventionsandcases">Name conventions and cases</h3>
  <ul>
    <li>Property: propertyExample</li>
    <li>Private property: _privatePropertyExample</li>
    <li>Observable: observableExample$</li>
    <li>Subject: subjectExample$</li>
    <li>Function: exampleFunction()</li>
    <li>Getter/Setter: get propertyName() / set propertyName(value)</li>
    <li>Component / Service / Directive / Pipe: ExampleComponent / ExampleService / ExampleDirective / ExamplePipe
    </li>
    <li>Snake case: snake_case_example</li>
    <li>Camel case: camelCaseExample</li>
    <li>Pascal case: PascalCaseExample</li>
    <li>Kebab-case: kebab-case-example</li>
  </ul>
</div>

<div>
  <h3 #anonymousobject data-anchor="anonymousobject">Anonymous object</h3>
  <ul>
    <li>Olyan objektum, amelyet nem rendelünk hozzá változóhoz, vagy nem adunk neki nevet</li>
    <pre>
  &#123;
      name: 'Bob',
      age: 30
  }
    </pre>
  </ul>
</div>

<div>
  <h3 #emptytype data-anchor="emptytype">Empty type</h3>
  <ul>
    <li>Üres típus</li>
    <li>TypeScript-ben létező típus, amelyet a never típus képvisel</li>
    <li>Az üres típus jellemzője, hogy semmilyen értéket nem vehet fel</li>
    <li>A változó soha nem kap értéket, vagy egy függvény soha nem tér vissza</li>
    <pre>
  function throwError(message: string): never &#123;
    throw new Error(message);
  }      
    </pre>
    <li>A throwError függvény never típust ad vissza, mivel soha nem tér vissza, hanem egy hibát dob, és véget vet a
      futásának</li>
  </ul>
</div>

<div>
  <h3 #jsonfunctions data-anchor="jsonfunctions">JSON functions</h3>
  <ul>
    <li>A JavaScript beépített metódusai, amelyek JSON adatokat kezelnek</li>
    <li>
      <ol>
        <li>JSON.stringify()
          <ul>
            <li>JavaScript objektumot, vagy tömböt JSON formátumú szöveggé alakít</li>
            <li>Például localStorage-ba mentéskor hasznos</li>
            <pre>
  const user = &#123; name: "John", age: 30 };
  const jsonString = JSON.stringify(user);
  console.log(jsonString); 

  ↓↓↓↓↓

  '&#123;"name":"John","age":30}'  // string típus
            </pre>
            <li>Három paramétert fogad
              <ul>
                <pre>
  JSON.stringify(value, replacer, space);
                </pre>
                <li>A value kötelező, ez az az érték, amit szöveggé kívánunk alakítani</li>
                <li>A replacer nem kötelező
                  <ul>
                    <li>Meghatározza, hogy mely kulcsokat tartsuk meg</li>
                    <li>Lehet egy...
                      <ol>
                        <li>...tömb
                          <ul>
                            <pre>
  const obj = &#123; name: "John", age: 30, city: "New York" };
  console.log(JSON.stringify(obj, ["name", "city"]));

  ↓↓↓↓↓

  '&#123;"name":"John","city":"New York"}' // az age kimarad
                            </pre>
                          </ul>
                        </li>
                        <li>...függvény
                          <ul>
                            <pre>
  const obj = &#123; name: "John", age: 30, city: "New York" };

  function replacer(key, value) &#123;
    if (typeof value === "number") return undefined; // a számokat kihagyjuk
    return value;
  }

  console.log(JSON.stringify(obj, replacer));

  ↓↓↓↓↓

  '&#123;"name":"John","city":"New York"}' // az age így is kimarad
                            </pre>
                          </ul>
                        </li>
                      </ol>
                    </li>
                  </ul>
                </li>
                <li>A space szintén nem kötelező
                  <ul>
                    <li>Egy szám vagy string, amely formázza a JSON szöveget
                      <ul>
                        <li>A kulcsok előtti behúzást adatjuk meg</li>
                      </ul>
                    </li>
                    <pre>
  const obj = &#123; name: "John", age: 30, city: "New York" };
  console.log(JSON.stringify(obj, null, '')); // a behúzás 0

  ↓↓↓↓↓

  &#123;"name":"John","age":30,"city":"New York"}
                    </pre>
                    <pre>
  const obj = &#123; name: "John", age: 30, city: "New York" };
  console.log(JSON.stringify(obj, null, 4)); // a behúzás 4

  ↓↓↓↓↓

  &#123;
      "name": "John",
      "age": 30,
      "city": "New York"
  ....                      // 4 karakter jönnek beljebb a kulcsok
  }
                    </pre>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>JSON.parse()
          <ul>
            <li>JSON formátumú szöveget JavaScript objektummá vagy tömbbé alakít</li>
            <li>Hasznos például localStorage-ban tárolt szöveg kiolvasásakor</li>
            <pre>
  const jsonString = '&#123;"name":"John","age":30}';
  const userObj = JSON.parse(jsonString);
  console.log(userObj); 

  ↓↓↓↓↓

  &#123;name: "John", age: 30} // objektum
            </pre>
          </ul>
        </li>
      </ol>
    </li>
    <table style="border-collapse: collapse; width: 100%;">
      <tr>
        <th>Függvény</th>
        <th>Mit csinál?</th>
        <th>Példa input</th>
        <th>Példa output</th>
      </tr>
      <tr>
        <td>JSON.stringify()</td>
        <td>Objektumot JSON szöveggé alakít</td>
        <td>&#123; name: "John", age: 30 }</td>
        <td>'&#123;"name":"John","age":30}'</td>
      </tr>
      <tr>
        <td>JSON.parse()</td>
        <td>JSON szöveget objektummá alakít</td>
        <td>'&#123;"name":"John","age":30}'</td>
        <td>&#123; name: "John", age: 30 }</td>
      </tr>
    </table>

  </ul>
</div>

<div>
  <h3 #angularpipes data-anchor="angularpipes">Angular pipes</h3>
  <ul>
    <li>Beépített pipe-ok</li>
    <li>Az Angular beépített pipe-ok a CommonModule részei</li>
    <br>
    <li>Szöveg formázása
      <table style="border-collapse: collapse; width: 100%;">
        <tr>
          <th></th>
          <th>leírás</th>
          <th>példa</th>
        </tr>
        <tr>
          <td><b>uppercase</b></td>
          <td>Nagybetűssé alakítja a szöveget</td>
          <td>"hello" | uppercase → <b>"HELLO"</b></td>
        </tr>
        <tr>
          <td><b>lowercase</b></td>
          <td>Kisbetűssé alakítja a szöveget</td>
          <td>"Hello" | lowercase → <b>"hello"</b></td>
        </tr>
        <tr>
          <td><b>titlecase</b></td>
          <td>Minden szó első betűjét nagybetűssé alakítja</td>
          <td>"hello world" | titlecase → <b>"Hello World"</b></td>
        </tr>
        <tr>
          <td><b>slice</b></td>
          <td>Részstring kivágása</td>
          <td>"Angular" | slice:1:4 → <b>"ngu"</b></td>
        </tr>
        <tr>
          <td><b>json</b></td>
          <td>Objektum JSON formátumba alakítása</td>
          <td>&#123; name: "John", age: 30 } | json → <b>&#123;"name":"John","age":30}</b></td>
        </tr>
      </table>
    </li>
    <br>
    <li>Számformázás
      <table style="border-collapse: collapse; width: 100%;">
        <tr>
          <th></th>
          <th>leírás</th>
          <th>példa</th>
        </tr>
        <tr>
          <td><b>number</b></td>
          <td>Tizedesjegyek és elválasztók beállítása</td>
          <td>1234.5 | number:'1.2-2' → <b>"1,234.50"</b></td>
        </tr>
        <tr>
          <td><b>percent</b></td>
          <td>Százalékos formátum</td>
          <td>0.2543 | percent:'1.2-2' → <b>"25.43%"</b></td>
        </tr>
        <tr>
          <td><b>currency</b></td>
          <td>Pénznem formázása</td>
          <td>1234.5 | currency:'EUR' → <b>"€1,234.50"</b></td>
        </tr>
      </table>
    </li>
    <br>
    <li>Dátum formázás
      <table style="border-collapse: collapse; width: 100%;">
        <tr>
          <th></th>
          <th>leírás</th>
          <th>példa</th>
        </tr>
        <tr>
          <td><b>date</b></td>
          <td>Dátum és idő formázása</td>
          <td>today | date:'yyyy-MM-dd' → <b>"2024-01-31"</b></td>
        </tr>
        <tr>
          <td><b>date</b></td>
          <td>Rövidebb formátum</td>
          <td>today | date:'short' → <b>"1/31/24, 12:00 AM"</b></td>
        </tr>
      </table>
    </li>
    <br>
    <li> i18n (nemzetközi formázás)
      <table style="border-collapse: collapse; width: 100%;">
        <tr>
          <th></th>
          <th>leírás</th>
          <th>példa</th>
        </tr>
        <tr>
          <td><b>i18nPlural</b></td>
          <td>Többes szám formázás</td>
          <td>&#123;=0: 'nincs elem', =1: '1 elem', other: '&#123;} elem'}</td>
        </tr>
        <tr>
          <td><b>i18nSelect</b></td>
          <td>Feltételes szövegmegjelenítés</td>
          <td>&#123;male: 'Mr.', female: 'Ms.', other: 'User'}</td>
        </tr>
      </table>
    </li>
    <br>
    <li>Objektum és tömb
      <table style="border-collapse: collapse; width: 100%;">
        <tr>
          <th></th>
          <th>leírás</th>
          <th>példa</th>
        </tr>
        <tr>
          <td><b>keyvalue</b></td>
          <td>Objektum kulcs-érték párjait listává alakítja</td>
          <td>&#123;name: "John", age: 30} | keyvalue → <b>[&#123;key: "name", value: "John"}, &#123;key: "age", value:
              30}]</b></td>
        </tr>
        <tr>
          <td><b>async</b></td>
          <td>Observable vagy Promise értékének kiolvasása</td>
          <td>user$ | async</td>
        </tr>
      </table>
    </li>
    <pre>
  <b>// keyvalue</b>
  // Objektumok kulcs-érték párjait alakítja át egy tömbbé, ahol minden elem egy &#123; key, value } objektum

  &#60;div *ngFor="let item of &#123;name: 'John', age: 30} | keyvalue">
    &#60;p>&#123; &#123; item.key }}: &#123; &#123; item.value }}&#60;/p>
  &#60;/div>

  ↓↓↓↓↓

  // 2 ciklus

  &#60;div>
    &#60;p>name: John&#60;/p>
  &#60;/div>

  &#60;div>
    &#60;p>age: 30&#60;/p>
  &#60;/div>
    </pre>
    <pre>
  <b>// async</b>
  // Observable, vagy Promise értékének kiolvasására szolgál


  // Observable
  import &#123; Component } from '@angular/core';
  import &#123; Observable, of } from 'rxjs';

  @Component(&#123;
    selector: 'app-root',
    template: `&#60;p>&#123; &#123; user$ | async }}&#60;/p>`
  })
  export class AppComponent &#123;
    user$: Observable&#60;string> = of('Jack Smith');
  }

  // Amint az Observable kibocsátja az értéket, a kimenet Jack Smith lesz
  // Az async pipe automatikusan előfizet (subscribe) az Observable-re és leiratkozik róla, amikor a komponens megszűnik



  // Promise
  import &#123; Component } from '@angular/core';

  @Component(&#123;
    selector: 'app-root',
    template: `&#60;p>&#123; &#123; user | async }}&#60;/p>`
  })
  export class AppComponent &#123;
    user = new Promise(resolve => setTimeout(() => resolve('Jack Smith'), 2000));
  }

  // 2 másodperc után megjelenik a Jack Smith
    </pre>
  </ul>
</div>

<div>
  <h3 #valuevsreference data-anchor="valuevsreference">Value vs reference</h3>
  <ul>
    <li>JavaScript-ben az értékek két típusra oszthatók
      <ol>
        <li>Primitív típus / Value type</li>
        <li>Objektum / Reference type</li>
      </ol>
    </li>
    <li>Value type
      <ul>
        <li>A primitív típusok közvetlenül a memóriában tárolódnak</li>
        <li>Ha egy változót másolunk, az érték másolatát kapjuk, így az eredeti változó nem módosul</li>
        <li>Primitív típusok: number, string, boolean, null, undefined, symbol, BigInt</li>
        <pre>
  let a = 10;
  let b = a;  // lemásoljuk

  b = 20;  // b értékének módosítása nem változtatja meg az a értékét

  console.log(a); // 10
  console.log(b); // 20
        </pre>
      </ul>
    </li>
    <li>Reference type
      <ul>
        <li>A hivatkozás típusok az adatok memóriában lévő helyére mutató referenciát tárolnak
          <ul>
            <li>Magyarán memóriacímet tárolnak</li>
          </ul>
        </li>
        <li>Ha egy ilyen változót másolunk, mindkét változó ugyanarra a memóriahelyre mutat, így a módosítás minden
          helyen érvényes lesz</li>
        <li>Objektum: object, array, function, Date</li>
        <pre>
  let obj1 = &#123; name: "John", age: 28 };
  let obj2 = obj1;  // hivatkozást másolunk

  obj2.name = "John";  // obj1 is módosul
  console.log(obj1.name); // "John"
  console.log(obj2.name); // "John"
        </pre>
        <img src="assets/imgs/js_ref_type.png" width="100%">
        <br>
        <br>
        <li>A referencia alapú másolás elkerülhető
          <ol>
            <li>Array másolás
              <ul>
                <pre>
  let arr1 = [1, 2, 3];
  let arr2 = [...arr1]; // spread operátorral való másolás

  arr2.push(4);

  console.log(arr1); // [1, 2, 3]
  console.log(arr2); // [1, 2, 3, 4]  // arr1 nem változott
                </pre>
              </ul>
            </li>
            <li>Object másolás
              <ul>
                <pre>
  let obj1 = &#123; name: "Jack" };
  let obj2 = &#123; ...obj1 }; // új objektum készül spread operátorral

  obj2.name = "Joe";

  console.log(obj1.name); // "Jack" // nem változott meg
  console.log(obj2.name); // "Joe"
                </pre>
              </ul>
            </li>
            <li>Deep copy
              <ul>
                <pre>
  let obj1 = &#123; name: "Jack", address: &#123; city: "NY" } };
  let obj2 = JSON.parse(JSON.stringify(obj1)); // mély másolás

  obj2.address.city = "LA";

  console.log(obj1.address.city); // "NY" // aZ eredeti érték nem változott
  console.log(obj2.address.city); // "LA"
                </pre>
              </ul>
            </li>
          </ol>
        </li>
      </ul>
    </li>
    <li>Amikor függvénynek paraméterként értéket adunk át, primitív típus esetén új változó jön létre egy másik címen,
      ugyanazzal az értékkel, objektum esetében pedig ugyanarra a memóriacímre fog mutatni az új, függvénynek átadott
      változónk
      <ul>
        <li>Ebből az következik, hogy ha a függvényen belül változtatjuk a primitív típus értékét, akkor az eredeti
          változónk értéke marad a régi, objektum esetében viszont minden változónk ugyanarra a címre mutat, így
          megváltoztatjuk a benne lévő értéket</li>
        <pre>
  let code = 'ABC123';

  let person = &#123; name: 'Jill', age: 40 };

  function checkIn(passenger, flightCode) &#123;
    flightCode = 'QWE987'; // a code értéke változatlan marad

    passenger.name = 'Sarah'; // a person értéke ettől a pillanattól kezdve &#123; name: 'Sarah', age: 40 }
  }

  checkIn(person, code);
          </pre>
      </ul>
    </li>
    <li>Egyenlőségek ellenőrzése
      <ul>
        <pre>
  // primitív típusok

  let x = 30;
  let y = 30;

  console.log(x === y); // true
        </pre>
        <li>A két különböző memóriacímen lévő érték ugyanaz</li>
        <pre>
  // referencia típusok

  let obj1 = &#123; age: 25 };
  let obj2 = &#123; age: 25 };

  console.log(obj1 === obj2); // false
        </pre>
        <li>A két objektum más címen tárolja a referenciáját az objektumhoz, ezért nem egyenlő a kettő értéke
          <ul>
            <li>Más referencia értéket tárolnak</li>
          </ul>
        </li>
        <pre>
  // referencia típusok

  let obj2 = &#123; age: 25 };
  let obj3 = obj2; // 

  console.log(obj2 === obj3); // true
        </pre>
        <li>Referencia másolódik, így mindkettő ugyanazt a referencia értéket fogja tárolni</li>
        <pre>
  let arr1 = [20, 10, 30];
  let arr2 = arr1;

  arr2.push(50, 40);

  console.log(arr2); // [20, 10, 30, 50, 40]
  console.log(arr1); // [20, 10, 30, 50, 40]
        </pre>
        <li>A két új elem arr1-hez is hozzáadódik, mert refeerencia típus</li>
        <pre>
  let arr1 = [20, 10, 30];
  let arr2 = arr1;

  arr1 = []; // arr1-nek új memóriacímet adunk
  arr2.push(50, 40);

  console.log(arr2); // [20, 10, 30, 50, 40]
  console.log(arr1); // []
        </pre>
        <li>Az arr1-nek üres tömb átadásával tulajdonképpen egy új tömböt hoztunk létre, ami más memóriacímet kap, ezért
          marad üres, arr2 pedig korábban megkapta arr1 referenciáját, ami egy három elemű tömb volt, és ahhoz adtunk
          hozzá még kettőt</li>
        <pre>
  let age = 30;
  let obj1 = &#123; age: 30 };

  console.log(obj1.age === age); // true
        </pre>
        <li>Primitív típust hasonlítunk össze egy referencia típus egyik property-jével, egy olyan property-vel, aminek
          típusa szintén primitív
          <ul>
            <li>Az objektum (obj1) referencia típusú, de a benne lévő property nem</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #implementsvsextends data-anchor="implementsvsextends">Implements vs extends</h3>
  <ul>
    <li>Alapvető objektumorientált programozási fogalmak</li>
    <li>Gyakran előfordulnak TypeScript-ben is</li>
  </ul>
  <br>
  <ol>
    <li>extends (Öröklés)
      <ul>
        <li>Arra szolgál, hogy egy osztály (subclass) örököljön egy másik osztálytól (superclass)</li>
        <li>A származtatott osztály (child class) megkapja az ősosztály (parent class) tulajdonságait és metódusait</li>
        <li>JavaScript-ben az osztályok öröklésére szolgál, amelyet az ES6-ban vezettek be</li>
        <pre>
  <b>// superclass</b>
  class Animal &#123;
    name: string;
  
    constructor(name: string) &#123;
      this.name = name;
    }
  
    speak(): void &#123;
      console.log(`$&#123;this.name} makes a sound`);
    }
  }

  <b>// subclass</b>
  class Dog extends Animal &#123;
    breed: string;
  
    constructor(name: string, breed: string) &#123;
      super(name);  // meghívja az ősosztály (Animal) konstruktorát
      this.breed = breed;
    }
  
    speak(): void &#123;
      console.log(`$&#123;this.name} barks`);
    }
  }

  -----

  const dog = new Dog('Buddy', 'Golden Retriever');
  dog.speak();

  ↓↓↓↓↓

  'Buddy barks' // felülírtuk az ősosztály metódusát a származtatott osztályéval
        </pre>
      </ul>
    </li>
    <li>implements (Interfész implementálása)
      <ul>
        <li>Egy interfész implementálására szolgál</li>
        <li>Az interfész egy olyan "egyezmény", amely meghatározza, hogy egy osztálynak milyen metódusokat, és
          tulajdonságokat kell biztosítania</li>
        <li>Az implements biztosítja, hogy az osztály kötelezően implementálja az interfészben meghatározott metódusokat
        </li>
        <li>Az interfészek nem tartalmaznak logikát, csak a szükséges metódusokat és tulajdonságokat</li>
        <li>Az osztály, amely az interfészt implementálja, biztosítja a metódusok tényleges működését</li>
        <li>Kifejezetten TypeScript-ben lett bevezetve</li>
        <pre>
  <b>// interface</b>
  interface Animal &#123;
    name: string;
    speak(): void;
  }

  // class
  class Dog implements Animal &#123;
    name: string;
  
    constructor(name: string) &#123;
      this.name = name;
    }
  
    speak(): void &#123; // a speak method létezik az osztályban
      console.log(`$&#123;this.name} barks`);
    }
  }

  -----

  const dog = new Dog('Buddy');
  dog.speak();

  ↓↓↓↓↓

  'Buddy barks'
        </pre>
      </ul>
    </li>
  </ol>
</div>

<div>
  <h3 #oopexpressions data-anchor="oopexpressions">OOP expressions</h3>
  <ul>
    <li>Az extends, és implements kulcsszavakon kívül más fontos kifejezések is léteznek az objektumorientált
      programozásban</li>
  </ul>
  <br>
  <ol>
    <li>static
      <ul>
        <li>A static kulcsszóval ellátott metódusok és tulajdonságok nem az osztály példányaihoz tartoznak, hanem
          magához az osztályhoz</li>
        <li>Ezeket a metódusokat a példányosítás előtt is elérhetjük az osztály nevén keresztül</li>
        <pre>
  class Calculator &#123;
    static add(a: number, b: number): number &#123;
      return a + b;
    }
  }

  console.log(Calculator.add(2, 3));

  ↓↓↓↓↓

  5
        </pre>
        <li>Az add metódus statisztikus és az osztályon keresztül hívható, anélkül, hogy példányosítanánk</li>
      </ul>
    </li>
    <li>abstract
      <ul>
        <li>Olyan osztályokat hozhatunk létre, amelyek nem példányosíthatók, de leszármazott osztályok számára
          biztosítanak alapot</li>
        <pre>
  abstract class Animal &#123;
    abstract sound(): void;  // absztrakt metódus, amelyet a származtatott osztályoknak kell implementálniuk
  }
  
  class Dog extends Animal &#123;
    sound() &#123;
      console.log('Bark');
    }
  }
  
  const dog = new Dog();
  dog.sound();  
  
  ↓↓↓↓↓

  'Bark'
        </pre>
        <li>Az Animal osztály absztrakt, és nem példányosítható közvetlenül
          <ul>
            <li>A Dog osztály implementálja az abstract metódust</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>interface
      <ul>
        <li>Az osztályok számára szabályokat (metódusok, tulajdonságok) ad, amelyeket az osztályoknak implementálniuk
          kell</li>
        <li>Az interfészek nem tartalmaznak implementációt, csak a szükséges struktúrát</li>
        <pre>
  interface Vehicle &#123;
    wheels: number;
    drive(): void;
  }
  
  class Car implements Vehicle &#123;
    wheels = 4;
    drive() &#123;
      console.log('Driving a car');
    }
  }          
        </pre>
        <li>Az interface egy struktúrát definiál, amelyet a Car osztály implementál</li>
      </ul>
    </li>
    <li>constructor
      <ul>
        <li>Az osztály példányosításakor meghívott speciális metódus</li>
        <li>A konstruktor az osztály példányosítása előtt fut le</li>
        <pre>
  class Person &#123;
    name: string;
    constructor(name: string) &#123;
      this.name = name;
    }
  }
  
  const person = new Person('Joe');
  console.log(person.name);
  
  ↓↓↓↓↓

  'Joe'
        </pre>
      </ul>
    </li>
    <li>get/set
      <ul>
        <li>Lehetővé teszik, hogy az osztályon belül tulajdonságokat kezeljünk getter-ekkel és setter-ekkel, amelyeket
          példányosításkor hívhatunk meg a szokásos tulajdonságok helyett</li>
      </ul>
      <pre>
  class Person &#123;
    private _name: string;
    
    constructor(name: string) &#123;
      this._name = name;
    }
  
    get name(): string &#123;
      return this._name;
    }
  
    set name(value: string) &#123;
      if (value.length > 0) &#123;
        this._name = value;
      }
    }
  }
  
  const person = new Person('John');
  console.log(person.name); 

  ↓↓↓↓↓

  'John'

  person.name = 'Jane';  // setter hívása
  console.log(person.name);
  
  ↓↓↓↓↓

  'Jane'
      </pre>
    </li>
    <li>readonly
      <ul>
        <li>
          A kulcsszóval ellátott tulajdonságok csak olvashatók, azaz csak a konstruktorban, vagy az osztály
          példányosításakor adhatóak meg értékeik, később nem módosíthatók</li>
        <pre>
  class Person &#123;
    readonly name: string;
    constructor(name: string) &#123;
      this.name = name;
    }
  }
  
  const person = new Person('Sarah');
  console.log(person.name);

  ↓↓↓↓↓

  'Sarah'

  // person.name = 'Jane';  // hiba, mert a name readonly            
          </pre>
      </ul>
    </li>
    <li>type
      <ul>
        <li>Segítségével típusokat hozhatunk létre, amelyek változókat és objektumokat leíró típusokat tartalmaznak</li>
        <pre>
  type Point = &#123; x: number, y: number };

  const point: Point = &#123; x: 10, y: 20 };
        </pre>
      </ul>
    </li>
    <li>tuple
      <ul>
        <li>A tuple típusok lehetővé teszik, hogy különböző típusú értékeket tároljunk egy változóban, meghatározott
          sorrendben</li>
        <pre>
  let person: [string, number] = ['John', 25];
          </pre>
      </ul>
    </li>
    <li>typeof
      <ul>
        <li>A kulcsszó segítségével lekérhetjük egy változó típusát, amely statikusan meghatározható</li>
        <pre>
  let age = 30;
  let typeOfAge = typeof age;

  console.log(typeOfAge);

  ↓↓↓↓↓

  number
        </pre>
      </ul>
    </li>
    <li>in
      <ul>
        <li>Az in operátor az objektumok tulajdonságainak ellenőrzésére szolgál</li>
        <pre>
  let person = &#123; name: 'John', age: 25 };

  console.log('name' in person);

  ↓↓↓↓↓

  true

  console.log('address' in person);

  ↓↓↓↓↓

  false
        </pre>
      </ul>
    </li>
    <li>instanceof
      <ul>
        <li>Az instanceof operátor segítségével megállapíthatjuk, hogy egy objektum egy bizonyos osztály példánya-e</li>
        <pre>
  class Person &#123;
    constructor(public name: string) &#123; }
  }
  
  const person = new Person('John');

  console.log(person instanceof Person);          

  ↓↓↓↓↓

  true
        </pre>
      </ul>
    </li>
  </ol>
</div>

<div>
  <h3 #ngmodel data-anchor="ngmodel">ngModel</h3>
  <ul>
    <li>Az Angular FormsModule egyik kulcsfontosságú direktívája, amely lehetővé teszi a kéttirányú adat binding-ot
      (two-way data binding) a template-ek és a komponens változói között</li>
    <li>Biztosítja, hogy a hozzá kötött változó szinkronban maradjon, vagyis ha az egyik változik, a másik is
      automatikusan frissül</li>
    <pre>
  // template
  &#60;input type="text" [(ngModel)]="name">
  &#60;p>Beírt név: &#123; &#123; name }}&#60;/p>

  // class
  import &#123; Component } from '@angular/core';

  @Component(&#123;
    selector: 'app-example',
    templateUrl: './example.component.html'
  })
  export class ExampleComponent &#123;
    name: string = '';
  }
    </pre>
    <li>Egyirányú binding [ngModel]
      <ul>
        <li>Ha csak az érték beállítására van szükség használni az ngModel-t, akkor csak egyirányú bindingként kell
          használni</li>
        <pre>
            &#60;input type="text" [ngModel]="name">
        </pre>
        <li>Ebben az esetben az input mező megkapja a name értékét, de ha a felhasználó módosítja az input mezőt, az nem
          fogja megváltoztatni a name változót</li>
      </ul>
    </li>
    <li>Eseménykezelés
      <ul>
        <li>Ha szeretnénk figyelni, mikor változik az input mező értéke, akkor az (ngModelChange) esemény segíthet</li>
        <pre>
  &#60;input type="text" [(ngModel)]="name" (ngModelChange)="onNameChange($event)">

  onNameChange(newValue: string) &#123;
    console.log('Name változás történt:', newValue);
  }
        </pre>
        <li>Az (ngModelChange) akkor fut le, amikor az input mező értéke megváltozik</li>
      </ul>
    </li>
    <li>Egyirányú binding és eseménykezelés
      <ul>
        <li>A kétirányú adatbinding ([(ngModel)]) valójában két különálló binding kombinációja</li>
        <pre>
  &#60;input type="text" [(ngModel)]="name">

  // the same

  &#60;input type="text" [ngModel]="name" (ngModelChange)="name = $event"> // az új értéket tartalmazza az $event
        </pre>
        <li>Az $event egy speciális változó Angularban, amely az eseménykezelő függvényekben elérhető, és mindig az
          adott esemény objektumát tartalmazza</li>
        <li>A dollár jel konvenció, elkülönítés véget</li>
        <li>Az $event itt már maga a beírt érték, így nincs szükség .target.value-ra</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #anonymousentities data-anchor="anonymousentities">Anonymous entities</h3>
  <ul>
    <li>Anonymous object
      <ul>
        <li>Névtelen objektum</li>
        <li>Olyan objektum, amelyet közvetlenül létrehozunk anélkül, hogy külön változóba mentenénk</li>
        <li>Általában paraméterként adjuk át egy függvénynek, vagy visszatérési értékként használjuk</li>
        <li>Azonnal létrehozhatjuk, és használhatjuk, anélkül, hogy tárolnánk</li>
        <li>Függvény paraméter
          <ul>
            <pre>
  function printPerson(person: &#123; name: string; age: number }) &#123;
    console.log(`$&#123;person.name} $&#123;person.age} éves`);
  }
  
  printPerson(&#123; name: "John", age: 30 });              
            </pre>
          </ul>
        </li>
        <li>Visszatérési érték
          <ul>
            <pre>
  function createUser(name: string, age: number) &#123;
    return &#123; name, age };
  }
  
  console.log(createUser("Anna", 25));    
  
  ↓↓↓↓↓

  &#123; name: "Anna", age: 25 } 
            </pre>
          </ul>
        </li>
      </ul>
    </li>
    <li>Anonymous function
      <ul>
        <li>Névtelen függvény</li>
        <li>Egy névtelen függvény olyan függvény, amelynek nincs neve, és általában egy változóhoz rendeljük vagy
          közvetlenül egy másik függvény paramétereként használjuk</li>
        <pre>
  const add = function (a: number, b: number) &#123;
    return a + b;
  };
  console.log(add(3, 5)); // 8            
        </pre>
        <pre>
  const multiply = (a: number, b: number) => a * b;
  console.log(multiply(4, 2)); // 8
        </pre>
        <pre>
  setTimeout(function () &#123;
    console.log("Késleltetett üzenet");
  }, 1000);          
        </pre>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #stylepreprocessoroptions data-anchor="stylepreprocessoroptions">stylePreprocessorOptions</h3>
  <ul>
    <li>Angular konfigurációs beállítás, amelyet a angular.json fájlban lehet megadni</li>
    <li>lehetővé teszi az Angular számára, hogy a stílus preprocesszorok (pl. SCSS, LESS) esetén rövidebb, relatív
      elérési utakat használjunk az @import utasításokban</li>
    <pre>
  // SCSS importálás preprocesszálás nélkül

  @import '../scss/variables.scss';

  // SCSS importálás preprocesszálással

  "stylePreprocessorOptions": &#123;
    "includePaths": [
      "src/scss"
    ]
  },

  @import 'variables.scss';
    </pre>
    <li>Az Angular automatikusan az src/scss mappát fogja keresni az @import hivatkozásnál
      <ul>
        <li>Vagy más mappákat, amiket még megadunk a tömbben</li>
      </ul>
    </li>
    <li>Az beállított elérési út minden SCSS fájl importálásakor érvényes lesz</li>
  </ul>
</div>

<div>
  <h3 #jsmethods data-anchor="jsmethods">Javascript methods</h3>
  <ul>
    <li>trim()
      <ul>
        <li>Eltávolítja a szöveg elejéről és végéről a felesleges szóközöket</li>
        <pre>
  let str = "  Hello World!  ";
  console.log(str.trim());

  ↓↓↓↓↓

  "Hello World!"
        </pre>
      </ul>
    </li>
    <li>eval()
      <ul>
        <li>Futásidőben JavaScript kódot hajt végre, amit stringként kap</li>
        <li>biztonsági kockázatot jelenthet</li>
        <pre>
  let code = "2 + 2";
  console.log(eval(code));

  ↓↓↓↓↓

  4
        </pre>
      </ul>
    </li>
    <li>join()
      <ul>
        <li>Egy tömb elemeit összefűzi egy megadott szeparátorral</li>
        <li>Hasznos, ha egy tömböt szeretnénk stringgé alakítani</li>
        <pre>
  let arr = ["Hello", "World"];
  console.log(arr.join(" "));

  ↓↓↓↓↓

  "Hello World"
        </pre>
      </ul>
    </li>
    <li>slice()
      <ul>
        <li>Visszaadja a tömb, vagy string egészét, vagy egy részét</li>
        <li>Az eredeti tömböt nem módosítja, hanem egy új tömböt hoz létre</li>
        <li>Ha paraméter nélkül hívjuk meg, akkor egy teljes másolatot készít az eredeti tömbről</li>
        <pre>
  let arr = [1, 2, 3, 4];
  let copy = arr.slice(); // másolat készítés
  console.log(copy);

  ↓↓↓↓↓

  [1, 2, 3, 4]


  let arr = [1, 2, 3, 4];
  let part = arr.slice(1); // kizárólag start index-et megadva attól az indextől végig lemásolja az elemeket
  console.log(part);

  ↓↓↓↓↓

  [2, 3, 4]


  let arr = [1, 2, 3, 4, 5];
  console.log(arr.slice(1, 4)); // A start indexnél kezdődik, és az end index előtti elemig másolja az elemeket

  ↓↓↓↓↓

  [2, 3, 4]
        </pre>
      </ul>
    </li>
    <li>splice()
      <ul>
        <li>Elemeket ad hozzá, töröl vagy cserél egy tömbben</li>
        <li>A memóriában közvetlenül módosítja a tömb értékét</li>
        <li>Egy indexet vár, és a törlendő elemek számát</li>
        <li>Ha törlés nélkül szeretbénk beszúrni, a második paraméternek 0-át kell megadnunk</li>
        <pre>
  let arr = [1, 2, 3];
  arr.splice(1, 1, 99); // töröl 1 elemet az 1-es index helyén, és a helyére 99-et rak
  console.log(arr);

  ↓↓↓↓↓

  [1, 99, 3]


  let arr = [1, 2, 3, 4];
  arr.splice(2, 0, 99); // a 2-es indexre beszúrja a 99-et, törlés nélkül
  console.log(arr);

  ↓↓↓↓↓

  [1, 2, 99, 3, 4]
        </pre>
      </ul>
    </li>
    <li>indexOf()
      <ul>
        <li>Visszaadja az adott elem első előfordulási helyét egy tömbben vagy stringben</li>
        <pre>
  let arr = [1, 2, 3, 4, 2];
  console.log(arr.indexOf(2));

  ↓↓↓↓↓

  1
        </pre>
      </ul>
    </li>
    <li>findIndex()
      <ul>
        <li>Visszaadja az első elem indexét, amely megfelel egy feltételnek</li>
        <pre>
  let arr = [1, 2, 3, 4, 5];
  let index = arr.findIndex((x) => x > 3);
  console.log(index);

  ↓↓↓↓↓

  3 // a 4-es szám a 3-mas indexen már nagyobb, mint 3
        </pre>
      </ul>
    </li>
    <li>length()
      <ul>
        <li>Egy string vagy tömb hosszát adja vissza</li>
        <pre>
  let arr = [1, 2, 3];
  console.log(arr.length);

  ↓↓↓↓↓

  3
        </pre>
      </ul>
    </li>
    <li>push()
      <ul>
        <li>A memóriában közvetlenül módosítja a tömb értékét</li>
        <li>Új elemet ad a tömb végéhez</li>
        <pre>
  let arr = [1, 2];
  arr.push(3);
  console.log(arr);

  ↓↓↓↓↓

  [1, 2, 3]
        </pre>
      </ul>
    </li>
    <li>Object.keys()
      <ul>
        <li>Visszaadja az objektum összes kulcsát egy tömbben</li>
        <pre>
  let obj = &#123; a: 1, b: 2 };
  console.log(Object.keys(obj));

  ↓↓↓↓↓

  ["a", "b"]
        </pre>
      </ul>
    </li>
    <li>Object.values()
      <ul>
        <li>Visszaadja az objektum összes értékét egy tömbben</li>
        <pre>
  let obj = &#123; a: 1, b: 2 };
  console.log(Object.values(obj));

  ↓↓↓↓↓

  [1, 2]
        </pre>
      </ul>
    </li>
    <li>Object.hasOwn()
      <ul>
        <li>Ellenőrzi, hogy egy adott kulcs közvetlenül az objektumhoz tartozik-e</li>
        <li>Kulcsok létezésének ellenőrzésére használjuk objektumokban</li>
        <pre>
  let obj = &#123; a: 1 };
  console.log(Object.hasOwn(obj, 'a'));

  ↓↓↓↓↓

  true

  console.log(Object.hasOwn(obj, 'b'));

  ↓↓↓↓↓

  false
        </pre>
      </ul>
    </li>
    <li>concat()
      <ul>
        <li>Két vagy több tömböt vagy stringet összefűz</li>
        <li>Új tömbök vagy stringek létrehozásához használjuk</li>
        <pre>
  let arr1 = [1, 2];
  let arr2 = [3, 4];
  console.log(arr1.concat(arr2));

  ↓↓↓↓↓

  [1, 2, 3, 4]
        </pre>
      </ul>
    </li>
    <li>pop()
      <ul>
        <li>Eltávolítja és visszaadja a tömb utolsó elemét</li>
        <pre>
  let arr = [1, 2, 3];
  console.log(arr.pop());

  ↓↓↓↓↓

  3


  console.log(arr);

  ↓↓↓↓↓

  [1, 2]
        </pre>
      </ul>
    </li>
    <li>at()
      <ul>
        <li>A tömb, vagy string adott indexű elemét adja vissza, negatív index esetén a végéről számítva</li>
        <li>Ha pozitív indexet adunk meg az at()-nek, akkor ugyanúgy működik, mint a hagyományos arr[index] szintaxis
        </li>
        <pre>
  let test = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];

  console.log(test.at(5));

  ↓↓↓↓↓

  6


  let test = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]; // a 13-mas érték a -1-es index

  console.log(test.at(-5));

  ↓↓↓↓↓

  9
        </pre>
      </ul>
    </li>
    <li>reverse()
      <ul>
        <li>Megfordítja a tömb elemeinek sorrendjét</li>
        <pre>
  let arr = [1, 2, 3];
  console.log(arr.reverse());

  ↓↓↓↓↓

  [3, 2, 1]
        </pre>
      </ul>
    </li>
    <li>flat()
      <ul>
        <li>Többdimenziós tömböt lapít egy szinttel</li>
        <pre>
  let arr = [1, [2, [3, 4]]];
  console.log(arr.flat()); // 

  ↓↓↓↓↓

  [1, 2, [3, 4]]


  console.log(arr.flat(1)); // 

  ↓↓↓↓↓

  [1, 2, [3, 4]]

  
  console.log(arr.flat(2)); // 

  ↓↓↓↓↓

  [1, 2, 3, 4]
        </pre>
      </ul>
    </li>
    <li>sort()
      <ul>
        <li>Sorba rendezi a tömb elemeit</li>
        <pre>
  let arr = [3, 1, 2];
  console.log(arr.sort());

  ↓↓↓↓↓

  [1, 2, 3]
        </pre>
      </ul>
    </li>
    <li>toLowerCase()
      <ul>
        <li>A string összes betűjét kisbetűssé alakítja</li>
        <pre>
  let str = "HELLO";
  console.log(str.toUpperCase());

  ↓↓↓↓↓

  "hello"
        </pre>
      </ul>
    </li>
    <li>toUpperCase()
      <ul>
        <li>A string összes betűjét nagybetűssé alakítja</li>
        <pre>
  let str = "hello";
  console.log(str.toUpperCase());

  ↓↓↓↓↓

  "HELLO"
        </pre>
      </ul>
    </li>
    <li>flatMap()
      <ul>
        <li>Először egy függvény segítségével átalakítja a tömb elemeit, majd ellapítja az eredményt</li>
        <pre>
  const numbers = [1, 2, 3];

  const result = numbers.flatMap(num => [num, num * 2]); // minden számhoz adjuk hozzá a szám és a szám dupláját

  console.log(result); 

  ↓↓↓↓↓

  [1, 2, 2, 4, 3, 6]


  const users = [
    &#123; name: 'Alice', comments: ['Nice post!', 'Thanks!'] },
    &#123; name: 'Bob', comments: ['Great article!', 'Very helpful.'] },
    &#123; name: 'Charlie', comments: ['Loved it!', 'Keep it up!'] }
  ];

  // 
  const allComments = users.flatMap(user => user.comments); // a flatMap segítségével egy lapos tömböt kapunk, ami tartalmazza az összes hozzászólást

  console.log(allComments);

  ↓↓↓↓↓

  ["Nice post!", "Thanks!", "Great article!", "Very helpful.", "Loved it!", "Keep it up!"]

        </pre>
      </ul>
    </li>
    <li>reduce()
      <ul>
        <li>Az elemeket egyetlen értékké redukálja egy függvény alapján</li>
        <li>Összegzéshez, szorzáshoz, vagy összetettebb aggregációkhoz használjuk</li>
        <li>Az alapértelmezett viselkedése, hogy a tömb elemeit lépésről lépésre "összegyűjti", és visszaad egy végső
          értéket</li>
        <pre>
  let arr = [1, 2, 3];
  let sum = arr.reduce((acc, curr) => acc + curr, 0); // 0 a kezdő érték
  console.log(sum);

  ↓↓↓↓↓

  6


  const transactions = [
    &#123; id: 1, amount: 100, category: 'Food' },
    &#123; id: 2, amount: 50, category: 'Transport' },
    &#123; id: 3, amount: 200, category: 'Food' },
    &#123; id: 4, amount: 150, category: 'Entertainment' },
    &#123; id: 5, amount: 120, category: 'Food' },
    &#123; id: 6, amount: 90, category: 'Transport' }
  ];

  const summary = transactions.reduce((accumulator, transaction) => &#123; // összesítjük a tranzakciók összegét kategóriánként
    
    if (!accumulator[transaction.category]) &#123; // ha az adott kategória még nem létezik az accumulator-ben, akkor inicializáljuk
      accumulator[transaction.category] = 0;
    }

    accumulator[transaction.category] += transaction.amount; // hozzáadjuk az aktuális tranzakció összegét a megfelelő kategóriához

    return accumulator;
  }, &#123;}); // a kezdő érték egy üres objektum

  console.log(summary);

  ↓↓↓↓↓

  &#123; Food: 420, Transport: 140, Entertainment: 150 }
        </pre>
      </ul>
    </li>
    <li>some()
      <ul>
        <li>Ellenőrzi, hogy van-e legalább egy olyan elem a tömbben, amely megfelel egy feltételnek</li>
        <pre>
  let arr = [1, 2, 3];
  console.log(arr.some(x => x > 2));

  ↓↓↓↓↓

  true


  const transactions = [
    &#123; id: 1, amount: 100 },
    &#123; id: 2, amount: 250 },
    &#123; id: 3, amount: 500 },
    &#123; id: 4, amount: 1200 },
    &#123; id: 5, amount: 600 }
  ];

  const hasLargeTransaction = transactions.some(transaction => transaction.amount > 1000); // ellenőrizzük, hogy van-e olyan tranzakció, ami meghaladja az 1000-et

  console.log(hasLargeTransaction);

  ↓↓↓↓↓

  true
        </pre>
      </ul>
    </li>
    <li>find()
      <ul>
        <li>Visszaadja az első olyan elemet, amely megfelel egy feltételnek</li>
        <li>Akkor használjuk, ha egy konkrét elem megtalálására van szükség</li>
        <pre>
  let arr = [1, 2, 3, 4];
  console.log(arr.find(x => x > 2));

  ↓↓↓↓↓

  3


  const texts = ['hi', 'hello', 'hello there'];

  console.log(texts.find(f => f.length > 6));

  ↓↓↓↓↓

  'hello there'
        </pre>
      </ul>
    </li>
    <li>split()
      <ul>
        <li>Felosztja a stringet egy megadott karakter alapján, és egy tömböt ad vissza</li>
        <pre>
  let str = "a,b,c";
  console.log(str.split(","));

  ↓↓↓↓↓

  ["a", "b", "c"]
        </pre>
      </ul>
    </li>
    <li>includes()
      <ul>
        <li>Ellenőrzi, hogy egy string, vagy tömb tartalmaz-e egy adott részletet, elemet</li>
        <pre>
  let str = "hello world";
  console.log(str.includes("world"));

  ↓↓↓↓↓

  true


  const arr = ['ok', 'nemok', 'kb'];

  console.log(arr.includes('kb'));

  ↓↓↓↓↓

  true
        </pre>
      </ul>
    </li>
    <li>filter()
      <ul>
        <li>Új tömböt ad vissza a feltételnek megfelelő elemekkeL</li>
        <pre>
  let arr = [1, 2, 3, 4];
  let filtered = arr.filter(x => x > 2);
  console.log(filtered);

  ↓↓↓↓↓

  [3, 4]
        </pre>
      </ul>
    </li>
    <li>map()
      <ul>
        <li>Minden elemre alkalmaz egy függvényt, és az eredményeket egy új tömbben adja vissza</li>
        <pre>
  let arr = [1, 2, 3];
  let doubled = arr.map(x => x * 2);
  console.log(doubled);

  ↓↓↓↓↓

  [2, 4, 6]
        </pre>
      </ul>
    </li>
    <li>every()
      <ul>
        <li>Ellenőrzi, hogy minden elem megfelel-e egy feltételnek</li>
        <pre>
  let arr = [1, 2, 3];
  console.log(arr.every(x => x > 0));

  ↓↓↓↓↓

  true
        </pre>
      </ul>
    </li>
    <li>Object.entries()
      <ul>
        <li>Visszaadja az objektum kulcs-érték párok tömbjét</li>
        <pre>
  let obj = &#123; a: 1, b: 2 };
  console.log(Object.entries(obj));

  ↓↓↓↓↓

  [["a", 1], ["b", 2]]
        </pre>
      </ul>
    </li>
    <li>Object.assign()
      <ul>
        <li>Egy vagy több objektumot egy másik objektumba másol</li>
        <pre>
  let target = &#123; a: 1 };
  let source = &#123; b: 2 };
  Object.assign(target, source);
  console.log(target);

  ↓↓↓↓↓

  &#123; a: 1, b: 2 }
        </pre>
      </ul>
    </li>
    <li>Object.fromEntries()
      <ul>
        <li>A kulcs-érték pár tömbből visszaalakítja az objektumot</li>
        <pre>
  const entries = [['name', 'Alice'], ['age', 30]];
  const person = Object.fromEntries(entries);
  console.log(person);

  ↓↓↓↓↓

  &#123; name: 'Alice', age: 30 }
        </pre>
      </ul>
    </li>
    <li>Math.random()
      <ul>
        <li>Visszaad egy véletlen számot 0 és 1 között</li>
        <pre>
          console.log(Math.random());

          ↓↓↓↓↓

          0.132947


          const randomInt = Math.floor(Math.random() * 101); // 0 és 100 közötti véletlenszerű egész számot ad vissza
          console.log(randomInt);

          ↓↓↓↓↓

          32
        </pre>
      </ul>
    </li>
    <li>Math.floor()
      <ul>
        <li>Lefelé kerekíti az értéket</li>
        <pre>
          const number = 4.7;
          console.log(Math.floor(number));

          ↓↓↓↓↓

          4
        </pre>
      </ul>
    </li>
    <li>Math.ceil()
      <ul>
        <li>Felfelé kerekíti az értéket</li>
        <pre>
          const number = 4.7;
          console.log(Math.floor(number));

          ↓↓↓↓↓

          5
        </pre>
      </ul>
    </li>
    <li>setTimeout()
      <ul>
        <li>Egyszeri késleltetett futtatást biztosít</li>
        <pre>
  console.log("A folyamat elkezdődött");

  setTimeout(() => &#123;
    console.log("Ez a üzenet 3 másodperc múlva jelenik meg");
  }, 3000); // a 3000 milliszekundumban van megadva, ami 3 másodpercet jelent

  console.log("A folyamat folytatódik...");

  ↓↓↓↓↓

  A folyamat elkezdődött
  A folyamat folytatódik...
  Ez a üzenet 3 másodperc múlva jelenik meg
        </pre>
      </ul>
    </li>
    <li>setInterval()
      <ul>
        <li>Egy függvényt ismétlődően hajt végre egy meghatározott időközönkén</li>
        <li>A függvény minden időközönként lefut, amíg nem töröljük a clearInterval() segítségével</li>
        <pre>
  let count = 0;

  const intervalId = setInterval(() => &#123;
    console.log(`Ez az üzenet $&#123;++count} másodpercenként jelenik meg`);
    
    // Leállítjuk az intervallumot 5 ismétlés után
    if (count === 5) &#123;
      clearInterval(intervalId);
      console.log("Az intervallum leállt");
    }
  }, 1000); // 1000 milliszekundum (1 másodperc)

  ↓↓↓↓↓

  Ez az üzenet 1 másodpercenként jelenik meg
  Ez az üzenet 2 másodpercenként jelenik meg
  Ez az üzenet 3 másodpercenként jelenik meg
  Ez az üzenet 4 másodpercenként jelenik meg
  Ez az üzenet 5 másodpercenként jelenik meg
  Az intervallum leállt
        </pre>
      </ul>
    </li>
    <li>isNaN
      <ul>
        <li>ellenőrzi, hogy egy érték NaN-e (Not-a-Number)</li>
        <li>Automatikusan átalakítja a bemenetet szám típussá, és csak utána vizsgál</li>
        <pre>
  isNaN(123);        // false   mert 123 egy szám
  isNaN('hello');    // true    mert 'hello' nem alakítható számmá
  isNaN(undefined);  // true    mert undefined nem szám
  isNaN(null);       // false   mert a null numerikus értékké (0) alakul
  isNaN('123');      // false   mert a '123' string számmá alakítható
  isNaN(NaN);        // true    mert NaN önmaga is NaN
        </pre>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #ngrx data-anchor="ngrx">NgRx</h3>
  <ul>
    <li>Reactive State for Angular</li>
    <li>Egy állapotkezelő könyvtár Angular alkalmazásokhoz, amely a Redux mintán alapul
      <ul>
        <li>A Redux minta egy olyan állapotkezelési megoldás, ahol az alkalmazás teljes állapota egy központi helyen van
          tárolva, és az állapot csak jól meghatározott műveletek (actions) és azokhoz kapcsolódó állapotfrissítő
          funkciók (reducers) segítségével változhat, ami átláthatóbbá, és könnyebben követhetővé teszi az állapot
          változásait</li>
      </ul>
    </li>
    <li>Az állapotot egy központi "store"-ban tartja, ami megkönnyíti az adatok előzményének követését, debuggolását és
      tesztelését</li>
    <li>Fogalmak
      <ol>
        <li>Store
          <ul>
            <li>A központi hely, ahol az alkalmazás állapotát tároljuk</li>
          </ul>
        </li>
        <li>Actions
          <ul>
            <li>Az állapot módosítására vonatkozó események</li>
          </ul>
        </li>
        <li>Reducers
          <ul>
            <li>Funkciók, amelyek meghatározzák, hogyan változik az állapot az egyes akciók hatására</li>
          </ul>
        </li>
        <li>Effects
          <ul>
            <li>"Mellék" műveletek kezelése (pl. API hívások)</li>
          </ul>
        </li>
        <li>Selectors
          <ul>
            <li>Az állapot különböző részeinek kinyerésére szolgálnak</li>
          </ul>
        </li>
      </ol>
    </li>
    <br>
    <li>Lifecycle
      <ul>
        <br>
        <img src="assets/imgs/ngrx_flow.png" width="100%">
        <br>
        <br>
        <li>A Store-ban tároljuk az App state-eket
          <ul>
            <li>Például egy számérték</li>
          </ul>
        </li>
        <li>Az Action minden olyan interakció, kezdeményezés, ami state-e módosít
          <ul>
            <li>Ha például van három gombunk, egy +, egy -, és egy reset, amik a Stora-ban lévő számot hivatottak
              módosítani</li>
          </ul>
        </li>
        <li>A Reducer fogja a valós manipuláció végrehajtani
          <ul>
            <li>Az Action alapján hajt végre valamilyen logikát</li>
            <li>Például, ha a - gombra kattintunk, akkor az jelenlegi state-ből kivon egyet</li>
            <li>Ha lefuttt a logika, átadja az értéket a Store-nak</li>
          </ul>
        </li>
        <li>A Component az az elem, ami megjelenik számunkra
          <ul>
            <li>Például kiírja a Store-ban tárolt aktuális számértéket</li>
            <li>Tulajdonképpen a Component határozza meg az Action-t, hiszen benne jelennek meg azok az eszközök,
              amikkel adatmanupulációt tudunk kezdeményezni</li>
          </ul>
        </li>
        <li>Selector
          <ul>
            <li>Ahhoz, hogy a Component meg tudja jeleníteni a State-et, ki kell választanunk azt</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Használat
      <ul>
        <pre>
  ng add @ngrx/store@16
        </pre>
        <li>Hozzunk létre egy mappát (pl. state), és benne egy fájlt (app.state.ts) az állapotok kezeléséhez</li>
        <pre>
  state/
  ├── app.state.ts              // a globális állapotok leírására szolgál
  └── counter/
      ├── counter.actions.ts
      └── counter.reducer.ts
      └── counter.selector.ts
        </pre>
        <li>Amennyiben egy egyszerű countert veszünk alapul, úgy készítsünk egy counter mappát, benne pedig egy
          counter.actions.ts fájlt</li>
        <pre>
  <b>// counter.action.ts</b>
  import &#123; createAction } from "@ngrx/store";

  export const increment = createAction('[Counter Component] Increment');
  export const decrement = createAction('[Counter Component] Decrement');
  export const reset = createAction('[Counter Component] Reset');
        </pre>
        <li>Az Action-ök ezzel regisztrálva vannak a Store-ban</li>
        <pre>
  <b>// counter.reducer.ts</b>
  import &#123; createReducer, on } from "@ngrx/store"
  import &#123; decrement, increment, reset } from "./counter.actions";

  export interface CounterState &#123;
      count: number
  }

  export const initialCounterState: CounterState = &#123;
      count: 0,
      // cart: CartState
      // ...
  }

  export const CounterReducer = createReducer(
      initialCounterState,
      on(increment, (state) => (&#123; ...state, count: state.count + 1 })), // counter.action.ts increment Action-je
      on(decrement, (state) => (&#123; ...state, count: state.count - 1 })), // counter.action.ts decrement Action-je
      on(reset, (state) => (&#123; ...state, count: 0})) // counter.action.ts reset Action-je
  );
        </pre>
        <li>A Reducer ezzel kezeli a kiindulási State-et
          <ul>
            <li>Az állapot egyetlen count mezőt tartalmaz, amely number típusú</li>
            <li>Az interface segít a típusbiztonság biztosításában</li>
            <li>A típusosság révén az IDE (például a VS Code) is képes autocomplete, és hibajelzéseket adni</li>
          </ul>
        </li>
        <pre>
  <b>// counter.selector.ts</b>
  import &#123; AppState } from "../app.state";

  export const SelectCounterState = (state: AppState) => state.counter;

  export const SelectCount = createSelector(
    SelectCounterState, 
    (state) => state.count // projektáló függvény
  )
        </pre>
        <li>El kell készítenünk a Selector-t is
          <ul>
            <li>Az app.state.ts-ben készítjük el az App State-et / global State-et</li>
            <li>Bármilyen érték is van az AppState-ben, mint counter, átadásra kerül a Selector-nak</li>
            <li>A createSelector függvény első paramétere a Selector, a második egy projektáló függvény
              <ul>
                <li>A projektáló függvény azt mondja meg, hogy a CounterState állapotból pontosan melyik adatot kell
                  kiválasztani</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Ha ez a 3 fájlunk készen van (actions, reducer, selector), akkor a Component-ben már tudjuk használni a
          State-ünket
          <ul>
            <li>A State-et regisztrálni szükséges az app.config.ts-ben / app.module.ts-ben</li>
            <pre>
  <b>// app.module.ts</b>
  @NgModule(&#123;
    ...
    providers: [
      provideStore(),
      provideState('counter', CounterReducer), // a State nevét, és a Reducer-t kell definiálni
    ],
    ...
  })
            </pre>
            <li>Akár egy state.config.ts-t is létrehozatunk, ha külön szeretnénk kezelni őket</li>
            <pre>
  <b>// state/state.config.ts</b>
  import &#123; provideState } from '@ngrx/store';
  import &#123; CounterReducer } from './counter/counter.reducer';

  export const AppStateProviders = [
    provideState('counter', CounterReducer)
  ];

  <b>// app.module.ts</b>
  @NgModule(&#123;
    ...
    providers: [
      ...AppStateProviders // spread operátort használunk, mivel tömb
    ],
    ...
  })
            </pre>
          </ul>
        </li>
      </ul>
    </li>
    <li>A megvalósított mini példa
      <ul>
        <app-ngrx></app-ngrx>
        <pre>
  <b>// ngrx.component.html</b>
    &#60;div>
      &#60;div>&#123; &#123; count$ | async }}&#60;/div>
      &#60;div>
          &#60;button class="btn btn-secondary" (click)="increment()">+&#60;/button>
          &#60;button class="btn btn-secondary" (click)="reset()">reset&#60;/button>
          &#60;button class="btn btn-secondary" (click)="decrement()">-&#60;/button>
      &#60;/div>
  &#60;/div>

  <b>// ngrx.component.ts</b>
  export class NgrxComponent &#123;
    count$: Observable&#60;number>

    constructor(private store: Store&#60;AppState>) &#123;
      this.count$ = this.store.select(SelectCount);
    }

    increment() &#123;
      this.store.dispatch(increment());
    }

    decrement() &#123;
      this.store.dispatch(decrement());
    }

    reset() &#123;
      this.store.dispatch(reset());
    }
  }
        </pre>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #svgsprite data-anchor="svgsprite">SVG sprite</h3>
  <ul>
    <li>Olyan technika, amely lehetővé teszi több SVG ikon vagy grafikai elem egyetlen fájlba történő összegyűjtését
    </li>
    <li>Segítségével hatékonyan kezelhetünk több SVG fájlt, csökkenthetjük a hálózati kérések számát, és
      gyorsíthatjuk az oldal betöltését</li>
    <li>Az egyes elemeket az &#60;use> tag segítségével lehet hivatkozni, így az adott elem nem kerül külön fájlként
      betöltésre</li>
    <pre>
  <b>// SVG sprite szerkezet</b>
  &#60;svg xmlns="http://www.w3.org/2000/svg">
      &#60;symbol id="icon-heart" viewBox="0 0 24 24">
        &#60;path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z">&#60;/path>
      &#60;/symbol>
      &#60;symbol id="icon-star" viewBox="0 0 24 24">
        &#60;path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z">&#60;/path>
      &#60;/symbol>
  &#60;/svg>
        </pre>
    <li>A &#60;symbol> tag tartalmazza az SVG egyes elemeit</li>
    <li>Az id attribútum segítségével adhatunk egyedi nevet ezeknek az elemeknek</li>
    <pre>
  <b>// SVG sprite használata</b>
  &#60;svg class="icon">
      &#60;use xlink:href="assets/icons.svg#icon-heart">&#60;/use>
  &#60;/svg>

  &#60;svg class="icon">
      &#60;use xlink:href="assets/icons.svg#icon-star">&#60;/use>
  &#60;/svg>
    </pre>
  </ul>
</div>

<div>
  <h3 #importantsites data-anchor="importantsites">Important sites</h3>
  <ul>
    <li><a href="https://caniuse.com/" target="_blank">CanIuse</a>
      <ul>
        <li>Böngészőkompatibilitás ellenőrzés</li>
        <li>Megmutatja, hogy a különböző HTML, CSS és JavaScript funkciók mely böngészőkben támogatottak</li>
      </ul>
    </li>
    <li><a href="https://css-tricks.com/" target="_blank">css-Tricks</a>
      <ul>
        <li>Népszerű blog és tudásbázis, amely tele van CSS, JavaScript és frontend fejlesztési tippekkel, trükkökkel és
          best practice-ekkel</li>
      </ul>
    </li>
    <li><a href="https://javascript.info/" target="_blank">JavaScript.info</a>
      <ul>
        <li>Részletes, jól strukturált tananyag a modern JavaScript működéséről</li>
      </ul>
    </li>
    <li><a href="https://angular.dev/update-guide" target="_blank">Angular Update Guide</a>
      <ul>
        <li>Hivatalos Angular tool</li>
        <li>Lépésről lépésre végigvezet az Angular verziófrissítés folyamatán</li>
        <li>Megmutatja, hogy milyen változások történtek az adott verziók között, és milyen módosításokat kell elvégezni
          a kódbanMegmutatja, hogy milyen változások történtek az adott verziók között, és milyen módosításokat kell
          elvégezni a kódban</li>
      </ul>
    </li>
    <li><a href="https://pagespeed.web.dev/" target="_blank">PageSpeed Insight</a>
      <ul>
        <li>Nyílt forráskódú eszköz, amely elemzi a weboldalak teljesítményét, SEO-ját, hozzáférhetőségét és legjobb
          gyakorlatait</li>
      </ul>
    </li>
    <li><a href="https://education.github.com/git-cheat-sheet-education.pdf" target="_blank">Git Cheat Sheet</a>
      <ul>
        <li>Cheatsheet a leggyakrabban használt Git parancsokhoz</li>
        <li>Tartalmaz alapvető műveleteket, haladóbb parancsokat</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #accessibilityattributes data-anchor="accessibilityattributes">Accessibility attributes</h3>
  <ul>
    <li>aria-label / aria-hidden / aria-expanded / aria-control (accessibility attributes)</li>
    <li>ARIA = Accessible Rich Internet Applications</li>
    <li>Olyan HTML attribútumokat biztosít, amelyek segítik a weboldalak hozzáférhetőségét, különösen a
      képernyőolvasókat, és más segédeszközöket használó felhasználók számára</li>
  </ul>
  <br>
  <h5 #arialabel data-anchor="arialabel">aria-label</h5>
  <ul>
    <li>aria-label
      <ul>
        <li>HTML attribútum, amely lehetővé teszi, hogy egy elemhez egy szöveges címkét (label) rendeljünk</li>
        <li>A képernyőolvasó számára olvasható, de nem jelenik meg vizuálisan az oldalon</li>
        <li>Segít a felhasználónak megérteni az elem funkcióját (például egy felirat nélküli gomb)</li>
        <br>
        <button class="btn btn-dark" aria-label="További információk megtekintése">
          <i class="bi bi-info-circle"></i>
        </button>
        <pre>
  &#60;button class="btn btn-dark" aria-label="További információk megtekintése">
    &#60;i class="bi bi-info-circle">&#60;/i>
  &#60;/button>
        </pre>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #ariahidden data-anchor="ariahidden">aria-hidden</h5>
  <ul>
    <li>Segítségével elrejthetünk egy elemet a képernyőolvasók elől anélkül, hogy eltávolítanánk azt a DOM-ból</li>
    <pre>
  &#60;div aria-hidden="true">Ez az elem rejtett a képernyőolvasók számára.&#60;/div>
    </pre>
  </ul>
  <br>
  <h5 #ariaexpanded data-anchor="ariaexpanded">aria-expanded</h5>
  <ul>
    <li>Állapotjelző attribútum, amely megmondja, hogy egy összecsukható, vagy kibővített tartalom látható-e az adott
      elem alatt</li>
    <li>Leggyakrabban menük, legördülő listák és accordion-ok esetén használjuk</li>
    <pre>
  &#60;button aria-expanded="false" aria-controls="menu">Menü&#60;/button>

  &#60;div id="menu" hidden>
    &#60;!-- menu content -->
  &#60;/div>
    </pre>
  </ul>
  <br>
  <h5 #ariacontrols data-anchor="ariacontrols">aria-controls</h5>
  <ul>
    <li>Azt jelzi, hogy az adott elem egy másik elemre van hatással</li>
    <li>Például egy gomb, amely kinyit egy menüt, vagy egy másik gomb, amely kibővíti egy szövegdoboz tartalmát</li>
    <li>Értéke a vonatkozó elem id-ja</li>
    <pre>
  &#60;button aria-controls="info-box" aria-expanded="false">További információk&#60;/button>

  &#60;div id="info-box" hidden>
    &#60;!-- More text -->
  &#60;/div>
    </pre>
  </ul>
  <br>
  <h5 #ariarole data-anchor="ariarole">aria-role</h5>
  <ul>
    <li>Meghatározza, hogy egy adott elem milyen szerepet (funkciót) tölt be a weboldalon</li>
    <li>Ha egy HTML elem viselkedése nem egyértelmű a böngésző számára, az aria-role segítsévével azonosíthatjuk a
      funkcióját</li>
    <pre>
  &#60;div role="button" tabindex="0">Kattints ide!&#60;/div>
    </pre>
  </ul>
  <br>
  <h5 #arialive data-anchor="arialive">aria-live</h5>
  <ul>
    <li>Dinamikusan frissülő tartalmaknál használják, hogy jelezze a képernyőolvasó számára, hogy egy elem tartalma
      frissült</li>
    <li>Segít a frissített tartalom figyelésében, és olvasásában</li>
    <li>Értékei lehetnek
      <ol>
        <li>off - a frissülő tartalomról nem szükséges értesíteni a felhasználót</li>
        <li>polite - az frissítésről az üzenet csak akkor kerül beolvasásra, amikor az aktuális beszéd befejeződik</li>
        <li>assertive - a képernyőolvasónak azonnal értesíti a felhasználót a frissülő tartalomról</li>
      </ol>
    </li>
    <pre>
  &#60;div aria-live="polite">A tartalom frissült.&#60;/div>
    </pre>
  </ul>
  <br>
  <h5 #ariadescribedby data-anchor="ariadescribedby">aria-describedby</h5>
  <ul>
    <li>Egy elemhez kapcsol egy másik elemet, amely további leírást ad a felhasználónak</li>
    <li>Gyakran űrlapoknál, és interaktív elemeknél alkalmazzák, hogy magyarázó szöveget biztosítsanak</li>
    <pre>
  &#60;input type="text" aria-describedby="emailHelp">
  &#60;small id="emailHelp">Kérjük, adja meg az email címét.&#60;/small>
    </pre>
  </ul>
  <br>
  <h5 #ariachecked data-anchor="ariachecked">aria-checked</h5>
  <ul>
    <li>Jelzi, hogy egy interaktív elem (például egy checkbox) ki van-e választva, és azt is, hogy milyen állapotban van
    </li>
    <li>Értékei lehetnek
      <ol>
        <li>false - nincs kiválasztva</li>
        <li>true - ki van választva</li>
        <li>mixed - részben kiválasztott az elem (például indeterminate Bootstrap checkbox)</li>
      </ol>
    </li>
    <pre>
  &#60;input type="checkbox" aria-checked="true"> Feltételek elfogadása
    </pre>
  </ul>
  <br>
  <h5 #ariaselected data-anchor="ariaselected">aria-selected</h5>
  <ul>
    <li>Azt jelzi, hogy egy elem ki van választva egy csoportból</li>
    <li>Tab-oknál vagy listáknál használatos, hogy a felhasználó tudja, melyik elem van kiválasztva</li>
    <pre>
  &#60;li role="tab" aria-selected="true">Tab 1&#60;/li>
  &#60;li role="tab" aria-selected="false">Tab 2&#60;/li>
    </pre>
  </ul>
  <br>
  <h5 #ariainvalid data-anchor="ariainvalid">aria-invalid</h5>
  <ul>
    <li>Ha egy form mező érvénytelen, true értéket vesz fel</li>
    <li>Különösen hasznos űrlapok esetében, amikor a felhasználónak egy hibát jelezni kell</li>
    <pre>
  &#60;input type="email" aria-invalid="true" />
    </pre>
  </ul>
</div>

<div>
  <h3 #cdn data-anchor="cdn">CDN</h3>
  <ul>
    <li>Content Delivery Network
      <ul>
        <li>hálózati infrastruktúra, amely a weboldalak tartalmát különböző szerverekre tárolja, amelyek földrajzilag
          elosztva vannak a világ különböző pontjain</li>
      </ul>
    </li>
    <li>Egy globális hálózat, amely a weboldalak statikus tartalmát (például képek, CSS, JavaScript fájlok) gyorsabban,
      és hatékonyabban képes elérhetővé tenni a felhasználók számára, függetlenül attól, hogy hol tartózkodnak a
      világban
    </li>
    <li>A felhasználó, amikor megnyitja a weboldalt, a geográfiailag legközelebbi CDN szerveréről tölti le az adatokat
    </li>
    <li>Gyors betöltést, terheléselosztás, magas uptime-ot biztosít</li>
    <pre>
  &#60;!-- jQuery CDN -->
  &#60;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js">&#60;/script>

  &#60;!-- Bootstrap CDN -->
  &#60;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  &#60;script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js">&#60;/script>
    </pre>
  </ul>
</div>

<div>
  <h3 #es6 data-anchor="es6">ES6</h3>
  <ul>
    <li>Avagy ECMAScript 2015, a JavaScript egyik verziója</li>
    <li>A JavaScript egyik legnagyobb, és legfontosabb frissítése volt</li>
    <li>Az ECMAScript a JavaScript hivatalos szabványa, amelyet az ECMA International fejleszt és karbantart</li>
    <li>Az ES6 számos új funkciót hozott a JavaScript nyelvbe, amelyeket ma már széles körben használnak a modern
      fejlesztésben</li>
    <li>A legtöbb modern böngésző, és JavaScript motor már támogatja az ES6-t
      <ul>
        <li>Illetve az újabb ECMAScript verziókat is</li>
      </ul>
    </li>
    <li>A TypeScript alapja ES6+ szintaxisra épül, tehát minden ES6 funkció elérhető benne
      <ul>
        <li>TypeScriptben akár ESNext (a legújabb ECMAScript szabványok) kódot is írhatunk</li>
      </ul>
    </li>
    <li>A legfontosabb újításai
      <ol>
        <li>let és const változók
          <ul>
            <pre>
  let x = 10;  // újra értéket lehet adni neki
  const y = 20; // állandó, nem módosítható
            </pre>
          </ul>
        </li>
        <li>Arrow functions
          <ul>
            <li>Rövidebb szintaxist eredményez</li>
            <li>Megőrzi a this kontextust</li>
            <li>Nem kell külön return, ha csak egy kifejezést tartalmaz</li>
            <pre>
  const add = (a, b) => a + b;
  console.log(add(2, 3));

  ↓↓↓↓↓

  5
            </pre>
          </ul>
        </li>
        <li>Backtick szintaxis ``
          <ul>
            <li>Template literal</li>
            <li>Helyettesíti a régi + összefűzést</li>
            <li>Segítségével többsoros szövegeket is könnyen lehet kezelni</li>
            <li>Változókat és kifejezéseket ( $&#123;} ) is könnyen beilleszthetünk</li>
            <pre>
  const name = "John Connor";
  console.log(`Hello, $&#123;name}!`);

  ↓↓↓↓↓

  "Hello, John!"


  const text = `Ez egy többsoros
      szöveg, amit gond nélkül
      leírhatunk több sorban!`;

  console.log(text);

  ↓↓↓↓↓

  "Ez egy többsoros szöveg, amit gond nélkül leírhatunk több sorban!""
            </pre>
          </ul>
        </li>
        <li>Destructuring
          <ul>
            <li>Objektumok és tömbök bontása</li>
            <li>Egyszerűsíti az értékek kinyerését objektumokból és tömbökből</li>
            <pre>
  // object destructuring
  const person = &#123; name: "Alice", age: 25 };
  const &#123; name, age } = person;
  console.log(name, age);

  ↓↓↓↓↓

  "Alice" 25
            </pre>
          </ul>
        </li>
        <li>Spread és Rest operátor
          <ul>
            <li>Másolat készítéséhez, és argumentumok összegyűjtéséhez</li>
            <pre>
  const arr = [1, 2, 3];
  const newArr = [...arr, 4, 5]; // spread - a másolathoz új elemeket adunk
  console.log(newArr);

  ↓↓↓↓↓

  [1, 2, 3, 4, 5]

  function sum(...numbers) &#123; // rest - több paraméter egy tömbbe gyűjtve
    return numbers.reduce((acc, num) => acc + num, 0);
  }
  console.log(sum(1, 2, 3, 4));

  ↓↓↓↓↓

  10
            </pre>
          </ul>
        </li>
        <li>Class (OOP támogatás)
          <ul>
            <li>Bevezetésre került a class szintaxis, ami tisztább OOP-t (objektum-orientált programozást) tesz lehetővé
            </li>
            <pre>
  class Fruit &#123;
    constructor(name) &#123;
      this.name = name;
    }
    name() &#123;
      console.log(`$&#123;this.name} makes me hungry!`);
    }
  }
  
  const fruit = new Fruit("Orange");
  fruit.name(); 
  
  ↓↓↓↓↓

  "Orange makes me hungry!"
            </pre>
          </ul>
        </li>
        <li>Module-ok
          <ul>
            <li>Import és export</li>
            <li>Segítségével külön fájlokba szervezhetjük a kódot</li>
            <pre>
  // math.js
  export const add = (a, b) => a + b;

  // main.js
  import &#123; add } from './math.js';
  console.log(add(8, 5));

  ↓↓↓↓↓

  13
            </pre>
          </ul>
        </li>
        <li>Promise
          <ul>
            <li>Aszinkron műveletek</li>
            <li>Az ES6 bevezette a Promise-okat az aszinkron műveletek jobb kezelésére</li>
            <pre>
  const fetchData = () => &#123;
    return new Promise((resolve) => &#123;
      setTimeout(() => resolve("Adat betöltve!"), 2000);
    });
  };
  
  fetchData().then(data => console.log(data)); // 2mp múlva: "Adat betöltve!"              
            </pre>
          </ul>
        </li>
      </ol>
    </li>
    <li>Angularban is találkozhatunk különféle ES verziókkal
      <ul>
        <li>A tsconfig.json fájlban a target, module és lib beállításoknál
          <ul>
            <li>target
              <ul>
                <li>Meghatározza, hogy milyen JavaScript verzióra fordítsa le a TypeScript kódot (például ES5, ES6,
                  ES2022, stb.)</li>
              </ul>
            </li>
            <li>module
              <ul>
                <li>Meghatározza, hogy milyen modulkezelési rendszert használjon az app (például CommonJS, ESNext, AMD,
                  stb.)
                </li>
              </ul>
            </li>
            <li>lib
              <ul>
                <li>Meghatározza, hogy milyen beépített funkciókat, és API-kat támogasson az app (például DOM, ES2020,
                  ESNext, stb.)
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Ezek a beállítások azért fontosak, mert meghatározzák, hogy az elkészült JavaScript kód milyen környezetben
          (példéul böngésző, Node.js) fog megfelelően működni</li>
      </ul>
    </li>
    <br>
    <li>Kiegészítések
      <ol>
        <li>ES5 - Az egyik legelterjedtebb JavaScript szabvány (2009-ből), széles körben támogatott, de még nem
          tartalmazza a modern ES6 funkciókat</li>
        <li>ES2017 - Bevezette az async/await szintaxist, az Object.values() és Object.entries() metódusokat</li>
        <li>ES2020 - Többek között az optional chaining (?.), nullish coalescing (??), és a BigInt támogatásával bővült
        </li>
        <li>ES2022 - Új class fields, top-level await, Array.prototype.at() és más fejlesztések kerültek bele</li>
        <li>ESNext - Az éppen fejlesztés alatt álló, legfrissebb JavaScript verziót jelenti</li>
        <li>AMD - Asynchronous Module Definition, egy modulkezelési rendszer, amelyet főleg böngészőoldali JavaScript
          kódokhoz használtak</li>
        <li>DOM - Document Object Model, egy böngésző API, amely lehetővé teszi a HTML, és XML dokumentumok
          manipulálását JavaScript segítségével</li>
      </ol>
    </li>
  </ul>
</div>

<div>
  <h3 #elementref data-anchor="elementref">ElementRef</h3>
  <ul>
    <li>ElementRef
      <ul>
        <li>Az Angular által biztosított osztály, amely lehetővé teszi, hogy hozzáférjünk a natív DOM elemhez, amely
          egy adott Angular komponensben, vagy direktívában szerepel</li>
        <li>Egy egyszerű wrapper, amely az adott DOM elemet reprezentálja, és az Angular környezetén
          kívül lehetővé teszi az elérését</li>
      </ul>
    </li>
    <li>nativeElement
      <ul>
        <li>Az ElementRef tulajdonsága, amely közvetlenül az adott DOM elemet adja vissza</li>
        <li>Lehetővé teszi, hogy közvetlenül manipuláljuk a DOM elemet, például megváltoztassuk a stílusát,
          attribútumait, vagy bármilyen egyéb jellemzőjét</li>
      </ul>
    </li>
    <br>
    <li>Közvetlen DOM módosítás
      <ul>
        <li>Közvetlen DOM manipulációt csak akkor alkalmazzunk, ha valóban szükséges, mivel az Angular biztonsági
          mechanizmusai nem érvényesülnek ilyenkor</li>
        <pre>
          constructor(private el: ElementRef) &#123;} // a this.el.nativeElement az adott komponens vagy direktíva gyökér DOM elemére mutat

          ngAfterViewInit() &#123;
            this.el.nativeElement.style.backgroundColor = 'yellow';
          }

        </pre>
      </ul>
    </li>
    <li>Ajánlott DOM módosítás
      <ul>
        <li>Az Angular ajánlása szerint a manipulációkat a Renderer2-vel kell végezni</li>
        <li>Biztosítja az Angular biztonságos működését, például a különböző platformok közötti kompatibilitást (például
          server-side rendering)</li>
        <pre>
            constructor(private renderer: Renderer2, private el: ElementRef) &#123;}

            ngAfterViewInit() &#123;
              this.renderer.setStyle(this.el.nativeElement, 'backgroundColor', 'yellow');
            }
          </pre>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #injectable data-anchor="injectable">@Injectable</h3>
  <ul>
    <li>Angular dekorátor</li>
    <li>arra szolgál, hogy jelezze, hogy egy osztály "injectable", vagyis az osztály példányosítása DI (Dependency
      Injection) segítségével történhet</li>
    <li>A DI-t használva biztosítjuk, hogy az osztályok példányait más komponensek, vagy szolgáltatások használhatják
    </li>
    <li>Paraméterei
      <ol>
        <li>providedIn
          <ul>
            <li>Meghatározza, hogy hol regisztráljuk a szolgáltatást, és mikor legyen az elérhető</li>
            <li>Az alapértelmezett értéke null
              <ul>
                <li>Ebben az esetben a szolgáltatás explicit módon a @NgModule-ban kell, hogy regisztrálva legyen</li>
              </ul>
            </li>
            <li>Értékei
              <ol>
                <li>root
                  <ul>
                    <li>A leggyakrabban használt</li>
                    <li>A szolgáltatás globálisan elérhetővé válik az egész alkalmazás számára</li>
                    <li>Az Angular automatikusan regisztrálja az adott szolgáltatást az alkalmazás gyökérmoduljában</li>
                    <li>Ezzel elkerülhetjük a szolgáltatás manuális hozzáadását a providers tömbhöz a @NgModule-ban</li>
                    <li>A szolgáltatás egyetlen példánya (singleton) lesz az alkalmazásban</li>
                    <pre>
  @Injectable(&#123;
    providedIn: 'root'
  })
  
  export class MyService &#123; }
                    </pre>
                  </ul>
                </li>
                <li>platform
                  <ul>
                    <li>A szolgáltatás a platform szinten lesz elérhető, és így megosztható több Angular alkalmazás
                      között ugyanazon a platformon</li>
                    <li>Nem olyan gyakran használt, de különböző alkalmazások közötti megosztás esetén hasznos lehet
                    </li>
                    <pre>
  @Injectable(&#123;
    providedIn: 'platform'
  })

  export class MyService &#123; }
                    </pre>
                  </ul>
                </li>
                <li>any
                  <ul>
                    <li>Azt jelenti, hogy az adott szolgáltatás minden egyes module esetén külön példányosítódik</li>
                    <li>Hasznos lehet, ha azt szeretnénk, hogy a szolgáltatás minden modul számára külön példányban
                      legyen elérhető</li>
                    <pre>
  @Injectable(&#123;
    providedIn: 'any'
  })

  export class MyService &#123; }                        
                      </pre>
                  </ul>
                </li>
                <li>null
                  <ul>
                    <li>Az alapértelmezett érték</li>
                    <li>A szolgáltatás nem kerül automatikusan regisztrálásra</li>
                    <li>A szolgáltatás explicit módon kell, hogy regisztrálva legyen egy modul providers tömbjében</li>
                    <pre>
  @Injectable(&#123;
    providedIn: null
  })

  export class MyService &#123; }                      
                    </pre>
                  </ul>
                </li>
              </ol>
            </li>
          </ul>
        </li>
        <li>factory
          <ul>
            <li>Ritkán használt paraméter</li>
            <li>Egy függvény, amely a szolgáltatás példányát létrehozza</li>
            <li>A DI rendszer által futtatott kód, amely a szolgáltatás példányosítását végzi</li>
            <pre>
  @Injectable(&#123;
    providedIn: 'root',
    factory: () => new MyService()  // a szolgáltatás példányosítása factory függvényből
  })
  
  export class MyService &#123; }              
            </pre>
            <li>A szolgáltatás példányát nem közvetlenül az Angular Dependency Injection rendszere hozza létre, hanem
              egy általunk megadott factory függvény generálja azt</li>
            <pre>
  export class MyService &#123;
    constructor(private message: string) &#123;}
  
    logMessage() &#123;
      console.log(this.message);
    }
  }


  export function myServiceFactory() &#123;
    // dinamikusan generáljuk a szolgáltatás példányát, például egy üzenettel.
    return new MyService('We used factory function!');
  }

  
  import &#123; Injectable } from '@angular/core';

  @Injectable(&#123;
    providedIn: 'root',
    factory: myServiceFactory  // factory függvény megadása
  })
  export class MyService &#123;
    constructor(private message: string) &#123;}

    logMessage() &#123;
      console.log(this.message);
    }
  }
              </pre>
            <li>Miután a szolgáltatás regisztrálva van a DI rendszerben, ugyanúgy tudjuk használni, mint bármely más
              szolgáltatást az Angular DI rendszerének segítségével</li>
          </ul>
        </li>
      </ol>
    </li>


    <li>@Injectable(&#123;providedIn: 'root'})
      <ul>
        <li>providedIn: 'platform' / 'any'</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #tabindex data-anchor="tabindex">tabindex</h3>
  <ul>
    <li>Az input mezők tabulátor sorrendjét a tabindex attribútum segítségével állíthatjuk be a HTML-ben</li>
    <li>Értékei lehetnek
      <ol>
        <li>pozitív
          <ul>
            <li>A mezők tab sorrendjét állíthatjuk be vele</li>
          </ul>
        </li>
        <li>0
          <ul>
            <li>A normális tab sorrendben következik</li>
          </ul>
        </li>
        <li>-1
          <ul>
            <li>Az elem nem lesz fókuszálható a Tab billentyűvel</li>
            <li>Kisebb számot megadva az alapértelmezett tabindex="0"-ként viselkedik, vagy a böngésző figyelmen kívül
              hagyja</li>
          </ul>
        </li>
      </ol>
    </li>
    <li>Alapértelmezés szerint a fókuszálható elemek tulajdonképpen megkapják a tabindex="0" értéket</li>
    <li>Alapértelmezetten indexelt elemek
      <ol>
        <li>input</li>
        <li>textarea</li>
        <li>select</li>
        <li>button</li>
        <li>a (de csak ha href-fel ellátott)</li>
        <li>details</li>
        <li>iframe</li>
        <li>pre</li>
      </ol>
    </li>
    <li>Indexelhető elemek
      <ol>
        <li>div</li>
        <li>span</li>
        <li>p</li>
        <li>fieldset</li>
        <li>legend</li>
        <li>table, tr, td</li>
      </ol>
    </li>
    <br>
    <div class="container">
      <div class="row">
        <div class="col-12 col-md-6 col-xl-3 mx-auto">
          <form>
            <div class="input-group mb-3">
              <input type="text" class="form-control" tabindex="1" placeholder="tabindex='1'">
            </div>
            <div class="input-group mb-3">
              <input type="text" class="form-control" tabindex="3" placeholder="tabindex='3'">
            </div>
            <div class="input-group mb-3">
              <input type="text" class="form-control" tabindex="2" placeholder="tabindex='2'">
            </div>
            <div class="input-group mb-3">
              <input type="text" class="form-control" tabindex="0" placeholder="tabindex='0'">
            </div>
            <div class="input-group mb-3">
              <input type="text" class="form-control" tabindex="-1" placeholder="tabindex='-1'">
            </div>
            <div class="input-group mb-3">
              <input type="text" class="form-control" tabindex="-2" placeholder="tabindex='-2'">
            </div>
            <div class="mb-3" tabindex="4">tabindex="4"</div>
          </form>
        </div>
      </div>
    </div>
    <pre>
  &#60;form>
    &#60;div class="input-group mb-3">
      &#60;input type="text" class="form-control" tabindex="1" placeholder="tabindex='1'">
    &#60;/div>
    &#60;div class="input-group mb-3">
      &#60;input type="text" class="form-control" tabindex="3" placeholder="tabindex='3'">
    &#60;/div>
    &#60;div class="input-group mb-3">
      &#60;input type="text" class="form-control" tabindex="2" placeholder="tabindex='2'">
    &#60;/div>
    &#60;div class="input-group mb-3">
      &#60;input type="text" class="form-control" tabindex="0" placeholder="tabindex='0'">
    &#60;/div>
    &#60;div class="input-group mb-3">
      &#60;input type="text" class="form-control" tabindex="-1" placeholder="tabindex='-1'">
    &#60;/div>
    &#60;div class="input-group mb-3">
      &#60;input type="text" class="form-control" tabindex="-2" placeholder="tabindex='-2'">
    &#60;/div>
    &#60;div class="mb-3" tabindex="4">tabindex="4"&#60;/div>
  &#60;/form>
    </pre>
  </ul>
</div>

<div>
  <h3 #angularversions data-anchor="angularversions">Angular versions</h3>
  <ul>
    <li><strong>Angular 2</strong> (2016 szeptember)
      <ul>
        <li>Teljes újraírás a TypeScript alapú fejlesztéshez</li>
        <li>Új komponens-alapú architektúra bevezetése</li>
        <li>Reactive Forms és Angular CLI bevezetése</li>
      </ul>
    </li>
    <br>
    <li><strong>Angular 4</strong> (2017 március)
      <ul>
        <li>Tree Shakable Modules, hogy csökkentsék a bundle méretét</li>
        <li>Új érvényesítő rendszer (Validators) a reaktív formokban</li>
        <li>Csökkentett fájlméret és gyorsabb renderelés</li>
      </ul>
    </li>
    <br>
    <li><strong>Angular 5</strong> (2017 november)
      <ul>
        <li>HttpClient API bevezetése az API hívások kezelésére</li>
        <li>Angular Universal: Server-Side Rendering (SSR) jobb támogatása</li>
        <li>CLI optimalizálás és build sebesség javítása</li>
      </ul>
    </li>
    <br>
    <li><strong>Angular 6</strong> (2018 május)
      <ul>
        <li>Angular CLI Workspaces bevezetése, hogy egyszerűbbé váljon több projekt kezelése</li>
        <li>RxJS 6 támogatás, új operátorok és szintaxisok</li>
        <li>Angular Elements: web komponensek egyszerű integrálása Angular alkalmazásokba</li>
      </ul>
    </li>
    <br>
    <li><strong>Angular 7</strong> (2018 október)
      <ul>
        <li>Angular Material és CDK fejlesztések, mint a drag-and-drop és virtualizálás</li>
        <li>HttpClient JsonP támogatás</li>
        <li>CLI Builder API, ami segít testre szabni a build folyamatot</li>
      </ul>
    </li>
    <br>
    <li><strong>Angular 8</strong> (2019 május)
      <ul>
        <li>Web Workers és differential loading támogatása a jobb teljesítmény érdekében</li>
        <li>Lazy loading és routing fejlesztések</li>
        <li>IVY: Az új renderelő motor első bevezetése a projektben</li>
      </ul>
    </li>
    <br>
    <li><strong>Angular 9</strong> (2020 február)
      <ul>
        <li>IVY teljes körű bevezetése: jelentős teljesítményjavulás és kisebb bundle méretek</li>
        <li>TypeScript 3.7+ támogatás</li>
        <li>A Component Tests egyszerűsítése</li>
      </ul>
    </li>
    <br>
    <li><strong>Angular 10</strong> (2020 június)
      <ul>
        <li>Augmented diagnostics és több új hibakeresési funkció</li>
        <li>Strict Mode bevezetése, amely segít a kódminőség javításában</li>
        <li>Új, könnyebben konfigurálható Angular CLI módok</li>
      </ul>
    </li>
    <br>
    <li><strong>Angular 11</strong> (2020 november)
      <ul>
        <li>ESLint bevezetése TSLint helyett a kód elemzésére</li>
        <li>Hot Module Replacement támogatás a gyorsabb fejlesztési ciklus érdekében</li>
        <li>Javított Build és Optimizer funkcionalitás</li>
      </ul>
    </li>
    <br>
    <li><strong>Angular 12</strong> (2021 május)
      <ul>
        <li>Strict mode alapértelmezetté tétele a jobb típusbiztonság érdekében</li>
        <li>Az Ivy renderelő motor további finomhangolása és optimalizálása</li>
        <li>Javított CSS és HTML Template support</li>
      </ul>
    </li>
    <br>
    <li><strong>Angular 13</strong> (2021 november)
      <ul>
        <li>Angular CLI új lehetőségei, például a CLI Builder API további fejlesztése</li>
        <li>Components - Simplified API for routing and change detection</li>
        <li>Support for TypeScript 4.4+ and better Reactivity handling in large applications</li>
      </ul>
    </li>
    <br>
    <li><strong>Angular 14</strong> (2022 június)
      <ul>
        <li>Standalone Components: a komponensek könnyebb kezelése a modulok nélkül</li>
        <li>RxJS és más könyvtárak optimalizálása a jobb teljesítmény érdekében</li>
        <li>Extended developer tool support for debugging and performance insights</li>
      </ul>
    </li>
    <br>
    <li><strong>Angular 15</strong> (2022 november)
      <ul>
        <li>Stricter Type Checking and Error Reporting for better consistency</li>
        <li>Improved Lazy Loading mechanism and Advanced Route Prefetching techniques</li>
        <li>Enhanced SSR (Server-Side Rendering) capabilities</li>
      </ul>
    </li>
    <br>
    <li><strong>Angular 16</strong> (2023 május)
      <ul>
        <li>Bevezetésre került egy új reaktivitási modell, amely egyszerűsíti a mentális modellezést, javítja a futási
          teljesítményt és jobb RxJS interoperabilitást biztosít</li>
        <li>Bevezetésre került a 'signals' könyvtár, amely új módot kínál a komponensek deklarálására, és potenciálisan
          a jövőben helyettesítheti a zone.js-t</li>
        <li>Fejlesztették a fejlesztői szervert, integrálva a Vite és az esbuild eszközöket, amelyek gyorsabb build időt
          és jobb fejlesztői élményt biztosítanak</li>
      </ul>
    </li>
    <br>
    <li><strong>Angular 17</strong> (2023 november)
      <ul>
        <li>Az Angular Signals könyvtárat fejlesztették tovább, és a fejlesztői előnézetből stabil verzióvá lépett elő,
          lehetővé téve a reaktív programozás egyszerűbb alkalmazását</li>
        <li>Bevezetésre került a 'deferrable views' funkció, amely lehetővé teszi a nézetek késleltetett betöltését,
          javítva ezzel a teljesítményt és a felhasználói élményt</li>
        <li>Az Angular Material komponenseiben eltávolították a régi, elavult komponenseket, ösztönözve a fejlesztőket
          az újabb, modernebb alternatívák használatára</li>
      </ul>
    </li>
    <br>
    <li><strong>Angular 18</strong> (2024 május)
      <ul>
        <li>Bevezetésre került a 'zoneless' mód, amely lehetővé teszi a zone.js nélküli működést, javítva a
          teljesítményt és a hibakeresést</li>
        <li>Fejlesztették a fejlesztői eszközöket, különös tekintettel a Signal-ok hibakeresésére az Angular
          DevTools-ban</li>
        <li>Az Angular CLI-ben bevezetésre került a 'standalone components' támogatása, amely lehetővé teszi a
          komponensek modulok nélküli használatát, egyszerűsítve a projekt struktúrát</li>
      </ul>
    </li>
    <br>
    <li><strong>Angular 19</strong> (2024 november)
      <ul>
        <li>Az Angular Signals könyvtárban stabilizálták a 'signal-based queries', 'inputs' és 'model inputs'
          funkciókat, elősegítve a reaktív programozás elterjedését</li>
        <li>Bevezetésre került a 'route-level render mode' funkció, amely lehetővé teszi a különböző útvonalakhoz eltérő
          renderelési módok alkalmazását, növelve a rugalmasságot és a teljesítményt</li>
        <li>Fejlesztették a Hot Module Replacement (HMR) támogatást, gyorsabbá téve a fejlesztési ciklust és javítva a
          fejlesztői élményt</li>
        <li>Minden komponens alapértelmezetten standalone komponens
          <ul>
            <li>Ezt a standalone: false meta adattal tudjuk tiltani</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #designpatterns data-anchor="designpatterns">Design patterns</h3>
  <ul>
    <li>Tervezési minták a szoftverfejlesztésben
      <ul>
        <li>Singleton pattern
          <ul>
            <li>Biztosítja, hogy egy adott osztályból csak egy példány létezzen a program futása során</li>
            <li>Globális hozzáférést biztosít az osztály példányához</li>
            <li>Általában statikus változókat használ a példány tárolására</li>
            <li>Elkerüli a példányok többszörös létrehozását, ami memóriát takarít meg</li>
            <li>Hasznos, ha a rendszerben egy központi, megosztott erőforrásra van szükség (például konfigurációk,
              adatbázis-kapcsolatok)</li>
            <br>
            <li>Angularban gyakran alkalmazzuk a szolgáltatások (services) esetében, hogy egyetlen
              példányban tároljuk őket, és ezt a példányt az egész alkalmazásban használjuk</li>
            <pre>
  import &#123; Injectable } from '@angular/core';

  @Injectable(&#123;
    providedIn: 'root', // Singleton minta alkalmazása a root szintjén
  })
  export class LoggerService &#123;
    log(message: string): void &#123;
      console.log(message);
    }
  }

  // Komponens, ahol használjuk
  import &#123; Component } from '@angular/core';
  import &#123; LoggerService } from './logger.service';

  @Component(&#123;
    selector: 'app-my-component',
    template: '&#60;button (click)="logMessage()">Log Message&#60;/button>',
  })
  export class MyComponent &#123;
    constructor(private logger: LoggerService) &#123;}

    logMessage(): void &#123;
      this.logger.log('Button clicked');
    }
  }
            </pre>
            <li>A LoggerService egy singleton, mert az Angular DI rendszer biztosítja, hogy a providedIn: 'root' szint
              beállításával az alkalmazás egészében csak egyetlen példányban létezzen</li>
          </ul>
        </li>
        <li>Observer pattern
          <ul>
            <li>Arra használják, hogy objektumok között létrehozzanak egy egyirányú kapcsolatot&#123;</li>
            <li>Az alany (subject) értesíti a hozzá tartozó figyelőket (observers), ha valamilyen változás
              történik&#123;
            </li>
            <li>Az observer minta használata lehetővé teszi a laza csatolást az objektumok között&#123;</li>
            <li>Segít a különböző rendszerek közötti kommunikációban, anélkül, hogy az alanyról bármit is tudnának a
              megfigyelők&#123;</li>
            <li>Például események kezelése, UI frissítése, állapotváltozások figyelése&#123;</li>
            <br>
            <li>Az RxJS-en alapuló reaktív programozásnál gyakran használt, például a Subject és BehaviorSubject
              segítségével</li>
            <pre>
  import &#123; Component, OnInit } from '@angular/core';
  import &#123; Subject } from 'rxjs';

  @Component(&#123;
    selector: 'app-message',
    template: '&#60;button (click)="sendMessage()">Send Message&#60;/button>',
  })
  export class MessageComponent implements OnInit &#123;
    private messageSubject = new Subject&#60;string>();
    message$ = this.messageSubject.asObservable();

    ngOnInit() &#123;
      this.message$.subscribe(message => &#123;
        console.log('Received message:', message);
      });
    }

    sendMessage() &#123;
      this.messageSubject.next('Hello from MessageComponent');
    }
  }
              </pre>
            <li>A Subject egy Observer minta alkalmazása, amely figyeli az üzenetküldéseket, és azokat a feliratkozott
              komponensnek továbbítja</li>
          </ul>
        </li>
        <li>Factory pattern
          <ul>
            <li>Lehetővé teszi objektumok létrehozását anélkül, hogy közvetlenül az osztályt hívnánk meg&#123;</li>
            <li>Agy üzleti logikát és objektumok inicializálását egy központi helyen tartja, így azokat könnyen
              módosíthatjuk&#123;</li>
            <li>Segít az objektumok típusának dinamikus meghatározásában a futásidőben&#123;</li>
            <li>Csökkenti a kód ismétlődését és javítja a karbantarthatóságot&#123;</li>
            <li>Például különböző típusú járművek vagy termékek gyártása egy központi "gyár" osztály segítségével&#123;
            </li>
            <br>
            <li>Akkor alkalmazzuk Angularban, ha szükség van különböző típusú objektumok dinamikus létrehozására</li>
            <pre>
  import &#123; Injectable } from '@angular/core';

  export interface Animal &#123;
    makeSound(): void;
  }

  export class Dog implements Animal &#123;
    makeSound() &#123;
      console.log('Woof!');
    }
  }

  export class Cat implements Animal &#123;
    makeSound() &#123;
      console.log('Meow!');
    }
  }

  @Injectable(&#123;
    providedIn: 'root',
  })
  export class AnimalFactory &#123;
    createAnimal(type: string): Animal &#123;
      if (type === 'dog') &#123;
        return new Dog();
      } else if (type === 'cat') &#123;
        return new Cat();
      }
      throw new Error('Unknown animal type');
    }
  }

  // komponens használata
  import &#123; Component } from '@angular/core';
  import &#123; AnimalFactory, Dog, Cat } from './animal.factory';

  @Component(&#123;
    selector: 'app-animal',
    template: '&#60;button (click)="createAnimal()">Create Animal&#60;/button>',
  })
  export class AnimalComponent &#123;
    constructor(private animalFactory: AnimalFactory) &#123;}

    createAnimal() &#123;
      const animal = this.animalFactory.createAnimal('dog');
      animal.makeSound(); // "Woof!"
    }
  }
            </pre>
            <li>Az AnimalFactory minta a Factory tervezési mintát valósítja meg, amely különböző típusú Animal
              objektumokat hoz létre</li>
          </ul>
        </li>
        <li>Strategy pattern
          <ul>
            <li>Lehetővé teszi a különböző algoritmusok cserélhetőségét anélkül, hogy a kliens osztályt
              módosítanánk&#123;
            </li>
            <li>Az algoritmusokat egy interfészhez kötve implementálják, így a kliens a kívánt algoritmust választja
              futás közben&#123;</li>
            <li>Segít a kód rugalmasabbá tételében, ha többféle viselkedés közül kell választani&#123;</li>
            <li>Jó választás, ha egy osztály többféle viselkedéssel kell, hogy rendelkezzen, de nem akarunk minden egyes
              viselkedést kódba égetni&#123;</li>
            <li>Például egy fizetési rendszer, ahol a különböző fizetési módokat (kártya, PayPal, banki átutalás)
              különböző algoritmusok reprezentálják&#123;</li>
            <br>
            <li>Alkalmazható Angularban, például az űrlapok validálásában, ahol többféle validációs stratégiát
              alkalmazhatunk különböző mezőkhöz</li>
            <pre>
  import &#123; Component } from '@angular/core';

  // validációs stratégiák
  interface ValidationStrategy &#123;
    validate(value: string): boolean;
  }

  class RequiredValidation implements ValidationStrategy &#123;
    validate(value: string): boolean &#123;
      return value.trim() !== '';
    }
  }

  class EmailValidation implements ValidationStrategy &#123;
    validate(value: string): boolean &#123;
      const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,4}$/;
      return emailRegex.test(value);
    }
  }

  @Component(&#123;
    selector: 'app-form',
    template: `&#60;input [(ngModel)]="value" (ngModelChange)="validate()"> &#60;p>&#123; &#123; validationMessage }}&#60;/p>`,
  })
  export class FormComponent &#123;
    value = '';
    validationMessage = '';
    validationStrategy: ValidationStrategy = new RequiredValidation(); // Alapértelmezett stratégia

    validate() &#123;
      if (this.validationStrategy.validate(this.value)) &#123;
        this.validationMessage = 'Valid';
      } else &#123;
        this.validationMessage = 'Invalid';
      }
    }

    setValidationStrategy(strategy: ValidationStrategy) &#123;
      this.validationStrategy = strategy;
    }
  }
              </pre>
            <li>A minta lehetővé teszi, hogy futás közben váltsunk a validációs stratégiák között, például egyes
              mezőkhez más-más validációs logikát rendelhetünk</li>
          </ul>
        </li>
        <li>Decorator pattern
          <ul>
            <li>Lehetővé teszi, hogy új funkciókat adjunk egy objektumhoz anélkül, hogy az eredeti osztályt
              módosítanánk&#123;</li>
            <li>Az osztályokat egyesével "díszítjük" egy új funkcióval, így az új viselkedés a futás ideje alatt adódik
              hozzá&#123;</li>
            <li>Segít az osztályok bővítésében, ha azokat túlzottan komplexé tenné a változtatás&#123;</li>
            <li>Jó választás, ha egy objektumot szeretnénk dinamikusan kibővíteni különböző funkciókkal&#123;</li>
            <li>Például egy grafikus felületen különböző szűrők és stílusok alkalmazása egy képen anélkül, hogy a
              képfeldolgozó osztályt módosítanánk&#123;</li>
            <br>
            <li>Alkalmazható Angularban, például HTTP kérés előtti, és utáni műveletek bővítésére egy dekorátor
              segítségével, mint az HttpInterceptor a HTTP hívások testreszabásához</li>
            <pre>
  import &#123; Injectable } from '@angular/core';
  import &#123; HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';
  import &#123; Observable } from 'rxjs';

  @Injectable()
  export class AuthInterceptor implements HttpInterceptor &#123;
    intercept(req: HttpRequest&#60;any>, next: HttpHandler): Observable&#60;HttpEvent&#60;any>> &#123;
      const clonedReq = req.clone(&#123;
        setHeaders: &#123;
          Authorization: `Bearer your-token-here`,
        },
      });
      return next.handle(clonedReq);
    }
  }

  // AppModule-ban beállítva
  import &#123; NgModule } from '@angular/core';
  import &#123; HTTP_INTERCEPTORS } from '@angular/common/http';

  @NgModule(&#123;
    providers: [
      &#123;
        provide: HTTP_INTERCEPTORS,
        useClass: AuthInterceptor,
        multi: true,
      },
    ],
  })
  export class AppModule &#123;}
            </pre>
            <li>Az AuthInterceptor dekorálja a HttpRequest-et az autentikációs fejlécekkel, anélkül hogy az alap
              HttpRequest osztályt módosítanánk</li>
          </ul>
        </li>
      </ul>
    </li>

  </ul>
</div>

<div>
  <h3 #cicd data-anchor="cicd">CI/CD pipeline</h3>
  <ul>
    <li>Fejlesztési és üzemeltetési gyakorlatok sorozata, amelyeket a szoftverfejlesztésben használnak annak érdekében,
      hogy a kód folyamatosan integrálódjon, tesztelődjön, és gyorsan a felhasználók számára elérhetővé váljon</li>
    <li>Lényegében automatizálja, és optimalizálja a fejlesztési, tesztelési és telepítési folyamatokat</li>
    <br>
    <li>CI pipeline
      <ul>
        <li>Continuous Integration</li>
        <li>A folyamatos integráció azt jelenti, hogy a fejlesztők rendszeresen integrálják a kódjaikat egy központi
          repóba
          <ul>
            <li>Típikusan naponta többször, feladatok, részfeladatok elvégzését követően</li>
            <li>A rendszer minden egyes kódfrissítés után automatikusan futtatja az automatizált teszteket, hogy
              biztosítva legyen a kód működőképessége</li>
            <li>Az új kód integrálása után automatikusan történik a build, és a tesztelés, hogy elkerüljék
              a hibák felhalmozódását</li>
            <li>A folyamatos integráció magában foglalhatja a kód minőségi ellenőrzését
              <ul>
                <li>Például statikus kódelemzés vagy kódformázás</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A folyamat röviden a gyakorlatban
          <ol>
            <li>Kód commitálása egy verziókezelő rendszerbe (például Git)</li>
            <li>A CI rendszer automatikusan letölti a kódot és felépíti az alkalmazást</li>
            <li>Az automatizált tesztek (unit tesztek, integrációs tesztek) lefutnak, hogy megbizonyosodjanak arról,
              hogy az új kód nem törte el az alkalmazás működését</li>
            <li>Ha a tesztek sikeresek, a kód bekerül a központi repóba, ha nem, akkor a fejlesztő értesítést kap a
              hibáról</li>
          </ol>
        </li>
      </ul>
    </li>
    <br>
    <li>CD pipeline
      <ul>
        <li>Continuous Deployment / Continuous Delivery</li>
        <li>A folyamatos szállítás és folyamatos telepítés két hasonló, de mégis különböző fogalom
          <ol>
            <li>Continuous Delivery
              <ul>
                <li>Minden kódváltoztatás, miután sikeresen átment az integrációs teszteken, automatikusan készen áll
                  arra, hogy telepítésre kerüljön bármely környezetbe (például production)</li>
                <li>Ez biztosítja, hogy bármikor elérhető legyen egy kiadás, de a tényleges telepítés manuálisan
                  történhet</li>
              </ul>
            </li>
            <li>Continuous Deployment
              <ul>
                <li>A sikeres tesztelést követően a kód automatikusan telepítésre kerül a production környezetbe is,
                  anélkül, hogy manuális beavatkozásra lenne szükség
                  <ul>
                    <li>Tehát egy lépéssel tovább megy, mint a Continuous Delivery</li>
                  </ul>
                </li>
                <li>Lehetővé teszi a fejlesztők számára, hogy nagyon gyorsan reagáljanak a felhasználói igényekre</li>
              </ul>
            </li>
          </ol>
        </li>
        <li>A kód folyamatosan, automatikusan kerül a tesztelő vagy élő környezetekbe</li>
        <li>A hibák gyorsan észlelhetők, és a csapat azonnal tud reagálni a változásokra, új funkciókra</li>
        <li>A manuális telepítési folyamatok lecsökkennek, vagy teljes automatizálttá válnak</li>
        <li>A folyamat röviden a gyakorlatban
          <ul>
            <li>A kód átment a teszteken, tehát a CI résznél a tesztelés sikeres, és a kód készen áll a telepítésre</li>
            <li>A kód bekerül a staging környezetbe, ahol további manuális tesztelés történhet</li>
            <li>Continuous Deployment esetén, miután minden teszt sikeresen lefutott, a kód automatikusan telepítésre
              kerül az éles környezetbe</li>
            <li>A production környezetben a rendszer folyamatosan figyeli az alkalmazás működését, és ha hibát észlel,
              visszaállítható egy korábbi, stabil verzió</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>CI/CD munkafolyamat
      <ol>
        <li>A fejlesztők írják a kódot a gépükön</li>
        <li>A kód egy verziókezelő rendszerbe feltöltésre kerül</li>
        <li>A CI rendszer elindítja a build folyamatot (például Webpack, Maven, Gradle), amely létrehozza az alkalmazás
          futtatható verzióját</li>
        <li>Az automatizált tesztek lefutnak (például unit tesztek, integrációs tesztek)</li>
        <li>A sikeres build után a kód átkerül a staging környezetbe, hogy manuálisan ellenőrizhető legyen</li>
        <li>Continuous Deployment esetében, ha minden teszt sikeres, a kód automatikusan kerül az élő környezetbe</li>
        <li>Az alkalmazás működése figyelhető, és ha hibát találnak, visszaállítható egy korábbi verzió</li>
      </ol>
    </li>
    <br>
    <li>CI/CD eszközök
      <ul>
        <li>Jenkins
          <ul>
            <li>Az egyik legismertebb CI/CD eszköz, amely rugalmas konfigurációval rendelkezik</li>
          </ul>
        </li>
        <li>GitLab CI
          <ul>
            <li>GitLab által biztosított CI/CD eszköz, amely közvetlenül integrálódik a GitLab repókkal</li>
          </ul>
        </li>
        <li>CircleCI
          <ul>
            <li>Könnyen használható és skálázható CI/CD eszköz</li>
          </ul>
        </li>
        <li>Travis CI
          <ul>
            <li>Egy másik népszerű CI eszköz, amely a GitHub repókkal jól együttműködik</li>
          </ul>
        </li>
        <li>Azure DevOps
          <ul>
            <li>A Microsoft által kínált eszköz, amely CI/CD pipeline-okhoz készült a .NET és egyéb technológiákhoz</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #devops data-anchor="devops">DevOps</h3>
  <ul>
    <li>Development és Operation</li>
    <li>Szoftverfejlesztési és üzemeltetési filozófia és gyakorlat, amely a fejlesztői (Dev) és az üzemeltetési (Ops)
      csapatok közötti együttműködést helyezi a középpontba
      <ul>
        <li>A fejlesztők és az üzemeltetők közösen dolgoznak a szoftverek gyorsabb kiadásán, a hibák gyorsabb javításán,
          és az üzemeltetési problémák megoldásán</li>
      </ul>
    </li>
    <li>Célja, hogy gyorsabbá és hatékonyabbá tegye a szoftverek fejlesztését, tesztelését, telepítését, és
      üzemeltetését</li>
    <li>Nem csupán technológia, hanem szemlélet, ami az együttműködésre, a kommunikációra, és az automatizálásra helyezi
      a hangsúlyt a csapatok között</li>
    <li>Csökkenteni a szoftverkiadások idejét, növelni a termelékenységet, és javítani a kód minőségét</li>
    <li>Szoros kapcsolatban áll a folyamatos integrációval (CI), és a folyamatos telepítéssel (CD)</li>
    <br>
    <li>DevOps munkafolyamat
      <ol>
        <li>A fejlesztők új funkciókat készítenek, és azokat rendszeresen integrálják a központi kódbázisba</li>
        <li>Mielőtt a kódot beépítenék a rendszerbe, automatizált teszteken megy keresztül</li>
        <li>Az új kódot folyamatosan integrálják a rendszerbe, és automatikusan építik a szoftvert</li>
        <li>A kód automatikusan telepíthető a különböző környezetekbe, mint például a staging vagy production</li>
        <li>Az alkalmazás futás közben történő figyelése, hogy biztosítsák a stabil működést és gyorsan reagáljanak a
          problémákra</li>
        <li>A monitorozás és a felhasználói visszajelzések alapján történik a folyamatos fejlesztés, és finomhangolás
        </li>
      </ol>
    </li>
    <br>
    <li>DevOps eszközök
      <ul>
        <li>Jenkins
          <ul>
            <li>A CI/CD automatizálására szolgáló eszköz</li>
          </ul>
        </li>
        <li>Docker
          <ul>
            <li>Konténerek használatával segíti az alkalmazások gyors fejlesztését, tesztelését és telepítését</li>
          </ul>
        </li>
        <li>Kubernetes
          <ul>
            <li>Konténerek kezelésére szolgáló rendszer, amely segít az alkalmazások automatikus skálázásában és
              üzemeltetésében</li>
          </ul>
        </li>
        <li>Ansible
          <ul>
            <li>Automatizálja a rendszerek konfigurálását és üzemeltetését</li>
          </ul>
        </li>
        <li>Terraform
          <ul>
            <li>Infrastruktúra-kód (Infrastructure as Code) eszköz, amely lehetővé teszi az infrastruktúra automatikus
              felépítését és kezelését</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #eventhandling data-anchor="eventhandling">Event handling</h3>
  <ul>
    <li>event.preventDefault()
      <ul>
        <li>Javascript függvény</li>
        <li>Az események viselkedését befolyásolja</li>
        <li>Megakadályozza, hogy az alapértelmezett eseménykezelő viselkedés végbemenjen</li>
        <li>Ha egy form esetében nem szeretnénk, hogy az űrlap elküldése után frissüljön az oldal (alapértelmezett
          esemény művelet), a stopPropagation függvénnyel ezt meggátolhatjuk</li>
        <pre>
  document.getElementById("myForm").addEventListener("submit", function(event) &#123;
    event.preventDefault();
    console.log("Form submit prevented");
  });

  formSubmit(event: any) &#123;
    event.preventDefault();
    console.log("Form submit prevented");
  }
        </pre>
      </ul>
    </li>
    <li>event.stopPropagation()
      <ul>
        <li>Javascript függvény</li>
        <li>Az események viselkedését befolyásolja</li>
        <li>Megakadályozza, hogy az esemény tovább terjedjen az "eseménybuborékolás" (event bubbling) láncolatában</li>
        <li>Akkor használjuk, ha nem szeretnénk, hogy egy esemény a szülőre is hatással legyen</li>
        <pre>
  &#60;div (click)="onParentClick()">
    &#60;p>Szülő elem&#60;/p>
    &#60;button class="btn btn-primary" (click)="onChildClick($event)">Click here&#60;/button>
  &#60;/div>

  // parent.component.ts
  import &#123; Component } from '@angular/core';

  @Component(&#123;
    selector: 'app-parent',
    templateUrl: './parent.component.html',
  })
  export class ParentComponent &#123;

    onParentClick() &#123; // eseménykezelő szülőre kattintáskor
      console.log('Szülő elemre kattintottak!');
    }

    onChildClick(event: Event) &#123; // eseménykezelő gyerekre kattintáskor
      event.stopPropagation();  // Megakadályozza, hogy az esemény a szülőre is eljusson
      console.log('Gyermek elemre kattintottak!');
    }
  }
        </pre>
        <li>Ha a szülő elemre kattintunk, akkor az onParentClick() fut le</li>
        <li>Ha a gyermek gombra kattintunk, akkor a onChildClick() fut le, de az event.stopPropagation() hívása
          miatt az onParentClick() nem fog lefutni</li>
      </ul>
    </li>
    <br>
    <li>event.target
      <ul>
        <li>Event object tulajdonság</li>
        <li>Az eseményt ténylegesen kiváltó DOM elemet jelöli</li>
        <pre>
  &#60;button class="btn btn-primary" (click)="onClick($event)">Kattints rám!&#60;/button>

  onClick(event: Event) &#123;
    console.log(event.target); // kiírja azt az elemet, amire kattintottak
  }
        </pre>
        <li>Az a DOM elem, amelyhez az eseménykezelőt hozzárendeltük</li>
        <li>Ez az elem mindig ugyanaz marad, bárhol is történjen az esemény a DOM hierarchiában</li>
      </ul>
    </li>
    <br>
    <li>event.currentTarget
      <ul>
        <li>Event object tulajdonság</li>
      </ul>
    </li>
    <br>
    <li>event.type
      <ul>
        <li>Event object tulajdonság</li>
        <li>String típusú tulajdonság, amely visszaadja az esemény típusát (például "click", "keydown", stb.)</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #salting data-anchor="salting">Salting</h3>
  <ul>
    <li>Biztonságot növelő technika</li>
    <li>Egyedi, véletlenszerű értéket (salt) adunk hozzá minden egyes jelszóhoz, mielőtt azt hasheljük</li>
    <li>Megnehezíti a szótár alapú, és rainbow table támadásokat
      <ul>
        <li>Rainbow Table
          <ul>
            <li>Előre kiszámított hash-listák segítségével a támadók gyorsan visszafejthetik a gyenge jelszavakat</li>
          </ul>
        </li>
        <li>Dictionary Attack
          <ul>
            <li>Egy jelszótörési technika, amely előre összeállított, gyakori jelszavakat tartalmazó szótárakat használ
              a helyes jelszó kitalálására</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Lépések
      <ol>
        <li>Jelszó megadása</li>
        <li>Random salt generálás
          <ul>
            <li>Minden felhasználónak véletlenszerű</li>
          </ul>
        </li>
        <li>Salt és a jelszó összefűzése
          <ul>
            <li>Ha használunk pepper-t, itt kerül hozzá</li>
          </ul>
        </li>
        <li>A kombinált érték hash-elése
          <ul>
            <li>jelszó + só</li>
            <pre>
  // a felhasználó a "pwd123"-mat adta meg jelszónak
  // a random generált só az "slt987"
  // a kombináció a "pwd123slt987"
            </pre>
            <li>Kriptográfiai hash-függvénnyel kódoljuk
              <ul>
                <li>A salt-ot külön tároljuk az adatbázisban</li>
                <li>Hash algorutmusok például
                  <ol>
                    <li>SHA-256
                      <ul>
                        <li>Gyors, de önmagában nem elég biztonságos jelszavakhoz</li>
                      </ul>
                    </li>
                    <li>bcrypt
                      <ul>
                        <li>Lassú, de erős, beépített salt támogatással</li>
                        <li>A salt már a hash része, így külön nem kell tárolni</li>
                      </ul>
                    </li>
                    <li>Argon2
                      <ul>
                        <li>Modern, memóriaigényes hash-elés, az egyik legbiztonságosabb</li>
                      </ul>
                    </li>
                  </ol>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ol>
    </li>
    <li>Bejelentkezésnél a beírt jelszót sózzzuk az adatbázisban tárolt sóval, összerakjuk őket, hash-elünk, majd
      összehasonlítjuk a korábban legenerált, és a procedúrákon átesett string-et</li>
    <li>Salt típusai
      <ul>
        <li>Statikus
          <ul>
            <li>Ugyanaz a salt minden jelszóhoz</li>
          </ul>
        </li>
        <li>Random
          <ul>
            <li>Minden jelszóhoz külön generált a salt</li>
          </ul>
        </li>
        <li>Peppering
          <ul>
            <li>Egy globális titkos kulcsot (pepper) ad a jelszóhoz a hash-elés előtt, vagy közben</li>
            <li>Minden jelszóhoz ugyanaz, és nem az adatbázisban, hanem egy külön biztonságos helyen (például
              szerverkonfiguráció) van tárolva</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #bindings data-anchor="bindings">Bindings</h3>
  <ol>
    <li>Attribute Binding
      <ul>
        <li>Lehetővé teszi, hogy HTML attribútumokat hozzunk létre dinamikusan</li>
        <li>Például class, style, vagy href</li>
        <li>Egyirányú adatáramlás</li>
        <pre>
  [attr.attributeName]="value"
        </pre>
      </ul>
    </li>
    <li>Property Binding
      <ul>
        <li>Az elemek tulajdonságainak (properties) értékeit állítja be dinamikusan</li>
        <li>Például disabled, value, src, vagy checked</li>
        <li>Egyirányú adatáramlás</li>
        <pre>
  [propertyName]="value"
        </pre>
      </ul>
    </li>
    <li>Event Binding
      <ul>
        <li>Események kezelésére szolgál</li>
        <li>Például click, input, vagy keyup</li>
        <li>Egyirányú adatáramlás</li>
        <pre>
  (eventName)="method()"
        </pre>
      </ul>
    </li>
    <li>Data Binding
      <ul>
        <li>Összefoglaló fogalom</li>
        <li>Különböző típusú adatkommunikációkat jelenti a komponens, és a template között</li>
        <li>Magában foglalja a property binding-ot, attribute binding-ot, event binding-ot, és kétirányú binding-ot is
        </li>
        <li>Angularban a two-way binding tipikusan az [(ngModel)] használatával érhető el
          <ul>
            <li>Emellett egyéni eventek, és property binding segítségével is megoldható</li>
            <pre>
  &#60;input [value]="username" (input)="username = $event.target.value" />
            </pre>
          </ul>
        </li>
        <pre>
  [property]="value" / &#123; &#123;  expression }}
        </pre>
      </ul>
    </li>
    <li>Directive
      <ul>
        <li>Nem binding</li>
        <li>Angular funkció, amely a DOM viselkedését vagy megjelenését módosítja</li>
        <li>Lehet struktúrált direktíva (*ngFor, *ngIf, stb.), vagy attribútum direktíva ([ngClass], stb.)</li>
        <pre>
  *directive / [directive]
        </pre>
      </ul>
    </li>
  </ol>
</div>

<div>
  <h3 #gettersetter data-anchor="gettersetter">Getter / Setter</h3>
  <ul>
    <li>A getter, és a setter method-ok az objektumok tulajdonságainak elérésére, és módosítására szolgálnak</li>
    <li>Amíg a setter függvények egy adott értéket állítanak be, addig a getter függvények visszaadnak egy értéket</li>
    <li>Az adatátvitelt további logikákkal is bővíthetjük</li>
    <br>
    <li>Getter
      <ul>
        <li>Visszaad egy osztályon belüli privát változót, egy értéket, de nem változtatja meg az objektum
          állapotát</li>
        <li>Használhatjuk, ha valamilyen logikát szeretnénk végrehajtani a tulajdonság visszaadása előtt
          <ul>
            <li>Például formázás, vagy esetleg valamilyen feltételt alkalmaznánk</li>
          </ul>
        </li>
        <pre>
  class Person &#123;
    private _age: number;
  
    constructor(age: number) &#123;
      this._age = age;
    }
  
    get age(): number &#123;
      return this._age;
    }
  }
  
  const person = new Person(30);
  console.log(person.age);
  
  ↓↓↓↓↓

  30
        </pre>
      </ul>
    </li>
    <li>Setter
      <ul>
        <li>egy privát változó értékét állítja be, és lehetőséget ad arra, hogy módosítás előtt érvényességi ellenőrzést
          vagy egyéb logikát hajtsunk végre</li>
        <pre>
  class Person &#123;
    private _age: number;
  
    constructor(age: number) &#123;
      this._age = age;
    }
  
    set age(value: number) &#123;
      if (value &#60; 0) &#123;
        console.log("Invalid age");
      } else &#123;
        this._age = value;
      }
    }
  }
  
  const person = new Person(30);
  person.age = -5;
  
  ↓↓↓↓↓
  
  "Invalid age"

  person.age = 35;
  console.log(person.age);
  
  ↓↓↓↓↓

  35
        </pre>
      </ul>
    </li>
    <br>
    <pre>
  <b>// példa 1</b>
  class Rectangle &#123;
    private _width: number;
    private _height: number;

    constructor(width: number, height: number) &#123;
      this._width = width;
      this._height = height;
    }

    // Getter a terület kiszámításához
    get area(): number &#123;
      return this._width * this._height;
    }

    set width(value: number) &#123;
      if (value &#60;= 0) &#123;
        console.log("Width must be greater than zero");
      } else &#123;
        this._width = value;
      }
    }

    set height(value: number) &#123;
      if (value &#60;= 0) &#123;
        console.log("Height must be greater than zero");
      } else &#123;
        this._height = value;
      }
    }
  }

  const rectangle = new Rectangle(10, 5);
  console.log(rectangle.area);

  ↓↓↓↓↓

  50

  rectangle.width = 15;
  rectangle.height = 0; // invalid, a height setter feltétele miatt

  console.log(rectangle.area); // 15 * 5   

  ↓↓↓↓↓

  75
    </pre>
    <pre>
  <b>// példa 2</b>
  class Price &#123;
    constructor(private _price: number, private _piece: number) &#123;
  
    }
  
    get price(): number &#123;
      return this._price;
    }
  
    set price(value: any) &#123; // szándékosan any a típusa, és nem number
      if (typeof value !== 'number' || isNaN(value)) &#123; // az isNaN a NaN típus kiszűrése miatt szerepel, mivel az is egy szám
        console.log('Not a number!');
        return;
      }
      this._price = value;
    }
  
    get piece(): number &#123;
      return this._piece;
    }
  
    set piece(value: number) &#123;
      this._piece = value;
    }
  
    get totalPrice() &#123; // ha gyakran változik, érdemes lehet így használni
      return this._piece * this._price;
    }
  
    getTotalPrice(): number &#123; // ha ritkán frissül, akkor egy metódussá érdemes alakítani
      return this._piece * this._price;
    }
  
    toString(): string &#123;
      return `
          A teljes kifizetett összeg: $&#123;this.totalPrice} Ft,
          mivel $&#123;this._piece} karton tejet vásároltál,
          $&#123;this._price} forintos darabáron
      `;
    }
  }
  
  let milkPurchased = new Price(200, 5);
  
  console.log(milkPurchased); // &#123;_price: 200, _piece: 5}
  console.log(milkPurchased.totalPrice); // 1000
  console.log(milkPurchased.getTotalPrice()); // 1000
  
  milkPurchased.piece = 7;
  
  console.log(milkPurchased); // &#123;_price: 200, _piece: 7}
  console.log(milkPurchased.totalPrice); // 1400
  console.log(milkPurchased.getTotalPrice()); // 1400
  
  milkPurchased.price = 'A'; // "Not a number!"
  
  console.log(milkPurchased.toString()); // "A teljes kifizetett összeg: 1400 Ft, mivel 7 karton tejet vásároltál, 200 forintos darabáron"
    </pre>
    <li>@Input() setter
      <ul>
        <li>Egy komponens adatokat kap a szűlő komponenstől</li>
        <li>A setter alkalmazásával ez az érték nem csak megadható, hanem extra logikát is alkalmazhatunk, mielőtt a
          komponens belső állapotába kerül</li>
        <pre>
  <b>// példa 1</b>

  <b>// parent</b>
  @Component(&#123;
    selector: 'app-parent',
    template: `&#60;app-child [message]="parentMessage">&#60;app-child>`
  })
  export class ParentComponent &#123;
    parentMessage = 'Oh my...this message is longer than it should be!';
  }

  <b>// child</b>
  import &#123; Component, Input } from '@angular/core';

  @Component(&#123;
    selector: 'app-child',
    template: `&#60;p>&#123; &#123; message }}&#60;/p>`
  })
  export class ChildComponent &#123;
    private _message: string;

    @Input() set message(value: string) &#123;
      if (value && value.length > 10) &#123;
        this._message = value;
      } else &#123;
        this._message = 'No valid message arrived';
      }
    }

    get message(): string &#123;
      return this._message;
    }
  }
          </pre>
        <pre>
  <b>// példa 2</b>

  <b>// parent</b>
  @Component(&#123;
    selector: 'app-parent',
    template: `&#60;app-child [userRole]="role">&#60;/app-child>`
  })
  export class ParentComponent &#123;
    role = 'admin';
  }  
  
  <b>// child</b>
  @Component(&#123;
    selector: 'app-child',
    template: `&#60;div>
                 &#60;p>&#123; &#123; message }}&#60;/p>
                 &#60;button *ngIf="hasAccess">Access Restricted Area&#60;/button>
               &#60;/div>`
  })

  export class ChildComponent &#123;
    private _role: string;
    message: string = '';
    hasAccess: boolean = false;
  
    @Input() set userRole(role: string) &#123;
      this._role = role;
      this.setRoleMessage();
    }
  
    private setRoleMessage() &#123;
      // A setterben beállítjuk, hogy mit jelenítsen meg a komponens a felhasználó szerepe alapján
      if (this._role === 'admin') &#123;
        this.message = 'You have admin access.';
        this.hasAccess = true;
      } else if (this._role === 'user') &#123;
        this.message = 'You have user access.';
        this.hasAccess = false;
      } else &#123;
        this.message = 'Access denied.';
        this.hasAccess = false;
      }
    }
  }  
          </pre>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #corserror data-anchor="corserror">CORS error</h3>
  <ul>
    <li>Cross-Origin Resource Sharing</li>
    <li>Mechanizmus, amely lehetővé teszi, hogy egy weboldal biztonságosan kérjen adatokat egy másik weboldalról
      anélkül, hogy a böngésző blokkolná a kérést</li>
    <li>A Same-Origin Policy (SOP) egy biztonsági intézkedés, amely megakadályozza, hogy egy weboldal hozzáférjen egy
      másik weboldal erőforrásaihoz (például API-k, adatbázisok) anélkül, hogy a felhasználó ezt engedélyezné</li>
    <li>Sokszor viszont szükség van arra, hogy egy webalkalmazás más domainről kérjen adatokat
      <ul>
        <li>A CORS mechanizmus oldja meg ezt a problémát, ami engedélyezi a cross-origin kéréseket biztonságos módon
        </li>
      </ul>
    </li>
    <br>
    <li>A teljes folyamat
      <ol>
        <pre>
  https://frontend.com            https://api.com
            |                             |
            |---- preflight (OPTIONS) --->|
            |                             |
            |&#60;--- preflight response -----|
            |                             |
            |------------- GET request -->|
            |                             |
            |&#60;--- GET response -----------|
            |                             |
            |             ...             |
        </pre>
        <li>A böngésző cross-origin kérést indít egy úgynevezett preflight kérés elküldésével
          <ul>
            <li>Cross-origin felé szükséges a preflight</li>
            <li>Ez egy OPTIONS HTTP kérés, amelyet az API szerver kap</li>
            <li>A preflight kérés ellenőrzi, hogy a cél szerver elfogadja-e a cross-origin kéréseket, és ha igen, akkor
              engedélyezi majd a tényleges kérést</li>
            <pre>
  <b>// OPTIONS / preflight</b>
  OPTIONS /data HTTP/1.1
  Host: api.com
  Origin: https://frontend.com
  Access-Control-Request-Method: GET
  Access-Control-Request-Headers: Authorization, X-Custom-Header
              </pre>
          </ul>
        </li>
        <li>A szerver válaszai
          <ol>
            <li>Engedélyezett HTTP metódusok</li>
            <li>Request-ben használható header-ök</li>
            <li>Origin-ek (domain-ek), amik hozzáférhetnek az erőforrásokhoz</li>
          </ol>
          <ul>
            <pre>
  <b>// szerver válasza a preflight-ra</b>
  HTTP/1.1 204 No Content
  Access-Control-Allow-Origin: https://frontend.com
  Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
  Access-Control-Allow-Headers: Content-Type, Authorization, X-Custom-Header
  Access-Control-Allow-Credentials: true
  Access-Control-Max-Age: 3600
            </pre>
          </ul>
        </li>
        <li>A böngésző végrehajtja a tényleges (GET) kérést
          <ul>
            <pre>
  GET /data HTTP/1.1
  Host: api.com
  Origin: https://frontend.com
  Authorization: Bearer XYZ
  X-Custom-Header: my-custom-value
            </pre>
          </ul>
        </li>
        <li>A szerver válaszol a kért adatokkal
          <ul>
            <pre>
  HTTP/1.1 200 OK
  Access-Control-Allow-Origin: https://frontend.com
  Access-Control-Allow-Credentials: true
  Content-Type: application/json

  &#123;
    "message": "Hello, this is your data!"
  }
            </pre>
          </ul>
        </li>
      </ol>
    </li>
    <br>
    <li>CORS header-ök (válasz tartalmazza őket)
      <ul>
        <li>Access-Control-Allow-Origin
          <ul>
            <li>Domainek hozzáférhetőségét adja meg</li>
            <pre>
  Access-Control-Allow-Origin: * // minden domain hozzáférhet

  Access-Control-Allow-Origin: https://cors-test.com // csak ez a domain férhet hozzá az erőforráshoz
            </pre>
          </ul>
        </li>
        <li>Access-Control-Allow-Methods
          <ul>
            <li>Engedélyezett HTTP metódusok</li>
          </ul>
        </li>
        <li>Access-Control-Allow-Headers
          <ul>
            <li>Meghatározza, hogy mely HTTP header-ek használhatóak a kérésben (például Content-Type, Authorization)
            </li>
          </ul>
        </li>
        <li>Access-Control-Allow-Credentials
          <ul>
            <li>Meghatározza, hogy az alkalmazás küldhet-e hitelesítő adatokat (például sütik vagy HTTP authentikációs
              információk) a kéréshez</li>
          </ul>
        </li>
        <li>Access-Control-Max-Age
          <ul>
            <li>Meghatározza, hogy mennyi ideig érvényesek a preflight válaszok</li>
            <li>Ezáltal a böngésző nem küldi el újra a preflight kérdést minden egyes alkalommal, amikor ugyanazt az
              erőforrást kéri</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>CORS hiba
      <ul>
        <li>Ha a szerver nem küldi vissza a megfelelő CORS header-eket, akkor a böngésző blokkolja a választ, és CORS
          error jelenik meg</li>
        <li>Ez egy biztonsági intézkedés, hogy megakadályozza az illetéktelen hozzáférést más domainek erőforrásaihoz
        </li>
        <pre>
  // https://frontend.com adatokat kérne https://api.com domainről, de a szerver válasza nem tartalmazza az Access-Control-Allow-Origin header-t

  Access to XMLHttpRequest at 'https://api.com/data' from origin 'https://frontend.com'
  has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present
  on the requested resource.
        </pre>
        <li>Kétféleképpen oldható fel
          <ol>
            <li>Szerver konfiguráció változtatás</li>
            <li>Proxy használata</li>
          </ol>
        </li>
      </ul>
    </li>
    <br>
    <li>CORS bypass
      <ul>
        <pre>
  sudo nano /etc/hosts

  ↓↓↓↓↓

  127.0.0.1       frontend.com
        </pre>
        <pre>
  sudo ng s --port 30000 --disable-host-check
        </pre>
        <li>Helyi DNS felülírás</li>
        <li>Ha a frontend.com domaint próbáljuk elérni, akkor történik egy átirányítás a 127.0.0.1 címre
        </li>
        <li>Amikor a böngészőbe begépeljük a https://frontend.com, az a saját gépünkön futó szerverhez fog kapcsolódni
        </li>
        <li>Ha az API például https://api.com címen van, akkor a böngésző normál esetben blokkolná a
          http://localhost:30000 és https://api.com közötti kéréseket CORS miatt</li>
        <li>Viszont ha a frontendet localhost helyett frontend.com-ként használjuk, és az API engedélyezi ezt a domaint,
          akkor a CORS problémát elkerülhetjük</li>
        <li>A --disable-host-check kapcsoló engedélyezi, hogy az Angular szerver bármilyen hostnévvel fusson, beleértve
          a frontend.com domaint is</li>
        <li>Fejlesztői környezetben hasznos trükk</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #recursion data-anchor="recursion">Recursion</h3>
  <ul>
    <li>Programozási technika, amelyben egy függvény önmagát hívja meg</li>
    <li>Megoldási módszer lehet például fa struktúrák, menük, vagy fájlstruktúrák kezelésére</li>
    <li>Két fő részből áll
      <ol>
        <li>Base case / Báziseset
          <ul>
            <li>Az a feltétel, amikor a rekurzió leáll</li>
          </ul>
        </li>
        <li>Recursive step / Rekurzív lépés
          <ul>
            <li>A függvény önmagát hívja meg kisebb bemenettel</li>
          </ul>
        </li>
      </ol>
    </li>
    <pre>
  interface FileSystemItem &#123;
    name: string;
    type: string;
    children?: FileSystemItem[]; // ha directory akkor tartalmazhat további gyermekeket
  }

  const fileSystem = &#123;
    name: "root",
    type: "directory",
    children: [
      &#123;
        name: "documents",
        type: "directory",
        children: [
          &#123; name: "resume.txt", type: "file" },
          &#123; name: "cover_letter.pdf", type: "file" }
        ]
      },
      &#123;
        name: "photos",
        type: "directory",
        children: [
          &#123; name: "vacation.jpg", type: "file" },
          &#123;
            name: "family",
            type: "directory",
            children: [
              &#123; name: "family_portrait.png", type: "file" }
            ]
          }
        ]
      },
      &#123; name: "todo.txt", type: "file" }
    ]
  };

  function listFilesAndDirectories(directory: FileSystemItem, level: number = 0) &#123;
          const indent = '-'.repeat(level * 2);
          if (directory.type === "file") &#123;    // ha a bemenet fájl típusú, csak a fájl nevét írjuk ki
            console.log(indent + directory.name);
          } else &#123;                            // ha könyvtár, akkor bejárjuk annak összes gyermekét
            console.log(`$&#123;indent}$&#123;directory.name.toUpperCase()}`);
            directory.children?.forEach((child: FileSystemItem) => listFilesAndDirectories(child, level + 1));
          }
        }

  listFilesAndDirectories(fileSystem);
    </pre>
    <img src="assets/imgs/recursion.png" width="100%">
    <pre>
  <b>// extras.component.ts</b>
  export interface MenuItem &#123;
    title: string;
    anchor: string;
    subtitles?: MenuItem[];
  }

  ...

  menu: MenuItem[] = [
    &#123;
      title: 'Type guard',
      anchor: 'typeguard',
      subtitles: [
        &#123;
          title: 'Template usage',
          anchor: 'templateusage',
          subtitles: [
            &#123; title: 'typeof', anchor: 'typeof' },
            &#123; title: 'instanceof', anchor: 'instanceof' }
          ]
        },
        &#123; title: 'Type predicate', anchor: 'typepredicate' }
      ]
    }
  ];

  <b>// extras.component.html</b>
  &#60;div>
    &#60;!-- menü komponens meghívása, adatok átadása -->
    &#60;app-menu [menu]="menu">&#60;/app-menu>
  &#60;/div>
  
  <b>// menu.component.ts</b>
  interface MenuItem &#123;
    title: string;
    anchor: string;
    subtitles?: MenuItem[];
  }

  ...

  @Input() menu: MenuItem[] = [];

  <b>// menu.component.html</b>
  &#60;ul>
    &#60;li *ngFor="let item of menu">
      &#60;a [href]="'#' + item.anchor">&#123; &#123; item.title }}&#60;/a>
  
      &#60;!-- ha van subtitle, rekurzív módon jelenítjük meg azt -->
      &#60;ul *ngIf="item.subtitles?.length">
        &#60;app-menu [menu]="item.subtitles">&#60;/app-menu>
      &#60;/ul>
    &#60;/li>
  &#60;/ul>
    </pre>
  </ul>
</div>

<div>
  <h3 #typeguard data-anchor="typeguard">Type guard</h3>
  <ul>
    <li>TypeScript funkció, amely segít ellenőrizni egy változó, vagy objektum típusát futásidőben</li>
    <br>
    <li>Típusok
      <ol>
        <li>typeof
          <ul>
            <li>Primitív típusok ellenőrzése</li>
            <li>String, number, boolean, symbol, undefined, bigint vagy function típusokat tudja ellenőrizni</li>
            <pre>
  function isString(value: unknown): value is string &#123;
    return typeof value === "string";
  }
  
  const input: unknown = "Hello";
  const input2: unknown = 123;
  
  if (isString(input)) &#123; // true
    console.log(input.toUpperCase());
  }
  
  if (isString(input2)) &#123; // false
    console.log(input2.toUpperCase());
  }              
            </pre>
          </ul>
        </li>
        <li>instanceof
          <ul>
            <li>Osztályok és objektumok ellenőrzése</li>
            <pre>
  class Cat &#123;
    miau() &#123;
      console.log("Miauuu!");
    }
  }
  
  const pet = new Cat();
  
  if (pet instanceof Cat) &#123; // true
    pet.miau();
  }
            </pre>
          </ul>
        </li>
        <li>Custom type guard
          <ul>
            <li>Komplex objektumok ellenőrzése (API válasz)</li>
            <pre>
  interface User &#123;
      id: number;
      name: string;
  }
  
  interface Admin extends User &#123;
      role: "admin";
  }
  
  // saját type guard:
  function isAdmin(user: User | Admin): user is Admin &#123;
      return (user as Admin).role !== undefined;
  }
  
  // API válasz
  const response: User | Admin = &#123; id: 1, name: "John", role: "admin" };
  
  if (isAdmin(response)) &#123; // true
      console.log(`Admin belépés: $&#123;response.name}, jogosultság: $&#123;response.role}`);
  } else &#123;
      console.log(`User belépés: $&#123;response.name}`);
  }              
            </pre>
          </ul>
        </li>
      </ol>
    </li>
  </ul>
  <br>
  <h5 #templateusage data-anchor="templateusage">Template usage</h5>
  <ul>
    <li>A typeof és az instanceof operátorok a tempate-ben nem használhatók</li>
    <li>Custom pipe segítségével viszont ez kiküszöbölhető</li>
    <br>
    <li>typeof
      <ul>
        <pre>
  <b>// pipe</b>
  import &#123; Pipe, PipeTransform } from '@angular/core';

  @Pipe(&#123;
    name: 'isString'
  })
  export class IsStringPipe implements PipeTransform &#123;
    transform(value: any): value is string &#123;
      return typeof value === 'string';
    }
  }

  <b>// template</b>
  &#60;p *ngIf="name | isString">Name contains &#123; &#123;name.length}} characters!&#60;/;p>
        </pre>
        <li>Csak akkor fog megjelenni a paragráfus, ha name string típusú</li>
      </ul>
    </li>
    <br>
    <li>instanceof
      <ul>
        <pre>
          <b>// pipe</b>
          import &#123; Pipe, PipeTransform } from '@angular/core';

          @Pipe(&#123;
            name: 'isInstanceOf'
          })
          export class IsInstanceOfPipe implements PipeTransform &#123;
            transform&#60;T>(value: any, target: new () => T): value is T &#123;
              return value instanceof target;
            }
          }

          <b>// class</b>
          hero: any = new Hero('Superman');

          <b>// template</b>
          &#60;p *ngIf="hero | isInstanceOf:Hero">&#123; &#123;hero}} is a hero!&#60;/p>
        </pre>
        <li>Ellenőrizzük, hogy az objektum egy adott osztály példánya-e</li>
        <li>A transform() metódus egy értéket (value), és egy cél osztályt (target) kap</li>
        <li>A 'value is T' type predicate </li>
        <li>Ha hero a Hero osztály példánya, az ngIf igaz lesz, és megjelenik a &#60;p> elem</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #typepredicate data-anchor="typepredicate">Type predicate</h5>
  <ul>
    <li>Megmondja a Typescript-nek, hogy egy függvény type guard-ként fog működni</li>
    <pre>
  function isString(value: unknown): value is string &#123; // a value is string type predicate
      return typeof value === "string";
  }          
        </pre>
    <li>A Typescript-nek ugyancsak megmondjuk, hogy ha a függvény visszatérési értéke true, akkor a value biztosan
      string</li>
  </ul>
  <br>
  <h5 #unknown data-anchor="unknown">Unknown</h5>
  <ul>
    <li>Bármilyen értéket elfogad, csak úgy, mint az any</li>
    <li>Any használatakor a Typescript nem figyelmeztet a hibákra
      <ul>
        <li>Mintha kikapcsolnánk a hibaellenőrzést</li>
        <pre>
  let data: any;

  data = "Üdv";     // megadhatjuk, mint érték
  data = 123;       // megadhatjuk, mint érték
  data = true;      // megadhatjuk, mint érték

  // hibát egyik esetben sem kapunk

  console.log(data.toUpperCase());

  ↓↓↓↓↓

  Amennyiben nem string-et adtunk meg a data változónak, mint érték, pórul jártunk, hibát kapunk
        </pre>
        <li>Az unknown biztonságosabb
          <ul>
            <li>A TypeScript nem engedi, hogy használjuk, amíg nem ellenőriztük a típusát</li>
            <pre>
  let data: unknown;

  data = "Csá";  // megadhatjuk, mint érték
  data = 987;       // megadhatjuk, mint érték
  data = false;     // megadhatjuk, mint érték

  console.log(data.toUpperCase()); // fordítási hiba

  if (typeof data === "string") &#123;
    console.log(data.toUpperCase());
  }

  ↓↓↓↓↓

  "Csá" // ha nem string, nincs console.log
            </pre>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #sorting data-anchor="sorting">Sorting</h3>
  <ul>
    <div>{{ [ "banana", "cherry", "apple" ] }}</div>
    <div>{{ [ "banana", "cherry", "apple" ].sort() }}</div>
    <pre>
  &#60;div>&#123; &#123; [ "banana", "cherry", "apple" ] }}&#60;/div>
  &#60;div>&#123; &#123; [ "banana", "cherry", "apple" ].sort() }}&#60;/div>

  &#123; &#123; [ 10, 5, 8, 2, 7 ].sort((a, b) => a - b) }} // növekvő sorrend

  ↓↓↓↓↓

  [2, 5, 7, 8, 10] 

  &#123; &#123; [ 10, 5, 8, 2, 7 ].sort((a, b) => b - a) }} // csökkenő sorrend

  ↓↓↓↓↓

  [10, 8, 7, 5, 2] 


  let superHeroes = [
    &#123; name: "Superman", strength: 10 },
    &#123; name: "Spider-Man", strength: 7 },
    &#123; name: "Iron Man", strength: 8 }
  ];

  superHeroes.sort((a, b) => a.strength - b.strength); // növekvő sorrend
  console.log(superHeroes);

  ↓↓↓↓↓

  &#123; name: "Spider-Man", strength: 7 }
  &#123; name: "Iron Man", strength: 8 }
  &#123; name: "Superman", strength: 10 }

  superHeroes.sort((a, b) => b.strength - a.strength); // csökkenő sorrend
  console.log(superHeroes);

  ↓↓↓↓↓

  &#123; name: "Superman", strength: 10 }
  &#123; name: "Iron Man", strength: 8 }
  &#123; name: "Spider-Man", strength: 7 }
    </pre>
  </ul>
  <br>
  <h5 #keyvalue data-anchor="keyvalue">keyvalue</h5>
  <ul>
    <li>A keyvalue pipe egy objektumot, vagy egy Map-ot átalakít át tömbbé, ahol az objektumok kulcsai és értékei
      egy-egy elemként szerepelnek
      <ul>
        <li>Működik tömbökön is, de az indexeket kezeli kulcsként</li>
        <pre>
  &#123; &#123; hero.value.name}} // tömb esetében a template-ben erre hibát kapunk
        </pre>
      </ul>
    </li>
    <li>keyValue használata
      <ul>
        <div *ngFor="let hero of superHeroes | keyvalue">
          <div>Key: {{ hero.key }}</div>
          <div>Value: {{hero.value}} (Hero object)</div>
          <br>
        </div>
        <pre>
  <b>// class</b>
  interface Hero &#123;
    name: string;
    origin: string;
    specialAbility: string;
    strength: number
  }

  superHeroes: &#123; [key: string]: Hero } = &#123;
    superman: &#123;
      name: "Superman",
      origin: "Kryptonian",
      specialAbility: "Super strength, flight, heat vision",
      strength: 10
    },
    spiderman: &#123;
      name: "Spider-Man",
      origin: "Earth (New York)",
      specialAbility: "Spider senses, web-shooting, wall-crawling",
      strength: 7
    },
    wonderwoman: &#123;
      name: "Wonder Woman",
      origin: "Amazonian",
      specialAbility: "Super strength, combat skills, lasso of truth",
      strength: 9
    },
    ironman: &#123;
      name: "Iron Man",
      origin: "Earth (USA)",
      specialAbility: "Powered armor, genius-level intellect",
      strength: 8
    },
    thor: &#123;
      name: "Thor",
      origin: "Asgardian",
      specialAbility: "Control of thunder, flight (via Mjolnir)",
      strength: 10
    },
    flash: &#123;
      name: "Flash",
      origin: "Earth (Central City)",
      specialAbility: "Super speed, time travel",
      strength: 7
    },
    hulk: &#123;
      name: "Hulk",
      origin: "Earth (USA)",
      specialAbility: "Incredible strength, healing factor",
      strength: 10
    }
  };

  <b>// template</b>
  &#60;div *ngFor="let hero of superHeroes | keyvalue">
    &#60;div>Key: &#123; &#123; hero.key }}&#60;/div>
    &#60;div>Value: &#123; &#123; hero.value}} (Hero object)&#60;/div>
    &#60;br>
  &#60;/div>
            </pre>
        <div *ngFor="let hero of superHeroes | keyvalue">
          <div>Name: {{ hero.value.name }}</div>
          <div>Strength: {{hero.value.strength}}</div>
          <br>
        </div>
        <pre>
  &#60;div *ngFor="let hero of superHeroes | keyvalue">
    &#60;div>Name: &#123; &#123; hero.value.name }}&#60;/div>
    &#60;div>Strength: &#123; &#123;hero.value.strength}}&#60;/div>
    &#60;br>
  &#60;/div>
            </pre>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #valueorder data-anchor="valueorder">valueOrder</h5>
  <ul>
    <li>A valueOrder egy rendezési logika, amit arrow function-ként írunk le, és a keyvalue pipe-ot használva
      alkalmazzuk</li>
    <li>valueOrder használata
      <br>
      <ul>
        <div *ngFor="let hero of superHeroes | keyvalue: valueOrder">
          <div>Name: {{ hero.value.name }}</div>
          <div>Strength: {{hero.value.strength}}</div>
          <br>
        </div>
        <pre>
          <b>// template</b>
  &#60;div *ngFor="let hero of superHeroes | keyvalue: valueOrder">
    &#60;div>Name: &#123; &#123; hero.value.name }}&#60;/div>
    &#60;div>Strength: &#123; &#123;hero.value.strength}}&#60;/div>
    &#60;br>
  &#60;/div>

  <b>// class</b>
  valueOrder = (a: KeyValue&#60;string, any>, b: KeyValue&#60;string, any>): number => &#123;
    return b.value.strength - a.value.strength; // csökkenő sorrendben rendezzük az erősség szerint
  };
            </pre>
        <li>A valueOrder egy névtelen függvény, amit a keyValue pipe-nak adunk át
          <ul>
            <li>Normál függvényként is definiálható lehetne</li>
            <pre>
  valueOrderFunction(a: KeyValue&#60;string, Hero>, b: KeyValue&#60;string, Hero>): number &#123;
    return b.value.strength - a.value.strength;
  }

  &#60;div *ngFor="let hero of superHeroes | keyvalue: valueOrderFunction">
    &#123; &#123; hero.value.name }} - Strength: &#123; &#123; hero.value.strength }}
  &#60;/div>
        </pre>
            <li>A keyValue elfogad egy összehasonlító függvényt, amely meghatározza a kulcs-érték párok sorrendjét
            </li>
            <pre>
  (a: KeyValue&#60;string, Hero>, b: KeyValue&#60;string, Hero>) => number
        </pre>
            <li>a és b egy-egy KeyValue&#60;string, Hero> objektum</li>
            <li>A függvény egy számot ad vissza
              <ol>
                <li>-1 - 'a' elem kerül előrébb</li>
                <li>1 - 'b' elem kerül előrébb</li>
                <li>0 - nem változik a sorrend</li>
              </ol>
            </li>
            <pre>
  // KeyValue objektum
  &#123;
    key: superman,         // &#60;string,
    value: &#123;               // Hero>
        name: "Superman",
        origin: "Kryptonian",
        specialAbility: "Super strength, flight, heat vision",
        strength: 10
    }
  }
                </pre>
            <div *ngFor="let hero of superHeroes | keyvalue: valueOrderFunction">
              <div>Name: {{ hero.value.name }}</div>
              <div>Strength: {{hero.value.strength}}</div>
              <br>
            </div>
            <pre>
  valueOrderFunction(a: KeyValue&#60;string, Hero>, b: KeyValue&#60;string, Hero>): number &#123;
      return a.value.name.localeCompare(b.value.name); // fordított sorrend: b.value.name.localeCompare(a.value.name)
  }
                </pre>
            <li>A localeCompare egy beépített függvény, amelyet szövegek összehasonlítására használunk
              <ul>
                <li>Három értéket ad vissza (-1, 0, 1), attól függően, hogy milyen sorrendben állnak a szavak</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #trackby data-anchor="trackby">trackBy</h3>
  <ul>
    <li>Teljesítményoptimalizáló mechanizmus az Angularban</li>
    <li>Az *ngFor direktívával együtt használjuk, hogy hatékonyabban kezeljük a listák újrarenderelését</li>
    <li>Alapértelmezés szerint az Angular az azonosítás helyett az objektumok memóriacíme alapján követi a listákat</li>
    <li>Ha egy új elemet adunk hozzá, vagy egy meglévőt módosítunk, akkor az Angular az egész listát újragenerálja, még
      akkor is, ha a legtöbb elem / többi elem változatlan maradt</li>
    <li>A trackBy egy függvény, amely az egyes elemek azonosítóját adja vissza
      <ul>
        <li>Segít az Angularnak megérteni, hogy mely elemek változtak és melyek maradtak ugyanazok</li>
      </ul>
    </li>
    <pre>
  heroes = [
    &#123; id: 1, name: "Superman" },
    &#123; id: 2, name: "Batman" },
    &#123; id: 3, name: "Iron Man" }
  ];

  &#60;li *ngFor="let hero of heroes; trackBy: trackById">
    &#123; &#123; hero.name }}
  &#60;/li>
  
  trackById(index: number, hero: Hero): number &#123;
    return hero.id; // az Angular az id alapján követi az elemeket
  }
    </pre>
    <li>Az index automatikusan átadásra kerül a trackByFn függvénybe, mint első paraméter
      <ul>
        <li>A trackByFn egy elnevezési konvenció, azt a függvényt jelenti, amit trackBy-ra használunk</li>
        <li>Nem az id, hanem az index</li>
        <li>Illetve ehhez nem szükséges a "let i = index" sem</li>
        <li>A heroes tömbelemeket a trackById függvény a következők szerint kapja meg
          <ol>
            <li>trackById(0, &#123; id: 1, name: "Superman" })</li>
            <li>trackById(0, &#123; id: 2, name: "Batman" })</li>
            <li>trackById(0, &#123; id: 3, name: "Iron Man" })</li>
          </ol>
        </li>
      </ul>
    </li>
    <li>Ha csak egy elem módosul a listában, az Angular csak azt az egyet frissíti, a többi változatlan marad
      <ul>
        <li>Így kevesebb DOM művelet történik</li>
      </ul>
    </li>
    <li>Érdemes használni, ha
      <ol>
        <li>dinamikusan változó a lista</li>
        <li>nagy mennyiségű adatról van szó</li>
        <li>az elemek azonosíthatók egyedi értékekkel</li>
      </ol>
    </li>
    <li>Objektum esetében is segítségünkre lehet</li>
    <pre>
  superHeroes: &#123; [key: string]: Hero } = &#123;
    superman: &#123;
      name: "Superman",
      origin: "Kryptonian",
      specialAbility: "Super strength, flight, heat vision",
      strength: 10
    },
    spiderman: &#123;
      name: "Spider-Man",
      origin: "Earth (New York)",
      specialAbility: "Spider senses, web-shooting, wall-crawling",
      strength: 7
    },
    wonderwoman: &#123;
      name: "Wonder Woman",
      origin: "Amazonian",
      specialAbility: "Super strength, combat skills, lasso of truth",
      strength: 9
    },
  ]

  &#60;li *ngFor="let hero of superHeroes | keyvalue; trackBy: trackByKey">
    &#123; &#123; hero.key }} - &#123; &#123; hero.value.name }}
  &#60;/li>

  trackByKey(index: number, hero: KeyValue&#60;string, Hero>): string &#123;
    return hero.key; // hiszen key-re, és value-ra bontottuk az elemeket a keyvalue használatával
  }
    </pre>
  </ul>
</div>

------------------------------------------------------------------

<div>
  <h3 #newdirectives data-anchor="newdirectives">New directives</h3>
  <ul>
    <li>Angular 17-től új szintaktikák kerültek be az Angularba
      <ul>
        <li>A logika változatlan, a szintaktika különbözik</li>
        <li>Az alábbiak nem mind Angular 17-es újítások, van, amelyik 18-as (például a @let)</li>
      </ul>
    </li>
    <br>
    <li>@if
      <ul>
        <pre>
  @if (condition) &#123;
      &#60;div>Content&#60;/div>
  }
        </pre>
      </ul>
    </li>
    <li>@else if
      <ul>
        <pre>
  @if (condition) &#123;
      &#60;div>Content&#123;/div>
  } @else if (otherCondition) &#123;
      &#60;div>Content 2&#60;/div>
  } @else &#123;
      &#60;div>Default content&#60;/div>
  }
        </pre>
      </ul>
    </li>
    <li>@for
      <ul>
        <li>Egy teljesítményoptimalizált reactive rendering megoldás
          <ul>
            <li>A track nélküli használat nem engedélyezett</li>
            <li>Ha nincs id, akkor a track az indexre alapoz</li>
            <pre>
  @for (...; track $index) &#123; }
            </pre>
            <li>Problémás, ha a tömb módosul, mert az indexek eltolódhatnak</li>
          </ul>
        </li>
        <pre>
  @for (elem of elements; let i = $index; let last = $last; let first = $first; track elem.id) &#123;
        @if (first)&#123;
          &#60;div>#&#123; &#123;i}} &#123; &#123; elem.name }} (first)&#60;/div> 
        } 
        @if (!first && !last)&#123;
            &#60;div>#&#123; &#123;i}} &#123; &#123; elem.name }}&#60;/div> 
        } 
        @if (last)&#123;
            &#60;div>#&#123; &#123;i}} &#123; &#123; elem.name }} (last)&#60;/div> 
        } 
  }
        </pre>
      </ul>
    </li>
    <li>@empty
      <ul>
        <li>Az üres listák eseteit kezeli</li>
        <pre>
  @for (elem of elements; track elem.id) &#123;
      &#60;div>&#123; &#123; elem.nev }}&#60;/div>
  } @empty &#123;
      &#60;div>No elements&#60;/div>
  }
        </pre>
      </ul>
    </li>
    <li>@switch & @case
      <ul>
        <pre>
  @switch (status) &#123;
    @case ('available') &#123;
      &#60;div>Available&#60;/div>
    }
    @case ('notAvailable') &#123;
      &#60;div>Not Available&#60;/div>
    }
    @default &#123;
      &#60;div>Default status&#60;/div>
    }
  }   
  
  &#60;ng-container [ngSwitch]="status">
    &#60;div *ngSwitchCase="'available'">Available&#60;/div>
    &#60;div *ngSwitchCase="'notAvailable'">Not available&#60;/div>
    &#60;div *ngSwitchDefault>Default status&#60;/div>
  &#60;/ng-container>
        </pre>
      </ul>
    </li>
    <li>@let
      <ul>
        <li>Angular 18+</li>
        <li>A sablonban közvetlenül definiálhatunk változókat</li>
        <pre>
  @let salute = 'Dear, Mr. President!';
  &#60;p>&#123; &#123; salute }}&#60;/p>
        </pre>
      </ul>
    </li>
    <li>@defer
      <ul>
        <li>Angular 18+</li>
        <li>Lazy loading-ot valósít meg</li>
        <li>Javítja a teljesítményt</li>
        <li>Egy adott blokkot csak akkor renderel az Angular, ha az szükséges</li>
        <li>A ritkán használt, nagy komponenseknél érdemes használni</li>
        <li>A komponens csak akkor töltődik be, ha a user a megfelelő helyre görget, esetleg megnyom egy gombot, vagy
          előtöltés történik, miközben a felhasználó böngészi az oldalt</li>
        <pre>
  @defer &#123;
      &#60;huge-component>&#60;/huge-component>
  }

  // OR (shorter)

  @defer &#123;
    &#60;/huge-component />
  }
          </pre>
        <li>A @defer egy extra bundle-t hoz létre</li>
        <li>Különféle feltételeket adhatunk meg a betöltődés kapcsán</li>
        <pre>
  @defer (buttonIsClicked) &#123;
      &#60;huge-component />
  }
        </pre>
      </ul>
    </li>
    <li>@placeholder
      <ul>
        <li>Angular 18+</li>
        <li>Ez a kétrészlet fog megjelenni, amíg a @defer nem töltődött be</li>
        <li>Opcionális minimum paraméterrel is rendelkezik
          <ul>
            <li>Azt jelenti, hogy minimum ennyi idő után jelenjen meg a placeholder</li>
          </ul>
        </li>
        <pre>
  @defer &#123;
      &#60;huge-component />
  } @placeholder (minimum 500ms) &#123;
      &#60;div>Loading...&#60;/div>
  }
        </pre>
        <li>Ha a huge-component 500ms-on belül betöltődik, akkor a placeholder meg sem jelenik</li>
      </ul>
    </li>
    <li>@loading
      <ul>
        <li>Angular 18+</li>
        <li>Amíg a @defer töltődik, egyedi @loading állapotot is megadhatunk</li>
        <li>Két opcionális paramétere is létezik
          <ol>
            <li>minimum
              <ul>
                <li>A legkevesebb idő, ami után megjelenik a @loading blokk</li>
              </ul>
            </li>
            <li>after
              <ul>
                <li>Az az idő, amíg vár az alkalmazás a loading történte után, hogy megjelenítse a @loading-ot</li>
              </ul>
            </li>
          </ol>
        </li>
        <li>A loading a @placeholder helyét veszi át akkor, amikor már megtriggerelődött a blokk, hogy be kell töltődnie
        </li>
        <pre>
  @defer &#123;
      &#60;huge-component />
  } @loading (after 100ms; minimum 1s) &#123;
      &#60;img src="loading.png" />
  } @placeholder (minimum 100ms) &#123;
      &#60;div>Loading...&#60;/div>
  }
        </pre>
      </ul>
    </li>
    <li>@error
      <ul>
        <li>Angular 18+</li>
        <li>Ha a komponens valamilyen okból kifolyólag nem tud betöltődni, akkor egyedi hibakezelést adhatunk meg</li>
        <pre>
  @defer &#123;
    &#60;huge-component />
  } @error &#123;
    &#60;p>Component cannot be loaded...&#60;/p>
  }          
        </pre>
      </ul>
    </li>
    <br>
    <li>Az Angular CLI képes a korábbi kódokat átalakítani az új szintaxisra</li>
    <pre>
      ng generate @angular/core:control-flow
    </pre>
    <li>A korábbi szintaxis nem deprecated, mindkettő szabadon használható</li>
  </ul>
</div>

<div>
  <h3 #callbackfunction data-anchor="callbackfunction">Callback function</h3>
  <ul>
    <li>A callback function egy olyan függvény, amelyet egy másik függvény paramétereként adunk át, és amelyet
      később, a hívó függvény egy bizonyos pontján hívunk meg</li>
    <li>A callback-ek különösen hasznosak aszinkron műveleteknél használjuk, vagy felhasználói interakcióknál</li>
    <pre>
  function greeting (name) &#123;
  alert('Hello 1 + name);
  }
  function process UserInput (callback) &#123;
            var name = prompt('Please enter your name');
            callback(name);
  }
  processUserInput (greeting);
        </pre>
    <li>Például az addEventListener függvény második paramétere callback függvény
      <ul>
        <pre>
  document.getElementById('order')
      .addEventListener('click', () => &#123;
          console.log('Order button clicked')
      });

  OR

  const cbfgv = () => &#123;
      console.log('Order button clicked')
  }

  document.getElementById('order')
      .addEventListener('click', cb);
            </pre>
      </ul>
    </li>
    <li>A callback legprimitívebb formája
      <ul>
        <pre>
  const cb = () => &#123;console.log('Hi there!')};

  const f = (callback: any) => callback();

  f(cb);

  ↓↓↓↓↓

  "Hi there!"
            </pre>
      </ul>
    </li>
    <li>Bizonyos esetekben érdemes lehet leellenőrizni, hogy a callback függvényünk valóban függvény-e
      <ul>
        <li>Ezt legegyszerűbben a typeof segítségével tehetjük meg</li>
        <pre>
  function myFunction(callback) &#123;
    if (typeof callback === "function") &#123;
        // logic
    }
  }
  
  myFunction(myCallback);
            </pre>
      </ul>
    </li>
  </ul>
</div>

-------------------------------------

<div>
  <h3 #fontsizes data-anchor="fontsizes">Font sizes</h3>
  <ul>
    <pre>
  100: Thin
  200: Extra / Ultra Light
  300: Light
  400: Normal / Regular
  500: Medium
  600: Semi Bold
  700: Bold
  800: Extra / Ultra Bold 
  900: Black / Heavy
    </pre>
  </ul>
</div>

<div>
  <h3 #handlingimages data-anchor="handlingimages">Handling images</h3>
  <ul>
    <li>Lazy loading
      <ul>
        <li>HTML attribútum</li>
        <li>Késlelteti a kép betöltését, amíg az nincs a viewportban (látható területen)
          <ul>
            <li>Amikor az oldal betöltődik, a kép nem töltődik le azonnal</li>
            <li>A böngésző akkor kezdi el letölteni, amikor a felhasználó elkezd lefelé görgetni, és a kép közel kerül a
              viewporthoz</li>
          </ul>
        </li>
        <li>Gyorsabb oldalbetöltést eredményez</li>
        <li>SEO barát</li>
        <li>Hero-ra, banner-re nem szabad használni</li>
      </ul>
    </li>
    <li>srcset
      <ul>
        <li>Hasznos HTML attribútum az &#60;img> tagekben</li>
        <li>Segítségével a böngésző a böngésző a képernyő méretéhez, és felbontásához legmegfelelőbb tölti be a képeket
        </li>
        <li>Reszponzív webdesign esetén hasznos</li>
        <pre>
  &#60;img src="image-regular.jpg"
    srcset="image-small.jpg 480w, image-medium.jpg 1024w, image-large.jpg 1920w"
    sizes="(max-width: 600px) 480px, (max-width: 1200px) 1024px, 1920px"
    alt="Example">
        </pre>
        <li>Az srcset azt mondja meg, hogy milyen szélességű képek állnak rendelkezésre</li>
        <li>A sizes megmondja a böngészőnek, hogy adott képernyőszélességnél mekkora képet használjon
          <ul>
            <li>Viewport <= 600px==> Az image-small.jgp-t jeleníti meg a böngésző (480w)</li>
            <li>Viewport <= 1200px==> Az image-medium.jgp-t jeleníti meg a böngésző (1024w)</li>
            <li>Viewport > 1200px ==> Az image-large.jgp-t jeleníti meg a böngésző (1920w)</li>
          </ul>
        </li>
        <li>A böngésző nem a teljes képernyő szélességét veszi figyelembe, hanem azt, hogy az &#60;img> elem mekkora a
          layoutban</li>
        <pre>
  &#60;img src="image.jpg"
    srcset="image-1x.jpg 1x, image-2x.jpg 2x, image-3x.jpg 3x"
    alt="Example">
        </pre>
        <li>DPR (Device Pixel Ratio) alapú változat</li>
        <li>Az eszköz pixelsűrűsége dönti el, hogy élesebb vagy kevésbé részletes képre van-e szükség</li>
        <li>Akkor érdemes használni, ha a kép mindig fix méretű (nem reszponzív a layoutban)</li>
        <li>Az x érték a kijelző pixelsűrűségére vonatkozik
          <ul>
            <li>1x - normál felbontás</li>
            <li>2x - retina felbontás</li>
            <li>3x,4x... - extrém nagy pixelsűrűség</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #routerinrouter data-anchor="routerinrouter">Router in router</h3>
  <ul>
    <li>Az app modulunk rendelkezik routing-gal, ezáltal tudunk az oldalon navigálni a menüpontok segítségével</li>
    <li>Mi van akkor, ha egy adott oldalon szeretnénk az app navigációjától független navigációt megvalósítani
      <ul>
        <li>Avagy váltsunk kontentet/komponenst anélkül, hogy az adott oldalról elnavigálnánk, mindezt routing-gal
          megoldva</li>
      </ul>
    </li>
    <pre>
  <b>// URL /extras</b>
  ...
  &#123; path: 'extras', loadChildren: () => import('./extras/extras.module').then(mod => mod.ExtrasModule) },
  ...
    </pre>
    <li>Jelen komponensünk egyben egy modul is</li>
    <li>Ahhoz, hogy megvalósítsuk a fent leírtakat, szükségünk lesz egy gyermek modulra</li>
    <pre>
  <b>// extras.component.html</b>
  &#60;app-animeroute>&#60;/app-animeroute> // a gyerek komponens, ami gyermek modul része

  <b>// extras.module.ts</b>
  @NgModule(&#123;
      declarations: [
          ExtrasComponent,
          ...
      ],
      imports: [
          CommonModule,
          ExtrasRoutingModule,
          ...
          AnimerouteModule // be kell importálnunk a gyermek modult
      ],
  })

  <b>// extras-routing.module.ts</b>
  const routes: Route[] = [
      &#123;
          path: '',
          component: ExtrasComponent,
          loadChildren: () => import('./anime/animeroute/animeroute.module').then(m => m.AnimerouteModule)
      },
  ]
    </pre>
    <li>Az alapértelmezett útvonal (path: '') az ExtrasComponent-et jeleníti meg</li>
    <li>Ha a loadChildrenben (lazy loading) a gyermek modulra hivatkozunk, akkor a gyermek modul automatikusan
      betöltődik</li>
    <li>Amennyiben a gyermek modul routing-jában adtunk meg alapértelmezett útvonalat (path: ''), az szintén
      automatikusan betöltődik</li>
    <pre>
  <b>// animeroute.component.html</b>
  &#60;nav>
      &#60;ul>
          &#60;li>
              &#60;a [routerLink]="['home']" [routerLinkActive]="['is-active']">Home&#60;/a>
              &#60;a [routerLink]="['about']" [routerLinkActive]="['is-active']">About&#60;/a>
              &#60;a [routerLink]="['contact']" [routerLinkActive]="['is-active']">Contact&#60;/a>
          &#60;/li>
      &#60;/ul>
  &#60;/nav>

  &#60;router-outlet>&#60;/router-outlet>

  <b>// animeroute.module.ts</b>
  @NgModule(&#123;
    declarations: [
      AnimerouteComponent,
      HomeComponent,
      ContactComponent,
      AboutComponent
    ],
    imports: [
      CommonModule,
      AnimerouteRoutingModule,
    ],
    exports: [
      AnimerouteComponent // szükséges exportálni, hogy használhassuk az extras.component.html
    ]
  })

  <b>// animeroute-routing.module.ts</b>
  const routes: Routes = [
    &#123; path: '', component: HomeComponent }, // alapértelmezett útvonal, így egyből be is tölt
    &#123; path: 'home', component: HomeComponent },
    &#123; path: 'about', component: AboutComponent },
    &#123; path: 'contact', component: ContactComponent },
    // &#123; path: 'about', component: HomeComponent, outlet: 'animerouting' }, // ha az animeroute.component.html-ben named router-outlet-et akarnánk használni
  ];
    </pre>
    <li>A router-outlet-et tartalmazó HTML-ben a router-outlet-en kívüli kód navigálástól függetlenül jelen van mindig
    </li>
    <br>
    <!--app-animeroute></!--app-animeroute-->
  </ul>
</div>


<div>
  <h3 #lineheight1 data-anchor="lineheight1">line-height: 1</h3>
  <ul>
    <li>Azt eredményezi, hogy a sor magassága megegyezik a betűmérettel (font-size)</li>
    <li>Így a szöveg pontosan annyi helyet foglal el, mint a karakterek magassága, plusz a betűk közötti minimális
      távolság</li>
    <br>
    <div class="box1">BOX1</div>
    <div class="box2">BOX2</div>
    <pre>
  &#60;div class="box1">BOX1&#60;/div>
  &#60;div class="box2">BOX2&#60;/div>

  .box1 &#123;
    display: inline-block;
    font-size: 20px;
    background: lightcoral;
    color: black;
  }
  
  .box2 &#123;
    display: inline-block;
    font-size: 20px;
    line-height: 1;
    background: lightblue;
    color: black;
  }
    </pre>
  </ul>
</div>

<div>
  <h3 #host data-anchor="host">:host</h3>
  <ul>
    <li>Speciális CSS pszeudo-szelektor az Angularban</li>
    <li>Az adott komponens saját gyökérelemére (host) vonatkozik</li>
    <li>Alapértelmezés szerint az Angular komponensekben a stílusok csak a komponens belső elemeire vonatkoznak</li>
    <li>A :host segítségével viszont maga a komponens "tartalmazó eleme" kaphat stílust</li>
    <pre>
  <b>// child.component.scss</b>
  :host &#123;
    display: block;
    border: 1px solid red;
    padding: 10px;
  }

  <b>// parent.component.html</b>
  &#60;app-card>&#60;/app-card> <!-- ez az elem kapja meg a stílust -->
    </pre>
  </ul>
</div>

<div>
  <h3 #visibilitytracking data-anchor="visibilitytracking">Visibility tracking</h3>
  <ul>
    <li>Ha azt szeretnénk megfigyelni, hogy egy elem látható-e a Viewport-ban, használhatjuk az IntersectionObserver
    </li>
    <br>
    <div #visibilityObservedElement class="visibility-tracked-element">TRACKED ELEMENT</div>
    <div>observedElementIsVisible: {{ observedElementIsVisible }}</div>
    <pre>
  <b>// template</b>
  &#60;div #visibilityObservedElement class="visibility-tracked-element">TRACKED ELEMENT&#60;/div>
  &#60;div>observedElementIsVisible: &#123; &#123; observedElementIsVisible }}&#60;/div>

  <b>// class</b>
  ...
  @ViewChild('visibilityObservedElement') visibilityObservedElement!: ElementRef;
  observedElementIsVisible!: boolean;
  ...

  ngAfterViewInit() &#123;
    const observer = new IntersectionObserver(([entry]) => &#123; // [entry] - destructuring assignment
      this.observedElementIsVisible = entry.isIntersecting
    }, &#123; threshold: 0.2 }); // ha az elem legalább 80%-a nem látszik, a változó false lesz

    observer.observe(this.visibilityObservedElement.nativeElement); // az IntersectionObserver-t az adott DOM elemhez rendeljük
  }

  // így is meg lehetne adni

  const observer = new IntersectionObserver((entries) => &#123;
    const entry = entries[0]; // az első elem kivétele a tömbből
    // logika
  }, &#123; threshold: 0.2 });
    </pre>
    <li>Amennyiben a tracked elementt kikerül a Viewport-ból, az observedElementIsVisible változó false állapotba kerül
    </li>
    <li>A megfigyelés azért kerül az AfterViewInit lifecycle hookba, mert az @ViewChild-dal való hivatkozás az elemekre
      a komponens renderelése után történik, tehát biztosítani kell, hogy az observedElement már létezzen a DOM-ban,
      amikor a IntersectionObserver-t elindítjuk</li>
    <li>A threshold az IntersectionObserver konfigurációs opciója (0 és 1 között), amely meghatározza, hogy egy elem
      mekkora része legyen látható ahhoz, hogy az observer aktiválódjon</li>
    <li>Az observer.observe értesíti a callback függvényt, amelyben megadtuk, hogy milyen logika futton le, ha az elem X
      része már nem látszik a Viewport-ban</li>
    <li>Az IntersectionObserver callback függvény első paramétere egy tömböt ad át, amelyben az egyes belépési események
      találhatók
      <ul>
        <li>Egyébként 2 paramétere van a függvénynek</li>
        <pre>
  const observer = new IntersectionObserver((entries, observerInstance) => &#123;
    // logika
  }, &#123; threshold: 0.2 });
        </pre>
        <li>A második paraméter maga az IntersectionObserver példány
          <ul>
            <li>Fontosabb metódusai
              <ol>
                <li>observe(element: Element): új elem figyelése</li>
                <li>unobserve(element: Element): egy adott elem figyelésének leállítása</li>
                <li>disconnect(): minden elem figyelésének leállítása</li>
                <li>takeRecords(): Az utolsó események lekérése</li>
              </ol>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Több elemet is megfigyelhetünk</li>
    <br>
    <div #visibilityObservedElements class="visibility-tracked-element">ELEM 1</div>
    <div #visibilityObservedElements class="visibility-tracked-element">ELEM 2</div>
    <div #visibilityObservedElements class="visibility-tracked-element">ELEM 3</div>
    <div>observedElementsVisibility: {{observedElementsVisibility | json}}</div>
    <pre>
  <b>// template</b>
  &#60;div #visibilityObservedElements class="visibility-tracked-element">ELEM 1&#60;/div>
  &#60;div #visibilityObservedElements class="visibility-tracked-element">ELEM 2&#60;/div>
  &#60;div #visibilityObservedElements class="visibility-tracked-element">ELEM 3&#60;/div>

  &#60;div>observedElementsVisibility: &#123; &#123; observedElementsVisibility | json}}&#60;/div>

  <b>// class</b>
  ...
  @ViewChildren('visibilityObservedElements') visibilityObservedElements!: QueryList&#60;ElementRef>;
  observedElementsVisibility: boolean[] = [];
  ...

  ngAfterViewInit() &#123;
    const elements = this.visibilityObservedElements.toArray(); // az Angular ElementRef listát tömbbé alakítjuk

    const observers = new IntersectionObserver((entries) => &#123;
      entries.forEach(entry => &#123;
        const realIndex = elements.findIndex(el => el.nativeElement === entry.target);

        // console.log(entry.target); // entry.target: maga a HTMLElement

        this.observedElementsVisibility[realIndex] = entry.isIntersecting;
      });
    }, &#123; threshold: 0.2 });

    this.visibilityObservedElements.forEach(element => observers.observe(element.nativeElement)); // az összes figyelt elem hozzáadása
  }
    </pre>
  </ul>
</div>

<div>
  <h3 #navigationevent data-anchor="navigationevent">Navigation event</h3>
  <ul>
    <li>Az Angular Router egyik fontos eseménye, amely lehetővé teszi, hogy figyeljük, mi történik a navigáció során az
      alkalmazásunkban</li>
    <li>A navigációs események (NavigationEvent) akkor keletkeznek, amikor a felhasználó új útvonalra navigál, vagy egy
      linket kattint
      <ul>
        <li>A következő események kapcsolódnak hozzá (időrendben)
          <ol>
            <li>NavigationStart: A navigáció kezdete, amikor a felhasználó elindítja a navigációt</li>
            <li>RouteConfigLoadStart: Amikor elkezdődik egy route konfiguráció betöltése (például lazy loading esetén)
            </li>
            <li>RouteConfigLoadEnd: A route konfiguráció sikeresen betöltődött (például lazy loading esetén)</li>
            <li>RoutesRecognized: A route sikeresen felismerésre került a router által</li>
            <li>NavigationEnd: A navigáció befejeződött</li>
            <li>NavigationCancel: A navigációt valami megszakította</li>
            <li>NavigationError: A navigációs folyamat során hiba történt</li>
          </ol>
        </li>
      </ul>
    </li>
    <li>A navigációs események a Router osztályból elérhetőek, és figyelhetjük őket a router.events Observable
      segítségével</li>
    <li>Elérhetjük például, hogy megjelenítünk egy töltő animációt a NavigationStart esemény indításakor,
      majd eltüntetjük a navigáció befejeztekor (NavigationEnd)</li>
    <pre>
      import &#123; Component, OnInit } from '@angular/core';
      import &#123; Router, NavigationStart, NavigationEnd, NavigationError, NavigationCancel, Event } from '@angular/router';

      @Component(&#123;
        selector: 'app-navigation-listener',
        templateUrl: './navigation-listener.component.html',
        styleUrls: ['./navigation-listener.component.css']
      })
      export class NavigationListenerComponent implements OnInit &#123;
        loading: boolean = false;

        constructor(private router: Router) &#123;}

        ngOnInit(): void &#123;
          this.router.events.subscribe((event: Event) => &#123;
            if (event instanceof NavigationStart) &#123; // a navigáció kezdete
              this.loading = true;
            }
            if (event instanceof NavigationEnd) &#123; // a navigáció vége
              this.loading = false;
            }
            if (event instanceof NavigationError) &#123; // hiba történt a navigáció során
              this.loading = false;
            }
            if (event instanceof NavigationCancel) &#123; // a navigációt megszakították
              this.loading = false;
            }
          });
        }
      }
    </pre>
  </ul>
</div>

<div>
  <h3 #httperrors data-anchor="httperrors">HTTP errors</h3>
  <ul>
    <li>1xx - Információs kódok
      <ul>
        <li>100 Continue: A kliens folytathatja a kérést, mert a szerver úgy döntött, hogy nincs hiba, és nem szükséges
          semmilyen más információ</li>
        <li>101 Switching Protocols: A szerver elfogadta a kliens által kért protokollváltást</li>
      </ul>
    </li>
    <br>
    <li>2xx - Sikeres kódok
      <ul>
        <li>200 OK: A kérés sikeresen feldolgozásra került, az adatok a válaszban találhatók</li>
        <li>201 Created: A kérés sikeresen végrehajtva, és egy új erőforrást hozott létre</li>
        <li>204 No Content: A kérés sikeresen végrehajtva, de nincs visszaküldött tartalom</li>
      </ul>
    </li>
    <br>
    <li>3xx - Átirányítási kódok
      <ul>
        <li>301 Moved Permanently: Az erőforrás véglegesen másik helyre lett áthelyezve</li>
        <li>302 Found: Az erőforrás ideiglenesen másik helyen található</li>
        <li>304 Not Modified: Az erőforrás nem változott, így a kliens az előző cache-elt verziót használhatja</li>
        <li>307 Temporary Redirect: Az erőforrás ideiglenesen másik helyre lett áthelyezve, és a kliensnek ugyanazzal a
          HTTP módszerrel kell újra kérni</li>
        <li>308 Permanent Redirect: Az erőforrás véglegesen másik helyre lett áthelyezve</li>
      </ul>
    </li>
    <br>
    <li>4xx - Kliensoldali hibák
      <ul>
        <li>400 Bad Request: A kérés nem érvényes vagy hibás formátumú, és a szerver nem tudja feldolgozni</li>
        <li>401 Unauthorized: A kéréshez hitelesítés szükséges, és a kliens nem biztosította azt (például nem adta meg a
          megfelelő hitelesítést)</li>
        <li>403 Forbidden: A kérés végrehajtása megtagadva, mivel a kliens nem rendelkezik megfelelő jogosultsággal</li>
        <li>404 Not Found: Az erőforrás nem található, ami az egyik leggyakoribb hiba, amit a felhasználók látnak</li>
        <li>405 Method Not Allowed: A kérésben szereplő HTTP módszer (például GET, POST) nem engedélyezett az adott
          erőforráson</li>
        <li>406 Not Acceptable: A kérés elfogadott formátuma nem érhető el a szerveren</li>
        <li>407 Proxy Authentication Required: A proxy-kiszolgáló hitelesítést kér a klienssel szemben</li>
        <li>408 Request Timeout: A szerver nem kapott választ a kliens kérésére a megadott időn belül</li>
        <li>409 Conflict: A kérés ellentmondásba kerül a szerver állapotával (például próbálkozás egy már létező
          erőforrás módosításával)</li>
        <li>410 Gone: Az erőforrás véglegesen eltűnt, és már nem elérhető</li>
        <li>411 Length Required: A kérés nem tartalmazza a szükséges Content-Length fejléceket</li>
        <li>412 Precondition Failed: A kérés feltételei nem teljesültek</li>
        <li>413 Payload Too Large: A kérés testének mérete túl nagy, és a szerver nem képes feldolgozni</li>
        <li>414 URI Too Long: A kérés URI-ja túl hosszú, és nem feldolgozható</li>
        <li>415 Unsupported Media Type: A kérésben megadott típus nem támogatott</li>
        <li>416 Range Not Satisfiable: A kérésben megadott tartomány nem érvényes</li>
        <li>417 Expectation Failed: A kérésben szereplő elvárás nem teljesíthető</li>
      </ul>
    </li>
    <br>
    <li>5xx - Szerveroldali hibák
      <ul>
        <li>500 Internal Server Error: A szerver belső hibát észlelt, ami megakadályozza a kérés teljesítését</li>
        <li>501 Not Implemented: A szerver nem támogatja a kérésben szereplő funkciót</li>
        <li>502 Bad Gateway: A szerver közvetítőként működik, és hiba történt, miközben egy másik szerver válaszát várta
        </li>
        <li>503 Service Unavailable: A szerver ideiglenesen nem elérhető (például karbantartás miatt)</li>
        <li>504 Gateway Timeout: A szerver nem kapott időben választ egy másik szervertől, amely közvetítő szerepet
          látott el</li>
        <li>505 HTTP Version Not Supported: A kérésben szereplő HTTP verziót a szerver nem támogatja</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #phpnodeversions data-anchor="phpnodeversions">PHP / Node versions</h3>
  <ul>
    <li>Node.js
      <ul>
        <li>Angular CLI, buildelés, fejlesztői szerver, csomagkezelés mind-mind Node.js-t használ</li>
        <li>SSR esetében a szerver is Node.js környezetben fut (server.ts)</li>
        <pre>
  curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
  source ~/.bashrc  # vagy ~/.zshrc

  nvm install 20
  nvm install 18

  nvm use 18
  nvm alias default 18

  node -v
        </pre>
      </ul>
    </li>
    <li>PHP
      <ul>
        <li>Ha az Angular app nem csupán statikus, hanem adatokat kér egy szervertől (API), akkor kell backend</li>
        <li>Ha a backend PHP, szükséges a PHP telepítése, ha nem, hanem mondjuk Node.js, vagy Firebase, akkor nincs
          szükség rá</li>
        <li>A futtatásához szerverre van szükség (Apache / Nginx / XAMPP / MAMP)
          <ul>
            <li>Vagy lehet használni beépített szervert
              <ul>
                <pre>
  php -S localhost:8000
                </pre>
              </ul>
            </li>
          </ul>
        </li>
        <li>Illetve webhosting környezetben (például cPanel), ami csak PHP-t támogat</li>

        <pre>
  /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

  brew install php@7.4
  brew install php@8.2

  brew unlink php
  brew link php@8.2

  php -v
        </pre>
        <li>A 7.4 biztonsági támogatása 2022 végén véget ért</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #slimphp data-anchor="slimphp">Slim PHP</h5>
  <ul>
    <li>PHP-s backend keretrendszer</li>
    <li>Teljes értékű framework</li>
    <li>MVC (Model-View-Controller) struktúra</li>
    <li>Ideális nagyobb projekteknél</li>
    <li>A Laravel + Angular együtt népszerű full-stack kombináció</li>
  </ul>
  <br>
  <h5 #laravel data-anchor="laravel">Laravel</h5>
  <ul>
    <li>Szintén PHP-s backend keretrendszer</li>
    <li>Egyszerű, minimalista framework</li>
    <li>Csak a legszükségesebb komponenseket tartalmazza (például routing, middleware, stb...)</li>
    <li>Ideális kis appokhoz</li>
  </ul>
  <br>
  <h5 #eloquent data-anchor="eloquent">Eloquent</h5>
  <ul>
    <li>A Laravel beépített ORM-je (Object-Relational Mapping) / része, de elvileg más projektekben is használható
      <ul>
        <li>ORM
          <ul>
            <li>Egy programozási technika, amely lehetővé teszi, hogy objektumorientált nyelvben (mint a PHP,
              JavaScript, Java, stb...) adatbázis-táblákkal dolgozzunk úgy, mintha objektumok lennének</li>
            <li>Az adatbázis táblák (például users, posts) osztályokká alakulnak (például User, Post)</li>
            <li>A rekordok objektumokká alakulnak (például $user->name)</li>
            <li>Az SQL lekérdezések metódushívásokká alakulnak</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Lehetővé teszi, hogy PHP osztályokkal (modellekkel) kezelj adatbázistáblákat</li>
    <li>SQL helyett objektumorientált módszerekkel tudunk lekérdezni, beszúrni, frissíteni</li>
    <pre>
      $user = User::find(1); // lekérünk egy felhasználót ID alapján
      
      $users = User::all(); // lekérjük az összes felhasználót

      $user = new User;  // létrehozunk, és elmentünk egy új felhasználót
      $user->name = 'John';
      $user->email = 'john@example.com';
      $user->save();
    </pre>
  </ul>
</div>

<div>
  <h3 #vite data-anchor="vite">Vite</h3>
  <ul>
    <li>Az Angular 17+ támogatja a Vite-ot, mint fejlesztői szervert az alapértelmezett Webpack helyett
      <ul>
        <li>Eredetileg a React / Vue / VanillaJS projektekhez készült</li>
      </ul>
    </li>
    <li>Gyorsabb hot-reloadot, és build időt jelent
      <ul>
        <li>Különösen SSR, és SSG terén gyorsít</li>
      </ul>
    </li>
    <li>Alapból az Angular CLI nem használ Vite-ot, hanem a Webpackra épül
      <ul>
        <li>Vite használatával az Angular-CLI-t sem használjuk</li>
        <li>Nincs ng build, ng serve, ng generate, stb... parancs</li>
      </ul>
    </li>
    <br>
    <table style="border-collapse: collapse; width: 100%;">
      <thead>
        <tr>
          <th>Előny</th>
          <th>Leírás</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Villámgyors dev szerver</td>
          <td>On-demand modulbetöltés (ESM), nincs teljes újrafordítás</td>
        </tr>
        <tr>
          <td>HMR (Hot Module Replacement)</td>
          <td>Instant frissítés komponens módosítás után</td>
        </tr>
        <tr>
          <td>Kis bundle méret</td>
          <td>Tree-shaking és optimalizálás Rollup segítségével</td>
        </tr>
        <tr>
          <td>Könnyű konfigurálhatóság</td>
          <td>vite.config.ts által könnyen szabályozható viselkedés</td>
        </tr>
        <tr>
          <td>Plugin rendszer</td>
          <td>Vite pluginokkal egyszerűen bővíthető</td>
        </tr>
        <tr>
          <td>Gyorsabb tesztelés</td>
          <td>Vitest támogatás, gyors tesztfuttatás, snapshot lehetőségek</td>
        </tr>
        <tr>
          <td>SSR támogatás</td>
          <td>Egyszerűbb szerveroldali renderelés (bár Angularban még külön setup kell)</td>
        </tr>
      </tbody>
    </table>
    <br>
    <li>Új projekt lépései
      <ul>
        <pre>
  npm create vite@latest angular-vite
        </pre>
        <img src="assets/imgs/angular_vite_install.png" width="100%">
        <br>
        <li>Ezt követően még telepíthetjük a Tailwind CSS framework-öt, és eldönthetjük, hogy full-stack, blog, vagy
          minimal applikációt
          hozunk létre</li>
        <pre>
  npm install

  <b>// minimalista app</b>

  angular-vite-app/
  │
  ├── .vscode/                      // VS Code specifikus konfigurációs fájlok
  │   ├── extensions.json
  │   ├── launch.json
  │   └── tasks.json
  │
  ├── node_modules/                 // összes telepített npm csomag
  │   └── ...
  │
  ├── public/                       // nyilvános (statikus) fájlok
  │   ├── .gitkeep
  │   └── favicon.ico
  │
  ├── src/                          // forráskód
  │   ├── app/                      // applikáció
  │   │   ├── pages/                // komponensek / oldalak
  │   │   │     └── index.page.ag   // komponensek / oldalak
  │   │   │
  │   │   ├── app-root.ag           // az alkalmazás fő komponense
  │   │   ├── app.config.server.ts  // szerveroldali konfigurációs fájl (SSR)
  │   │   └── app.config.ts         // app konfigurációs fájl
  │   │        
  │   ├── analog.env.d.ts
  │   ├── main.server.ts
  │   ├── main.ts
  │   ├── styles.css
  │   └── vite-env.d.ts             // a Vite környezet típusdefiníciója
  │
  ├── editorconfig
  ├── .gitignore
  ├── angular.json
  ├── index.html
  ├── package-lock.json
  ├── package.json
  ├── postcss.config.cjs              // PostCSS konfiguráció
  ├── README.md
  ├── tailwind.config.html            // Tailwind konfiguráció
  ├── tsconfig.app.json
  ├── tsconfig.json
  └── vite.config.ts                  // a Vite konfigurációs fájlja


  npm run dev
        </pre>
      </ul>
    </li>
    <br>
    <img src="assets/imgs/angular_vite_improvements.png" width="100%">
    <br>
    <br>
    <li>Az Analog egy Vite-alapú (full-stack) keretrendszer Angularhoz
      <ul>
        <li>Beépített SSR, routing, Vitest, és nem használ Angular CLI-t</li>
      </ul>
    </li>
    <li>Teszteléshez használhatjuk alternatívaképp a Vitest-et
      <ul>
        <li>Gyors, modern</li>
        <li>A Jest API-ra épít, amely a Karma + Jasmine kombinációjától eltérő, de hasonló tesztelési megközelítést
          biztosít</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #innerhtml data-anchor="innerhtml">innerHTML</h3>
  <ul>
    <li>Egy DOM elem belső HTML-jét reprezentálja</li>
    <pre>
  &#60;div id="greetings">
    &#60;span>Hi there!&#60;/span>
  &#60;/div>
  
  &#60;script>
    const div = document.getElementById('greetings');
    console.log(div.innerHTML); // &#60;span>Hi there!&#60;/span>
    div.innerHTML = '&#60;b>Good bye!&#60;/b>'; //  // lecseréljük a belső HTML-t
  &#60;/script>
    </pre>
    <li>Használata biztonsági rést nyithat, ha dinamikus, felhasználótól származó adatot írunk be
      <ul>
        <li>Soha nem szabad validálás/szűrés nélkül megtenni</li>
      </ul>
    </li>
    <li>Angular esetében a template-ben használható
      <ul>
        <pre>
  &#60;div [innerHTML]="htmlContent">&#60;/div>

  htmlContent = this.sanitizer.bypassSecurityTrustHtml('&#60;span>Content&#60;/span>');
        </pre>
        <li>Alapesetben az Angular sanitize-olja az értéket, így például a &#60;script> tag automatikusan eltávolításra
          kerül
          <ul>
            <li>Security bypass esetében nincs sanitize</li>
          </ul>
        </li>
        <li>Bevállt gyakorlat a bypassSecurity használatára a pipe alkalmazása
          <ul>
            <pre>
  @Pipe(&#123;
    name: 'safeHtml'
  })
  export class SafeHtmlPipe implements PipeTransform &#123;
    constructor(private sanitized: DomSanitizer) &#123; }
    transform(value) &#123;
      return this.sanitized.bypassSecurityTrustHtml(value);
    }
  }

  &#60;div [innerHTML]="htmlContent | safeHtml">&#60;/div>
            </pre>
          </ul>
        </li>
        <li>A bypassSecurityTrustHtml alkalmazásával az Angular nem "védi meg" a DOM-ot</li>
        <br>
        <li>DomSanitizer függvények
          <ol>
            <li>bypassSecurityTrustHtml() - HTML tartalom</li>
            <li>bypassSecurityTrustStyle() - CSS stílus</li>
            <li>bypassSecurityTrustScript() - JS kód</li>
            <li>bypassSecurityTrustUrl() - URL-ek</li>
            <li>bypassSecurityTrustResourceUrl() - iframe, object src, stb...</li>
          </ol>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #outerhtml data-anchor="outerhtml">outerHTML</h3>
  <ul>
    <li>Az egész DOM elem HTML-jét adja vissza, beleértve magát az elemet is</li>
    <li>Lecserélhető az egész node, nemcsak a belseje</li>
    <pre>
  &#60;div id="templateVariable">
    outer&#60;b>HTML&#60;/b>
  &#60;/div>
  
  &#60;script>
    const div = document.getElementById('templateVariable');
    console.log(div.outerHTML);
    div.outerHTML = '&#60;section>Section&#60;/section>';  // az egész div lecserélődik
  &#60;/script>
    </pre>
    <li>Használata biztonsági rést nyithat, ha dinamikus, felhasználótól származó adatot írunk be
      <ul>
        <li>Soha nem szabad validálás/szűrés nélkül megtenni</li>
      </ul>
    </li>
    <li>Az Angularban nincs direkt [outerHTML] binding
      <ul>
        <li>A komponens class-ban manipulálató a DOM, de nem ajánlott, helyette ott van az *ngIf, vagy az *ngSwitch
          stuktúrális direktíva</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #fcp data-anchor="fcp">FCP</h3>
  <ul>
    <li>First Contentful Paint</li>
    <li>azt az időpontot jelenti, amikor a böngésző először jelenít meg bármilyen tartalmi elemet (szöveget, képet,
      SVG-t, stb...) a képernyőn</li>
    <li>Fontos web performance mérőszám a Core Web Vitals metrikák között
      <ul>
        <li>Core Web Vitals
          <ul>
            <li>A Google által meghatározott webes teljesítménymutatók összessége, amelyek a felhasználói élményt mérik
            </li>
            <li>Ezeket figyeli például a Google PageSpeed Insights, a Lighthouse, és a Chrome böngésző is</li>
            <li>3 fő metrikát foglal magában
              <br>
              <table style="border-collapse: collapse; width: 100%;">
                <thead>
                  <tr>
                    <th>Metrika</th>
                    <th>Jelentés</th>
                    <th>Jó érték</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>LCP (Largest Contentful Paint)</td>
                    <td>A legnagyobb látható tartalom betöltésének ideje</td>
                    <td>&lt; 2.5 másodperc</td>
                  </tr>
                  <tr>
                    <td>FID (First Input Delay)</td>
                    <td>Első interakcióra adott válaszidő</td>
                    <td>&lt; 100 ms</td>
                  </tr>
                  <tr>
                    <td>CLS (Cumulative Layout Shift)</td>
                    <td>Váratlan elmozdulások mértéke az oldalon</td>
                    <td>&lt; 0.1</td>
                  </tr>
                </tbody>
              </table>

              <br>
            <li>Az Angular SSR (@defer) segíti a LCP csökkentését azáltal, hogy gyorsabban megjelenik a fő tartalom</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Ha gyors az FCP, a felhasználó azt érzi, hogy az oldal gyorsan reagál</li>
  </ul>
</div>

<div>
  <h3 #selfclosingsyntax data-anchor="selfclosingsyntax">Self-closing syntax</h3>
  <ul>
    <li>A forma a standalone komponensek, és az Angular enhanced template parser-ének megjelenésével vált hivatalosan
      támogatottá</li>
    <li>Angular 17-től elérhető</li>
    <pre>
  &#60;app-test-component /> // self-closing

  =====

  &#60;app-heavy-component>&#60;/app-heavy-component>
    </pre>
    <li>Kényelmi újítás, ami az alábbi feltételekkel használható
      <ol>
        <li>A komponens standalone</li>
        <li>Nem használunk content projection-t (&#60;ng-content>)</li>
      </ol>
    </li>
  </ul>
</div>

<div>
  <h3 #xss data-anchor="xss">XSS</h3>
  <ul>
    <li>Cross-Site Scripting</li>
    <li>biztonsági hiba, amely lehetővé teszi, hogy támadók káros JavaScript kódot injektáljanak egy weboldalba, amit
      más felhasználók böngészője hajt végre</li>
    <li>Űrlapokba, URL paraméterekbe injektálható</li>
    <li>A támadók érzékeny adatokhoz férhetnek hozzá</li>
    <br>
    <li>Típusai
      <ol>
        <li>Reflected XSS
          <ul>
            <li>A támadó egy manipulált URL-t küld a felhasználónak, amely tartalmazza a káros JavaScript kódot</li>
            <li>Ha a felhasználó rákattint, az oldal a kódot visszatükrözi, és a böngésző végrehajtja azt</li>
            <li>Ez jellemzően egy keresési vagy űrlap beküldésével történik</li>
          </ul>
        </li>
        <li>Stored / Persistent XSS
          <ul>
            <li>A támadó egy webalkalmazásba szúr be kártékony kódot, például egy hozzászólás vagy üzenet formájában
            </li>
            <li>A kódot a szerver tárolja, és a későbbi felhasználók böngészője végrehajtja, amikor megjeleníti a
              szkriptet</li>
          </ul>
        </li>
        <li>DOM-based XSS
          <ul>
            <li>Akkor fordul elő, amikor a támadó a JavaScript kódot manipulálja közvetlenül a böngészőben, anélkül hogy
              a szervernek közvetlenül módosítania kellene a választ</li>
            <li>A DOM (Document Object Model) manipulálásával történik, és akkor aktiválódik, amikor a felhasználó egy
              linkre vagy gombra kattint</li>
          </ul>
        </li>
      </ol>
    </li>
    <br>
    <li>Megelőzése
      <ul>
        <li>Minden inputot érdemes validálni
          <ul>
            <li>Ha például számot várunk, ne engedjük meg a betűket, és egyéb speciális karaktereket</li>
          </ul>
        </li>
        <li>Alkalmazzunk HTML karakterkódolást, mert a böngésző a &#60;, >, &, ', " karaktereket speciális módon
          értelmezi
          <ul>
            <li>&#60; helyett &lt ;</li>
            <li>> helyett &gt ;</li>
            <li>& helyett &amp ;</li>
            <li>' helyett &apos ;</li>
            <li>" helyett &quot ;</li>
          </ul>
        </li>
        <li>Content Security Policy (CSP)
          <ul>
            <li>Biztonsági intézkedés, amely korlátozza, hogy milyen forrásokból tölthetők be szkriptek és egyéb
              tartalmak</li>
          </ul>
        </li>
        <li>HTTPOnly cookie használata
          <ul>
            <li>Megakadályozza, hogy a JavaScript hozzáférjen a cookie-khoz</li>
            <li>Ha valaki XSS-t hajt végre, nem tudja ellopni a cookie-t, mivel azt a böngésző nem engedi JavaScript-ből
              elérni</li>
          </ul>
        </li>
        <li>Secure cookie
          <ul>
            <li>Biztosítja, hogy a cookie-k csak HTTPS kapcsolaton keresztül kerüljenek átadásra, így nem lesznek
              elérhetők egy nem titkosított (HTTP) kapcsolaton</li>
          </ul>
        </li>
        <li>Például az Angular, és a React gyakran automatikusan megakadályozza az XSS támadásokat azáltal, hogy az
          adatokat megfelelően kódolják</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #websocketandmqtt data-anchor="websocketandmqtt">Websocket & MQTT</h3>
  <ul>
    <li>Websocket
      <ul>
        <li>Kommunikációs protokoll</li>
        <li>Kétirányú, állandó kapcsolatot tesz lehetővé a kliens (például böngésző), és a szerver között</li>
        <li>Valós idejű alkalmazásokhoz használatos, ahol gyors, folyamatos adatáramlásra van szükség
          <ul>
            <li>Chat</li>
            <li>Élő értesítések</li>
            <li>Stb...</li>
          </ul>
        </li>
        <li>A kliens létrehozza egy kapcsolatot a szerverrel, ami nyitva marad, így nem kell újra, és újra HTTP kérést
          küldeni</li>
        <li>A szerver bármikor küldhet adatot a kliensnek</li>
        <br>
        <div class="input-group mb-3">
          <input #websocketinput type="text" class="form-control">
          <button class="btn btn-outline-secondary" type="button"
            (click)="sendWebsocketMessage(websocketinput.value); websocketinput.value = ''">
            Send
          </button>
        </div>
        <div style="display: block; max-height: 100px; overflow: auto;">
          <ul>
            <li *ngFor="let message of websocketMessages">
              {{ message }}
            </li>
          </ul>
        </div>
        <br>
        <img src="assets/imgs/websocket_2.png" width="100%">
        <br>
        <pre>
  <b>// websocket.service.ts</b>

  @Injectable(&#123;
    providedIn: 'root'
  })
  export class WebSocketService &#123;
      private socket$: WebSocketSubject&#60;any>;
  
      constructor() &#123;
          this.socket$ = webSocket('wss://ws.postman-echo.com/raw');
      }
  
      sendMessage(message: any) &#123;     // üzenetküldés a szervernek
          this.socket$.next(message);
      }
  
      getMessages(): Observable&#60;any> &#123;        // szerver felől érkező üzenet fogadása
          return this.socket$.asObservable();
      }
  
      closeConnection() &#123;     // WebSocket kapcsolat bezárása
          this.socket$.complete();
      }
  }

  <b>// extras.component.html</b>

  &#60;div class="input-group mb-3">
    &#60;input #websocketinput type="text" class="form-control">
    &#60;button class="btn btn-outline-secondary" type="button" (click)="sendWebsocketMessage(websocketinput.value); websocketinput.value = ''">   // küldés, majd mező törlés
      Send
    &#60;/button>
  &#60;/div>

  &#60;div
    &#60;ul>
      &#60;li *ngFor="let message of websocketMessages">
        &#123; &#123; message}}
      &#60;/li>
    &#60;/ul>
  &#60;/div>

  <b>// extras.component.ts</b>

  export class ExtrasComponent implements OnInit, OnDestroy &#123;
    ...

    websocket: WebSocketService = inject(WebSocketService);
    websocketMessages: any[] = [];
    private messageSubscription!: Subscription;

    ngOnInit() &#123;
      this.messageSubscription = this.websocket.getMessages().subscribe(
        (message) => &#123;
          this.websocketMessages.push(message);
        }
      );
      this.subscriptions = [...this.subscriptions, this.messageSubscription];
    }

    ...

    sendWebsocketMessage(message: string) &#123;
      const messageToSend = &#123; type: 'message', data: message };
      this.websocket.sendMessage(messageToSend);
    }

    ngOnDestroy() &#123;
      for (let subscription of this.subscriptions) &#123;
        subscription.unsubscribe();
      };
      this.websocket.closeConnection();
    }
  }
        </pre>
        <li>Echo server, amit küldünk neki, visszaküldi ugyanannak a kapcsolatnak, nem broadcastol más klienseknek, mint
          például más böngésző ablakoknak</li>
        <li>Ahhoz, hogy valós üzenetváltás történhessen, Node.js szerverre lesz szükségünk</li>
        <pre>
  <b>// websocket.server.js</b>

  const WebSocket = require('ws');

  const PORT = 3000;
  const wss = new WebSocket.Server(&#123; port: PORT });

  console.log(`WebSocket server is running on ws://localhost:$&#123;PORT}`);

  wss.on('connection', (ws) => &#123;
      console.log('New client connected');

      ws.on('message', (message) => &#123;
          console.log(`Received: $&#123;message}`);

          if (Buffer.isBuffer(message)) &#123;     // ellenőrizzük, hogy a kapott üzenet egy Buffer típusú adat-e
              const textMessage = message.toString('utf-8');      // ha bináris üzenet érkezett, alakítsuk szöveggé
              // Broadcast minden kliensnek
              wss.clients.forEach((client) => &#123;
                  if (client !== ws && client.readyState === WebSocket.OPEN) &#123;   // client !== ws --> ez mondja meg, hogy a küldő ne kapja vissza az üzenetét
                      client.send(textMessage);       // szöveges üzenet küldése
                  }
              });
          } else &#123;
              wss.clients.forEach((client) => &#123;       // ha szöveges üzenet jött, broadcast szöveges üzenetként
                  if (client !== ws && client.readyState === WebSocket.OPEN) &#123;
                      client.send(message);
                  }
              });
          }
      });

      ws.on('close', () => &#123;
          console.log('Client disconnected');
      });
  });

  <b>// websocket.service.ts</b>

  @Injectable(&#123;
    providedIn: 'root'
  })
  export class WebSocketService &#123;
      private socket$: WebSocketSubject&#60;any>;

      constructor() &#123;
          // this.socket$ = webSocket('wss://ws.postman-echo.com/raw');
          this.socket$ = webSocket('ws://localhost:3000');    // itt fut a Node.js szerver
      }

      sendMessage(message: any) &#123;     // üzenetküldés a szervernek
          this.socket$.next(message);
      }

      getMessages(): Observable&#60;any> &#123;        // szerver felől érkező üzenet fogadása
          return this.socket$.asObservable();
      }

      closeConnection() &#123;     // WebSocket kapcsolat bezárása
          this.socket$.complete();
      }
  }

  <b>// extras.component.ts</b>

  this.messageSubscription = this.websocket.getMessages().subscribe(
    (message) => &#123;
      console.log(message);
      this.websocketMessages.push(message.data);    // csak az változott, hogy a data kerül ki
    }
  );
        </pre>
        <li>Általában a WebSocket szerver úgy van beállítva, hogy a szerver válaszait csak más klienseknek küldi el, nem
          pedig annak a kliensnek, aki az üzenetet küldte</li>
        <br>
        <img src="assets/imgs/websocket_1.png" width="100%">
        <br>
        <br>
        <li>Aktív az echo szerver maradt</li>
        <br>
      </ul>
    </li>
    <li>MQTT
      <ul>
        <li>Message Queuing Telemetry Transport</li>
        <li>Bináris protokoll, tehát a teljes csomagolás bináris</li>
        <li>Publish-subscribe (közzététel-feliratkozás) elvű üzenetküldő protokoll, amit főleg IoT (Internet of
          Things) eszközöknél használnak</li>
        <li>Van egy központi broker, ami fogadja, és továbbítja az üzeneteket a feliratkozott "küldőknek"</li>
        <li>Bizonyos időközönként (alapesetben 60 másodperc) az MQTT kliens keep-alive üzenetet küld a brókernek, amire
          utóbbi (optimális esetben) válaszol is
          <ul>
            <li>Így történik a kapcsolat ellenőrzése, hogy él-e még</li>
          </ul>
        </li>
        <pre>
  npm install mqtt
        </pre>
        <br>
        <div class="input-group mb-3">
          <input #mqttinput type="text" class="form-control">
          <button class="btn btn-outline-secondary" type="button"
            (click)="sendMqttMessage(mqttinput.value); mqttinput.value = ''">
            Send
          </button>
        </div>

        <div style="display: block; max-height: 100px; overflow: auto;">
          <ul>
            <li *ngFor="let msg of mqttMessages">
              {{ msg }}
            </li>
          </ul>
        </div>
        <br>
        <img src="assets/imgs/mqtt.png" width="100%">
        <br>
        <pre>
  <b>// mqtt.service.ts</b>

  @Injectable(&#123;
    providedIn: 'root'
  })
  export class MqttService &#123;
      private client: mqtt.MqttClient;
      private readonly topic = 'mqtt/Z-5-0';
  
        constructor() &#123;
          this.client = mqtt.connect('ws://broker.hivemq.com:8000/mqtt', &#123;        // második paraméterben lehet beeállításokat végrehajtai
              keepalive: 10,      // így például 10 másodpercenként ellenőrizzük a kapcsolatot
          });
  
          this.client.on('connect', () => &#123;
              // console.log('MQTT connected');
              this.client.subscribe(this.topic);
          });
  
          this.client.on('error', err => &#123;
              // console.error('MQTT error', err);
          });
      }
  
      publishMessage(msg: string): void &#123;
          // console.log(msg);
          this.client.publish(this.topic, msg);
      }
  
      onMessage(callback: (msg: string) => void) &#123;
          this.client.on('message', (topic, payload) => &#123;
            const message = payload.toString();
            callback(message);
          });
        }  
  }

  <b>// extras.component.html</b>

  &#60;div class="input-group mb-3">
    &#60;input #mqttinput type="text" class="form-control">
    &#60;button class="btn btn-outline-secondary" type="button"
      (click)="sendMqttMessage(mqttinput.value); mqttinput.value = ''">
      Send
    &#60;/button>
  &#60;/div>

  &#60;div>
    &#60;ul>
      &#60;li *ngFor="let msg of mqttMessages">
        &#123; &#123; msg }}
      &#60;/li>
    &#60;/ul>
  &#60;/div>

  <b>// extras.component.ts</b>

  export class ExtrasComponent implements OnInit, AfterViewInit, OnDestroy &#123;
    ...

    mqtt: MqttService = inject(MqttService);
    mqttMessages: string[] = [];

    ngOnInit() &#123;
      this.mqtt.onMessage((msg) => &#123;
        console.log('mqtt: ', msg);
        this.mqttMessages.push(msg);
      });
    }

    ...

    sendMqttMessage(message: any): void &#123;
      this.mqtt.publishMessage(message);
      message = '';
    }
  }
        </pre>
        <li>A bróker felé küldött üzeneteket minden feliratkozott megkapja</li>
      </ul>
    </li>
    <br>
    <table style="border-collapse: collapse; width: 100%;">
      <thead>
        <tr>
          <th>Különbségek és kapcsolat</th>
          <th>WebSocket</th>
          <th>MQTT</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Fogalom</td>
          <td>Kommunikációs protokoll</td>
          <td>Üzenetküldő protokoll (publish-subscribe)</td>
        </tr>
        <tr>
          <td>Szint</td>
          <td>Alacsonyabb szintű (Transport Layer felett)</td>
          <td>Magasabb szintű protokoll WebSocket vagy TCP felett</td>
        </tr>
        <tr>
          <td>Használat</td>
          <td>Valós idejű kommunikáció (például chat, multiplayer játék)</td>
          <td>IoT, szenzoradatok, gép-gép közti kommunikáció</td>
        </tr>
        <tr>
          <td>Adatmozgás</td>
          <td>TCP felett működik</td>
          <td>Általában TCP, de lehet WebSocket felett is</td>
        </tr>
        <tr>
          <td>Üzenet formátum</td>
          <td>Nincs kötött formátum (például JSON)</td>
          <td>Kötött, kis méretű bináris üzenet</td>
        </tr>
        <tr>
          <td>Közvetítő</td>
          <td>Nincs közvetítő (direkt kapcsolat kliens, és szerver között)</td>
          <td>Van közvetítő, az MQTT broker</td>
        </tr>
      </tbody>
    </table>
  </ul>
</div>

<!--div>
  <h3 #todo data-anchor="todo">TODO</h3>
  <ul>
    <li></li>
  </ul>
</!--div-->