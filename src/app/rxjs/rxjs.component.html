<h1>RxJS</h1>

<div class="anchor-navi-container">
  <div *ngFor="let mainButton of anchorButtons" class="btn-group">
    <button type="button" class="btn btn-primary btn-sm anchor" (click)="scrollToAnchor(mainButton?.anchor)">
      {{ mainButton.title }}
    </button>
    <button *ngIf="mainButton?.subtitles?.length" type="button"
      class="btn btn-primary dropdown-toggle dropdown-toggle-split btn-sm anchor" data-bs-toggle="dropdown"
      aria-expanded="false">
    </button>
    <ul *ngIf="mainButton.subtitles?.length" class="dropdown-menu dropdown-menu-dark">
      <li>
        <button *ngFor="let subButton of mainButton?.subtitles" class="dropdown-item"
          (click)="scrollToAnchor(subButton?.anchor)">
          {{ subButton?.title }}
        </button>
      </li>
    </ul>
  </div>
</div>

<div>
  <h3 #rxjs data-anchor="rxjs">RxJS</h3>
  <ul>
    <li>Az Angular-tól teljesen független könyvtár</li>
    <li>Ugyanakkor az Angular felhasználja, és sok RxJS alapú eszközt szolgáltat számunkra</li>
    <li>Az Appunk futása közben, bizonyos időpillanatokban események következnek be (például click valamire), és ezen
      eseményekkor tipikusan valamilyen adatcsomag is generálódik
    </li>
    <li>Az RxJS segítségével ezt a végtelen számú csomagot lehet reprezentálni, még mielőtt ténylegesen
      rendelkezésre állnának
    </li>
    <li>Előnyei
      <ul>
        <li>Az operátorok láncolásával kifejező és olvasható kódot írhatunk</li>
        <li>Az operátorok használatával összetett adatfolyamokat hozhatunk létre és kezelhetünk könnyedén</li>
        <li>Egységesíti az aszinkron adatkezelést különböző forrásokból (például események, időzítők, HTTP
          kérések)
        </li>
      </ul>
    </li>
    <li>Főbb elemei
      <ol>
        <li>Observable (Megfigyelhető)
          <ul>
            <li>Amikor létrehozunk egy Observable-t, például egy element click eseménye kapcsán, akkor azzal
              azt mondjuk, hogy reprezentáljuk az ezen element-re bekövetkező összes jövőbeli click
              esemény hatására létrejövő adatcsomagot
            </li>
            <li>A tényleges adatcsomagokat úgy tudjuk kezelni, hogy időben valamikor feliratkozunk az
              adatfolyamra egy úgynevezett Observer-rel (megfigyelővel)
            </li>
            <li>A feliratkozást bármikor megtehetjük, akár az Observable létrehozásakor, vagy egy későbbi
              időpillanatban
            </li>
            <li>A $ konvenció, Observable típusok mögé kell rakni
              <ul>
                <li>Olyan, mint egy 'S' betű, többesszámra utal, pl.: click$, azaz click-ekből álló adatfolyam
                </li>
              </ul>
            </li>
            <li>Az Observable 3 féle működést tud reprezentálni
              <ul>
                <li>next
                  <ul>
                    <li>Amikor kibocsátja magából a következő adatcsomagot</li>
                  </ul>
                </li>
                <li>error
                  <ul>
                    <li>Ilyenkor a működése véget ér</li>
                  </ul>
                </li>
                <li>completed
                  <ul>
                    <li>Ebben az állapotban is véget ér a működése</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <br>
        <li>Observer (Megfigyelő)
          <ul>
            <li>Olyan objektum, amely fogadja a az Observable által kibocsátott adatokat</li>
            <li>Amikor egy Observer-rel feliratkozunk egy Observable-re, akkor a fenti 3 dolgot tudjuk
              megadni a feliratkozás kapcsán
              <ul>
                <pre>
  clickDataFlow.subscribe(
  &#123;
      next: (data) => &#123;
          console.log(data);
      &#125;,
      error: (err) = &#123;
          console.log(err);
      &#125;,
      complete: () => &#123;
          console.log('Data flow completed');
      &#125;,
  &#125;)
                </pre>
                <li>Meg lehet mondani, hogy ha érkezik egy adatcsomag, mi történjen, ha hibára futunk,
                  akkor mi történjen, és ha lezárul az adatfolyam, mi történjen
                </li>
                <li>A(z adott) Observer le is tud iratkozni az adatfolyamról unsubscribe() method-dal
                  <ul>
                    <li>Ettől függetlenül az Observable továbbra is bocsáthat ki adatcsomagokat,
                      amiket más, még feliratkozott Observerek megkapnak
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Az Observer csak a feliratkozástól kezdve fogadja az adatcsomagokat, a korábbi
              adatcsomagokhoz nincs hozzáférése
            </li>
          </ul>
        </li>
        <br>
        <li>Subscription (Feliratkozás)
          <ul>
            <li>A Subscription kezeli a kapcsolatot az Observable és az Observer között</li>
            <li>A Subscription segítségével leiratkozhatunk az Observable-ről, megszakítva ezzel az
              adatfolyamot
            </li>
          </ul>
        </li>
        <br>
        <li>Operators (Operátorok)
          <ul>
            <li>Az egész adatfolyam működése befolyásolható operátorokkal</li>
            <li>Egymás után szekvenciálisan végrehajtódó műveletek történnek</li>
            <li>Tehát az operátorok láncolhatók, így összetett adatfolyam-transzformációkat hozhatunk
              létre
            </li>
            <li>A csőrendszerbe regisztálható műveleteket operátoroknak nevezzük</li>
            <li>A műveletek lehetnek kihatással közvetlenül az érkező adatcsomagra, vagy az adatcsomag
              működésére
              <ul>
                <li>map
                  <ul>
                    <li>Leképezi az érkező adatot valami más adattá</li>
                    <pre>
  const source$ = of(1, 2, 3, 4, 5);    // Observable

  const result$ = source$.pipe(   // erre a stream-re fel is kell iratkozni
    map(value => value * 10)
  );
                      </pre>
                    <li>Minden kibocsátott értéket megszoroz tízzel</li>
                  </ul>
                </li>
                <li>take
                  <ul>
                    <li>Egy megadott számú adatcsomag kibocsátása után completed állapotba futtatja arendszert</li>
                    <li>Automatikusan leiratkozik</li>
                  </ul>
                </li>
                <li>filter
                  <ul>
                    <li>Szűri az Observable kibocsátásait egy feltétel alapján</li>
                    <pre>
  const source$ = of(1, 2, 3, 4, 5);
  const result$ = source$.pipe(
    filter(value => value % 2 === 0)    // Csak a páros számokat engedi át
  );
                      </pre>
                  </ul>
                </li>
                <li>merge</li>
                <li>concat</li>
                <li>mergeMap
                  <ul>
                    <li>Kiterjeszti az adatfolyamot egy új Observable-re, és összeolvassza az összes kibocsátást</li>
                    <pre>
  const source$ = of('https://jsonplaceholder.typicode.com/posts/1', 'https://jsonplaceholder.typicode.com/posts/2');
  const result$ = source$.pipe(
    mergeMap(url => ajax.getJSON(url))
  );
                     </pre>
                    <li>Egy HTTP kérést indít minden kibocsátott értéknél</li>
                  </ul>
                </li>
                <li>switchMap
                  <ul>
                    <li>Hasonló a mergeMap-hez</li>
                    <pre>
  const result$ = input$.pipe(
    map(event => event.target.value),
    switchMap(query => ajax.getJSON(`https://api.example.com/search?q=$&#123;query&#125;`))
  );
                    </pre>
                  </ul>
                </li>
                <li>debounceTime
                  <ul>
                    <li>Késlelteti az Observable kibocsátásait egy adott időtartammal</li>
                    <pre>
  const result$ = input$.pipe(
    debounceTime(300),
    map(event => event.target.value)
  );
                    </pre>
                    <li>Csak akkor bocsát ki új értéket, ha egy adott időtartamig nem érkezik újabb
                      kibocsátás
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Creation operators
              <ul>
                <li>Mindegyik Observable-t hoz létre
                  <ul>
                    <li>of
                      <ul>
                        <pre>
  const array$ = of([10, 20, 30]);
  array$.subscribe(value => console.log(value));

  ↓↓↓↓↓

  [10, 20, 30]
                         </pre>
                        <li>Visszaadja a számokat egymás után</li>
                      </ul>
                    </li>
                    <li>from
                      <ul>
                        <pre>
  const array$ = from([1, 2, 3, 4, 5]);
  array$.subscribe(value => console.log(value));

  ↓↓↓↓↓

  1
  2
  3
  4
  5
                         </pre>
                        <li>Tömböt, string-et, Map-et, Set-et, vagy Promise-t vesz át, és egy
                          Observable-t hoz létre
                        </li>
                        <li>Visszaadja őket egymás után</li>
                        <pre>
  const array$ = from([
    10,
    20,
    new Promise(resolve => resolve('Hello'))])
    .pipe(
      mergeMap(item => &#123;
        if (item instanceof Promise) &#123;
          return from(item);
        &#125; else &#123;
          return from([item]);
        &#125;
      &#125;)
    );
  array$.subscribe(value => console.log(value));

  ↓↓↓↓↓

  10
  20
  'Hello'
                         </pre>
                        <li>A tömb egyik eleme egy Promise, a mergeMap-pal laposítjuk a tömb
                          másik két értékéhez, és benne feldolgozzuk a Promise-t, így lesz az
                          eredmény végül egymás után következve 10, 20, 'Hello'
                        </li>
                      </ul>
                    </li>
                    <li>interval
                      <ul>
                        <pre>
  const interval$ = interval(1000);
  interval$.subscribe(value => console.log(value));
                        </pre>
                        <li>Egy másodpercenként számokat bocsájt ki magából 0-tól kezdve,
                          növekvő módon
                        </li>
                        <li>Ha nincs fókuszban az ablak, megáll</li>
                      </ul>
                    </li>
                    <li>timer
                      <ul>
                        <pre>
  const timer$ = timer(2000, 1000);
  timer$.subscribe(value => console.log(value));
                        </pre>
                        <li>2 másodpercig vár, majd 0-tól indulva másodpercenként számokat ad vissza (0, 1, 2, ...)
                        </li>
                      </ul>
                    </li>
                    <li>fromEvent
                      <ul>
                        <li>Például DOM eseményből hoz létre Observable-t</li>
                        <pre>
  const buttonClicked = document.getElementById('clickButton');
  let buttonClickedObservable$ = new Observable();
  if (this.clickButton) &#123;
      const buttonClickedObservable$ = fromEvent(buttonClicked, 'click');
  &#125;
                          </pre>
                        <li>A fromEvent első paramétere egy elem (HTMLElement-et vár), a második maga az event</li>
                        <li>ViewChild használatakor nativeElement-et szükséges neki adni, mert alapvetően 'ElementRef'
                          típus képződik, ami Angular specifikus</li>
                        <pre>
  @ViewChild('clickButton') clickButton!: ElementRef&#60;HTMLButtonElement&#62;;
    let buttonClickedObservable$ = fromEvent(this.clickButton.nativeElement, 'click');
    buttonClickedObservable$.subscribe(&#123;
        next: (data) => &#123;
        console.log(data);
          &#125;,
        error: (err) => &#123;
          &#125;,
        complete: () => &#123;
          &#125;,
    &#125;);
                        </pre>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <br>
        <li>Subject
          <ul>
            <li>A Subject egy speciális típusú Observable, amely lehetővé teszi, hogy több Observer
              csatlakozzon hozzá, és közvetlenül küldhet adatokat az Observer-eknek
            <li>A Subject lehet multicasting, azaz több Observer-t is kiszolgálhat egyszerre</li>
          </ul>
        </li>
      </ol>
    </li>
  </ul>
</div>

<div>
  <h3 #rxjs_ data-anchor="rxjs_">RxJS+</h3>
  <ul>
    <li>fromEvent
      <ul>
        <li>Gombnyomásra létrehozott Observable</li>
        <div class="d-inline-flex align-items-center gap-1">
          <button #clickButton id="clickButton" class="clickButton btn btn-secondary">CLICK</button>
          {{buttonClickedObservable$ | async}}
          <span *ngIf="buttonClickedObservableSteamCompleted">(steam completed)</span>
        </div>
        <pre>
  &#60;button #clickButton class="clickButton"&#62;CLICK&#60;/button&#62;
  &#123; &#123; buttonClickedObservable$ | async }}
  &#60;span *ngIf="buttonClickedObservableSteamCompleted">(steam completed)&#60;/span>

  @ViewChild('clickButton') clickButton!: ElementRef&#60;HTMLButtonElement&#62;;

  fromEventButtonClick() &#123;
    let buttonClickedObservable$ = fromEvent(this.clickButton.nativeElement, 'click')
      .pipe(
        map((event: any) => event.clientX),
        take(5)
      );

    buttonClickedObservable$.subscribe(&#123;
        next: (data) => &#123;
              console.log(data);
        &#125;,
        error: (err) => &#123;
        &#125;,
        complete: () => &#123;
          console.log('fromEvent completed!');
        &#125;,
      &#125;);
  &#125;
        </pre>
        <li>A fromEvent első paraméterének szelektálást is meg lehet adni
          <pre>
  let buttonClickedObservable$ = fromEvent(document.getElementById('clickButton'), 'click')
          </pre>
        </li>
        <li>A map() a feliratkozottaknak a next ágba csak a click event clientX property-jét adja tovább</li>
        <li>A take() pedig azt eredményezi, hogy 5 darab click után completed ágba fut az adatfolyam
          <ul>
            <li>Nem bocsát ki több értéket</li>
          </ul>
        </li>
        <br>
        <li>Az error ágat letesztelhetjük úgy, hogy a map() body-ját megnyitjuk, és manuálisan idézünk elő error-t
          <pre>
  let buttonClickedObservable$ = fromEvent(this.clickButton.nativeElement, 'click')
    .pipe(
      map((event: any) => event.clientX),
      take(5)
    );

  buttonClickedObservable$.subscribe(&#123;
              next: (data) => &#123;
      console.log(data);
    &#125;,
    error: (err) => &#123;
      console.log('HIBA');
    &#125;,
    complete: () => &#123;
      console.log('fromEvent completed!');
    &#125;,
  &#125;);
        </pre>
        </li>
      </ul>
    </li>
    <li>interval
      <ul>
        <li>Bizonyos megadott milliszekundumnyi időnként az Observable adatcsomagot fog kibocsátani magából</li>
        <li>Gyakori, hogy a fejlesztők csak a next ágat dobják be, így az alábbi megadási móddal lehet a leggyakrabban
          találkozni
          <ul>
            <pre>
  const counter = interval(1000).pipe(
    filter(bemenet => bemenet % 2 === 0),
    map(filteredData => filteredData + ' másodperc telt el'),
    take(5)
  );

  counter.subscribe((data) => &#123;
              console.log(data);
  &#125;);
            </pre>
            <li>A filter() a bedobott függvény olvasatában enged csak tovább elemeket, azaz szűrőként működik</li>
            <li>Jelen esetben csak a páros számokat engedjük tovább</li>
            <li>A következő operátor, a map() már a leszűrt adatfolyamot kapja</li>
            <li>A take(5) miatt pedig 5 darab adatcsomagnál meg is állunk</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>tap
      <ul>
        <li>Adott egy form</li>
        <br>

        <form #colorForm id="colorForm">
          <input type="text" name="color" class="form-control" placeholder="Enter a color!">
          <button type="submit" class="btn btn-secondary">Send</button>
        </form>

        <pre>
  &#60;form #colorForm id="colorForm"&#62;
    &#60;input type="text" name="color"&#62;
    &#60;button type="submit"&#62;Send&#60;/button&#62;
  &#60;/form&#62;

  @ViewChild('colorForm') colorForm!: ElementRef&#60;HTMLFormElement&#62;;

  const formSent$ = fromEvent(
    this.colorForm.nativeElement,
    "submit"
  ).pipe(
    tap(event => &#123;
      event.preventDefault();
    &#125;)
    map((event: any) => event.target.elements.color.value)
  );

  formSent$.subscribe(data => &#123;
          console.log('%c ' + color, 'color: ' + color);    // színt megadva a console.log szövege színes lesz
  &#125;)
        </pre>
        <li>A tap() operátorral nem az adatfolyamra vagyunk hatással, az adatfolyammal nem csinál semmit, viszont
          mellékhatásokat tudunk végrehajtani
        </li>
        <li>Érkezik az event a tap() operátorhoz, és meghívhatjuk az event.preventDefault() metódust, felülírva az
          alapértelmezett HTML működést
        </li>
        <li>A következő operátor változatlanul megkapja az adatot, ahol is egy map() csak az input mezőbe bevitt értéket
          adja át a rá feliratkozottaknak
        </li>
      </ul>
    </li>
    <li>mergeMap
      <ul>
        <li>Két Observable egyesítésére szolgál</li>
        <li>A fenti példából a szín kiszelektálást, és az interval-t fogjuk összerakni</li>
        <li>Minden egyes színnek külön számlálót fogunk indítani</li>
        <li>Meghatározhatunk egy külső Observable-t (Outer Observable), és egy belső Observable-t (Inner Observable), és
          mergeMap-pel össze lehet őket olvasztani
        </li>
        <li>Amint a külső Observable kibocsát egy eseményt, elindulhat egy belső Observable</li>
        <li>Akármelyik bocsát ki adatot, a mergeMap elkapja, és tovább passzolja a csőrendszerben a következő
          operátornak
        </li>
        <li>Ez a művelet a funkcionális programozásban flatMap() (leképezés és kilapítás)</li>
        <li>A mergeMap megkapja az adatot, esetünkben a formba begépelt színt
          <ul>
            <li>Emiatt: 'map((event: any) => event.target.elements.color.value),'</li>
          </ul>
        </li>
        <li>A mergeMap()-ből a belső Observable-lel kell visszatérnünk</li>
        <li>A mergeMap minden egyes belső Observable-re feliratkozik, és bármelyik bocsát ki eseményt, a mergeMap()
          továbbküldi
        </li>
        <br>
        <form #colorFormForMergeMap id="colorFormForMergeMap">
          <input type="text" name="color" class="form-control" placeholder="Enter a color!">
          <button type="submit" class="btn btn-secondary">Send</button>
        </form>
        <br>
        <li>Minden egyes submit esetén elindul egy újabb számláló, ami 1 másodpercenként ont ki magából értéket, de a
          counter-ben lévő filter miatt mi ebből csak 2 másodpercenként fogunk látni valamit
        </li>
        <pre>
  const formSent$ = fromEvent(this.colorFormForMergeMap.nativeElement, "submit").pipe(
    tap(event => &#123;
          event.preventDefault();
    &#125;),
    map((event: any) => event.target.elements.color.value),
    mergeMap(color => counter$
      .pipe(
        map(text => &#123;
          return [color, text];
        &#125;)
      )),
    take(20)
  );

  const counter$ = interval(1000).pipe(
    filter(inputData => inputData % 2 === 0),
    map(data => data + " másodperc telt el"),
  );

  formSent$.subscribe(([color, text]) => &#123;
    console.log('%c ' + color, 'color: ' + text);
  &#125;);
        </pre>
        <li>A gyakorlatban ezt arra szokás használni, hogy a külső Observable-ből megkaparintott adatot a belső
          Observable kapcsán fel lehessen használni
        </li>
        <li>A mergeMap() egy Observable-t vár, amit kedvünk szerint alakíthatunk pipe használatával
          <ul>
            <li>Jelen esetben a map() operátor segítségével egy tömböt küldünk tovább a csőben, aminek az első eleme a
              külső Observable-ből származik (color), és nem más, mint az 'event.target.elements.color.value'-ban lévő
              szín, a második eleme pedig a counter$ Observable-ből származó data + " másodperc telt el", ami egy
              megszűrt szám, concat-olva statikus szöveggel
            </li>
          </ul>
        </li>
        <li>A subscription függvény paraméterénél array destructuring történik</li>
        <li>Angularban a HTTPClient használatakor, AJAX kérések küldésekor erre a működésre (mergeMap()) lesz szükség
        </li>
      </ul>
    </li>
    <li>switchMap
      <ul>
        <li>Ugyanúgy működik, mint a mergeMap()</li>
        <li>Az egyetlen különbség, hogy csak egyetlen egy belső Observable-t hagy érvényesülni, mindig a legkésőbbit, és
          a többiről automatikusan leiratkozik
        </li>
        <li>A subscription next ágába mindig csak a legutóbbi belső Observable által kibocsátott adat jut el, a
          korábbiakról automatikusan leiratkozik
        </li>
        <li>Angularban a HTTPClient használatakor, AJAX kérések kiküldésekor nagy szükség van rá
          <ul>
            <li>Ott is mindig létezik egy külső, és egy belső Observable</li>
            <li>A külső tipikusan valamilyen user esemény (click, vagy submit)</li>
            <li>A belső Observable pedig maga az AJAX kérés</li>
          </ul>
        </li>
        <pre>
  &#60;button (click)="switchMapTesting()"&#62;AJAX request&#60;/button&#62;

  switchMapTesting() &#123;
    const ajaxRequest = ajax('https://kodbazis.hu/api/cimek').pipe(
      map(event => event.response)
    );
    ajaxRequest.subscribe((resp) => &#123;
      console.log(resp);
    &#125;);
  &#125;
        </pre>
        <ul>
          <li>Observable-lel tér vissza</li>
          <li>Amíg nem iratkozunk fel rá, addig a kérés nem megy ki, csak reprezentálja a jövőben megkaparintható HTTP
            választ
          </li>
        </ul>
        <br>
        <button #switchMapButton class="btn btn-secondary">AJAX request</button>
        <pre>
  {{ switchMapArray | json }}
        </pre>
        <li>A switchMap úgy jöhet képbe, ha mondjuk nem akarjuk, hogy az AJAX kérés bekövetkezzen, csak ha mondjuk
          történik egy gombnyomás
          <ul>
            <li>Ilyenkor nem az ajaxRequest$ Observable-re akarunk feliratkozni</li>
            <li>switchMap() segítségével hozzuk létre gombnyomásra a belső feliratkozót, amiből, ha jön az adat, az
              megérkezik az 'ajaxRequest.subscribe' next ágába
            </li>
            <pre>
  this.switchMapTesting();

  switchMapTesting() &#123;
  const ajaxRequest = ajax('https://kodbazis.hu/api/cimek').pipe(
    map(event => event.response),
  );

  const switchMapButtonClicked$ = fromEvent(this.switchMapButton.nativeElement, 'click')
    .pipe(
      switchMap(() => ajaxRequest)
    );

  switchMapButtonClicked$.subscribe((resp) => &#123;
      console.log(resp);
    &#125;);
  &#125;
            </pre>
            <li>A switchMap külső Observable-ből (például fromEvent) érkező értékre reagál, és visszatér egy belső
              Observable-lel (például ajaxRequest)</li>
            <li>A switchMap() meg tud szakítani folyamatban lévő adatkérést (ha közben jön egy újabb érték a külsőből),
              ha új click event érkezik, mivel megcsinálja a leiratkozást automatikusan
              <ul>
                <li>mergeMap()-et használva a fenti példában, az összes AJAX kérés végbemenne</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #examples data-anchor="examples">Examples</h3>
  <pre>
  constructor(private aRouter: ActivatedRoute) &#123;
    aRouter.params.subscribe(params => &#123;
      const albumID = params['id'];
      this.album$ = ajax(`https://jsonplaceholder.typicode.com/photos?albumId=$&#123;albumID}`).pipe(
        map(response => &#123;
            console.log('RESPONSE: ', response);
            return response;
        }),
        catchError(error => &#123;
            console.log('error: ', error);
            return of(error);
        })
      )
    });

    this.album$.subscribe(&#123; // az Observable akkor kezdi el az adatfolyamot (például a HTTP-kérést), amikor valaki feliratkozik rá
      next: photos => &#123;
            console.log('PHOTOS: ', photos);
      },
      error: error => &#123;
            },
      complete: () => &#123;
            this.isDownloaded = true;
      }
    });
  }
  </pre>
</div>

<div>
  <h3 #components data-anchor="components">Components</h3>
  <ul>
    <li>Observable
      <ul>
        <li>Az RxJS egyik legfontosabb összetevője, amely lehetővé teszi az aszinkron adatfolyamok kezelését</li>
        <li>Olyan objektum, amely képes adatokat kibocsátani (emitálni) egy adott időpontban, és azokat figyelni,
          reagálni rájuk</li>
        <li>Az Observable elindítja az adatáramlást és figyeli a változásokat</li>
        <li>A változásokra egy Observer, vagy akár több Observer reagálhat</li>
        <li>Késleltetett (aszinkron) eseményekkel dolgozik, így például HTTP kérések, vagy események kezelésére
          használható</li>
        <pre>
  const observable = new Observable((observer) => &#123;
    setTimeout(() => &#123;
      observer.next('Hello RxJS');
      observer.complete();
    }, 1000);
  });            
          </pre>
      </ul>
    </li>
    <li>Observer
      <ul>
        <li>Egy objektum, amely figyeli az Observable által kibocsátott értékeket</li>
        <li>Meghatározza, hogy mi történjen, amikor az Observable adatot bocsát ki, hibát dob, vagy befejeződik</li>
        <li>3 fő metódust tartalmaz
          <ol>
            <li>next(): tartalmazza az adatokat, amelyeket az Observable kibocsátott</li>
            <li>error(): a hibákat kezeli</li>
            <li>complete(): az Observable befejeztét jelzi, már nem fog új adatokat kibocsátani</li>
          </ol>
        </li>
        <pre>
  const observer = &#123;
    next: (value) => console.log(value),
    error: (err) => console.error('Error:', err),
    complete: () => console.log('Completed')
  };
  
  observable.subscribe(observer);
        </pre>
      </ul>
    </li>
    <li>Subscription
      <ul>
        <li>Referencia, amely az Observable és az Observer közötti kapcsolatot jelöli</li>
        <li>Lehetővé teszi, hogy az Observer feliratkozzon, vagy leiratkozzon az Observable-ről
          <ul>
            <li>Az unsubscribe() metódus segítségével leiratkozhatunk az Observable-ről</li>
          </ul>
        </li>
        <pre>
  const subscription = observable.subscribe(observer);

  subscription.unsubscribe();   // ha már nem akarjuk figyelni, akkor leiratkozunk
        </pre>
      </ul>
    </li>
    <li>Subject
      <ul>
        <li>Különleges típusú Observable, amely képes egyszerre adattárolásra, és Subscription kezelésére</li>
        <li>Egyszerre Observer, és Observable is lehet, így képes adatokat fogadni (mint Observer), és ugyanazokat az
          adatokat más Observer-eknek átadni (mint Observable)</li>
        <li>Nagyon hasznos például az event stream-ek kezelésére, vagy ha egy Observable értékeit más Observable-öknek
          kell továbbítani</li>
        <pre>
  const subject = new Subject();

  subject.subscribe(value => console.log(`Observer 1: $&#123;value}`));
  subject.subscribe(value => console.log(`Observer 2: $&#123;value}`));

  subject.next('Hello from Subject');  // mindkét observer megkapja
        </pre>
        <li>Típusai</li>
        <br>
        <table style="border-collapse: collapse; width: 100%;">
          <tr>
            <th></th>
            <th>Mit csinál?</th>
            <th>Mikor használjuk?</th>
          </tr>
          <tr>
            <td>Subject</td>
            <td>Alapértelmezett Subject, minden új Subscriber csak az újonnan érkező értékeket kapja meg</td>
            <td>Ha több Observer-nek kell egyszerre adatot küldeni</td>
          </tr>
          <tr>
            <td>BehaviorSubject</td>
            <td>Az utolsó kibocsátott értéket is eltárolja, így az újonnan feliratkozók is megkapják ezt</td>
            <td>Ha mindig szükség van az utolsó ismert értékre (például állapotkezelés)</td>
          </tr>
          <tr>
            <td>ReplaySubject</td>
            <td>Az összes korábbi értéket eltárolja és minden új Subscriber-nek elküldi ezeket</td>
            <td>Ha minden új Observer-nek vissza kell adni az előzményeket is</td>
          </tr>
          <tr>
            <td>AsyncSubject</td>
            <td>Csak az utolsó értéket küldi ki, de csak akkor, ha az Observable befejeződött</td>
            <td>Ha csak a végső eredmény érdekes (például egy HTTP kérés után)</td>
          </tr>
        </table>
      </ul>
    </li>
    <br>
    <li>Operators
      <ul>
        <li>Az RxJS operátorok az Observable-ek feldolgozására szolgálnak</li>
        <li>Lehetővé teszik az adatok átalakítását, kombinálását, szűrését és létrehozását, hogy könnyebben kezelhessük
          az aszinkron eseményeket, például HTTP kéréseket, felhasználói interakciókat vagy időzített eseményeket</li>
        <li>A kód tisztább, hatékonyabb és reaktívabb lesz
          <ul>
            <li>Nincs összekuszálva callback-ekkel, és Promise láncokkal</li>
          </ul>
        </li>
        <br>
        <table style="border-collapse: collapse; width: 100%;">
          <tr>
            <th>Kategória</th>
            <th>Mit csinál?</th>
            <th>Példa operátorok</th>
          </tr>
          <tr>
            <td>Creation (Létrehozás)</td>
            <td>Új Observable-t hoz létre</td>
            <td>of(), from(), interval(), timer()</td>
          </tr>
          <tr>
            <td>Transformation (Átalakítás)</td>
            <td>Az adatok módosítása</td>
            <td>map(), switchMap(), mergeMap(), concatMap(), exhaustMap()</td>
          </tr>
          <tr>
            <td>Filtering (Szűrés)</td>
            <td>Csak a kívánt adatokat engedi át</td>
            <td>filter(), debounceTime(), distinctUntilChanged()</td>
          </tr>
          <tr>
            <td>Combination (Kombináció)</td>
            <td>Több Observable egyesítése vagy összehangolása</td>
            <td>merge(), combineLatest(), forkJoin(), withLatestFrom()</td>
          </tr>
        </table>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #operators data-anchor="operators">Operators</h3>
  <ul>
    <li>Creation operátorok
      <ul>
        <li>"Teremtő" operátorok</li>
        <li>Új Observable-t hoznak létre</li>
      </ul>
      <br>
      <ol>
        <li>of()
          <ul>
            <li>Statikus értékekből hoz létre egy Observable-t</li>
            <li>Használatos, amikor egy vagy több értéket akarunk egyszerűen kiadni</li>
            <pre>
  import &#123; of } from 'rxjs';

  const obs$ = of(1, 2, 3, 4, 5);
  obs$.subscribe(value => console.log(value));

  ↓↓↓↓↓

  1
  2
  3
  4
  5
            </pre>
          </ul>
        </li>
        <li>from()
          <ul>
            <li>Tömbből, Promise-ból vagy iterálható objektumból hoz létre Observable-t</li>
            <li>Akkor használjuk, ha egy tömb, vagy Promise adatait akarjuk Observable-ként kezelni</li>
            <pre>
  import &#123; from } from 'rxjs';

  const obs$ = from([10, 20, 30]);
  obs$.subscribe(value => console.log(value));

  ↓↓↓↓↓

  10
  20
  30
            </pre>
          </ul>
        </li>
        <li>interval()
          <ul>
            <li>Időzített intervallumonként kibocsát egy értéket</li>
            <li>Akkor jó, ha például egy számlálót szeretnénk időzíteni</li>
            <pre>
  import &#123; interval } from 'rxjs';

  const obs$ = interval(1000); // 1 másodpercenként ad ki egy számot
  obs$.subscribe(value => console.log(value));

  ↓↓↓↓↓

  0
  1
  2
  ...
            </pre>
          </ul>
        </li>
      </ol>
    </li>
    <br>
    <li>Transformation operátorok
      <ul>
        <li>Átalakító operátorok</li>
        <li>Segítségükkel az Observable által kibocsátott értékeket módosíthatjuk</li>
      </ul>
      <br>
      <ol>
        <li>map()
          <ul>
            <li>Egyenként módosítja az értékeket</li>
            <li>Előnyös, ha minden értéket át akarunk alakítani valami mássá</li>
            <pre>
  import &#123; of } from 'rxjs';
  import &#123; map } from 'rxjs/operators';

  const obs$ = of(1, 2, 3).pipe(
    map(value => value * 10)
  );

  obs$.subscribe(value => console.log(value));

  ↓↓↓↓↓

  10
  20
  30
            </pre>
          </ul>
        </li>
        <li>switchMap()
          <ul>
            <li>Egy új Observable-re vált, és az előzőt leállítja</li>
            <li>Akkor jó, ha például HTTP kéréseket végzünk, és mindig csak a legfrissebb eredményt akarjuk megtartani
            </li>
            <pre>
  import &#123; fromEvent, interval } from 'rxjs';
  import &#123; switchMap } from 'rxjs/operators';

  const click$ = fromEvent(document, 'click');
  const interval$ = interval(1000);

  click$.pipe(
    switchMap(() => interval$)
  ).subscribe(console.log);
            </pre>
            <li>Minden kattintás elindít egy számlálót, de az előzőt megszakítja</li>
          </ul>
        </li>
        <li>mergeMap()
          <ul>
            <li>Az összes új Observable-t megtartja, nem szakítja meg az előzőket</li>
            <li>Használjuk, ha minden új eseményt párhuzamosan akarunk kezelni</li>
            <pre>
  import &#123; of } from 'rxjs';
  import &#123; mergeMap } from 'rxjs/operators';

  const obs$ = of('A', 'B', 'C').pipe(
    mergeMap(letter => of(letter + '1', letter + '2'))
  );

  obs$.subscribe(console.log);

  ↓↓↓↓↓

  A1
  A2
  B1
  B2
  C1
  C2
            </pre>
          </ul>
        </li>
        <li>concatMap()
          <ul>
            <li>Sorban dolgozza fel az Observable-eket, egyet befejez, mielőtt a következőt elkezdi</li>
            <li>Jó, ha például HTTP kéréseket sorban akarunk végrehajtani</li>
            <pre>
  import &#123; of } from 'rxjs';
  import &#123; concatMap, delay } from 'rxjs/operators';

  const obs$ = of('X', 'Y', 'Z').pipe(
    concatMap(value => of(value).pipe(delay(1000)))
  );

  obs$.subscribe(console.log);

  ↓↓↓↓↓

  X   // utána 1 mp delay
  Y   // utána 1 mp delay
  Z 
            </pre>
          </ul>
        </li>
        <li>exhaustMap()
          <ul>
            <li>Amíg egy belső Observable fut, figyelmen kívül hagyja az új bejövő eseményeket</li>
            <li>Akkor jó, ha például egy gombra kattintásnál el akarjuk kerülni, hogy a felhasználó többször is
              elindítson egy HTTP kérést, amíg az előző nem futott le</li>
            <pre>
  import &#123; fromEvent, interval } from 'rxjs';
  import &#123; exhaustMap, take } from 'rxjs/operators';

  const button = document.getElementById('myButton') as HTMLButtonElement;
  const click$ = fromEvent(button, 'click');

  click$.pipe(
    exhaustMap(() => interval(1000).pipe(take(5))) // 5 másodpercig figyelmen kívül hagyja az új kattintásokat
  ).subscribe(console.log);
              </pre>
            <li>Ha véget ér az első folyamat, akkor a következő kattintás indít új számlálót</li>
          </ul>
        </li>
      </ol>
      <br>
      <table style="border-collapse: collapse; width: 100%;">
        <tr>
          <th></th>
          <th>Előző Observable</th>
          <th>Új Observable</th>
          <th>Mikor használjuk?</th>
        </tr>
        <tr>
          <td>switchMap()</td>
          <td>Megszakítja az előzőt</td>
          <td>Elindítja az újat</td>
          <td>Keresőmező, HTTP kérések, ha csak a legutóbbi fontos</td>
        </tr>
        <tr>
          <td>mergeMap()</td>
          <td>Párhuzamosan futtatja</td>
          <td>Új Observable-t mindig elindít</td>
          <td>Több async kérés egyszerre (például több API hívás)</td>
        </tr>
        <tr>
          <td>concatMap()</td>
          <td>Sorban dolgozza fel</td>
          <td>Csak az előző befejezése után indít újat</td>
          <td>Ha a kéréseknek sorrendben kell futniuk</td>
        </tr>
        <tr>
          <td>exhaustMap()</td>
          <td>Figyelmen kívül hagyja az új kéréseket</td>
          <td>Csak az elsőt futtatja, amíg be nem fejeződik</td>
          <td>Gombkattintásos HTTP hívás megelőzése (például dupla kattintás tiltása)</td>
        </tr>
      </table>
    </li>
    <br>
    <li>Filtering operátorok
      <ul>
        <li>Szűrő operátorok</li>
        <li>Csak bizonyos értékeket engednek át</li>
      </ul>
      <br>
      <ol>
        <li>filter()
          <ul>
            <li>Csak azokat az értékeket engedi tovább, amelyek megfelelnek egy feltételnek</li>
            <li>Használatos, ha adott értékeket ki akarunk szűrni egy adathalmazból</li>
            <pre>
  import &#123; of } from 'rxjs';
  import &#123; filter } from 'rxjs/operators';

  const obs$ = of(1, 2, 3, 4, 5).pipe(
    filter(value => value % 2 === 0)
  );

  obs$.subscribe(console.log);

  ↓↓↓↓↓

  2
  4
            </pre>
          </ul>
        </li>
        <li>debounceTime()
          <ul>
            <li>Egy esemény után vár egy adott időintervallumot, mielőtt továbbítaná az értéket</li>
            <li>Például API kéréseknél, keresési mezők optimalizálásánál előnyös</li>
            <pre>
  import &#123; fromEvent } from 'rxjs';
  import &#123; debounceTime } from 'rxjs/operators';

  const input = document.getElementById('searchBox') as HTMLInputElement;

  fromEvent(input, 'input').pipe(
    debounceTime(300) // csak akkor küldi az eseményt, ha 300 ms-ig nem történik karakterleütés a mezőbe
  ).subscribe(event => console.log(input.value));
            </pre>
          </ul>
        </li>
        <li>distinctUntilChanged()
          <ul>
            <li>Csak akkor engedi át az új értéket, ha az különbözik az előzőtől</li>
            <li>Például form validációs esemény optimalizálásánál használatos</li>
            <pre>
  import &#123; of } from 'rxjs';
  import &#123; distinctUntilChanged } from 'rxjs/operators';

  const obs$ = of(1, 1, 2, 2, 3, 3, 3, 4).pipe(
    distinctUntilChanged()
  );

  obs$.subscribe(console.log);

  ↓↓↓↓↓

  1
  2
  3
  4
            </pre>
          </ul>
        </li>
      </ol>
    </li>
    <br>
    <li>Combination operátorok
      <ul>
        <li>Kombinációs operátorok</li>
        <li>Lehetővé teszik több Observable egyesítését, vagy egyes Observable-ok értékeinek egyidejű kezelését</li>
      </ul>
      <br>
      <ol>
        <li>merge()
          <ul>
            <li>Több Observable-t egyesíthetünk, és azokat párhuzamosan figyelhetjük</li>
            <li>Minden kibocsátott értéket egyesít, tehát nem várja meg, hogy az előző Observable befejeződjön</li>
            <li>Használjuk, ha több aszinkron folyamatot párhuzamosan szeretnénk kezelni, és az összes eseményt
              egyszerre akarjuk figyelni</li>
            <pre>
  import &#123; of, merge } from 'rxjs';

  const obs1 = of('A', 'B', 'C');
  const obs2 = of(1, 2, 3);

  merge(obs1, obs2).subscribe(val => console.log(val));

  ↓↓↓↓↓

  A
  B
  C
  1
  2
  3
            </pre>
          </ul>
        </li>
        <li>combineLatest()
          <ul>
            <li>Csak akkor küldi el az adatokat, ha mindegyik Observable legalább egyszer kibocsátott egy értéket</li>
            <li>Hasznos, ha több Observable-t szeretnénk kombinálni, és mindig a legutolsó értéket szeretnénk megkapni
              mindegyikből</li>
            <pre>
  import &#123; combineLatest, of } from 'rxjs';

  const obs1 = of(1, 2, 3);
  const obs2 = of('A', 'B', 'C');

  combineLatest([obs1, obs2]).subscribe(([val1, val2]) => &#123;
    console.log(`obs1: $&#123;val1}, obs2: $&#123;val2}`);
  });

  ↓↓↓↓↓

  obs1: 3
  obs2: C
              </pre>
          </ul>
        </li>
        <li>forkJoin()
          <ul>
            <li>Akkor használatos, ha több Observable-t szeretnénk párhuzamosan futtatni, és csak akkor szeretnénk az
              eredményeket megkapni, amikor mindegyik Observable befejeződött</li>
            <pre>
  import &#123; forkJoin, of } from 'rxjs';

  const obs1 = of('A', 'B', 'C');
  const obs2 = of(1, 2, 3);

  forkJoin([obs1, obs2]).subscribe(([val1, val2]) => &#123;
    console.log(`obs1: $&#123;val1}, obs2: $&#123;val2}`);
  });

  ↓↓↓↓↓

  obs1: C
  obs2: 3
              </pre>
            <li>Különbség a combineLatest-hez képest, hogy a forkJoin csak akkor adja vissza az értékeket, ha minden
              Observable befejeződött</li>
          </ul>
        </li>
      </ol>
    </li>
    <table style="border-collapse: collapse; width: 100%;">
      <tr>
        <th></th>
        <th>Mit csinál?</th>
        <th>Példa</th>
      </tr>
      <tr>
        <td>of()</td>
        <td>Értékekből Observable-t hoz létre</td>
        <td>Egyszerű adatok</td>
      </tr>
      <tr>
        <td>from()</td>
        <td>Tömbből vagy Promise-ból Observable-t hoz létre</td>
        <td>Lista, Promise</td>
      </tr>
      <tr>
        <td>interval()</td>
        <td>Időzített eseményeket generál</td>
        <td>Timer, animációk</td>
      </tr>
      <tr>
        <td>map()</td>
        <td>Minden kibocsátott értéket átalakít</td>
        <td>Formázás, számítás</td>
      </tr>
      <tr>
        <td>switchMap()</td>
        <td>Megszakítja az előzőt, és újat indít</td>
        <td>HTTP keresés, autocomplete</td>
      </tr>
      <tr>
        <td>mergeMap()</td>
        <td>Párhuzamosan több kérést futtat</td>
        <td>Több aszinkron művelet egyszerre</td>
      </tr>
      <tr>
        <td>concatMap()</td>
        <td>Sorban dolgozza fel a kéréseket</td>
        <td>HTTP kérések sorrendben</td>
      </tr>
      <tr>
        <td>exhaustMap()</td>
        <td>Ha egy kérés aktív, az újakat figyelmen kívül hagyja</td>
        <td>Dupla kattintás tiltása</td>
      </tr>
      <tr>
        <td>filter()</td>
        <td>Csak a feltételnek megfelelő elemeket engedi át</td>
        <td>Adatszűrés</td>
      </tr>
      <tr>
        <td>debounceTime()</td>
        <td>Csak a késleltetett eseményeket továbbítja</td>
        <td>Keresőmező optimalizálás</td>
      </tr>
      <tr>
        <td>distinctUntilChanged()</td>
        <td>Csak az eltérő értékeket engedi tovább</td>
        <td>Form validáció optimalizálás</td>
      </tr>
      <tr>
        <td>merge()</td>
        <td>Több Observable-t párhuzamosan figyel</td>
        <td>Több esemény egyszerre történő kezelése</td>
      </tr>
      <tr>
        <td>combineLatest()</td>
        <td>Az utolsó értéket minden Observable-ból kibocsátja</td>
        <td>Formok, amelyeket a felhasználó egyszerre módosít</td>
      </tr>
      <tr>
        <td>forkJoin()</td>
        <td>Csak akkor küldi el az adatokat, amikor az összes Observable befejeződött</td>
        <td>Több aszinkron művelet, mindegyik eredménye egyetlen objektumban</td>
      </tr>
    </table>
  </ul>
</div>