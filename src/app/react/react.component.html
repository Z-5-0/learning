<h1>React</h1>

<div class="anchor-navi-container">
  <div *ngFor="let mainButton of anchorButtons" class="btn-group">
    <button type="button" class="btn btn-primary btn-sm anchor" (click)="scrollToAnchor(mainButton?.anchor)">
      {{ mainButton.title }}
    </button>
    <button *ngIf="mainButton?.subtitles?.length" type="button"
      class="btn btn-primary dropdown-toggle dropdown-toggle-split btn-sm anchor" data-bs-toggle="dropdown"
      aria-expanded="false">
    </button>
    <ul *ngIf="mainButton.subtitles?.length" class="dropdown-menu dropdown-menu-dark">
      <li>
        <button *ngFor="let subButton of mainButton?.subtitles" class="dropdown-item"
          (click)="scrollToAnchor(subButton?.anchor)">
          {{ subButton?.title }}
        </button>
      </li>
    </ul>
  </div>
</div>

<div>
  <h3 #howitworks data-anchor="howitworks">How it works?</h3>
  <ul>
    <li>Böngészőben működő Javascript alkalmazások működése
      <ul>
        <li>UI / User Interface
          <ul>
            <li>Az a felület, amivel a felhasználó találkozik, interakcióba lép</li>
            <li>Amikor a felhasználó valamilyen elemmel interakcióba lép, az alkalmazás állapotát fogja
              manipulálni
            </li>
          </ul>
        </li>
        <li>State
          <ul>
            <li>State / Alkalmazás állapot
              <ul>
                <li>Adatstruktúra, amit az alkalmazás futása során folyamatosan a memóriában tartunk</li>
                <li>A legminimálisabb módon leírja a UI-on megjelenő elemeket
                  <ul>
                    <li>Tehát minden információt tartalmaz, ami ahhoz szükséges, hogy az interface
                      kirajzolódhasson
                    </li>
                  </ul>
                </li>
                <li>A UI-on dinamikusan változó dolgok azok a State-nek a leképeződései</li>
                <li>Bármilyen adatstruktúra lehet</li>
                <li>Nem statikus adatstruktúra, hanem futási időben a memóriában folyamatosan felülíródik, ahogy
                  különféle események végbemennek a UI-on
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Eseménykezelők
          <ul>
            <li>Az az egység, amit megírtunk annak érdekében, hogy leírjuk, hogy a felhasználói interakció hatására
              miképp menjen végbe az értékváltozás az alkalmazás állapotában
            </li>
          </ul>
        </li>
        <li>Controller
          <ul>
            <li>A State és az eseménykezelők egysége</li>
            <li>Definiált állapot, amit eseménykezelő függvények bizonyos események hatására megváltoztatnak</li>
          </ul>
        </li>
        <li>Template / Sablon
          <ul>
            <li>Az adatstruktúrából konkrét elemeket készít</li>
            <li>HTML elemekből áll, amik a UI statikus részét képzik</li>
            <li>A statikus elemeket időközönként megszakítják a State-ből kiolvasott dinamikus értékek
              <ul>
                <li>String interpolációnak nevezik (amikor beleírjuk a State-ből a sablon dinamikus részébe)
                </li>
              </ul>
            </li>
            <li>A sablonban lehetnek egyszerű kontroll struktúrák
              <ul>
                <li>if-else</li>
                <li>for</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Render / Renderelés
          <ul>
            <li>A folyamat, amely során alapul vesszük a State-et, dinamikus adatokat, - és akár -
              kontroll struktúrákat használunk fel, és összeollózunk egy sablont
            </li>
          </ul>
        </li>
        <li>Component / Komponens
          <ul>
            <li>A Controller és a sablon logika összefoglaló neve</li>
            <li>React esetében a komponenst egyetlen egy fájlban kell definiálni</li>
            <li>Angular esetében két külön fájlban definiált</li>
          </ul>
        </li>
        <br>
        <li>A folyamat:
          <ul>
            <li>Ha végfelhasználóként letöltöd az oldalt, és elindul a Javascriptes alkalmazás, az első, hogy az
              alkalmazásnak van egy kiinduló állapota, ehhez jön hozzá a meghatározott statikus sablon, és ezek
              alapján megtörténik az első renderelés, megjelenik a User Interface-en a tartalom
            </li>
            <li>Ezután a felhasználó valamilyen action-t hajt végre, ami állapotmódosítást eredményez az általunk
              megírt eseménykezelők szerint
            </li>
            <li>Az állapotmódosítást renderelés követi a frissített adatokkal, aminek következtében a UI-on frissül
              a tartalom
            </li>
          </ul>
        </li>
        <br>
        <img src="assets/imgs/process.png" style="width: 100%;">
        <br>
        <br>
        <li>A folyamat bővebben
          <ol>
            <li>index.html betöltése
              <ul>
                <li>A bőngésző betölti az index.html</li>
                <li>Az oldalon szerepelnek stílusfájlok, és JS fájlok</li>
              </ul>
            </li>
            <li>JavaScript fájlok letöltése és futtatása
              <ul>
                <li>A hivatlkozott JS fájlokat letölti a böngésző, és futtatja</li>
              </ul>
            </li>
            <li>Angular indítása (Bootstrap)
              <ul>
                <li>Az Angular alkalmazás belépési pontja az main.ts fájl (az angular.json fájlban van meghatározva -->
                  'main'), amely bootstrappel elindítja az Angular alkalmazást
                </li>
                <li>Ez a fájl inicializálja az Angular keretrendszert, és meghívja az alapértelmezett root modul-t
                  (AppModule)
                </li>
              </ul>
            </li>
            <li>Root modul betöltése (AppModule)
              <ul>
                <li>Az Angular betölti a root modul-t, ami az alkalmazás legfelsőbb modulja</li>
                <li>Az app.module.ts-ben van meghatározva az AppComponent betöltése
                  <pre>
  ...
  bootstrap: [AppComponent]
  ...
                  </pre>
                </li>
              </ul>
            </li>
            <li>Komponensek inicializálása
              <ul>
                <li>Miután az AppModule betöltődött, az Angular elindítja az AppComponent-et, amely az alkalmazás
                  elsődleges
                  komponense
                </li>
                <li>Az Angular létrehozza a komponens template-jét</li>
              </ul>
            </li>
            <li>DOM renderelés
              <ul>
                <li>Az Angular change detection rendszere gondoskodik a megfelelő HTML elemek megjelenítéséről</li>
                <li>A DOM struktúra frissül az adatok alapján, és az Angular kirendereli az alkalmazást a böngészőben
                </li>
              </ul>
            </li>
            <li>Routing, interakció, adatkezelés
              <ul>
                <li>Route váltáskor, felhasználói interakciókat követően, vagy szerverről való adatbetöltés után az
                  Angular
                  (tehát változásokkor a Change Detection) újrarendereli a DOM-ot
                </li>
              </ul>
            </li>
          </ol>
        </li>
      </ul>
    </li>
    <li>Hogyan könnyíthetik meg a különféle kliens oldali könyvtárak és keretrendszerek (framework) a User Interface-ek
      készítését?
      <ul>
        <li>React / Angular / Vue</li>
        <li>React és Angular esetén a renderelés teljesen automatikus (amint valamilyen State változás
          történik), amíg vanilla Javascript esetén a renderelő mechanizmust a fejlesztőnek kell manuálisan
          működésbe léptetni a State változás után
        </li>
        <li>A felhasználói felület külön részegységekre bontható a segítségükkel
          <ul>
            <li>Egy interaktív részleg helyett létre lehet hozni többet</li>
            <li>Mindegyikért a saját, dedikált kontrollere és template-je, azaz komponense lesz felelőt</li>
            <li>Az összes komponensnek meg van a saját állapota, template-je, és action-jei
              <ul>
                <li>Ilyen módon két komponens egymástól teljesen függetlenül tud működni</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A React és Angular alkalmazásoknak egyetlen belépési pontja van
          <ul>
            <li>Létezik az egész alkalmazást összefogó, és az egész User Interface-ért felelős
              app.component
            </li>
            <li>Teljesen ugyanúgy működik, mint az összes többi</li>
            <li>A különbség, hogy szülő elem a többi komponenshez képest</li>
            <li>A sablon logikájában van hivatkozás a gyerek komponensekre</li>
            <li>Tehát egy-egy komponens a többitől elkülönülve le tudja írni saját maga működését, és ezt a
              szülő
              elem akárhányszor felhasználhatja
            </li>
            <li>A különböző komponensek közötti adatáramlás is könnyen manadzselhető</li>
            <li>Természetesen a gyerekeknek is lehetnek gyerekeik, így egy fa struktúra épül fel</li>
            <li>Egy komponens a szülő elemétől mindig kaphat kívülről adatot, és azt tovább tudja passzolni
              a saját gyerekének, gyerekeinek
            </li>
            <li>A gyermek elemek is tudnak a szülőnek adatot küldeni</li>
            <li>A komponensek más irányba is tud(hat)nak kommunikálni, például AJAX kérést küldhetnek,
              adatot tölthet fel, vagy szerezhet
            </li>
            <li>A komponensek a localstorage-dzsal is kapcsolatot teremthetnek (írás, olvasás)</li>
            <li>Az alkalmazások engedik, hogy létrehozzunk kliens oldali útvonal választót
              <ul>
                <li>Ez csak az SPA (Single Page App) kapcsán releváns
                  <ul>
                    <li>Olyan rendszer, amiben a felhasználó, ha rákattint egy linkre, akkor nem
                      történik tényleges oldalletöltés az oldalon, hanem mindezt virtuálisan
                      idézzük elő
                    </li>
                  </ul>
                </li>
                <li>Az útvonalválasztóban van eldöntve, hogy melyik komponens legyen aktív</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #react data-anchor="react">React</h3>
  <ul>
    <li>Javascript könyvtár kliens oldali applikációk készítéséhez
      <ul>
        <li>A Facebook fejlesztette ki 2011-ben</li>
        <li>Reaktív felületek készítéséhez készült</li>
        <li>Nem framework, library</li>
      </ul>
    </li>
    <li>Leginkább SPA készítésére használjuk</li>
    <li>Deklaratív, hatásos, rugalmas</li>
    <li>HTML-lel és CSS-sel együtt használjuk</li>
    <li>A kódot a böngésző futtatja</li>
    <li>Komponenseket használunk UI fejlesztéshez</li>
    <li>Egyetlen HTML fájlunk van, és ez a fájl nem cserélődik, csak a tartalma</li>
    <li>Sok third party könyvtárat mellőz
      <ul>
        <li>Nincs beépített routing a React-ban, ha szükség van rá, telepítésre szorul</li>
        <li>Plusz feature-ök telepítés útján érhetők el</li>
      </ul>
    </li>
    <br>
    <li>Imperatív eszköztár
      <ul>
        <li>A natív Javascript-ben a HTML elemeket reprezentáló JS objektumokon módosításokat kell végrehajtani
          bármiféle hatás érdekében</li>
        <li>Ezért közvetlen módosítást kellett végrehajtani a DOM-on</li>
        <li>A procedurális lépések szerepelnek a kódban</li>
        <pre>
  const btn = document.createElement('button');

  btn.onClick = function() &#123;
    alert('Click');
  }

  btn.innerText = 'Button';

document.getElementById('sample-button-container').appendChild('btn'); // közvetlen módosítás a DOM-on
        </pre>
      </ul>
    </li>
    <li>Deklaratív eszköztárral rendelkezik
      <ul>
        <li>A React esetében nem végzünk közvetlenül ilyen módosításokat a document object modelen
          <ul>
            <li>A React a motorhátető alatt megcsinálja</li>
            <li>Leírjuk, mi legyen a dokumentum felépítése, és a könyvtár bizonyosodik meg róla, hogy elő tudja-e
              állítani ezt az állapotot</li>
            <li>A könyvtár ennek elérésére egy virtuális DOM nevű eszközt vet be
              <ul>
                <li>Ez azt jelenti, hogy a React a natív document object elemei helyett saját, könnyebb
                  adatstruktúrával, a virtuális DOM-mal reprezentálja a dokumentum elemeit, és a futása során
                  folyamatosan szinkronban tartja az igazi DOM-mal</li>
                <li>A natív object elemekkel nem is kell interakcióba lépnünk</li>
              </ul>
            </li>
          </ul>
        </li>
        <pre>
  ReactDOM.render(React.createElement(
    'button',
    &#123;
      onClick: function () &#123;
        alert('Click');
      }
    },
    'Gomb'
  ), document.getElementById('button-element'));
        </pre>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #reactcomparison data-anchor="reactcomparison">React comparison</h3>
  <h5 #reactvsjs data-anchor="reactvsjs">React vs JS</h5>
  <ul>
    <li>Minimál demonstráció
      <ul>
        <li>Létrehoztunk 2 fájl
          <ol>
            <li>index.html
              <ul>
                <pre>
  &#60;!DOCTYPE html>
  &#60;html lang="en">

  &#60;head>
      &#60;meta charset="UTF-8">
      &#60;meta name="viewport" content="width=device-width, initial-scale=1.0">
      &#60;title>Document&#60;/title>

      // A defer attribútum biztosítja a scriptnek, hogy csak a teljes HTML betöltése után fusson le, hasonlóan ahhoz, mintha a &#60;body> végén helyezted volna el
      &#60;script defer src="./app.js">&#60;/script>
  &#60;/head>

  &#60;body>
      &#60;h6>Natív &#60;small>(imperatív)&#60;/small>&#60;/h6>
      &#60;div id="native-button-container">&#60;/div> // interaktív elem belépési pontja (natív)
      &#60;h6>React &#60;small>(deklaratív)&#60;/small>&#60;/h6>
      &#60;div id="react-button-container">&#60;/div> // interaktív elem belépési pontja (React)

      // A szkriptek body végére helyezésének oka az, hogy a böngésző lineárisan dolgozza fel a HTML dokumentumot, vagyis felülről lefelé halad
      // A DOM elemek már elérhetők és manipulálhatók a szkriptek által
      // behívjuk a React fejlesztőeszközeit
      &#60;script crossorigin src="https://unpkg.com/react@18/umd/react.development.js">&#60;/script>
      &#60;script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js">&#60;/script>
  &#60;/body>

  &#60;/html>
                </pre>
              </ul>
            </li>
            <li>app.js
              <ul>
                <pre>
  // natív JS

    const btn = document.createElement('button');

    btn.onclick = function () &#123;
        alert('Button');
    };

    btn.innerText = 'Gomb';

    document.getElementById('native-button-container').appendChild(btn);

    // React

    const gomb = React.createElement( // 3 paramétert vár
        'button',
        &#123;
            onClick: function () &#123;
                alert('Button');
            }
        },
        'Gomb'
    )

    ReactDOM.render( // 2 paramétert vár
        gomb,
        document.getElementById('react-button-container')
    ); 
                </pre>
              </ul>
            </li>
          </ol>
        </li>
        <li>A React kitalált egy speciális szintaxist
          <ul>
            <li>JSX</li>
            <li>Nem valid JS</li>
            <li>HTML-nek kinéző markup-ként leírhatóak az egyes elemek</li>
            <li>A transpiler átfordítja a fentebbi kódra</li>
            <pre>
  ReactDOM.render(
      &#60;button
          onClick=&#123;() => &#123;
              alert('Gomb')
          }}
          className="btn btn-dark"
      >
          Gomb
      &#60;/button>,
      document.getElementById('react-button-container-2')
  );
            </pre>
            <li>Az app.js fájlban ez a kód hibát okoz, mivel ezt a szintaxist a böngésző nem tudja értelmezni
              <ul>
                <li>Először le kell fordítani szabványos JavaScript kódra, mielőtt a böngésző képes lesz futtatni</li>
                <li>Build eszközök, amik erre képesek
                  <ol>
                    <li>Babel</li>
                    <li>Vite</li>
                    <li>Webpack</li>
                  </ol>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>React v18-as verziótól az incializálás két lépcsőben történik, a createRoot függvény segítségével</li>
        <pre>
  const gomb = React.createElement( // 3 paramétert vár
      'button',
      &#123;
          onClick: function () &#123;
              alert('Button');
          }
      },
      'Gomb'
  );

  const root = ReactDOM.createRoot(document.getElementById('react-button-container'));
  root.render(gomb);
        </pre>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #reactvsangular data-anchor="reactvsangular">React vs Angular</h5>
  <ul>
    <table style="border-collapse: collapse; width: 100%;">
      <thead>
        <tr>
          <th></th>
          <th>Angular</th>
          <th>React</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>direktívák</td>
          <td>igen (pl. ngIf, ngFor)</td>
          <td>nem</td>
        </tr>
        <tr>
          <td>pipe-ok</td>
          <td>igen (pl. async, uppercase)</td>
          <td>nem (de map(), filter() hasonló célra)</td>
        </tr>
        <tr>
          <td>szervizek</td>
          <td>igen (pl. szolgáltatásokat hozunk létre)</td>
          <td>custom hooks, context api, redux</td>
        </tr>
        <tr>
          <td>komponensek</td>
          <td>igen (pl. @Component)</td>
          <td>igen (komponens alapú struktúra)</td>
        </tr>
        <tr>
          <td>adatbinding</td>
          <td>igen (pl. kétirányú binding, [(ngModel)])</td>
          <td>props és state kezelés, egyirányú adatáramlás</td>
        </tr>
        <tr>
          <td>eventek kezelése</td>
          <td>igen (pl. (click), ngModelChange)</td>
          <td>igen (pl. onClick, onChange)</td>
        </tr>
        <tr>
          <td>modulok</td>
          <td>igen (pl. @NgModule)</td>
          <td>nem (komponensek fájlokba szervezve)</td>
        </tr>
        <tr>
          <td>routolás</td>
          <td>igen (pl. @angular/router)</td>
          <td>igen (pl. react-router-dom)</td>
        </tr>
      </tbody>
    </table>
  </ul>
  <br>
  <h5 #reactvsangularvsvue data-anchor="reactvsangularvsvue">React vs Angular vs Vue</h5>
  <ul>
    <li>React
      <ul>
        <li>Jellemzők
          <ul>
            <li>Könyvtár, amelyet felhasználói felületek készítésére terveztek</li>
            <li>Komponens alapú architektúra, egyszerű újrafelhasználhatóság</li>
            <li>Virtuális DOM-ot használ a gyorsabb teljesítmény érdekében</li>
            <li>JSX szintaxis: HTML-szerű JavaScript-ben</li>
            <li>Flexibilis, de nem tartalmaz beépített routingot vagy állapotkezelést</li>
            <li>Gyakran használt kiegészítők: React Router, Redux, Zustand</li>
          </ul>
        </li>
        <li>Erősségei
          <ul>
            <li>Könnyen tanulható, JavaScript tudás esetében</li>
            <li>Virtuális DOM miatt gyors</li>
            <li>Szabadság a projektek felépítésében</li>
          </ul>
        </li>
        <li>Gyengeségei
          <ul>
            <li>Nincs beépített routing vagy state management</li>
            <li>Ökoszisztéma moduljainak kiválasztása kihívás lehet</li>
          </ul>
        </li>
        <li>Használati esetek
          <ul>
            <li>Kisebb és közepes méretű alkalmazások</li>
            <li>Gyors fejlesztés igénye</li>
            <li>Olyan projektek, ahol nagy szabadságra van szükség</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Angular
      <ul>
        <li>Jellemzők
          <ul>
            <li>Teljes körű keretrendszer, amelyet a Google fejlesztett</li>
            <li>Typescript alapú, strukturált fejlesztést biztosít</li>
            <li>Komponens alapú architektúra és MVVM modell</li>
            <li>Beépített eszközök, mint routing, HTTP kliens, dependency injection</li>
            <li>Reactive programozás RxJS-sel</li>
          </ul>
        </li>
        <li>Erősségei
          <ul>
            <li>Nagyvállalati szintű alkalmazásokhoz ideális</li>
            <li>Könnyű fenntartani és bővíteni a projekteket</li>
            <li>Beépített funkcionalitások</li>
          </ul>
        </li>
        <li>Gyengeségei
          <ul>
            <li>Meredek tanulási görbe</li>
            <li>Kisebb projektekhez nehézsúlyú megoldás</li>
          </ul>
        </li>
        <li>Használati esetek
          <ul>
            <li>Nagyobb vállalati alkalmazások</li>
            <li>Olyan projektek, ahol szigorú szabályozottság szükséges</li>
            <li>Typescript kedvelők</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Vue
      <ul>
        <li>Jellemzők
          <ul>
            <li>Egy progresszív keretrendszer, amelyet Evan You hozott létre</li>
            <li>Középutat képez az Angular és React között</li>
            <li>Komponens alapú architektúra és reaktív adatkezelés</li>
            <li>Egyszerű és könnyen tanulható, különösen kezdőknek</li>
            <li>Beépített router és state management (Vue Router, Vuex/Pinia)</li>
          </ul>
        </li>
        <li>Erősségei
          <ul>
            <li>Könnyű tanulni, kezdőknek ideális</li>
            <li>Kicsi fájlméret, gyors betöltés</li>
            <li>Beépített eszközök gyors fejlesztéshez</li>
          </ul>
        </li>
        <li>Gyengeségei
          <ul>
            <li>Kevesebb nagyvállalati használat</li>
            <li>Modulok kevésbé kiforrottak</li>
          </ul>
        </li>
        <li>Használati esetek
          <ul>
            <li>Kis- és közepes méretű alkalmazások</li>
            <li>Gyors prototípusok vagy MVP fejlesztése</li>
            <li>Kezdő fejlesztők számára ajánlott</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <table style="width: 100%; table-layout: fixed">
      <thead>
        <tr>
          <th></th>
          <th>Angular</th>
          <th>React</th>
          <th>Vue</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Típus</strong></td>
          <td>Teljes keretrendszer</td>
          <td>Könyvtár</td>
          <td>Progresszív keretrendszer</td>
        </tr>
        <tr>
          <td><strong>Nyelv</strong></td>
          <td>Typescript</td>
          <td>JavaScript + JSX</td>
          <td>JavaScript + Templates</td>
        </tr>
        <tr>
          <td><strong>Virtuális DOM</strong></td>
          <td>Nem</td>
          <td>Igen</td>
          <td>Igen</td>
        </tr>
        <tr>
          <td><strong>Állapotkezelés</strong></td>
          <td>Beépített (RxJS)</td>
          <td>Redux, Zustand, Context API</td>
          <td>Vuex, Pinia</td>
        </tr>
        <tr>
          <td><strong>Routing</strong></td>
          <td>Beépített (RouterModule)</td>
          <td>React Router (külső)</td>
          <td>Beépített (Vue Router)</td>
        </tr>
        <tr>
          <td><strong>Tanulási görbe</strong></td>
          <td>Meredek</td>
          <td>Mérsékelt</td>
          <td>Alacsony</td>
        </tr>
        <tr>
          <td><strong>Teljesítmény</strong></td>
          <td>Lassabb (nagyobb méret)</td>
          <td>Gyors</td>
          <td>Gyors</td>
        </tr>
        <tr>
          <td><strong>Mikor használjuk?</strong></td>
          <td>Nagy, komplex alkalmazásokhoz</td>
          <td>Sokoldalú projektekhez</td>
          <td>Gyors prototípusokhoz</td>
        </tr>
      </tbody>
    </table>
  </ul>
</div>

<div>
  <h3 #initialization data-anchor="initialization">Initialization</h3>
  <ul>
    <li>A React-et egyetlen oldalon több alkalmazás inicializálására is lehet használni</li>
    <li>Három lehetséges konfiguráció (leggyakoribb használat)
      <ol>
        <li>
          <ul>
            <li>A React könyvtár egy olyan HTML node-ra kapcsolódik rá, ami egyéb HTML tartalommal van körülvéve (több
              HTML dokumentumot szolgáltat), és a weboldal, ahol mindez történik, több HTML dokumentumot is szolgáltat
            </li>
            <li>Linkre kattintva mindig új oldalletöltés történik</li>
            <li>Egy oldal HTML tartalomból, és a React által működtetett interaktív komponensből áll</li>
            <pre>
  &#60;!DOCTYPE html>
  &#60;html lang="en">

  &#60;head>
      &#60;meta charset="UTF-8">
      &#60;title>Document&#60;/title>
  &#60;/head>

  &#60;body>
      ---------- HTML ----------
      ---------- HTML ----------
      ---------- HTML ----------
      &#60;div id="react-app-container">&#60;/div>
      ---------- HTML ----------

      &#60;script>
        ReactDOM.render(App, document.getElementById('react-app-container'));
      &#60;/script>
  &#60;/body>

  &#60;/html>
            </pre>
          </ul>
        </li>
        <li>
          <ul>
            <li>Hasonló az előző pontban lévőhöz</li>
            <li>A HTML tartalomban két belépési pont van két különálló React applikációba</li>
            <li>Tipikus, amikor több egymástól teljesen független appot használ az oldal
              <ul>
                <li>Egymással belső állapotokat nem osztanak meg</li>
                <li>Bármennyi, nem csak 2 app inicializálható</li>
              </ul>
            </li>
            <li>Például az oldal tetején van egy weather widget, az alján pedig egy stock widget</li>
            <li>Jellemző továbbá még az olyan oldalak esetén, ahhol folyamatosan állnak át a React használatára</li>
            <pre>
  &#60;!DOCTYPE html>
  &#60;html lang="en">

  &#60;head>
      &#60;meta charset="UTF-8">
      &#60;title>Document&#60;/title>
  &#60;/head>

  &#60;body>
      ---------- HTML ----------
      ---------- HTML ----------
      ---------- HTML ----------
      &#60;div id="weather-app-container">&#60;/div>
      ---------- HTML ----------
      &#60;div id="stock-app-container">&#60;/div>
      ---------- HTML ----------

      &#60;script>
        ReactDOM.render(WeatherApp, document.getElementById('weather-app-container'));
        ReactDOM.render(StockApp, document.getElementById('stock-app-container'));
      &#60;/script>
  &#60;/body>

&#60;/html>
            </pre>
          </ul>
        </li>
        <li>
          <ul>
            <li>Egyetlen oldalletöltés történik, miután egyetlen React app fut a böngészőben, és generál ki minden HTML
              tartalmat
              <ul>
                <li>Több oldalletöltés nem is történik</li>
              </ul>
            </li>
            <li>A React app a navigálás illúzióját kelti</li>
            <li>A további szerver oldali adatokat AJAX kérésekkel szerzi meg</li>
            <li>SPA, azaz Single Page Application a neve</li>
            <pre>
  &#60;!DOCTYPE html>
  &#60;html lang="en">

  &#60;head>
      &#60;meta charset="UTF-8">
      &#60;title>Document&#60;/title>
  &#60;/head>

  &#60;body>
      &#60;div id="app-container">&#60;/div> // alkalmazás belépési pontja

      &#60;script>
        ReactDOM.render(WeatherApp, document.getElementById('app-container'));
      &#60;/script>
  &#60;/body>

  &#60;/html>
            </pre>
          </ul>
        </li>
      </ol>
    </li>
  </ul>
</div>

<div>
  <h3 #gettingstarted data-anchor="gettingstarted">Getting started</h3>
  <ol>
    <li>node.js telepítés
      <ul>
        <li>Mindig az LTS-t érdemes választani</li>
        <li>'node -v' paranccsal ellenőrizhetjük a verziószámot </li>
      </ul>
    </li>
    <li>A Create React App tool-lal készíthetünk React projektet
      <ul>
        <li>Tartalmaz néhány előre konfigurált, és alapvető fájlt</li>
        <li>Remek környezetet biztosít a fejlsztéshez</li>
        <li>Development web szerver futtatható, ami változás esetén frissíti a preview-t</li>
        <li>Production-be állítás előtt optimalizál</li>
        <pre>
  npx create-react-app *PROJEKTNÉV*
        </pre>
        <li>A parancs az npm-et állítja be alapértelmezett package manager-nek</li>
        <li>A legfrissebb verzió fog települni</li>
      </ul>
    </li>
    <li>Indítsuk el a projektet</li>
    <pre>
  npm start
    </pre>
  </ol>
  <ul>
    <li>Megjegyzés
      <ul>
        <li>Dev módban (npm run dev) minden console.log kétszer íródik ki</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #projectstructure data-anchor="projectstructure">Project structure</h3>
  <ul>
    <li>node_modules
      <ul>
        <li>A React, és minden third party könyvtár itt tárolódik</li>
        <li>Nincs dolgunk ezzel a mappával</li>
      </ul>
    </li>
    <li>public (mappa)
      <ul>
        <li>favicon.ico
          <ul>
            <li>A böngészőfülön megjelenő ikon</li>
          </ul>
        </li>
        <li>index.html
          <ul>
            <li>Alap HTML fájl, amely a React alkalmazás "konténere lesz</li>
            <li>A React alkalmazás a div#root elembe renderelődik</li>
            <li>Itt találhatók a statikus metaadatok, a cím, a favikonok és a React alkalmazás számára szükséges egyéb
              alapvető HTML szerkezetek</li>
          </ul>
        </li>
        <li>manifest.json
          <ul>
            <li>Az app-pal kapcsolatos meta adatokat tartalmaz</li>
          </ul>
        </li>
        <li>robots.txt
          <ul>
            <li>A keresőmotorok számára ad irányelveket, hogy mely oldalakat indexelhetnek és melyeket nem</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>src (mappa)
      <ul>
        <li>Ebben a mappában található az alkalmazásunk forráskódja, logikája, komponensei</li>
        <li>App.js
          <ul>
            <li>Az alkalmazás "szíve"</li>
            <li>A főbb UI elemek itt találhatók</li>
            <li>Tulajdonképpen az app komponens</li>
            <li>Alapértelmezetten JSX markup-ot használ
              <ul>
                <li>Javascript XML rövidítése</li>
                <li>Hasonlít a html-hez</li>
                <li>Így írjuk le, miképp nézzen ki az appunk</li>
                <li>A böngészők nem értik a JSX markup-ot
                  <ul>
                    <li>A Babel átfordítja JS kóddá
                      <ul>
                        <li>Modern JavaScript compiler</li>
                        <li>A package.lock.json-ben láthatjuk, hogy jelen van a projektben</li>
                        <li>A https://babeljs.io/ weboldalon kipróbálhatjuk, miképp fordul át a JSX kód JS kóddá</li>
                        <img src="../../assets/imgs/jsxtojs.png" width="100%">
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>App.test.js
          <ul>
            <li>Az app komponens automatizált tesztjei írhatók itt meg</li>
          </ul>
        </li>
        <li>reportWebVitals.js
          <ul>
            <li>A webes teljesítmény méréséhez szükséges</li>
          </ul>
        </li>
        <li>App.css
          <ul>
            <li>Az App komponenshez tartozó alapértelmezett stílusokat tartalmazza</li>
          </ul>
        </li>
        <li>index.css
          <ul>
            <li>Alapértelmezett globális stílusokat tartalmazza, amelyek minden React komponensre vonatkoznak</li>
          </ul>
        </li>
        <li>index.js
          <ul>
            <li>A React alkalmazás belépési pontja</li>
            <li>Importálja az App komponenst, és azt rendereli a root elembe, amely az index.html fájlban található</li>
          </ul>
        </li>
        <li>logo.svg
          <ul>
            <li>SVG formátumú fájl, amely az alapértelmezett React logót tartalmazza</li>
          </ul>
        </li>
        <li>setupTests.js
          <ul>
            <li>Tartalmazza a szükséges beállításokat a Jest és a React Testing Library számára</li>
          </ul>
        </li>
        <li>assets (mappa)
          <ul>
            <li>Új projekt nem hozza létre, de az assets mappát itt szokás elhelyezni</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>package.json
      <ul>
        <li>Az összes dependenciát tartalmazza</li>
      </ul>
    </li>
    <br>
    <li>SCSS is használható a projektekben
      <ul>
        <li>Ehhez telepítés szükséges</li>
        <pre>
  npm install sass
        </pre>
        <li>Ezután az src/App.css átnevezhető App.scss-re, valamint az src/index.css is lehet index.scss</li>
        <li>Illetve az importálást is át szükséges írni</li>
        <pre>
  <b>// App.js</b>
  import './App.css';

  ↓↓↓↓↓

  import './App.scss';

  <b>// index.js</b>
  import './index.css';

  ↓↓↓↓↓

  import './index.scss';
        </pre>
      </ul>
    </li>
    <br>
    <li>Typescriptet is lehet használni a projektben
      <ul>
        <li>A React projektekben alapértelmezés szerint .js kiterjesztésű fájlok jönnek létre, és ezekbe nyugodtan
          írhatunk JSX markup-ot</li>
        <li>Ha TypeScript-et szeretnénk használni, akkor a fájloknak a .tsx kiterjesztést kell adni, mivel a TypeScript
          szintaxis nem támogatja a JSX-t .ts fájlokban</li>
        <li>A .tsx fájlban használhatod a JSX leíró nyelvet</li>
        <li>A .tsx kiterjesztés biztosítja, hogy a fájl TypeScript-tel és JSX-sel is dolgozhat</li>
        <li>A .tsx fájlok a React és TypeScript kombinációja, ahol a JSX-t TypeScript-kóddal használjuk</li>
        <li>A .tsx fájlok lehetővé teszik a TypeScript típusellenőrzését és az erősebb típusbiztonságot, miközben
          ugyanazokat az összetevőket és szintaxist használják, mint a hagyományos .js vagy .jsx fájlok</li>
        <pre>
  npm install typescript @types/node @types/react @types/react-dom @types/jest
        </pre>
        <li>Ezt követően minden .js fájlt (és importját) át lehet nevezni .tsx-re</li>
        <li>Valamint a dev szerver újraindítást igényel</li>
      </ul>
    </li>
    <pre>
  /my-react-app
  │
  ├── /node_modules/                # Az összes telepített csomag, beleértve a React-ot és minden harmadik féltől származó könyvtárat
  │   └── ...
  │
  ├── /public/                      # Statikus fájlok
  │   ├── favicon.ico               # A böngésző fülnél megjelenő ikon
  │   ├── index.html                # Az alap HTML fájl, amely a React alkalmazás "konténere"
  │   │   └── <div id="root"></div> # Itt renderelődik a React alkalmazás
  │   ├── manifest.json             # Az app-pal kapcsolatos metaadatok
  │   └── robots.txt                # A keresőmotorok számára irányelvek a weboldalak indexelésére
  │
  ├── /src/                         # A forráskód, logika és komponensek
  │   ├── assets/                   # Képek, statikus fájlok (ha szükséges)
  │   ├── components/               # React komponensek
  │   │   └── App.js                # A fő React komponens (App komponens), JSX markup-kal
  │   ├── App.css                   # Alapértelmezett stílusok az App komponenshez
  │   ├── App.test.js               # Automatizált tesztek az App komponenshez
  │   ├── index.css                 # Globális stílusok minden komponenshez
  │   ├── index.js                  # A React alkalmazás belépési pontja
  │   ├── logo.svg                  # Az alapértelmezett React logó (SVG)
  │   ├── reportWebVitals.js        # A webes teljesítmény méréséhez szükséges fájl
  │   └── setupTests.js             # Beállítások a Jest és a React Testing Library számára
  │
  ├── package.json                  # A projekt függőségei és szkriptek
  ├── package-lock.json             # A pontos függőségek verzióinak zárolása
  ├── tsconfig.json                 # TypeScript konfigurációs fájl (ha TypeScript-et használsz)
  └── .gitignore                    # Git által figyelmen kívül hagyott fájlok
    </pre>
  </ul>
</div>

<div>
  <h3 #fromscratch data-anchor="fromscratch">From scratch</h3>
  <ul>
    <li>index.js
      <ul>
        <li>Belépési pont</li>
        <li>A React module-ból szükséges importálnunk</li>
        <li>A hot module reloading miatt újratöltődik a változtatásoknál az app</li>
        <pre>
  import React from 'react'; // a React könyvtár tartalmazza a szükséges eszközöket a JSX kód értelmezéséhez
  import ReactDOM from 'react-dom'; // a React alkalmazásoknak a DOM-mal való kapcsolódásáért felelős objektum
  import './index.scss'; // a globális stílusokat tartalmazza
  import App from './App'; // importáljuk az App komponenst, amely a fő React komponens
  import reportWebVitals from './reportWebVitals'; // a teljesítmény méréséhez az alapértelmezett kódban van egy példány, amely segít a mérési adatok naplózásában

  ReactDOM.render( // rendereljük a React komponenst (jelen esetben az App komponenst) a valódi DOM-ba
    &#60;React.StrictMode> // segédeszköz, amely segít a fejlesztésben, figyelmeztetéseket ad, ha a React alkalmazásban valamilyen hiba van
      &#60;App />
      &#60;/React.StrictMode>,
    document.getElementById('root') // a root id-jú elembe renderelődik az app
  );

  reportWebVitals(); // mérési eredményeket ír ki a console-ba
        </pre>
        <li>Ha létrehozunk egy jsx elemet, és kilogoljuk, egy objektumot kapunk, különféle kulcs-érték párokkal
          <ul>
            <li>Ez a React elem / objektum része a virtuális DOM-nak</li>
            <li>State változásnál a virtuális DOM frissül, a React megnézi, mi változott, majd hozzáfér a valódi
              DOM-hoz, és befrissíti azt</li>
            <li>A ReactDOM.render() egy elemet renderel a virtuális DOM-ból a valódi DOM-ba
              <ul>
                <li>Az első argomentum az az elem, amit renderelni szeretnénk
                  <ul>
                    <li>Ez az elem az app komponens</li>
                    <li>Az app komponensnek lehetnek gyerekei</li>
                  </ul>
                </li>
                <li>A másoodik argoumentum, hogy hova szeretnénk renderelni
                  <ul>
                    <li>Az index.html-ben (konténerben) lévő 'root' id-val rendelkező div-be kívánjuk renderelni</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Minden React alkalmazás egy komponens fa
          <ul>
            <li>Ezek kombinációja tesz ki egy Ract alkalmazást</li>
            <li>A komponens egy JS osztályként van implementálva
              <ul>
                <li>Állapottal, és render metódussal rendelkezik</li>
                <pre>
  class App &#123;
    state; // adat, amit meg szeretnénk jeleníteni, amikor a komponens renderelésre kerül

    render() &#123; // a UI kinézetéért felelős

    }
}
                </pre>
                <li>A render függvény kimenete egy React elem
                  <ul>
                    <li>JavaScript objektum, ami (virtuális) DOM elemhez kötött
                      <ul>
                        <li>Csak a memóriában reprezentálja a valódi DOM elemet</li>
                        <li>A state változás után a DOM interakciókat a React automatikusan megoldja</li>
                        <li>Először a virtuális DOM frissül, majd a valódi DOM azon része frissül, ahol történt változás
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <br>
                <table>
                  <thead>
                    <tr>
                      <th></th>
                      <th>Virtuális DOM</th>
                      <th>Valódi DOM</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>Meghatározás</td>
                      <td>A valódi DOM egy könnyített másolata, amelyet hatékony frissítésekhez használnak</td>
                      <td>A dokumentum tényleges struktúrája, amelyet a böngésző használ</td>
                    </tr>
                    <tr>
                      <td>Gyorsaság</td>
                      <td>Gyorsabb frissítések, mivel a változások először memóriában kerülnek kiszámításra.</td>
                      <td>Lassabb frissítések, mivel minden változás közvetlenül a DOM-ot módosítja.</td>
                    </tr>
                    <tr>
                      <td>Hatékonyság</td>
                      <td>Csak a módosított részek kerülnek frissítésre.</td>
                      <td>A teljes DOM-fa újrarenderelése szükséges minden változtatásnál.</td>
                    </tr>
                    <tr>
                      <td>Használat</td>
                      <td>Modern keretrendszerekben, mint például React és Vue.</td>
                      <td>A böngészők által natívan használt DOM.</td>
                    </tr>
                    <tr>
                      <td>Változtatás módja</td>
                      <td>A változásokat egyben, csoportosan alkalmazza.</td>
                      <td>A változásokat azonnal, egyenként alkalmazza.</td>
                    </tr>
                    <tr>
                      <td>Teljesítmény</td>
                      <td>Elkerüli a felesleges műveleteket, csökkenti a teljesítményproblémákat.</td>
                      <td>Több művelet miatt teljesítménybeli problémák léphetnek fel gyakori frissítéseknél.</td>
                    </tr>
                  </tbody>
                </table>
                <br>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #jsx data-anchor="jsx">JSX</h3>
  <ul>
    <li>Általánosságban elmondható, hogy HTML-t nem írhatunk JavaScript fájlba
      <ul>
        <li>Stringként szokás beleírni</li>
        <li>React esetében kvázi megtehetjük, de valójában a HTML-nek kinéző kód nem HTML, hanem JSX</li>
      </ul>
    </li>
    <li>A böngésző nem érti a JSX kódokat
      <ul>
        <li>Javascript kóddá szükséges átalakítani</li>
        <li>Kompiláláskor ez a transzformáció megtörténik</li>
        <li>Az átalakítást a Babel végzi, a böngészőben való renderelés előtt</li>
        <li>Írhatunk Javascriptet is a .js fájlokba JSX helyett
          <ul>
            <pre>
  <b>// app.js</b>
  function App() &#123;
    const p = document.createElement(p);
    p.textContent = 'This is a paragraph';
    return p;
  }

  export default App;

  <b>// index.js</b>
  let div = document.getElementById('root');
  div.append(App());
            </pre>
            <li>Sokkal több kódot írtunk így, és komplexitástól függően igencsak megnehezedhet a dolgunk</li>
          </ul>
        </li>
        <li>JSX esetében a HTML-be különféle kifejezéseket is írhatunk</li>
        <pre>
  function App() &#123;
    return &#60;h1>This is the title &#123;10 + 5}&#60;/h1> // kapcsos zárójelbe JavaScript kifejezést írhetunk
  }

  function App() &#123;
    let message = 'nice'
    return &#60;h1>This is the &#123;message} title&#60;/h1>
  }
        </pre>
        <li>A return mögött csak egy elem szerepelhet
          <ul>
            <pre>
  return &#60;h1>This is the &#123;message} title&#60;/h1>&#60;h2>Subtitle&#60;/h2> // hibás
            </pre>
            <li>Egyetlen top level / konténer elemben szükséges elhelyzeni</li>
            <pre>
  return &#60;span>&#60;h1>This is the &#123;message} title&#60;/h1>&#60;h2>Subtitle&#60;/h2>&#60;/span> // ez így rendben van
            </pre>
          </ul>
        </li>
        <li>Jó gyakorlat sort törni, és zárójellel körbevenni a JXS kifejezést
          <ul>
            <pre>
  function App() &#123;
    let message = 'nice'
    return (&#60;span>
      &#60;h1>This is the &#123;message} title&#60;/h1>
      &#60;h2>Subtitle&#60;/h2>
      &#60;/span>);
  }
            </pre>
          </ul>
        </li>
        <li>A JSX XML szabályokat követ
          <ul>
            <li>Minden tag-et ennek megfelelően be kell zárni</li>
            <li>Az egyébként self-closing tag-eket is, mint az 'img', vagy az 'input'</li>
            <pre>
  function App() &#123;
    let message = 'nice'
    return (&#60;span>
      &#60;h1>This is the &#123;message} title&#60;/h1>
      &#60;h2>Subtitle&#60;/h2>
      &#60;input type='text'>&#60;/input>
    &#60;/span>);
  }
            </pre>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #component data-anchor="component">Component</h3>
  <ul>
    <li>Lehetővé teszik a felhasználói felület újrafelhasználható darabokra való felosztását</li>
    <li>A komponensek egy fa struktúrát alkotnak, amiknek a gyökér eleme maga az app</li>
    <li>A komponenst legegyszerűbben függvény formában lehet leírni
      <ul>
        <li>Kap egy bemenetet, ami az őt körülölelő szülő komponenstől érkezik</li>
        <li>Visszatér egy React element-tel, amit a React kirenderel</li>
        <pre>
  function Komponens(props) &#123;
    return React.createElement(
      'div',
      &#123;
        className: 'border'
      },
      // további gyerek elemek és komponensek
    )
  }
        </pre>
        <li>A props egy objektum
          <ul>
            <li>Tetszőleges kulcs-érték párokból állhat</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Tehát a kódban egy függvényt deklarálunk, amit odaadunk a React-nak
      <ul>
        <li>Nem mi, a React fogja meghívni automatikusan, újrarendereléskor</li>
      </ul>
    </li>
    <pre>
  ReactDOM.render(
    React.createElement(Komponens),
    document.getElementById('app-container')
  )
    </pre>
    <li>Kétféleképpen készíthetünk komponenst
      <ol>
        <li>Funkcionális komponens (function)
          <ul>
            <pre>
  import React from 'react';

  const Greeting = () => &#123;
    return &#60;h1>Helló, világ!&#60;/h1>;
  };

  export default Greeting;
            </pre>
          </ul>
        </li>
        <li>Osztály alapú komponens (class)
          <ul>
            <pre>
  import React, &#123; Component } from 'react';

  class Greeting extends Component &#123;
    render() &#123;
      return &#60;h1>Helló, világ!&#60;/h1>;
    }
  }

  export default Greeting;
            </pre>
          </ul>
        </li>
      </ol>
    </li>
    <pre>
  function App() &#123;
    &#60;h1>This is a component&#60;/h1>
  }

  export default App;
    </pre>
    <li>Ahhoz, hogy egy komponens más fájlokban elérhető legyen, exportálni szükséges
      <ul>
        <li>A default kulcsszó miatt szabadon elnevezhető az importálás</li>
        <pre>
  import HelloComponent from './Greeting';
        </pre>
        <li>Default nélkül pontos elnevezést kell megadni</li>
        <pre>
  import &#123; Greeting } from './Greeting';
        </pre>
      </ul>
    </li>
    <li>A 18-as verziótól a ReactDOM.render() deprecated
      <ul>
        <pre>
  <b>// index.html (public mappában)</b>
  &#60;!DOCTYPE html>
  &#60;html lang="en">
  &#60;head>
    ...
  &#60;/head>
  &#60;body>
    &#60;div id="root">&#60;/div>
  &#60;/body>
  &#60;/html>

  <b>// index.js</b>
  import React from 'react';
  import ReactDOM from 'react-dom';
  import App from './App';

  const root = ReactDOM.createRoot(document.getElementById('root'));
  // root.render(&#60;App>&#60;/App>); // így is leírható, de a következő sor rövidebb
  root.render(&#60;App />);

  <b>// App.js</b>
  function App() &#123;
    return &#60;h1>This is the title&#60;/h1> // a függvényből jsx kifejezéssel térünk vissza
  }
  
  export default App;
        </pre>
        <li>A createRoot használatos helyette</li>
      </ul>
    </li>
    <li>Példa
      <ul>
        <li>Hozzunk létre egy egyszerű alkalmazást</li>
        <li>Két komponenst fogunk létrehozni</li>
        <pre>
  <b>// html</b>
  &#60;!DOCTYPE html>
  &#60;html lang="en">

  &#60;head>
      &#60;meta charset="UTF-8">
      &#60;title>Document&#60;/title>

      &#60;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  &#60;/head>

  &#60;body>
    &#60;div class="container">
      &#60;div class="row m-5 border p-5">
        &#60;div id="app-container">&#60;/div> // az alkalmazás belépési pontja
      &#60;/div>
    &#60;/div>

      &#60;script crossorigin src="https://unpkg.com/react@18/umd/react.development.js">&#60;/script>
      &#60;script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js">&#60;/script>
  &#60;/body>

  &#60;/html>

  <b>// js</b>
  function App() &#123;
    return React.createElement(
      'div',
      &#123;
        className: 'border'
      },
      'App', // text tartalom
      React.createElement(BoxComponent, &#123;hatterSzin: 'red', felirat: 'piros'}), // gyermek elemek
      React.createElement(BoxComponent, &#123;hatterSzin: 'blue', felirat: 'kék'}),
      React.createElement(BoxComponent, &#123;hatterSzin: 'green', felirat: 'zöld'}),
    )
  }

  function BoxComponent(props) &#123; // gyerek elem
    return React.createElement(
      'div',
      &#123;
        style: &#123;
          width: '200px',
          height: '200px',
          margin: '10px',
          backgroundColor: props.hatterSzin,
        },
        className: 'p-2 m5 rounded' // fontos, hogy className, és nem class
      },
      props: felirat
    )
  }

  ReactDOM.render(
    React.createElement(App),
    document.getElementById('app-container')
  );
        </pre>
        <li>A gyerek elem várja a props objektumot
          <ul>
            <li>Az app-nak természetesen nincsen szülő eleme</li>
          </ul>
        </li>
        <li>A BoxComponent tudja használni az adatot
          <ul>
            <li>Mindig, amikor megváltozik az adat, a függvény újra meghívódik</li>
            <li>Ebből a függvényből kell visszatérni azzal, amit meg akarunk jeleníteni</li>
          </ul>
        </li>
        <li>A belépési pontunkra végül rácsatlakoztatjuk az App komponenst</li>
        <li>A createElement függvény második paramétere egy objektum, különféle property-kkel
          <ul>
            <li>Tulajdonképpen bármilyen property-t oda lehet neki adni</li>
            <li>Bármennyi lehet belőle</li>
          </ul>
        </li>
        <br>
        <img src="../../assets/imgs/simple_react_example.png" width="300px" height="500px">
      </ul>
    </li>
  </ul>
  <br>
  <h5 #addingcss data-anchor="addingcss">Adding CSS</h5>
  <ul>
    <li>A class szó helyett a className kifejezést használjuk
      <ul>
        <li>Mivel a JSX először Javascript-té konvertálódik, és a Javascript-ben a 'class' szócska foglalt</li>
      </ul>
    </li>
    <pre>
  <b>// App.js</b>
  import './App.scss'; // be kell importálni a stílus fájlt

  function App() &#123;
    let message = 'nice'
    return (&#60;span>
      &#60;h1 className='my-header'>Title&#60;/h1>
      &#60;p className="my-paragraph">This is the &#123;message} title&#60;/p>
    &#60;/span>);
  }

  <b>// App.css / App.scss</b>
  .my-header &#123;
    color: rgb(170, 0, 255);
  } 
  
  .my-paragraph &#123;
    color: rgb(63, 63, 81);
  }
    </pre>
  </ul>
  <br>
  <h5 #childcomponent data-anchor="childcomponent">Child component</h5>
  <ul>
    <li>Az app komponensben egyéb komponenseket használunk, mint az app komponens gyerekei
      <ul>
        <li>Ezért nevezzük root komponensnek</li>
        <li>Az app komponenst pedig az index.js fájlban rendereljük
          <ul>
            <li>Az index.js nem komponens, csak egy Javascript fájl</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A gyerek komponenseket érdemes az src/components mappában tárolni</li>
    <li>React konvenció, hogy a komponens fájlok neve nagy betűvel kezdődik
      <ul>
        <li>A komponens függvény is nagy betűvel kell, hogy kezdődjön (pascal case)</li>
        <pre>
  function Products() &#123; ... }

  function ProductDetails() &#123; ... }
        </pre>
      </ul>
    </li>
    <li>Gyerek komponensből is JSX kóddal térünk vissza
      <ul>
        <pre>
  <b>// Products.js</b>
  function Products() &#123;
    return &#60;div>All of the products&#60;/div>
  }
  
  // export &#123; Products }; // named export
  export default Products;

  <b>// App.js</b>
  import Products from './components/Products';

  function App() &#123;
    let message = 'nice'
    return (&#60;span>
      &#60;h1 className='my-header'>Title&#60;/h1>
      &#60;p className="my-paragraph">This is the &#123;message} title&#60;/p>
      &#60;Products />
    &#60;/span>);
  }

  export default App;
        </pre>
        <li>Az App.js-be importáltuk a Products.js-t</li>
        <li>Ha több függvényt is exportálunk, akkor named exportot szükséges használnunk</li>
      </ul>
    </li>
    <li>A komponensben return esetében a színfalak mögött valójában egy React.createElement() függvény áll
      <ul>
        <li>Ezért nem működik, ha több elemet akarunk megjeleníteni, de nem wrappeljük, mert a createElement function
          nem tudja, mit készítsen</li>
        <pre>
  return (
      &#60;div> // wrappelés
          &#60;div>All of the products&#60;/div>
          &#60;div>This is product description&#60;/div>
      &#60;/div>
  )
        </pre>
        <li>Érdemes bezárójelezni a többsoros visszatéréseket
          <ul>
            <li>Implicit semicolon insertion
              <ul>
                <li>Egy JavaScript-specifikus nyelvi mechanizmus, amely lehetővé teszi, hogy bizonyos helyeken
                  elhagyjuk a pontosvesszőt a kódból, mert a JavaScript automatikusan hozzáadja azokat a fordítás
                  során</li>
                <pre>
  function getValue() &#123;
    return; // az engine automatikusan ide tesz egy pontosvesszőt.
    &#123;
      value: 10
    }
  }                    
                  </pre>
              </ul>
            </li>
            <li>A zárójelben elhelyezett kód/logika egy kifejezésként értelmezendő, emiatt a Javascript csak a zárójel
              után helyez el pontosvesszőt, amennyiben elhagytuk</li>
          </ul>
        </li>
        <pre>
  <b>// Products.js</b>
  function Products() &#123;
    return (
        &#60;ul>
            &#60;li>
                &#60;div>
                    &#60;div>
                        &#60;h5>Fresh milk&#60;/h5>
                        &#60;p>Donec quam felis, ultricies nec&#60;/p>
                        &#60;div>
                            &#60;h6>499 HUF&#60;/h6>
                        &#60;/div>
                    &#60;/div>
                    &#60;img src="" alt="" width="100px" />
                &#60;/div>
            &#60;/li>
            &#60;li>
                &#60;div>
                    &#60;div>
                        &#60;h5>Banana&#60;/h5>
                        &#60;p>Nullam dictum felis eu pede&#60;/p>
                        &#60;div>
                            &#60;h6>230 HUF&#60;/h6>
                        &#60;/div>
                    &#60;/div>
                    &#60;img src="" alt="" width="100px" />
                &#60;/div>
            &#60;/li>
        &#60;/ul>
    )
  }

  export default Products;
        </pre>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #bootstrap data-anchor="bootstrap">Bootstrap</h3>
  <ul>
    <pre>
  npm install bootstrap
    </pre>
    <li>A telepítés után importálnunk kell a csomagot
      <ul>
        <ol>Globális használat
          <ul>
            <li>Az index.js fájlban tesszük</li>
            <pre>
  <b>// index.js</b>
  import 'bootstrap/dist/css/bootstrap.min.css';
            </pre>
            <li>Az index.scss fájlban tesszük</li>
            <pre>
  <b>// index.scss</b>
  @import '~bootstrap/scss/bootstrap';
            </pre>
          </ul>
        </ol>
        <li>Komponens használat
          <ul>
            <li>Abban a komponensben helyezzük el az importot, ahol használni szeretnénk</li>
            <li>Nem a leghatékonyabb, mert a komponens újrarenderelésekor újra importálásra kerül q csomag</li>
            <pre>
  import 'bootstrap/dist/css/bootstrap.min.css';
            </pre>
          </ul>
        </li>
      </ul>
    </li>
    <pre>
  <b>// index.js</b>
  import React from 'react';
  import ReactDOM from 'react-dom/client';
  import './index.scss';
  import App from './App';
  import reportWebVitals from './reportWebVitals';

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(&#60;App />);

  <b>// index.scss</b>
  @import '~bootstrap/scss/bootstrap';

  body &#123;
    background: #00b09b;
    background: -webkit-linear-gradient(to right, #00b09b, #96c93d);
    background: linear-gradient(to right, #00b09b, #96c93d);
    min-height: 100vh;
    padding: 20px;
  }

  .text-gray &#123;
    color: #aaa;
  }

  <b>// App.js</b>
  import './App.scss';
  import Products from './components/Products';

  function App() &#123;
    return (&#60;div className='row'>
      &#60;div className='col-lg-8 mx-auto'>
        &#60;Products />
      &#60;/div>
    &#60;/div>);
  }

  export default App;

  <b>// Products.js</b>
  function Products() &#123;
    return (
        &#60;ul className="list-group shadow">
            &#60;li className="list-group-item">
                &#60;div className="media align-items-lg-center flex-column flex-lg-row p3">
                    &#60;div className="media-body order-2 order-lg-1">
                        &#60;h5 className="mt-0 font-weight-bold mb-2">Fresh milk&#60;/h5>
                        &#60;p className="font-italic text-muted mb-0 small">Donec quam felis, ultricies nec&#60;/p>
                        &#60;div className="d-flex align-items-center justified-content-between mt-1">
                            &#60;h6 className="font-weight-bold my-2">499 HUF&#60;/h6>
                        &#60;/div>
                    &#60;/div>
                    &#60;img src="https://picsum.photos/100/100?blur=2&random=1" alt="" width="100px" className="ml-lg-5 order-1 order-lg-2" />
                &#60;/div>
            &#60;/li>
            &#60;li className="list-group-item">
                &#60;div className="media align-items-lg-center flex-column flex-lg-row p3">
                    &#60;div className="media-body order-2 order-lg-1">
                        &#60;h5 className="mt-0 font-weight-bold mb-2">Banana&#60;/h5>
                        &#60;p className="font-italic text-muted mb-0 small">Nullam dictum felis eu pede&#60;/p>
                        &#60;div className="d-flex align-items-center justified-content-between mt-1">
                            &#60;h6 className="font-weight-bold my-2">230 HUF&#60;/h6>
                        &#60;/div>
                    &#60;/div>
                    &#60;img src="https://picsum.photos/100/100?blur=2&random=2" alt="" width="100px" className="ml-lg-5 order-1 order-lg-2" />
                &#60;/div>
            &#60;/li>
        &#60;/ul>
    )
  }

  export default Products;
    </pre>
    <img src="../../assets/imgs/react_bootstrap.png" alt="" style="max-width: 100%">
  </ul>
</div>

<div>
  <h3 #dynamiccontent data-anchor="dynamiccontent">Dynamic content</h3>
  <ul>
    <li>A JSX kódban a kapcsos zárójelek közé ( &#123;} ) bármilyen Javascript kifejezés beírható
      <ul>
        <li>Használhatunk akár függvényt is
          <ul>
            <li>Sőt, a függvényből visszatérhetünk akár JSX kóddal is, hiszen kompilálva lesz React elemként</li>
          </ul>
        </li>
      </ul>
    </li>
    <pre>
  <b>// Products.js (className-ek kiszedve)</b>
  let productCount1 = 0;
  let productCount2 = 0;

  function displayFormattedProductCount() &#123;
      const returnValue = &#60;small>zero&#60;/small>; // változó is kaphat JSX kifejez
      // return productCount1 > 0 ? productCount1 : 'Zero';
      // return productCount1 > 0 ? productCount1 : &#60;small>zero&#60;/small>;
      return productCount1 > 0 ? productCount1 : returnValue;
  }

  function Products() &#123;
      return (
          &#60;ul>
              &#60;li>
                  &#60;div>
                      &#60;div>
                          &#60;h5>Fresh milk&#60;/h5>
                          &#60;p>Donec quam felis, ultricies nec&#60;/p>
                          &#60;div>
                              &#60;h6>499 HUF&#60;/h6>
                              &#60;button className="btn btn-primary">-&#60;/button>
                              &#60;span>&#123;displayFormattedProductCount()}&#60;/span>
                              &#60;button className="btn btn-primary">+&#60;/button>
                          &#60;/div>
                      &#60;/div>
                      &#60;img src="https://picsum.photos/100/100?blur=2&random=1" alt="" width="100px" />
                  &#60;/div>
              &#60;/li>
              &#60;li>
                  &#60;div>
                      &#60;div>
                          &#60;h5>Banana&#60;/h5>
                          &#60;p>Nullam dictum felis eu pede&#60;/p>
                          &#60;div>
                              &#60;h6>230 HUF&#60;/h6>
                              &#60;button className="btn btn-primary">-&#60;/button>
                              &#60;span>&#123;productCount2}&#60;/span>
                              &#60;button className="btn btn-primary">+&#60;/button>
                          &#60;/div>
                      &#60;/div>
                      &#60;img src="https://picsum.photos/100/100?blur=2&random=2" alt="" width="100px" />
                  &#60;/div>
              &#60;/li>
          &#60;/ul>
      )
    }

    export default Products;
    </pre>
  </ul>
</div>

<div>
  <h3 #jsxattributes data-anchor="jsxattributes">JSX attributes</h3>
  <ul>
    <li>Az attribútum egy XML elem property</li>
    <li>A HTML, és a JSX nagyon hasonlít az XML leíró nyelvre
      <ul>
        <li>Mindháromnak lehetnek attribútumai</li>
        <li>Ilyen attribútum JSX esetében például a className, az src, stb.</li>
      </ul>
    </li>
    <li>A legtöbb esetben a JSX attribútum nagyon hasonló a HTML attribútumhoz
      <ul>
        <li>Akad néhány, ami nem úgy működik, mint a HTML-ben</li>
      </ul>
    </li>
    <li>src
      <ul>
        <li>Külső hivatkozások tekintetében nincs változás</li>
        <pre>
  &#60;img src="https://picsum.photos/100/100?blur=2&random=1" alt="" width="100px" />
        </pre>
        <li>Ugyanakkor a megszokott módon a lokális képek beszúrása nem működik</li>
        <pre>
  &#60;img src="../../assets/imgs/process.png" style="width: 100%;"> // rossz
        </pre>
        <li>A require metódusnak szükséges átadni az image path-jét, és az egészet kapcsos zárójelbee tenni
          <ul>
            <li>Ilyenkor a Webpack kezeli a képet build során</li>
          </ul>
        </li>
        <pre>
  &#60;img src=&#123;require('../../assets/imgs/process.png')} alt="" width="100px" height="100px">&#60;/img>

  OR

  &#60;img src=&#123;require('../../assets/imgs/process.png')} alt="" width="100px" height="100px" /img>

  OR

  let imageUrl = require('../../assets/imgs/process.png');
  ...
  &#60;img src=&#123;imageUrl} alt="" width="100px" height="100px" /img>
        </pre>
        <li>Modernebb megközelítés az import használata</li>
        <pre>
  import processImg from './assets/imgs/process.png';
  ...
  &#60;img src=&#123;processImg} alt="Process" width="100px" height="100px" />
        </pre>
        <li>Ha a képet a public mappába helyeztük, akkor közvetlenül hivatkozhatunk rá
          <ul>
            <li>Érdemes itt létrehozni egy assets mappát a különféle file-oknak</li>
            <li>React esetén ez közvetlenül a build gyökérhez kerül</li>
            <li>Az útvonal az /public mappából indul</li>
            <li>Nincs szükség require() vagy dinamikus importálásra</li>
            <pre>
  &#60;img src="/assets/imgs/process.png" alt="Process" width="100px" height="100px" />
            </pre>
          </ul>
        </li>
      </ul>
    </li>
    <li>style
      <ul>
        <li>Objektumot vár
          <ul>
            <li>Ezért szükséges a dupla kapcsos zárójel, a külső, hogy JS kifejezést fogunk írni, a belső pedig az
              objektum</li>
          </ul>
        </li>
        <pre>
  &#60;div style=&#123; &#123; fontSize: 30, padding: 100 }}>&#60;/div>

  OR

  let styles = &#123;
    padding: '0px 20px',
    margin: 20, // a React hozzáilleszti a px-t
    'font-size': 30, // a kötőjeles css szabályok idézőjelben írandóak
    fontWeight: isActive ? 'bold' : 'normal', // feltételes stílus
  }

  &#60;div style=&#123;styles}>&#60;/div>
        </pre>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #dynamicclasses data-anchor="dynamicclasses">Dynamic classes</h3>
  <ul>
    <pre>
  <b>// Products.js</b>
  let isAvailable1 = 'Available';
  let badgeClass1 = 'badge ';
  badgeClass1 += isAvailable1 === 'Available' ? 'bg-success' : 'bg-danger';

  let isAvailable2 = 'Unavailable';
  let badgeClass2 = 'badge ';
  badgeClass2 += isAvailable2 === 'Available' ? 'bg-success' : 'bg-danger';

  function Products() &#123;
    return (
      ...
      &#60;div className=&#123;badgeClass1}>&#123;isAvailable1}&#60;/div>
      ...
      &#60;div className=&#123;badgeClass2}>&#123;isAvailable2}&#60;/div>
      ...
    )
  }

  export default Products;
    </pre>
    <li>Az isAvailable1 változó 'Available' értéket kap, míg az isAvailable2 változó 'Unavailable' értéket</li>
    <li>Az isAvailable1 és isAvailable2 értékei alapján a megfelelő háttérszínű osztályok (bg-success vagy bg-danger)
      kerülnek hozzáadásra a badgeClass1 és badgeClass2 változókhoz</li>
    <li>Az első div zöld színű badge-t fog tartalmazni (mivel isAvailable1 === 'Available'), és az Available szöveget
      jeleníti meg</li>
    <li>A második div piros színű badge-t tartalmaz (mivel isAvailable2 === 'Unavailable'), és az Unavailable szöveget
      jeleníti meg</li>
  </ul>
  <img src="../../assets/imgs/react_available.png" style="max-width: 100%">
  <br>
  <br>
</div>

<div>
  <h3 #props data-anchor="props">Props</h3>
  <ul>
    <li>A prop-okat arra használjuk, hogy adatot adjunk át az egyik komponenstől a másiknak
      <ul>
        <li>Pontosabban a szülő komponenstől a gyerek komponensnek</li>
      </ul>
    </li>
    <li>A szülő komponensben többször meghívva a gyereket, újra felhasználhatjuk ugyanazt a komponenst
      <ul>
        <pre>
  <b>// App.js</b>
  function App() &#123;
    return (&#60;div className='row'>
      &#60;div className='col-lg-8 mx-auto'>
        &#60;Products />
        &#60;Products />
        &#60;Products />
      &#60;/div>
    &#60;/div>);
  }
        </pre>
        <li>Ezzel még csak azt értük el, hogy 3x ugyanazt jelenítjük meg</li>
      </ul>
    </li>
    <li>A szülő (app) komponensben létrehozunk 3 darab terméket</li>
    <pre>
  let products = [
    &#123;
      id: 1,
      name: 'Fresh milk',
      desc: 'Lorem ipsum dolor sit amet',
      isAvailable: true,
      image: 'https://picsum.photos/100/100?blur=2&random=1',
      price: 400
    },
    &#123;
      id: 2,
      name: 'Fresh milk',
      desc: 'Curabitur gravida arcu ac turpis',
      isAvailable: true,
      image: 'https://picsum.photos/100/100?blur=2&random=2',
      price: 230
    },
    &#123;
      id: 3,
      name: 'Fresh milk',
      desc: 'Sed ut perspiciatis unde omnis',
      isAvailable: false,
      image: 'https://picsum.photos/100/100?blur=2&random=3',
      price: 355
    }
  ]
    </pre>
    <li>A products komponenst úgy használjuk, mint egy HTML elemet
      <ul>
        <li>Tehát adható neki attribútum</li>
        <li>Odaadhatunk neki egy általunk választott/elnevezett attribútumot</li>
        <pre>
  <b>// App.js</b>
  &#60;Products 
            id=&#123;products[0].id} // ezek az attribútumok jelennek meg a data propertyben
            name=&#123;products[0].name}
            desc=&#123;products[0].desc} 
            isAvailable=&#123;products[0].isAvailable}
            image=&#123;products[0].image}
            price=&#123;0products[0].price}
    />
  &#60;Products />
  &#60;Products />

  <b>// Products.js</b>
  function Products(data) &#123; ... }
        </pre>
        <li>A products komponens nem más, mint egy függvény</li>
        <li>Alapértelmezés szerint minden komponens függvény alapértelmezetten kap egy paramétert
          <ul>
            <li>Erről a React gondoskodik</li>
            <li>Ez a paraméter egy objektum, ami tartalmazza az átadott attribútumokat</li>
          </ul>
        </li>
        <li>A gyerek komponensben a paraméter objektumban benne lesznek azok a kulcs-érték párok, amiket a szülő
          komponensben átadunk a gyereknek</li>
        <li>Konvenció alapján a property neve 'props'</li>
        <li>A kommenteket a JSX-en belül
          <ul>
            <li>A // szintaxis nem működik JSX-en belül, csak a JavaScript kódokban</li>
            <pre>
  &#60;div className="first">First&#60;/div>
  &#123;/* &#60;div className="second">Second&#60;/div> */}
            </pre>
          </ul>
        </li>
      </ul>
    </li>
    <pre>
  <b>// App.js</b>
  function App() &#123;
    return (&#60;div className='row'>
      &#60;div className='col-lg-8 mx-auto'>
        &#60;Products
          id=&#123;products[0].id}
          name=&#123;products[0].name}
          desc=&#123;products[0].desc}
          isAvailable=&#123;products[0].isAvailable}
          image=&#123;products[0].image}
          price=&#123;products[0].price}
        />
        &#60;Products
          ...attribútumok egyesével, csak products[1]
        />
        &#60;Products
        ...attribútumok egyesével, csak products[2]
        />
      &#60;/div>
    &#60;/div>);
  }

  VAGY EGY ELEGÁNSABB MÓD

  function App() &#123;
    return (&#60;div className='row'>
      &#60;div className='col-lg-8 mx-auto'>
          &#123;products.map(product => (
            &#60;Products
              key=&#123;product.id}
              id=&#123;product.id}
              name=&#123;product.name}
              desc=&#123;product.desc}
              isAvailable=&#123;product.isAvailable}
              image=&#123;product.image}
              price=&#123;product.price}
            />
          ))}
      &#60;/div>
    &#60;/div>);
  }
    </pre>
    <li>A map() iteráló függvény segítségével végigmegyünk a products tömbön
      <ul>
        <li>Minden tömbelemnél keletkezik egy új products komponens, a megfelelő attribútumokkal</li>
        <li>Mivel a React listát generál, szükség van egy egyedi kulcsra, hogy a React jobban tudja kezelni a
          komponensek újrarenderelését (key)</li>
      </ul>
    </li>
    <pre>
  function Products(props) &#123;
    return (
      &#60;div>
        &#60;h2>&#123;props.name}&#60;/h2>
        &#60;p>&#123;props.desc}&#60;/p>
        &#60;div className=&#123;`badge $&#123;props.isAvailable ? 'bg-success' : 'bg-danger'}`}>
            &#123;props.isAvailable ? 'Available' : 'Unavailable'}
        &#60;/div>
        &#60;img src=&#123;props.image} alt=&#123;props.name} />
        &#60;p>&#123;props.price} HUF&#60;/p>
      &#60;/div>
    );
  }

  VAGY LOKÁLIS VÁLTOZÓKKAL

  function Products(props) &#123;
    let badgeClass = 'badge';
    badgeClass += props.isAvailable ? 'bg-success' : 'bg-danger';

    return (
      &#60;div>
        &#60;h2>&#123;props.name}&#60;/h2>
        &#60;p>&#123;props.desc}&#60;/p>
        &#60;div className=&#123;badgeClass}}>
            &#123;props.isAvailable ? 'Available' : 'Unavailable'}
        &#60;/div>
        &#60;img src=&#123;props.image} alt=&#123;props.name} />
        &#60;p>&#123;props.price} HUF&#60;/p>
      &#60;/div>
    );
  }

  VAGY DESTRUCTORING-ET ALKALMAZVA

  function Products(&#123; id, name, desc, isAvailable, image, price }) &#123;
    return (
      &#60;div>
        &#60;h2>&#123;name}&#60;/h2>
        &#60;p>&#123;desc}&#60;/p>
        &#60;div className=&#123;`badge $&#123;isAvailable ? 'bg-success' : 'bg-danger'}`}>
            &#123;isAvailable ? 'Available' : 'Unavailable'}
        &#60;/div>
        &#60;img src=&#123;image} alt=&#123;name} />
        &#60;p>&#123;price} HUF&#60;/p>
      &#60;/div>
    );
  }
    </pre>
    <li>Built-in prop-ok
      <ul>
        <li>Olyan speciális tulajdonságok, amelyeket a React natívan támogat, és amelyek bizonyos viselkedéseket
          határoznak meg a komponenseken belül</li>
        <ol>
          <li>key
            <ul>
              <li>Segít a React-nek hatékonyan újrarenderelni a listákat</li>
              <li>Minden egyedi elemhez egyedi kulcsot kell rendelni</li>
              <pre>
  const items = ['Apple', 'Banana', 'Cherry'];

  function FruitList() &#123;
    return (
      &#60;ul>
        &#123;items.map((item, index) => (
          &#60;li key=&#123;index}>&#123;item}&#60;/li>
        ))}
      &#60;/ul>
    );
  }
              </pre>
            </ul>
          </li>
          <li>children
            <ul>
              <li>A komponens belsejébe ágyazott JSX vagy egyéb tartalom</li>
              <pre>
  const Modal = (props) => &#123;
    return &#60;div className="modal">&#123;props.children}&#60;/div>;
  };

  // OR: destructuring, a props objektumot "szétszedjük", és rögtön külön változóként kapjuk meg a children-t

  const Modal = (&#123; children }) => &#123; // ( &#123;children, title, onClose ...} )
    return &#60;div className="modal">&#123;children}&#60;/div>;
  };
  
  function App() &#123;
    return (
      &#60;Card>
        &#60;h2>Hello, World!&#60;/h2>
        &#60;p>This is inside the card.&#60;/p>
      &#60;/Card>
    );
  }
              </pre>
            </ul>
          </li>
          <li>ref
            <ul>
              <li>A DOM vagy egy React-komponens referencia megszerzésére szolgál</li>
              <pre>
  import &#123; useRef, useEffect } from 'react';

  function InputFocus() &#123;
    const inputRef = useRef(null);

    useEffect(() => &#123;
      inputRef.current.focus();
    }, []);

    return &#60;input ref=&#123;inputRef} type="text" />;
  }
              </pre>
            </ul>
          </li>
          <li>dangerouslySetInnerHTML
            <ul>
              <li>Nyers HTML beillesztésére szolgál</li>
              <li>Veszélyes lehet XSS támadások miatt</li>
              <pre>
  const rawHTML = &#123; __html: '<h1>Dangerous Content</h1>' };

  function DangerousComponent() &#123;
    return &#60;div dangerouslySetInnerHTML=&#123;rawHTML} />;
  }
              </pre>
            </ul>
          </li>
          <li>suppressHydrationWarning
            <ul>
              <li>Ha SSR (Server-Side Rendering) során eltérések vannak a szerver és a kliens között, ezzel el lehet
                nyomni a figyelmeztetéseket</li>
              <pre>
  &#60;p suppressHydrationWarning>&#123;process.env.SERVER_TIME}&#60;/p>
              </pre>
            </ul>
          </li>
          <li>defaultProps
            <ul>
              <li>Alapértelmezett értékeket ad egy komponens prop-jainak</li>
              <pre>
  const Button = (&#123; text }) => &#60;button>&#123;text}&#60;/button>;

  Button.defaultProps = &#123;
    text: "Click me",
  };
              </pre>
            </ul>
          </li>
        </ol>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #splittingcomponents data-anchor="splittingcomponents">Splitting components</h3>
  <ul>
    <li>A komponensek lehetőséget biztosítanak arra, hogy kisebb blokkokra szedjük szét az applikációnkat</li>
    <pre>
  <b>// App.js</b>
  function App() &#123;
    return (&#60;div className='row'>
      &#60;div className='col-lg-8 mx-auto'>
        &#60;ul className="list-group shadow">
          &#123;products.map(product => (
            &#60;Products
              key=&#123;product.id}
              id=&#123;product.id}
              name=&#123;product.name}
              desc=&#123;product.desc}
              isAvailable=&#123;product.isAvailable}
              image=&#123;product.image}
              price=&#123;product.price}
            />
          ))}
        &#60;/ul>
      &#60;/div>
    &#60;/div>);
  }
  
  export default App;

  <b>// Products.js</b>
  function Products(props) &#123;
    console.log(props);
    return (
        &#60;li className="list-group-item">
            &#60;div className="media align-items-lg-center flex-column flex-lg-row p3 d-flex justify-content-between">
                &#60;div className="media-body order-2 order-lg-1">
                    &#60;h5 className="mt-0 font-weight-bold mb-2">
                        &#123;props.name}
                    &#60;/h5>
                    &#60;p className="font-italic text-muted mb-0 small">
                        &#123;props.desc}
                    &#60;/p>
                    &#60;ProductDetails
                        price=&#123;props.price}
                    />
                    &#60;div className=&#123;`badge $&#123;props.isAvailable ? 'bg-success' : 'bg-danger'}`}>
                        &#123;props.isAvailable ? 'Available' : 'Unavailable'}
                    &#60;/div>
                &#60;/div>
                &#60;img src=&#123;props.image} alt="" width="100px" className="ml-lg-5 order-1 order-lg-2" />
                &#123;/*&#60;img src=&#123;require('' + props.image)} alt="" width="100px" className="ml-lg-5 order-1 order-lg-2" /> külső url, ha az image any típusú, akkor így alakítható string-é  */}
            &#60;/div>
        &#60;/li>
      )
  }
  
  export default Products;
  
  <b>// ProductDetails.js</b>
  function ProductDetails(props) &#123;
    return (
        &#60;div className="d-flex align-items-center justified-content-between mt-1">
            &#60;h6 className="font-weight-bold my-2 pe-2">
                &#123;props.price} HUF
            &#60;/h6>
            &#60;button className="btn btn-primary">-&#60;/button>
            &#60;span>&#123;displayFormattedProductCount()}&#60;/span>
            &#60;button className="btn btn-primary">+&#60;/button>
        &#60;/div>
    )
  }

  export default ProductDetails;
    </pre>
    <li>Elérhetjük így, hogy egy komponens kevesebb JSX kódot tartalmazzon, így pedig könnyebben karbantartható</li>
    <li>Nincs ökölszabály, hogy mekkora kódrészletet tartalmazzon egyetlen komponens</li>
    <li>A komponensek pedig újra felhasználhatóak más komponensekben</li>
  </ul>
</div>

<div>
  <h3 #childrenprops data-anchor="childrenprops">Children props</h3>
  <ul>
    <li>A props.children egy speciális property a React komponensekben, amely automatikusan elérhető, amikor egy másik
      komponenst belső tartalommal hívunk meg
      <ul>
        <li>A JSX-ben egy komponens nyitó- és záró tag-jei közé helyezett tartalom a children property-ben érhető el
        </li>
        <li>Self-closing tag-et használva a props.children undefined</li>
        <pre>
  &#60;ProductDetails />
        </pre>
      </ul>
      <ol>
        <li>Ha stringet adunk át
          <ul>
            <li>A props.children egyszerű string lesz</li>
          </ul>
        </li>
        <li>Ha JXS-et adunk át
          <ul>
            <li>A props.children egy JSX-objektum lesz</li>
            <pre>
  const reactElement = &#123;
    $$typeof: Symbol('react.element'),
    key: null,
    props: &#123;
      children: 'Hello!',
    },
    ref: null,
    type: 'p',
    _owner: &#123;
      tag: 0,
      key: '3',
      stateNode: null,
      elementType: Function
      type: Function
    },
    _store: &#123;
      validated: true,
    },
    _self: undefined,
    _source: &#123;
      fileName:
        '/Users/user/Downloads/angular/practice/alapok/src/react/react-app/course/src/components/Products.js',
      lineNumber: 21,
      columnNumber: 25,
    },
  };              
            </pre>
          </ul>
        </li>
        <li>Ha több JSX-et adunk át
          <ul>
            <li>A props.children egy tömb lesz, amely tartalmazza a JSX-objektumokat</li>
            <pre>
  const elements = [
  &#123;
    $$typeof: Symbol('react.element'),
    key: null,
    props: &#123;
      children: 'Hello!',
    },
    ref: null,
    type: 'p',
    _owner: &#123;
      tag: 0,
      key: '3',
      stateNode: null,
      elementType: Function, // itt egy funkció referenciája van
      type: Function,        // itt egy másik funkció referenciája van
      // ...egyéb FiberNode tulajdonságok
    },
    _store: &#123;
      validated: true,
    },
    _self: undefined,
    _source: &#123;
      fileName:
        '/Users/user/Downloads/angular/practice/alapok/src/react/react-app/course/src/components/Products.js',
      lineNumber: 21,
      columnNumber: 25,
    },
  },
  &#123;
      $$typeof: Symbol('react.element'),
      key: null,
      props: &#123;
        children: 'Szia!',
      },
      ref: null,
      type: 'p',
      _owner: &#123;
        tag: 0,
        key: '3',
        stateNode: null,
        elementType: Function
        type: Function
      },
      _store: &#123;
        validated: true,
      },
      _self: undefined,
      _source: &#123;
        fileName:
          '/Users/user/Downloads/angular/practice/alapok/src/react/react-app/course/src/components/Products.js',
        lineNumber: 22,
        columnNumber: 25,
      },
    },
  ];
            </pre>
          </ul>
        </li>
      </ol>
    </li>
    <pre>
  <b>// Products.js</b>
  function ProductDetails(props) &#123;
    console.log(props.children);
    return (
        &#60;div className="d-flex align-items-center justified-content-between mt-1">
            &#60;h6 className="font-weight-bold my-2 pe-2">
                &#123;props.price} HUF
            &#60;/h6>
            &#60;Button>-&#60;/Button>
            &#60;span>&#123;displayFormattedProductCount()}&#60;/span>
            &#60;Button>+&#60;/Button>
            &#123;props.children}
        &#60;/div>
    )
  }

  export default ProductDetails;

  <b>// Button.js</b>
  function Button(props) &#123;
    return &#60;button className="btn btn-primary">&#123;props.children}&#60;/button>
  }
  
  export default Button;
    </pre>
    <li>Komponens attribútumnak megadhatjuk akár a children-t is
      <ul>
        <li>Nem kerül alkalmazásra, amennyiben a nyitó- és záró tag-ek közé kódot helyeztünk el</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #jsxsyntax data-anchor="jsxsyntax">JSX syntax</h3>
  <ul>
    <li>A 2 fő package a package.json fájlban a react, és a react-dom
      <ul>
        <li>A React-ot és a ReactDOM-ot az index.js fájlban használjuk</li>
        <pre>
  import React from 'react'; // csak a korábbi React verziókban szükséges beimportálni
  import ReactDOM from 'react-dom/client';

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(&#60;App />);
        </pre>
        <li>Az első sort ki is törölhetjük, nem használjuk, és nélküle is fog működni az alkalmazás</li>
      </ul>
    </li>
    <li>A JSX kód a projekt kompilálásakor átkonvertálódik JavaScript kóddá
      <ul>
        <li>Ekkor meghívódik a createElement metódus, ami a React objektumban van jelen</li>
        <pre>
  function Numbers(props) &#123;
    return (
      &#60;ul>
        &#60;li>One&#60;/li> 
        &#60;li>Two&#60;/li> 
      &#60;/ul>
    )
  }
        </pre>
        <li>A háttérben a React.createElement() hívódik meg
          <ul>
            <li>Direkt módon nem használjuk a React objektumot</li>
            <li>Az újabb verziókba implicit módon be van importálva</li>
            <li>Ezért láthatjuk minden korábbi verziójú komponens fájlban az importálást
              <ul>
                <li>import React from 'react';</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Nézzük meg, hogy miképp lehetne egy komponenst átalakítani (JSX helyett Javascriptet használunk)</li>
        <pre>
  function ProductDetails(props) &#123;
    return (
        &#60;div className="d-flex align-items-center justified-content-between mt-1">
            &#60;h6 className="font-weight-bold my-2 pe-2">
              &#123;props.price} HUF
            &#60;/h6>
            &#60;Button>-&#60;/Button>
            &#60;span>&#123;displayFormattedProductCount()}&#60;/span>
            &#60;Button>+&#60;/Button>
            &#123;props.children}
        &#60;/div>
    )
  }

  function ProductDetails(props) &#123;
      return React.createElement('div',  className: 'd-flex align-items-center justified-content-between mt-1' },
        React.createElement('h6', &#123; className: 'font-weight-bold my-2 pe-2' }, props.price),
        React.createElement(Button, &#123;}, '-'),
        React.createElement('span', &#123;}, displayFormattedProductCount()),
        React.createElement(Button, &#123;}, '+'),
        props.children
  }
        </pre>
        <li>A createElement első argomentuma a tag, a második a tag attribútumai, a harmadik pedig a tartalma, ami a
          nyitó- és záró tag-ek között található</li>
        <li>Itt is wrap-eltük az elemeket egy div-be
          <ul>
            <li>A return egy értéket tud visszaadni</li>
          </ul>
        </li>
        <li>A JSX-et könnyebb megérteni, és használni</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #eventsandstates data-anchor="eventsandstates">Events and states</h3>
  <ul>
    <li>Event handler attribútumot használunk</li>
    <pre>
  function btnEventHandler() &#123;
    console.log('click');
  }
  
  function Button(props) &#123;
      return (
          &#60;button onClick=&#123;btnEventHandler}
              onMouseOver=&#123;btnEventHandler}
              className="btn btn-primary">
              &#123;props.children}
          &#60;/button>
      )
  }
  
  export default Button;
    </pre>
    <li>Camel case-t használunk, azaz az event-eknél az on mindig kisbetűs, a többi szó pedig nagybetűs</li>
    <li>Bármikor esemény történik, a event attribútumba írt JavaScript kifejezés lefut
      <ul>
        <li>A Javascriptet kapcsos zárójelek közé írjuk</li>
        <li>Amennyiben függvényt hívunk, nem rakunk mögé zárójelet, mert akkor azonnal meghívódik a függvény, ahogy
          betöltődik az oldal
          <ul>
            <li>A kapcsos zárójelben csak referenciát adunk át</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Amennyiben custom komponensre rakunk event attribútumot, nem fog működni
      <ul>
        <li>Legalábbis nem, mint event handler</li>
        <li>A komponens nem más, mint egy függvény</li>
        <li>Amennyiben mégis megtesszük, úgy a props objektumban készítunk egy property-t</li>
        <pre>
  <b>// ProductDetails.js</b>
  let productCount = 0;
  
  function ProductDetails(props) &#123;
    let decrementCounter = function () &#123;
      productCount--;
    }
    return (
      &#60;Button onClick=&#123;decrementCounter}>-&#60;/Button>
    )
  }

  <b>// Button.js</b>
  function Button(props) &#123;
    console.log(props);
    return (
        &#60;button
            onClick=&#123;btnEventHandler}
            className="btn btn-primary">
            &#123;props.children}
        &#60;/button>
    )
  }

  <b>// console.log()</b>
  &#123;
    "children": "-",
    "onClick": &#123; // valóban itt van property-ként
      "name": "decreaseCounter",
      "length": 0,
      "prototype": &#123;},
      "location": "ProductDetails.js:13",
      "scopes": [
        &#123;
          "type": "Closure",
          ...
        },
        &#123;
          "type": "Global",
          ...
        }
      ]
    }
  }        
        </pre>
      </ul>
    </li>
    <li>Nézzük meg, hogy lehetne mégis megoldani, hogy a custom komponensnek legyen hatása a szülőre
      <ul>
        <pre>
  <b>// ProductDetails.js</b>
  let productCount = 0;

  function displayFormattedProductCount() &#123;
    const returnValue = &#60;small>zero&#60;/small>; // változó is kaphat JSX kifejez
    return productCount > 0 ? productCount : returnValue;
  }

  function ProductDetails(props) &#123;
    let decrementCounter = function () &#123; // callback function
        productCount--;
        console.log('decrease');
    }

    let incrementCounter = function () &#123; // callback function
        productCount++;
        console.log('increase');
    }

    return (
        &#60;div className="d-flex align-items-center justified-content-between mt-1">
            &#60;h6 className="font-weight-bold my-2 pe-2">
                &#123;props.price} HUF
            &#60;/h6>
            &#60;Button eventHandler=&#123;decrementCounter}>-&#60;/Button>
            &#60;span>&#123;displayFormattedProductCount()}&#60;/span>
            &#60;Button eventHandler=&#123;incrementCounter}>+&#60;/Button>
            &#123;props.children}
        &#60;/div>
    )
  }
        </pre>
        <li>Az eventHandler property bekerül a custom komponens props objektumába, és a decrementCounter függvény
          referenciáját tartalmazza</li>
        <li>Átadjuk az onClick event handler attribútumnak a szülőből a custom komponensbe a függvény referenciákat</li>
        <li>Ezzel így a productCount komponensre glibális változót változtatjuk, és az összes + és - gomb egyetlen
          értéket változtat</li>
        <li>Ezért a ProductDetails függvényben kell deklarálnunk a productCount változót</li>
        <pre>
  function ProductDetails(props) &#123;
    let productCount = 0;

    function displayFormattedProductCount() &#123;
      const returnValue = &#60;small>zero&#60;/small>; // változó is kaphat JSX kifejez
      return productCount > 0 ? productCount : returnValue;
    }

    ...
  }
        </pre>
        <li>Ezen a ponton még mindig zero jelenik meg a - és + gombok között a click eventek lefutásakor
          <ul>
            <li>A gombok nem fogják újra meghívni a ProductDetails komponenst/függvényt</li>
            <li>A productCount változó megváltozik, de a JSX nem fog újra visszatérni</li>
            <li>A counter-ek mindig zero állapotban maradnak</li>
            <li>Alapértelmezetten a React ignorálja a változók megváltozását</li>
          </ul>
        </li>
        <li>Ahhoz, hogy újrarenderelés történjen, a useState függvényt szükséges használnunk
          <ul>
            <li>React hook</li>
            <li>Állapotot biztosít a funkcionális komponensekben
              <ul>
                <li>a React állapotot tartja fenn két új renderelés között</li>
              </ul>
            </li>
            <li>Kizárólag komponens függvényben hívhatjuk meg</li>
            <li>Érdemes a React DevTools bővítményt feltelepíteni a böngészőbe</li>
            <li>Az osztályalapú komponensekben használt állapotkezelést váltja ki, így nincs szükség this.setState, vagy
              más osztálymódszerek használatára</li>
            <pre>
  <b>// ProductDetails.js</b>
  import React, &#123;useState} from 'react'; // named import

  function ProductDetails(props) &#123;
    useState(0);
  }
            </pre>
            <li>A useState első argomentuma a kiindulási érték
              <ul>
                <li>A kezdőértéke lehet szám, string, objektum, vagy akár null</li>
              </ul>
            </li>
            <li>Kételemű tömbbel tér vissza
              <ul>
                <li>Első elem: Az aktuális állapot</li>
                <li>Máspodik elem: Egy függvény, amellyel frissíthetjük az állapotot</li>
              </ul>
            </li>
            <li>A kételemű tömböt array destructuring-gal szokás két változóba bekötni</li>
            <pre>
  <b>// Products.js</b>
  ...
  function Products(props) &#123;
    return (
      ...
      &#60;ProductDetails
            price=&#123;props.price}>
                ID: &#123;JSON.stringify(props.id)} // így lehet debugolni, ha már nincs json pipe
      &#60;/ProductDetails>
      ...
    )
  }

  <b>// ProductDetails.js</b>
  function ProductDetails(props) &#123;
    let [productCount, updateCount] = useState(0);

    ...

    let decrementCount = function () &#123;
      updateCount(--productCount);
      // updateCount(productCount--); // post decrement operátor, a változáshoz két kattintás szükséges
    }

    let incrementCount = function () &#123;
        updateCount(++productCount);
        // updateCount(productCount++); // post increment operátor, a változáshoz két kattintás szükséges
    }

    ...

    return (
        ...
            &#60;h6 className="font-weight-bold my-2 pe-2">
                &#132;props.price} HUF
            &#60;/h6>
            &#60;Button eventHandler=&#123;decrementCount}>-&#60;/Button>
            &#60;span>&#123;displayFormattedProductCount()}&#60;/span>
            &#60;Button eventHandler=&#123;incrementCount}>+&#60;/Button>
            &#123;props.children} // itt jelenik meg a &#123;JSON.stringify(props.id)}
        ...
    )
  }
            </pre>
            <li>Bármikor, amikor megváltozik a productCount értéke, a komponens függvény újra lefut, és az UI frissül
            </li>
            <img src="assets/imgs/react_counter.png" style="width: 100%;">
          </ul>
        </li>
      </ul>
    </li>
    <li>Tehát a useState állapotot/értéket regisztrál a komponensben
      <ul>
        <li>Pontosabban egy kifejezett komponens példányban</li>
        <li>Frissítésre pedig természetesen csak az adott példány állapota változik meg</li>
        <li>Az egyes state-ek teljesen függetlenek egymástól</li>
        <li>Ugyan a komponens függvény újrainicializálódik, de a state kezdőértékét, amit mi adtunk meg, csak az első
          alkalommal veszi figyelembe a React
          <ul>
            <li>Detektálja, hogy már korábban történt inicializálás, és a frissített értéket használja</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>useState nélkül maximum statikus oldalt tudnánk létrehozni, holott a React-ot dinamikus weboldalak
      készítésére találták ki</li>
  </ul>
</div>

<div>
  <h3 #forms data-anchor="forms">Forms</h3>
  <h5 #codereformatting data-anchor="codereformatting">Code reformatting</h5>
  <ul>
    <li>Az összetartozó komponenseket az áttekinthetőség érdekében érdemes külön mappákban elhelyezni</li>
    <li>Az app.js-t (komponenst) lehetőség szerint hagyjuk a lehető legüresebben</li>
    <li>Alább látható az átformált, teljes eddigi kód</li>
    <pre>
  App.js
  components/
  ├── ProductList/
      ├── Button.js
      ├── ProductDetails.js
      ├── ProductList.js
      ├── Product.js

  <b>// App.js</b>
  function App() &#123;
    return (
      &#60;ProductList />
    );
  }
  
  export default App;

  <b>// ProductList.js</b>
  let products = [
      &#123;
          id: 1,
          name: 'Fresh milk',
          desc: 'Lorem ipsum dolor sit amet',
          isAvailable: true,
          image: 'https://picsum.photos/100/100?blur=2&random=1',
          price: 400
      },
      &#123;
          id: 2,
          name: 'Banana',
          desc: 'Curabitur gravida arcu ac turpis',
          isAvailable: true,
          image: 'https://picsum.photos/100/100?blur=2&random=2',
          price: 230
      },
      &#123;
          id: 3,
          name: 'Onion',
          desc: 'Sed ut perspiciatis unde omnis',
          isAvailable: false,
          image: 'https://picsum.photos/100/100?blur=2&random=3',
          price: 355
      }
  ]

  function ProductList(props) &#123;
      return (
          &#60;div className='row'>
              &#60;div className='col-lg-8 mx-auto'>
                  &#60;ul className="list-group shadow">
                      &#123;products.map(product => (
                          &#60;Products
                              key=&#123;product.id}
                              id=&#123;product.id}
                              name=&#123;product.name}
                              desc=&#123;product.desc}
                              isAvailable=&#123;product.isAvailable}
                              image=&#123;product.image}
                              price=&#123;product.price}
                          />
                      ))}
                  &#60;/ul>
              &#60;/div>
          &#60;/div>
      )
  }

  export default ProductList;

  <b>// Product.js</b>
  function Products(props) &#123;
    return (
        &#60;li className="list-group-item">
            &#60;div className="media align-items-lg-center flex-column flex-lg-row p3 d-flex justify-content-between">
                &#60;div className="media-body order-2 order-lg-1">
                    &#60;h5 className="mt-0 font-weight-bold mb-2">
                        &#123;props.name}
                    &#60;/h5>
                    &#60;p className="font-italic text-muted mb-0 small">
                        &#123;props.desc}
                    &#60;/p>
                    &#60;ProductDetails
                        price=&#123;props.price}>
                            ID: &#123;JSON.stringify(props.id)}
                    &#60;/ProductDetails>
                    &#60;div className=&#123;`badge $&#123;props.isAvailable ? 'bg-success' : 'bg-danger'}`}>
                        &#123;props.isAvailable ? 'Available' : 'Unavailable'}
                    &#60;/div>
                &#60;/div>
                &#60;img src=&#123;props.image} alt="" width="100px" className="ml-lg-5 order-1 order-lg-2" />
                &#123;/*&#60;img src=&#123;require('' + props.image)} alt="" width="100px" className="ml-lg-5 order-1 order-lg-2" /> külső url, ha az image any típusú, akkor így alakítható string-é  */}
            &#60;/div>
        &#60;/li>
      )
  }

  export default Products;

  <b>// ProductDetails.js</b>
  function ProductDetails(props) &#123;
    let [productCount, updateCount] = useState(0);

    function displayFormattedProductCount() &#123;
        const returnValue = &#60;small>zero&#60;/small>; // változó is kaphat JSX kifejez
        // return productCount1 > 0 ? productCount1 : 'Zero';
        // return productCount1 > 0 ? productCount1 : &#60;small>zero&#60;/small>;
        return productCount > 0 ? productCount : returnValue;
    }

    let decrementCount = function () &#123;
        updateCount(--productCount);
        // updateCount(productCount--); // post decrement operátor, a változáshoz két kattintás szükséges
    }

    let incrementCount = function () &#123;
        updateCount(++productCount);
        // updateCount(productCount++); // post increment operátor, a változáshoz két kattintás szükséges
    }

    return (
        &#60;div className="d-flex align-items-center justified-content-between mt-1">
            &#60;h6 className="font-weight-bold my-2 pe-2">
                &#123;props.price} HUF
            &#60;/h6>
            &#60;Button eventHandler=&#123;decrementCount}>-&#60;/Button>
            &#60;span>&#123;displayFormattedProductCount()}&#60;/span>
            &#60;Button eventHandler=&#123;incrementCount}>+&#60;/Button>
            &#123;props.children}
        &#60;/div>
    )
  }
  
  export default ProductDetails;

  <b>// Button.js</b>
  function Button(props) &#123;
    return (
        &#60;button
            onClick=&#123;props.eventHandler}
            className="btn btn-primary">
            &#123;props.children}
        &#60;/button>
    )
  }
  
  export default Button;
    </pre>
  </ul>
  <br>
  <h5 #skeleton data-anchor="skeleton">Skeleton</h5>
  <ul>
    <li>A termék hozzáadásának kezdeti lépései</li>
    <pre>
  App.js
  components/
  ├── ProductList/
      ├── Button.js
      ├── ProductDetails.js
      ├── ProductList.js
      ├── Product.js
  ├── CreateProduct/
      ├── CreateProduct.js
      ├── ProductForm.js

  <b>// App.js</b>
  function App() &#123;
    return (
      &#60;div>
        &#60;CreateProduct />
        &#60;ProductList />
      &#60;/div>
    );
  }

  <b>// CreateProduct.js</b>
  function CreateProduct(props) &#123;
    return (
        &#60;div className="row">
            &#60;div className="col-lg-8 mx-auto list-group shadow" style=&#123; &#123; backgroundColor: 'white', marginBottom: '30px', padding: '10px' }}>
                &#60;Form />
            &#60;/div>
        &#60;/div>
    )
  }
  
  export default CreateProduct;
  
  <b>// ProductForm.js</b>
  function ProductForm() &#123;
    return (
        &#60;form className="row g-3">
            &#60;div className="col-md-6">
                &#60;label for="name">Product Name&#60;/label>
                &#60;input type="text"
                    className="form-control"
                    id="name"
                    placeholder="Product Name" />
            &#60;/div>
            &#60;div className="col-md-6">
                &#60;label for="price">Product Price&#60;/label>
                &#60;input type="number"
                    min="0.01" step="0.01"
                    className="form-control"
                    id="price"
                    placeholder="Product Price" />
            &#60;/div>

            &#60;div className="form-group">
                &#60;label for="description">Product Description&#60;/label>
                &#60;input type="text"
                    className="form-control"
                    id="description"
                    placeholder="Product Description" />
            &#60;/div>

            &#60;div class="form-check form-switch">
                &#60;input class="form-check-input" type="checkbox" role="switch" id="isAvailable" />
                &#60;label class="form-check-label" for="isAvailable">Is product available in stock?&#60;/label>
            &#60;/div>

            &#60;div className="form-group">
                &#60;label for="select-image">Select product image&#60;/label>
                &#60;input type="file" className="form-control" id="select-image" />
            &#60;/div>


            &#60;button type="submit" className="btn btn-primary">Add Product&#60;/button>
        &#60;/form>
    )
  }
  
  export default ProductForm;
    </pre>
    <img src="assets/imgs/react_form_basics.png" style="width: 100%;">
    <br>
    <li>Ezzel előállt egy váz, amivel elkezdhetünk dolgozni</li>
    <li>JSX-ben a for attribútum helyett a htmlFor-t kell használni
      <ul>
        <li>A fenti kódban nem így szerepel</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #eventlistener data-anchor="eventlistener">Event listener</h5>
  <ul>
    <li>Ahhoz, hogy begyűjtsük a felhasználó által bevitt adatokat, az input elemekre event listener-eket szükséges
      helyeznünk
      <ul>
        <li>onInput
          <ul>
            <li>Minden billentyűleütésnél lefut</li>
            <li>Csak input elemeken használható</li>
            <li>A natív input esemény React-beli megfelelője</li>
            <pre>
  &#60;input
      type="text"
      value=&#123;value}
      onInput=&#123;(e) => setValue(e.target.value)} // anonymous inlibe function
  />
            </pre>
          </ul>
        </li>
        <li>onChange
          <ul>
            <li>Minden billentyűleütésnél lefut</li>
            <li>Nem csak input elemeken használható
              <ul>
                <li>Dropdown, checkbox, rádiógomb, vagy egyéb más elemeken is működik</li>
                <li>Más típusú inputoknál az esemény akkor váltódik ki, amikor az érték megváltozik</li>
              </ul>
            </li>
            <pre>
  &#60;input
    type="text"
    value=&#123;value}
    onChange=&#123;(e) => setValue(e.target.value)} // anonymous inlibe function
  />
            </pre>
          </ul>
        </li>
        <br>
        <table style="border-collapse: collapse; width: 100%;">
          <thead>
            <tr>
              <th></th>
              <th>onChange</th>
              <th>onInput</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Mikor fut le?</strong></td>
              <td>A változás befejeztével (karakter hozzáadása után, React állapot frissítésekor)</td>
              <td>Azonnal, amikor az érték változik</td>
            </tr>
            <tr>
              <td><strong>Sebesség</strong></td>
              <td>Lassabb, mert figyelni kell a React állapotát is</td>
              <td>Gyorsabb, mert közvetlenül reagál az input eseményre</td>
            </tr>
            <tr>
              <td><strong>Használat</strong></td>
              <td>Leggyakrabban form-validációkhoz vagy állapot kezeléshez</td>
              <td>Olyan esetekben, amikor azonnali visszacsatolás kell (pl. valós idejű keresőmező)</td>
            </tr>
          </tbody>
        </table>
      </ul>
    </li>
    <br>
    <li>Event listenerrel pedig a következőképp dolgozhatunk</li>
    <pre>
  function ProductForm() &#123;

    function nameInputHandler(event) &#123;
      console.log("event: ", event);
    }

    return (
      &#60;div className="col-md-6">
        &#60;label htmlFor="name">Product Name&#60;/label>
        &#60;input type="text"
            className="form-control"
            id="name"
            placeholder="Product Name"
            onChange=&#123;nameInputHandler}
        />
      &#60;/div>
    )
  }
    </pre>
    <li>Vanilla Javascript-et tekintve olyan, mintha kiszelektálnánk egy ID-t, és egy change event listenert
      definiálnánk az input mezőnek</li>
    <pre>
  document.getElementById('name').addEventListener('change', (event) => &#123;
    ...
  });
    </pre>
    <li>Ahányszor lefut az onChange, a 'nameInputHandler' függvény megkapja az event objektumot argomentumként</li>
  </ul>
  <br>
  <h5 #multiplestates data-anchor="multiplestates">Multiple states</h5>
  <ul>
    <li>Több állapotot is rögzíthetünk a komponensünkben</li>
    <pre>
  import React, &#123;useState} from 'react';

  function ProductForm() &#123;
      let [name, updateName] = useState('');
      let [price, priceName] = useState('');
      
      function nameInputHandler(event) &#123;
          updateName(event.target.value);
      }

      function priceInputHandler(event) &#123;
          priceName(event.target.value);
      }

      /* function availableInputHandler(event) &#123;
          priceName(event.target.checked); // value helyett checked 
      } */

      return (
        &#60;form className="row g-3">
          &#60;div className="col-md-6">
              &#60;label htmlFor="name">Product Name&#60;/label>
              &#60;input type="text"
                  className="form-control"
                  id="name"
                  placeholder="Product Name"
                  onChange=&#123;nameInputHandler}
              />
          &#60;/div>
          &#60;div className="col-md-6">
              &#60;label htmlFor="price">Product Price&#60;/label>
              &#60;input type="number"
                  min="0.01" step="0.01"
                  className="form-control"
                  id="price"
                  placeholder="Product Price"
                  onChange=&#123;priceInputHandler}
                  />
          &#60;/div>
        &#60;/form>
      )
  }
    </pre>
    <li>Így a két formban lévő input mező értékét eltároljuk valahol a memóriában, amiket később akár fel is tudunk
      használni</li>
    <li>A valóságban a külön szedett állapotokkal gyakrabban találkozni</li>
    <li>Több state helyett egyetlen state-et is tudunk használni
      <ul>
        <li>A kezdő értéknek ebben az esetben mindenképp objektumnak kell lennie</li>
        <pre>
  let [states, updateStates] = useState(&#123;
      name: '',
      price: 0,
      desc: '',
      available: '',
      url: ''
  });

  function priceInputHandler(event) &#123;
    // updateStates(&#123; price: event.target.value }); // így még mindig biztosítani szükséges, hogy a többi kulcs-érték pár nem veszik el
    updateStates(&#123;
      ...states,
      price: event.target.value
    });
  }

  return (
    &#60;form className="row g-3">
        &#123;JSON.stringify(states)} &#123; /* debug-képp */}

        &#60;div className="col-md-6">
            &#60;label htmlFor="name">Product Name&#60;/label>
            &#60;input type="text"
                className="form-control"
                id="name"
                placeholder="Product Name"
                onChange=&#123;nameInputHandler}
            />
        &#60;/div>
        &#60;div className="col-md-6">
            &#60;label htmlFor="price">Product Price&#60;/label>
            &#60;input type="number"
                min="0.01" step="0.01"
                className="form-control"
                id="price"
                placeholder="Product Price"
                onChange=&#123;priceInputHandler}
            />
        &#60;/div>
    &#60;/form>
  )
        </pre>
        <li>Az event.target.value az input mező értékét jelöli</li>
        <li>A spread operator (...) segítségével átmásoljuk a meglévő állapotot (states), és csak a price kulcsot
          frissítjük az új értékkel
          <ul>
            <li>A spread operátor kibontja az objektumot</li>
            <pre>
  <b>// array</b>
  const parts = ["shoulders", "knees"];
  const lyrics = ["head", ...parts, "and", "toes"];

  //  ["head", "shoulders", "knees", "and", "toes"]

  <b>// object</b>
  const person = &#123; name: 'John', age: 30 };
  const updatedPerson = &#123; ...person, city: 'New York' };

  // &#123; name: 'John', age: 30, city: 'New York' }
            </pre>
          </ul>
        </li>
        <li>Ilyen módon működik az update, de egyrészt nem best practice, másrészt akadnak esetek, amikor még sem a
          kívánt eredményt kapjuk
          <ul>
            <li>Abból ered mindez, hogy az előző állapotra hagyatkozunk</li>
            <li>A teljes objektumot frissítjük</li>
            <pre>
  updateStates(&#123;
    ...states,
    price: event.target.value
  });
            </pre>
            <li>Holott csak a name property-t szeretnénk frissíteni</li>
            <li>Ehelyett callback function-t is adhatunk az update függvényünknek
              <ul>
                <li>Argomentumként a frissítő függvényünk a korábbi state-et kapja meg</li>
                <li>Majd visszatérhetünk a spread operátor segítségével a függvényből</li>
                <pre>
  function priceInputHandler(event) &#123;
    updateStates((prevState) => &#123;
        return &#123; ...prevState, price: event.target.value }
    })
  }
                </pre>
                <li>Ezt a megközelítést szükséges használni, amennyiben függünk az előző állapottól</li>
                <li>A React beidőzíti a state változásokat, és előfordulhat, sok state egyszerre változtatása esetén,
                  hogy nem a megfelelő állapotra támaszkodunk, amennyiben nem callback függvénnyel használjuk a
                  frissítést</li>
                <li>Callback function használatakor a React garantálja, hogy a legutolsó érték kerül számításba</li>
                <li>Mindez primitív értékek használatára is igaz, szóval amikor nem objektumbeli értéket frissítünk</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Alább látható egy potenciális megoldás a különféle mezőtípusok egységesebb kezelésére
          <ul>
            <pre>
  import React, &#123; useState } from 'react';

  function ProductForm() &#123;
    let [states, updateStates] = useState(&#123; // kezdeti állapot inicializálása
        name: '',
        price: 0,
        desc: '',
        available: false,
        imgUrl: ''
    });

    function handleChange(event) &#123;
      let change;
      let &#123; name, value, checked, type } = event.target;

      switch (type) &#123;
          case 'text':
              change = value;
              break;
          case 'number':
              change = value;
              break;
          case 'checkbox':
              change = checked;
              break;
          case 'file':
              change = value;
              break;
          default: return;
      }
      
      updateStates((prevState) => &#123;
          return &#123; ...prevState, [name]: change }
      });
    }

    return (
      &#60;form>
              &#60;input
                type="text"
                name="name"
                id="name"
                onChange=&#123;handleChange} />

              &#60;input
                type="number"
                name="price"
                id="price"
                onChange=&#123;handleChange} />

              &#60;input
                type="text"
                name="desc"
                id="desc"
                onChange=&#123;handleChange} />

              &#60;input
                name="available" 
                type="checkbox" 
                role="switch" 
                id="available"
                onChange=&#123;handleChange} />

              &#60;input 
                type="file"
                name="imgUrl" 
                id="imgUrl" 
                onChange=&#123;handleChange} />

          &#60;button type="submit">Add Product&#60;/button>
      &#60;/form>
    )
  }

  export default ProductForm;
            </pre>
            <li>Csak az inputok szerepelnek néhány attribútumokkal a JSX-ben</li>
            <li>A handleChange függvény kezeli az összes mező változását
              <ul>
                <li>Az event.target dekonstruálásra kerül</li>
                <li>A frissítéshez szükséges mezőket eltároljuk
                  <ul>
                    <li>name: Az aktuális beviteli mező neve</li>
                    <li>value: Az input mező értéke</li>
                    <li>checked: A jelölőnégyzet értéke</li>
                    <li>type: A beviteli mező típusa</li>
                  </ul>
                </li>
                <li>Type alapján eltárolunk egy értéket a change változóban
                  <ul>
                    <li>Ezzel frissítjük az objektumunk [name] kulcsát</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Minden változásnál újrarenderelés történik</li>
            <br>
            <img src="assets/imgs/react_form_filled.png" style="width: 100%;">
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #formsubmission data-anchor="formsubmission">Form submission</h3>
  <ul>
    <li>A HTML rendelkezik egy alapértelmezett form submit viselkedéssel</li>
    <li>Amennyiben egy form-on belül egy submit típusú gombra rányomunk, a teljes form submit-álásra kerül
      <ul>
        <li>Submit event-et emit-ál</li>
      </ul>
    </li>
    <li>A form submit alapértelmezetten újratölti a teljes oldalt
      <ul>
        <li>A böngésző automatikusan kérést intéz a szerver felé</li>
        <li>Esetünkben ez most a lokális develop szerver</li>
        <li>Ezt a működést a preventDefault() függvénnyel meg tudjuk akadályozni annak érdekében, hogy a további logikát
          mi kezeljük</li>
      </ul>
    </li>
    <li>Amennyiben bármelyik értéket konvertálnánk, megtehetjük navít JavaScript-tel</li>
    <pre>
  function ProductForm() &#123;
      let [states, updateStates] = useState(&#123;
        name: '',
        price: 0,
        desc: '',
        available: false,
        imgUrl: ''
      });

      ...

      function createProductEventHandler(event) &#123;
        event.preventDefault();
        let product = &#123;
            id: 1,
            name: states.name,
            desc: states.desc,
            isAvailable: states.available, // Boolean(states.available)
            image: states.imgUrl,
            price: Number(states.price) // natív JS konvertálás
        }
      }

      return (
        &#60;form onSubmit=&#123;createProductEventHandler}>
          ...
        &#60;/form>
      )

      export default ProductForm;
  }
    </pre>
    <li>Használhatunk two-way data binding-ot annak érdekében, hogy a form a submit után reset-elődjön
      <ul>
        <li>A state biztosítja</li>
        <li>Ha state-ek helyett globális változókat használnánk, akkor is működne a form
          <ul>
            <li>Viszont nem biztosítaná a komponens frissülését változáskor</li>
          </ul>
        </li>

        <li>Első lépésként minden beviteli mező kapjon egy value attribútumot
          <ul>
            <li>A checkbox-nak checked attribútum szükséges</li>
          </ul>
        </li>
        <li>A második lépés, hogy a submit event függvényünkben az összes mezőt alapértelmezett értékre állítjuk
          <ul>
            <li>Ehhez az alapértelmezett objektumunkból egy konstanst készítünk, és a benne lévő értékeket adjuk át a
              useState-nek</li>
            <pre>
  const initalState = &#123;
    name: '',
    price: 0,
    desc: '',
    available: false,
    imgUrl: ''
  }

  let [states, updateStates] = useState(initalState);
              </pre>
            <li>Majd a submit függvényünk végén visszaállítjuk a kezdeti értékeket</li>
            <pre>
  function createProductEventHandler(event) &#123;
    event.preventDefault();
    let product = &#123;
        id: 1,
        name: states.name,
        desc: states.desc,
        isAvailable: states.available,
        image: states.imgUrl,
        price: Number(states.price)
    }

    updateStates(initalState); // itt a lényeg
  }
            </pre>
            <li>A JSX-ben a value/checked megadása nélkül valóban nem működik a form reset</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #childtoparentcommunication data-anchor="childtoparentcommunication">Child to parent communication</h3>
  <ul>
    <li>Az előző témában tárgyalt formban kitöltött adatokkal szeretnénk bővíteni a termékek listát</li>
    <li>A props segítségével a szülő irányából a gyerek kaphat adatot</li>
    <li>A ProductForm komponensből szeretnénk a CreateProduct komponensnek adatot átadni</li>
    <pre>
  <b>// CreateProduct.js // parent</b>
  import ProductForm from "./ProductForm";

  function CreateProduct(props) &#123;
      function onCreateProduct(product) &#123;
          console.log('product: ', product);
      }

      return (
          &#60;div className="row">
              &#60;div className="col-lg-8 mx-auto list-group shadow">
                  &#60;ProductForm createProduct=&#123;onCreateProduct} />
              &#60;/div>
          &#60;/div>
      )
  }

  export default CreateProduct;

  <b>// CreateProduct.js // child</b>
  function ProductForm(props) &#123;
    ...

    function createProductEventHandler(event) &#123;
      event.preventDefault();
      let product = &#123;
          id: 1,
          name: states.name,
          desc: states.desc,
          isAvailable: states.available,
          image: states.imgUrl,
          price: Number(states.price)
      }

      props.createProduct(product); // itt történik a szülő komponens függvényének meghívása

      updateStates(initalState);
    }

    ...
  }
    </pre>
    <li>A szülő egy függvényt definiál, aminek egyetlen bemeneti paramétere van</li>
    <li>A gyereknek a createProduct attribútum által átadjuk a függvény referenciáját</li>
    <li>A gyerek komponensben a prop objektumon keresztül meg tudjuk hívni a szülőben lévő függvényt
      <ul>
        <li>Bemeneti paraméterként átadjuk a kitöltött form-ot / terméket</li>
      </ul>
    </li>
    <li>Lifting state up
      <ul>
        <li>"Állapot felemelés"</li>
        <li>React tervezési minta</li>
        <li>Hasznos, ha több komponensnek is hozzáférésre van szüksége egy közös állapothoz</li>
        <li>Ha több, egymással nem közvetlenül kapcsolódó komponens is használ egy state-et, akkor az állapotot a
          legközelebbi közös ős komponensbe "fel kell emelni"</li>
        <li>Az ős komponensből prop-okon keresztül tovább adható a gyerekeknek a state</li>
        <pre>
  App.js
  ├── CreateProduct.js
  │     └── ProductForm.js
  └── ProductList.js
        </pre>
        <li>A ProductForm-ban adjuk meg az új termék adatait, amit első körben el akarunk juttatni a CreateProduct
          komponensen keresztül az App-ba, majd továbbadni a listának</li>
      </ul>
    </li>
    <pre>
  <b>// ProductForm.js</b>
      function ProductForm(props) &#123;
      ...
      function createProductEventHandler(event) &#123;
        ...
        let product = &#123;
          id: 1,
          name: states.name,
          desc: states.desc,
          isAvailable: states.available,
          image: states.imgUrl,
          price: Number(states.price)
        }

        props.createProduct(product); // a ProductForm meghívja a szülőjétől (CreateProduct) kapott createProduct callback függvényt, és továbbadja az új terméket
        ...
      }
      ...
  }

  <b>// CreateProduct.js</b>
  function CreateProduct(props) &#123;
    function onCreateProduct(product) &#123; // ezt a függvényt hívjuk meg a ProductForm-ból
        props.createProduct(product); // továbbadjuk az új product objektumot a CreateProduct szülőjében (App) lévő callback függvényének
    }

    return (
        &#60;div className="row">
            &#60;div className="col-lg-8 mx-auto list-group shadow">
                &#60;ProductForm createProduct=&#123;onCreateProduct} />
            &#60;/div>
        &#60;/div>
    )
  }

  <b>// App.js</b>
  function App() &#123;
    let [product, updateProduct] = useState(null); // state-ben tároljuk a legutóbb létrehozott új terméket
  
    function onCreateProduct(product) &#123;
      updateProduct(product); // frissítjük a product állapotát az új product-tal
    }
  
    return (
      &#60;div>
        &#60;CreateProduct createProduct=&#123;onCreateProduct} />
        &#60;ProductList newProduct=&#123;product} /> // továbbadjuk az új terméket a listának (ProductList)
      &#60;/div>
    );
  }

  <b>// ProductList.js</b>
  function ProductList(props) &#123;
    console.log('props: ', props); // props-on keresztül megkapjuk az App komponensből érkező legutóbb hozzáadott terméket
    return (
      &#123;JSON.stringify(props.newProduct)} // kilogoljuk az új terméket az UI-ra
      ...
    )
  }
    </pre>
    <li>A listában megjelenik a props.newProduct objektumban az újonnan létrehozott termék
      <ul>
        <li>Természetesen submit után</li>
      </ul>
    </li>
    <img src="assets/imgs/react_form_liftup.png" width="100%">
  </ul>
</div>

<div>
  <h3 #loopingoverlists data-anchor="loopingoverlists">Looping over lists</h3>
  <ul>
    <li>Ahhoz, hogy garantáljuk a lista bővíthetőségét, mindenképp iterálnunk kell a termékeken</li>
    <li>A JSX egy templating engine, nincs beépített megoldása arra, hogy végigmenjünk egy tömbön
      <ul>
        <li>Angularban, a template-ben van ilyen, az ngFor</li>
      </ul>
    </li>
    <li>Natív javascript függvénnyt viszont használhatunk
      <ul>
        <li>JSX-ben Javascript kódot kapcsos zárójelben tudunk írni</li>
        <pre>
  &#123;products.map(product => ( // a product a ciklus aktuális elemét tartalmazza
    &#60;Products
        key=&#123;product.id}
        id=&#123;product.id}
        name=&#123;product.name}
        desc=&#123;product.desc}
        isAvailable=&#123;product.isAvailable}
        image=&#123;product.image}
        price=&#123;product.price}
    />
  ))}
        </pre>
        <li>Fontos, hogy a return kulcsszóra azért nem volt szükség, mert nem nyitottuk ki a callback törzsét</li>
        <pre>
  &#123;products.map(product => // zárójel nélkül is működik
    &#60;Products
        key=&#123;product.id}
        id=&#123;product.id}
        name=&#123;product.name}
        desc=&#123;product.desc}
        isAvailable=&#123;product.isAvailable}
        image=&#123;product.image}
        price=&#123;product.price}
    />
  )}

  &#123;products.map(product => &#123; // nyitott callback, használni kell a return-t
    return &#60;Products
              key=&#123;product.id}
              id=&#123;product.id}
              name=&#123;product.name}
              desc=&#123;product.desc}
              isAvailable=&#123;product.isAvailable}
              image=&#123;product.image}
              price=&#123;product.price}
            />
  })}
        </pre>
        <li>Új tömböt hoz létre a map(), és a függvény első argomentuma egy callback function</li>
        <pre>
  array.map(function(element, index, array) &#123; // harmadik paramétere az eredeti tömb
    // transformation
  });        

  OR

  array.map( (element, index, array) => &#123; // harmadik paramétere az eredeti tömb
    // transformation
  });        
        </pre>
      </ul>
    </li>
    <li>Ahhoz, hogy egy új tömbelemet meg tudjunk jeleníteni a listában, újra kell generálni a lista komponenst
      <ul>
        <li>Használhatunk state-et</li>
        <li>Amennyiben a ProductList komponensünk elkészítésekor azonnal bővítjük a listát, infinite loop-ba kerülünk,
          amit hibával megakadályoz</li>
        <pre>
  function ProductList(props) &#123;
    let [productList, updateProductList] = useState(products);
    updateProductList(prev => &#123; // már töltjük is újra a komponenst
        return [...products, props.newProduct];
    })
    ...
  }
        </pre>
        <li>Ennél sokkal jobb megoldás, ha az eredeti listánkat elvisszük a ProductList komponensből az App.js-be</li>
        <pre>
  <b>// App.js</b>
  let products = [
    &#123;
      id: 1,
      name: 'Fresh milk',
      desc: 'Lorem ipsum dolor sit amet',
      isAvailable: true,
      image: 'https://picsum.photos/100/100?blur=2&random=1',
      price: 400
    },
    &#123;
      id: 2,
      name: 'Banana',
      desc: 'Curabitur gravida arcu ac turpis',
      isAvailable: true,
      image: 'https://picsum.photos/100/100?blur=2&random=2',
      price: 230
    },
    &#123;
      id: 3,
      name: 'Onion',
      desc: 'Sed ut perspiciatis unde omnis',
      isAvailable: false,
      image: 'https://picsum.photos/100/100?blur=2&random=3',
      price: 355
    }
  ]

  function App() &#123;
    let [productList, updateProductList] = useState(products);

    function onCreateProduct(product) &#123;
      updateProductList([...productList, product]); // az új termék a lista végére kerül
    }

    return (
      &#60;div>
        &#60;CreateProduct createProduct=&#123;onCreateProduct} />
        &#60;ProductList productList=&#123;productList} />
      &#60;/div>
    );
  }

  export default App;

  <b>ProductList.js</b>
  function ProductList(props) &#123;
    return (
        &#60;div className='row'>
            &#60;div className='col-lg-8 mx-auto'>
                &#60;ul className="list-group shadow row">
                    &#123;props.productList.map(product => (
                        &#60;Products
                            key=&#123;product?.id}
                            id=&#123;product?.id}
                            name=&#123;product?.name}
                            desc=&#123;product?.desc}
                            isAvailable=&#123;product?.isAvailable}
                            image=&#123;product?.image}
                            price=&#123;product?.price}
                        />
                    ))}
                &#60;/ul>
            &#60;/div>
        &#60;/div>
    )
  }

  export default ProductList;
        </pre>
        <li>A működés így nem túl bonyolult
          <ul>
            <li>Adott egy 3 elemű statikus tömb</li>
            <li>A useState segítségével egy állapotváltozót (productList) hozunk létre, amelyben az aktuális
              terméklistát</li>
            <li>A products tömb az állapot kezdeti értéke a state-nek</li>
            <li>Az updateProductList függvény segítségével frissíthetjük a terméklistát
              <ul>
                <li>A meglévő lista (productList) másolatát készíti (...productList), és az új terméket (product)
                  hozzáfűzi a lista végére</li>
              </ul>
            </li>
            <li>A ProductList.js props objektumának átadjuk az aktuális listát ( productList=&#123;productList} )</li>
            <li>A map függvény végigiterál a terméklistán</li>
          </ul>
        </li>
        <li>Végül nem direkt módon a ProductList komponensben frissítettük a state-et
          <ul>
            <li>Az App.js createProduct függvényében tesszük meg</li>
            <li>Ez a függvény minden alkalommal meghívódik, amikor a form-ban új terméket hozunk létre</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #keyprops data-anchor="keyprops">Key props</h3>
  <ul>
    <li>A React-nak egy speciális koncepciója van a weboldalon lista megjelenítésekor
      <ul>
        <li>Biztosítja a listák hatékony renderelését, és frissítését, teljesítményvesztés nélkül</li>
        <li>Új elem hozzáadásánál a DOM-ba az elem a végére kerül, majd utána frissíti be a React a listánkat, frissíti
          be a listtaelemek tartalmát
          <ul>
            <li>Performancia tekintetében ez nem túl előnyös</li>
            <li>Emellett bug-okba is belefuthatunk</li>
          </ul>
        </li>
        <li>A listelemekhez hozzáadhatjuk a key attribútumot
          <ul>
            <li>Egyedi értéket adunk neki</li>
            <pre>
  function onCreateProduct(product) &#123;
    updateProductList([...productList, &#123; ...product, id: productList.length + 1 }]);
  }
            </pre>
            <li>A spread operátor segítségével másolásra kerül a productList [...productList]</li>
            <li>Majd szintén spread operátor segítségével kiterítjük az újonnan létrehozott
              termék objektumát, és utána az id kulcsot felülírjuk a már meglévő tömb elemszámánál eggyel nagyobb
              értékkel, garantálva így az egyediséget</li>
          </ul>
        </li>
        <li>A key segít a React-nak beazonosítani az egyedi listaelemeket</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #listfiltering data-anchor="listfiltering">List filtering</h3>
  <ul>
    <li>A kód némi nemű átalakítása után létrehozunk egy filter komponenst</li>
    <pre>
  <b>// App.js</b>
  function App() &#123;
    let [productList, updateProductList] = useState(products);

    function onCreateProduct(product) &#123;
      console.log(products.length);
      updateProductList([...productList, &#123; ...product, id: productList.length + 1 }]); // az új termék a lista végére kerül
    }

    return (
      &#60;div className='row'>
        &#60;div className='col-lg-8 mx-auto'>
          &#60;CreateProduct createProduct=&#123;onCreateProduct} />
          &#60;ProductList productList=&#123;productList} />
        &#60;/div>
      &#60;/div>
    );
  }

  export default App;

  <b>// CreateProduct.js</b>
  function CreateProduct(props) &#123;
    function onCreateProduct(product) &#123;
        props.createProduct(product);
    }

    return (
        &#60;div className="list-group shadow" style=&#123; &#123; backgroundColor: 'white', padding: '10px' }}>
            &#60;ProductForm createProduct=&#123;onCreateProduct} />
        &#60;/div>
    )
  }

  export default CreateProduct;

  <b>// ProductList.js</b>
  function ProductList(props) &#123;
    return (
        &#60;ul className="list-group shadow">
            &#123;props.productList.map(product => (
                &#60;Products
                    key=&#123;product?.id}
                    id=&#123;product?.id}
                    name=&#123;product?.name}
                    desc=&#123;product?.desc}
                    isAvailable=&#123;product?.isAvailable}
                    image=&#123;product?.image}
                    price=&#123;product?.price}
                />
            ))}
        &#60;/ul>
    )
  }

  export default ProductList;

  <b>// FilterProduct.js</b>
  import './FilterProduct.scss'

  let FilterProduct = (props) => &#123;
      return (
          &#60;div className="list-group shadow filter">
              &#60;select name="isAvailable">
                  &#60;option value="all">All&#60;/option>
                  &#60;option value="isAvailable">Available&#60;/option>
                  &#60;option value="unavailable">Unavailable&#60;/option>
              &#60;/select>
          &#60;/div>
      )
  }

  export default FilterProduct;

  <b>// FilterProduct.scss</b>
  .filter &#123;
    width: 100%;
    background-color: white;
    padding: 20px;
    margin: 25px 0;
  }
    </pre>
    <img src="assets/imgs/react_filter_base.png" width="100%">
    <br>
    <br>
    <li>Amennyiben készen áll a dropdown-unk, valósítsuk meg a filterezést
      <ul>
        <li>Első lépésben érzékelnünk kell a listában a változásokat, amit az onChange eseménykezelő attribútum
          segítségével valósítunk meg</li>
        <pre>
  &#60;select name="isAvailable" onChange=&#123;onFilterChanged}>
    &#60;option value="all">All&#60;/option>
    &#60;option value="isAvailable">Available&#60;/option>
    &#60;option value="unavailable">Unavailable&#60;/option>
  &#60;/select>
        </pre>
        <li>Eseménykor pedig lefuttatunk egy függvényt</li>
        <pre>
  const onFilterChanged = (event) => &#123;
    props.productFilter(event.target.value); // meghívjuk az App komponensünk egy függvényét a kiválasztott option értékvel
  }
        </pre>
        <li>Mivel a filterező komponensünk az App komponensünk gyereke, ezért a prop objektumban átadjuk annak a
          függvénynek a referenciáját, amit meghívhatunk a FilterProduct-ban, de magát a függvény logikáját az
          App.js-ben kezeljük</li>
        <li>Az App komponensben egyéb változásokat is ecseteltünk
          <ul>
            <li>Létrehoztunk egy újabb state-et, ami a filter szövegét tartalmazza
              <ul>
                <li>all / isAvailable / unavailable</li>
              </ul>
            </li>
            <li>Továbbá készítettünk egy listát a szűrt tömbelemekről
              <ul>
                <li>A filteredList minden változásnál a szűrt értéknek megfelelő elemeket tartalmazza</li>
                <li>Ezért is van arra szükség, hogy JSX-ben az iterációhoz ezt a változót adjuk oda a lista
                  komponensnek</li>
              </ul>
            </li>
          </ul>
        </li>
        <pre>
  function App() &#123;
    let [productList, updateProductList] = useState(products);
    let [productFilterText, updateProductFilterText] = useState('all');
  
    let filteredList = productList.filter((product) => &#123;
      return productFilterText === 'all'
        ? product
        : productFilterText === 'isAvailable'
          ? product.isAvailable === true
          : product.isAvailable === false;
    });
  
    function onCreateProduct(product) &#123;
      updateProductList([...productList, &#123; ...product, id: productList.length + 1 }]); // az új termék a lista végére kerül
    }
  
    const onProductFilter = (filterText) => &#123;
      updateProductFilterText(filterText);
    }
  
    return (
      &#60;div className='row'>
        &#60;div className='col-lg-8 mx-auto'>
          &#60;CreateProduct createProduct=&#123;onCreateProduct} />
          &#60;FilterProduct productFilter=&#123;onProductFilter} />
          &#60;ProductList productList=&#123;filteredList} />
        &#60;/div>
      &#60;/div>
    );
  }
        </pre>
        <img src="assets/imgs/react_filtered_list.png" width="100%">
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #conditionalrendering data-anchor="conditionalrendering">Conditional rendering</h3>
  <h5 #conditionalcontent data-anchor="conditionalcontent">Conditional content</h5>
  <ul>
    <li>Azt szeretnénk elérni, hogy amikor egyetlen eleme sincs a terméklistánknak, akkor - és csak akkor - írjuk ki,
      hogy nincsenek termékek</li>
    <li>Első lépésként kommenteljük ki a products tömbünkben lévő, előre definiált 3 darab terméket</li>
    <li>Következőnek, egyszerűen csak használhatunk a listában if statement-et</li>
    <pre>
  <b>// ProductList.js</b>
  function ProductList(props) &#123;
    if (!props.productList.length) &#123;
        return (
            &#60;h3>There are no products&#60;/h3>
        )
    } else &#123;
        return (
            &#60;ul className="list-group shadow">
                &#123;props.productList.map(product => (
                    &#60;Products
                        key=&#123;product?.id}
                        id=&#123;product?.id}
                        name=&#123;product?.name}
                        desc=&#123;product?.desc}
                        isAvailable=&#123;product?.isAvailable}
                        image=&#123;product?.image}
                        price=&#123;product?.price}
                    />
                ))}
            &#60;/ul>
        )
    }
  }
  
  export default ProductList;
</pre>
    <li>Valamint semmi akadálya a ternary operátornak, mint alternatív megoldás</li>
    <pre>
  function ProductList(props) &#123;
    return (
        !props.productList.length
            ? (&#60;h3>There are no products&#60;/h3>)
            : (
                &#60;ul className="list-group shadow">
                    &#123;props.productList.map(product => (
                        &#60;Products
                            key=&#123;product?.id}
                            id=&#123;product?.id}
                            name=&#123;product?.name}
                            desc=&#123;product?.desc}
                            isAvailable=&#123;product?.isAvailable}
                            image=&#123;product?.image}
                            price=&#123;product?.price}
                        />
                    ))}
                &#60;/ul>
            )
      )
  }

  export default ProductList;
    </pre>
  </ul>
  <br>
  <h5 #conditionalform data-anchor="conditionalform">Conditional form</h5>
  <ul>
    <li>Célunk, hogy gombnyomásra jelenjen meg a form, amivel termékeket tudunk hozzáadni a listához</li>
    <pre>
  <b>// CreateProduct.js</b>
  function CreateProduct(props) &#123;
    let [formIsVisible, updateFormVisibility] = useState(false)

    const onCreateProduct = (product) => &#123;
        props.createProduct(product);
        toggleFormVisibility();
    }

    const toggleFormVisibility = () => &#123;
        updateFormVisibility(prev => !prev);
    }

    return (
        &#60;div className="list-group shadow" style=&#123; &#123; backgroundColor: 'white', padding: '10px' }}>
            &#123;formIsVisible
                ? (&#60;ProductForm createProduct=&#123;onCreateProduct} cancelForm=&#123;toggleFormVisibility} />)
                : (&#60;button className="btn btn-secondary" onClick=&#123;toggleFormVisibility}>Toggle form visibility&#60;/button>)
            }
        &#60;/div>
    )
  }

  <b>// ProductForm.js</b>
  function ProductForm(props) &#123;
    ...
    const onCancelForm = () => &#123;
      updateStates(initalState); // visszaállítja a form összes mezőjét a kezdeti ("üres") értékre 
      props.cancelForm(); // meghívja a szülő toggleFormVisibility függvényét, aminek hatására eltűnik a form
    }

    return (
      &#60;form className="row g-3" onSubmit=&#123;createProductEventHandler}>
      ...
        &#60;button type="button" className="btn btn-danger" onClick=&#123;onCancelForm}>Cancel&#60;/button>
      &#60;/form>
    )
  }
    </pre>
    <li>A toggleFormVisibility felelős a state állapotának változásáért
      <ul>
        <li>Amennyiben a toggle gombra kattintunk, elküldjük a form-ot, vagy az új Cancel gombra kattintunk, meghívjuk
        </li>
      </ul>
    </li>
    <li>A CreateProduct komponens JSX-ében a feltétel másképp is megvalósítható</li>
    <pre>
  return (
        &#60;div className="list-group shadow" style=&#123; &#123; backgroundColor: 'white', padding: '10px' }}>
            &#123;!formIsVisible && (&#60;ProductForm createProduct=&#123;onCreateProduct} />)}
            &#123;formIsVisible && (&#60;button onClick=&#123;toggleFormVisibility}>Toggle form visibility&#60;/button>)}
        &#60;/div>
    )
    </pre>
  </ul>
</div>

<div>
  <h3 #dynamicinlinestyling data-anchor="dynamicinlinestyling">Dynamic inline styling</h3>
  <ul>
    <li>Az inline style a React-ban az alábbi módon néz ki
      <ul>
        <li>Objektumban definiáljuk a szabályokat</li>
      </ul>
    </li>
    <pre>
  style=&#123; &#123; backgroundColor: 'white', padding: '10px' }}
    </pre>
    <li>Inline style feltétellel pedig a a következőképp</li>
    <pre>
  style=&#123; &#123;backgroundColor: !props.isAvailable ? '#e7e7e7' : ''}}
    </pre>
  </ul>
</div>

<div>
  <h3 #dynamicattributevalues data-anchor="dynamicattributevalues">Dynamic attribute values</h3>
  <ul>
    <li>Átadunk egy disable attribútumot a button komponensnek, ami true értéket fog tartalmazni, amennyiben a
      productCount kisebb, mint egy, majd a gyerek kompnensben a props objektumból dinamikusan kivesszük az értéket</li>
    <pre>
  <b>// ProductDetails.js</b>
  ...
  &#60;Button eventHandler=&#123;decrementCount} disable=&#123;productCount < 1}> - &#60;/Button>
  ...

  <b>// Button.js</b>
  &#60;button
        onClick=&#123;props.eventHandler}
        className="btn btn-primary"
        disabled=&#123;props.disable}
    >
        &#123;props.children}
  &#60;/button>
    </pre>
  </ul>
</div>

<div>
  <h3 #fragments data-anchor="fragments">Fragments</h3>
  <ul>
    <li>React komponensből csakis kizárólag egyetlen JSX elemmel térhetünk vissza
      <ul>
        <li>Ezért szükséges wrap-pelni, ha több elemet foglal magában a kód</li>
        <li>A "csomagoló" elem meg is jelenik a DOM-ban, pedig sokszor felesleges</li>
        <li>Ahelyett, hogy mondjuk egy div elemet használunk wrapper-nek, használhatunk fragment-et is</li>
        <pre>
  import React from 'react';

  function component1() &#123;
    return (
      &#60;React.Fragment>
        &#60;h1>This is component 1&#60;/h1>
        &#60;p>This is a paragraph&#60;/p>
      &#60;/React.Fragment>
    )
  }
        </pre>
        <li>Rövidebben is le lehet írni</li>
        <pre>
  function component1() &#123;
    return (
      &#60;>
        &#60;h1>This is component 1&#60;/h1>
        &#60;p>This is a paragraph&#60;/p>
      &#60;/>
    )
  }
        </pre>
        <li>Ezzel el tudjuk kerülni a felesleges HTML tag-eket</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #portals data-anchor="portals">Portals</h3>
  <ul>
    <li>Kód változtatás
      <ul>
        <li>A felső sávban gombbal váltani lehet a 2 miniapp között</li>
      </ul>
    </li>
    <pre>
  function App() &#123;
    ...
    let [selectedApp, updateSelectedApp] = useState(2);
    ...
    const onAppChange = (app) => &#123;
      updateSelectedApp(app);
    }
  
    return (
      &#60;div className='row'>
        &#60;div className='col-lg-8 mx-auto'>
          &#60;div className='d-flex justify-content-between mb-4 gap-1'>
            &#60;h1>&#123;`App ` + selectedApp}&#60;/h1>
            &#60;div className='d-flex gap-1'>
              &#60;button type='button' className='btn btn-warning' onClick=&#123;() => onAppChange(1)}>App 1&#60;/button>
              &#60;button type='button' className='btn btn-warning' onClick=&#123;() => onAppChange(2)}>App 2&#60;/button>
            &#60;/div>
          &#60;/div>
          &#123;
            selectedApp === 1 && &#60;>
              &#60;CreateProduct createProduct=&#123;onCreateProduct} />
              &#60;FilterProduct productFilter=&#123;onProductFilter} />
              &#60;ProductList productList=&#123;filteredList} />
            &#60;/>
          }
          &#123;
            selectedApp === 2 && &#60;>
              &#60;Component1 />
              &#60;Component2 />
            &#60;/>
          }
  
        &#60;/div>
      &#60;/div>
    );
  }
  
  export default App;
    </pre>
    <li>A gomboknak callback függvényt kell átadni, hogy ne hívódjanak meg rendereléskor</li>
    <img src="assets/imgs/react_app_switcher.png" width="100%">
    <br>
    <br>
    <li>A portal Lehetővé teszi, hogy egy React komponens tartalmát a DOM-fa egy teljesen más részére helyezzük el, mint
      ahol az a React komponens hierarchiájában logikailag található
      <ul>
        <li>Lehetőségünk van akár arra is, hogy ne a root node elem gyerekekénk jelenítsünk meg egy elemet</li>
        <li>Az index.html-ben a root id-jú elem alatt hozzunk létre egy másik elemet</li>
        <pre>
  <b>// index.html</b>
  &#60;body>
    &#60;div id="root">&#60;/div>
    &#60;div id="root-portal">&#60;/div>
  &#60;/body>
        </pre>
        <li>Amennyiben az App.js-hez hozzáadjuk az újonnan létrehozott PortalComponent-et, attól még ugyanúgy a másik
          két komponens mellett helyezkedik el a DOM-ban</li>
        <pre>
  <b>// App.js</b>

  &#60;Component1 />
  &#60;Component2 />  
  &#60;PortalComponent />

  ↓↓↓↓↓

  &#60;div id="root">
    &#60;h3>This is component 1&#60;/h3>
    &#60;p>This is a paragraph in component 1&#60;/p>
    &#60;h3>This is component 2&#60;/h3>
    &#60;p>This is a paragraph in component 2&#60;/p>
    &#60;h3>This is a portal component&#60;/h3>
  &#60;/div>
  &#60;div id="root-portal">&#60;/div>
        </pre>
      </ul>
    </li>
    <li>Ahhoz, hogy a root-portal id-val rendelkező DOM elem kapja meg a PortalComponent tartalmát, a createPortal
      függvényt szükséges használnunk
      <ul>
        <li>Az első argomentuma tulajdonképpen bármi lehet, ami kirenderelhető
          <ul>
            <li>Szám, szöveg, JSX, komponens</li>
          </ul>
        </li>
        <li>A második argomentum az a DOM node, ahova renderelni szeretnénk a JSX kódot</li>
        <pre>
  <b>// PortalComponent</b>
  import ReactDOM from 'react-dom';

  const PortalComponent = () => &#123;
      return ReactDOM.createPortal(
          &#60;>
              &#60;h3>This is a portal component&#60;/h3>
          &#60;/>,
          document.getElementById('root-portal')
      )
  }

  export default PortalComponent;

  ↓↓↓↓↓

  &#60;div id="root">
    &#60;h3>This is component 1&#60;/h3>
    &#60;p>This is a paragraph in component 1&#60;/p>
    &#60;h3>This is component 2&#60;/h3>
    &#60;p>This is a paragraph in component 2&#60;/p>
  &#60;/div>
  &#60;div id="root-portal">
    &#60;h3>This is a portal component&#60;/h3>
  &#60;/div>
        </pre>
      </ul>
    </li>
    <li>Modal, popup, tooltip esetében nagyon jól jön
      <ul>
        <li>Amennyiben mondjuk a modal-unknál nem alkalmazunk portal-t, és a wrapper-jének megadunk mondjuk szélességet,
          akkor a modal-unk 100% szélesség esetén is a konténer szélességét fogja felvenni
          <ul>
            <li>Ezért használunk portal-t</li>
          </ul>
        </li>
        <pre>
  <b>// App.js</b>
  return (
    &#60;div className='row' style=&#123; &#123; maxWidth: 200, position: 'relative' }}>
      ...
      &#60;Component1 />
      &#60;Component2 />
      &#60;Modal />}
    &#60;/div>
  )

  <b>// Modal.js</b>
  return ( // nem használunk portal-t
    &#60;>
      &#60;div className='alert'>
        ... // modal content
      &#60;/div>
    &#60;/>
  )

  <b>// Modal.scss</b>
  .alert&#123;
    position: absolute; // a modalnak középen kellene megjelennie CSS szabályok alapján
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 70%;
    ...
  }
        </pre>
        <img src="assets/imgs/react_modal_error.png" width="100%">
        <br>
        <br>
        <li>Az alábbi módon, portal használatával elkerülhető a fenti eset</li>
        <pre>
  <b>// App.js</b>
  ...
  let [showModal, showModalUpdate] = useState(false);

  const toggleModal = () => &#123;
    showModalUpdate(prev => &#123;
      return !prev;
    });
  }

  return (
    &#60;div className='row' style=&#123; &#123; maxWidth: 200, position: 'relative' }}>
      &#60;div className='col-lg-8 mx-auto'>
        &#60;div className='d-flex justify-content-between mb-4 gap-1'>
          &#60;h1>&#123;`App ` + selectedApp}&#60;/h1>
          &#60;div className='d-flex gap-1'>
            &#60;button type='button' className='btn btn-warning' onClick=&#123;() => onAppChange(1)}>App 1&#60;/button>
            &#60;button type='button' className='btn btn-warning' onClick=&#123;() => onAppChange(2)}>App 2&#60;/button>
          &#60;/div>
        &#60;/div>
        &#123;
          selectedApp === 1 && &#60;>
            ...
          &#60;/>
        }
        &#123;
          selectedApp === 2 && &#60;>
            &#60;Component1 />
            &#60;Component2 />
            &#60;button className='btn btn-primary' onClick=&#123;toggleModal}>Show modal&#60;/button>
            &#123;showModal && &#60;Modal showModal=&#123;showModal} toggleModal=&#123;toggleModal} />}
            &#123;/*&#60;PortalComponent />*/}
          &#60;/>
        }
      &#60;/div>
    &#60;/div>
    );
  }

  <b>// Modal.js</b>
  import "./Modal.scss"

  const Modal = (props) => &#123;
      const hideModal = () => &#123;
          props.toggleModal();
      }

      return ReactDOM.createPortal(
          &#60;>
              &#60;div className=&#123;`alert $&#123;props.showModal ? '' : 'hidden'}`}>
                  &#60;h2>This is an Alert!&#60;/h2>
                  &#60;p>
                      This is a very simple example of how a custom
                      alert window can be created and displayed
                      dynamically using JavaScript.
                  &#60;/p>
                  &#60;button className="modal-btn" onClick=&#123;hideModal}>OK&#60;/button>
              &#60;/div>
              &#60;div className=&#123;`overlay $&#123;props.showModal ? '' : 'hidden'}`}>&#60;/div>
          &#60;/>,
          document.getElementById("root-portal")
      )
  }

  export default Modal;
        </pre>
        <img src="assets/imgs/react_modal_portal.png" width="100%">
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #refs data-anchor="refs">Refs</h3>
  <ul>
    <li>A ref a React-ban direkt módon biztosít hozzáférést DOM elemekhez</li>
    <li>A ref nem más, mint egy referencia érték</li>
    <li>Használatához importálni szükséges a useRef-et a React könyvtárából</li>
    <pre>
  import &#123;useRef} from 'react';
    </pre>
    <li>A useRef is egy React hook
      <ul>
        <li>Kizárólag komponens függvényben használható, mint minden más hook</li>
      </ul>
    </li>
    <pre>
  let nameInputRef = useRef();

  ↓↓↓↓↓

  &#123;current: undefined} // console.log()
    </pre>
    <li>A useRef valamilyen értékkel tér vissza, amit hozzárendelünk egy változóhoz</li>
    <li>Adhatunk neki kezdeti értéket is
      <ul>
        <li>Érték nélkül undefined lesz a változó</li>
      </ul>
    </li>
    <pre>
  let nameInputRef = useRef('hello'); // a változóba a hello string fog bekerülni

  ↓↓↓↓↓

  &#123;current: 'hello'} // console.log()
    </pre>
    <li>Megadhatjuk, hogy a referencia változó egy DOM elemre mutasson</li>
    <pre>
  const RefsDemo = () => &#123;
    let [inputValue, updateInputValue] = useState('');

    let nameInputRef = useRef();
    console.log(nameInputRef); // itt még undefined, mert a DOM még nem renderelődött
    updateInputValue(nameInputRef.current.value); // újrarenderelést idéz elő

    const showNameEventHandler = () => &#123;
        console.log(nameInputRef); // az input DOM elemet tartalmazza
    }

    return (
        &#60;>
            &#60;span>Name: &#60;/span>
            &#60;input type="text" ref=&#123;nameInputRef}>&#60;/input>
            &#60;button className="btn btn-secondary" onClick=&#123;showNameEventHandler}>Show name&#60;/button>
            Current input value: &#123;inputValue} // kattintásra kiírjuk az input mező aktuális értékét
        &#60;/>
    )
  }
  
  export default RefsDemo;

  ↓↓↓↓↓

  &#123;
    current: &#123; // gombnyomást követően a console.log
      tagName: "INPUT",
      type: "text",
      value: "",
      placeholder: undefined,
      disabled: false,
      readOnly: false,
      name: undefined,
      id: undefined,
      className: "btn btn-secondary",
      style: &#123;},
      dataset: &#123;},
      focus: [Function: focus],
      blur: [Function: blur],
      addEventListener: [Function: addEventListener],
      removeEventListener: [Function: removeEventListener],
      oninput: null,
      onclick: null,
    }
  }
    </pre>
    <li>A 'ref' úgynevezett build-in prop, mint a 'key'</li>
    <li>Az input elem hozzárendelődik a nameInputRef property-hez
      <ul>
        <li>Egészen pontosan a property current kulcsához</li>
      </ul>
    </li>
    <li>Bármelyik elemnek adhatunk referencia változót
      <ul>
        <li>Majd utána direkt módon dolgozhatunk azzal az elemmel</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #hooks data-anchor="hooks">Hoooks</h3>
  <ul>
    <li>Komponensekben használható beépített eszközök</li>
    <li>Nem lifecycle hook-ok
      <ul>
        <li>Az Angular lifecycle hook-ok szigorúan a komponens élettartamához kötődnek</li>
      </ul>
    </li>
    <li>A hook-okkal az állapotkezelés és mellékhatások deklaratív módon kezelhetők, amitől az alkalmazás kódja
      könnyebben
      érthető és karbantartható</li>
    <li>
      React hook-ok
      <ul>
        <li>useState
          <ul>
            <li>Állapotot hoz létre komponensekben</li>
            <pre>
  const [state, setState] = useState(initialValue);
            </pre>
          </ul>
        </li>
        <li>useEffect
          <ul>
            <li>Mellékhatásokat kezel
              <ul>
                <li>API hívások</li>
                <li>DOM manipulációk</li>
              </ul>
            </li>
            <pre>
  useEffect(() => &#123;
    // mellékhatás
    return () => &#123;
      ...
    };
  }, [dependencyArray]);
            </pre>
          </ul>
        </li>
        <li>useContext
          <ul>
            <li>Lehetővé teszi a React Context értékek elérését</li>
            <pre>
  const value = useContext(MyContext);
            </pre>
          </ul>
        </li>
        <li>useRef
          <ul>
            <li>Referenciát hoz létre, amely megőriz egy változót újrarenderelés nélkül, vagy közvetlenül manipulálhatja
              a
              DOM elemeket</li>
            <pre>
  const ref = useRef(initialValue);
            </pre>
          </ul>
        </li>
        <li>useReducer
          <ul>
            <li>Állapotkezeléshez használható</li>
            <li>Használata hasonlít a Redux reducer-ekhez</li>
            <pre>
  const [state, dispatch] = useReducer(reducer, initialState);
            </pre>
          </ul>
        </li>
        <li>useMemo
          <ul>
            <li>Egy érték kiszámítását optimalizálja</li>
            <li>Csak akkor számolja újra, ha a függőségek változnak</li>
            <pre>
  const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
            </pre>
          </ul>
        </li>
        <li>useCallback
          <ul>
            <li>Egy függvény "memorizálására" szolgál, hogy ne jöjjön létre újra minden renderelésnél</li>
            <pre>
  const memoizedCallback = useCallback(() => doSomething(a, b), [a, b]);
            </pre>
          </ul>
        </li>
        <li>useLayoutEffect
          <ul>
            <li>Hasonló a useEffect-hez, de szinkronban fut a DOM frissítéseivel</li>
            <pre>
  useLayoutEffect(() => &#123;
    // mellékhatás
  }, [dependencyArray]);
            </pre>
          </ul>
        </li>
        <li>useImperativeHandle
          <ul>
            <li>Testreszabott ref objektumokat lehet létrehozni a segítségével, amelyek komponenseket manipulálnak</li>
            <pre>
  useImperativeHandle(ref, () => (&#213;
    // API
  }));
            </pre>
          </ul>
        </li>
        <li>useDebugValue
          <ul>
            <li>Egyedi debug információkat ad a React DevTools-nak</li>
            <pre>
  useDebugValue(value);
            </pre>
          </ul>
        </li>
        <li>useId
          <ul>
            <li>Egyedi azonosítót generál, például form elemekhez</li>
            <pre>
  const id = useId();
            </pre>
          </ul>
        </li>
        <li>useDeferredValue
          <ul>
            <li>Egy érték késleltetett frissítését biztosítja a felhasználói élmény optimalizálás érdekében</li>
            <pre>
  const deferredValue = useDeferredValue(value);
            </pre>
          </ul>
        </li>
        <li>useTransition
          <ul>
            <li>Egy nem "sürgős" állapotfrissítés kezelése, amely nem blokkolja az UI-t</li>
            <pre>
  const [isPending, startTransition] = useTransition();
            </pre>
          </ul>
        </li>
        <li>useSyncExternalStore
          <ul>
            <li>Külső állapot szinkronizálása egy komponenssel
              <ul>
                <li>Állapotkezelő könyvtárakhoz</li>
              </ul>
            </li>
            <pre>
  const state = useSyncExternalStore(subscribe, getSnapshot);
            </pre>
          </ul>
        </li>
        <li>useInsertionEffect
          <ul>
            <li>CSS-in-JS könyvtárakhoz használható</li>
            <li>A DOM renderelés előtt fut</li>
            <pre>
  useInsertionEffect(() => &#123;
    // code
  }, [dependencyArray]);
            </pre>
          </ul>
        </li>
      </ul>
    </li>
    <li>Két fő szabály vonatkozik a React hook-ok használatára
      <ol>
        <li>Csak React függvényben hívhatóak meg
          <ul>
            <li>Tehát csak komponenes függvényben, és custom React hook függvényben</li>
          </ul>
        </li>
        <li>Nem szabad belső függvényben hívni a hook-okat, csak 'top-level'-en</li>
      </ol>
    </li>
    <li>useEffect hook használata esetén a dependency array-ban azokat a property-ket szükséges megadni, amiket a
      useEffect függvényében használunk
      <ul>
        <li>Akár függvényt is, ha szükséges</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #sideeffects data-anchor="sideeffects">Side effects</h3>
  <ul>
    <li>Szintén React hook</li>
    <li>Olyan művelet, amely valamilyen külső állapotot módosít, vagy külső forrásból származó adatokat kezel a kódban
    </li>
    <li>Bármi lehet, ami megtörténik, vagy megtörténhet az alkalmazásban, ami nem kapcsolódik a UI-hoz</li>
    <li>Side effect például
      <ul>
        <li>API hívások</li>
        <li>Böngészőben adattárolás</li>
        <li>DOM manipuláció</li>
        <li>Állapot vagy változó módosítása kívülről</li>
        <li>Console logolás</li>
        <li>Időzített események (setTimeout, setInterval)</li>
        <li>Event listener-ek hozzáadása/eltávolítása</li>
      </ul>
    </li>
    <li>React-ben a side effect-ek kezelése a useEffect segítségével történik</li>
    <li>A React renderelési folyamatát nem szabad hosszú futású műveletekkel blokkolni</li>
    <li>Az Angular lifecycle hook-jai szintén használhatók side effect-ek kezelésére, de inkább az osztályalapú
      komponenseken keresztül vezeti be ezeket, míg a React funkcionális megközelítést alkalmaz a useEffect, és más
      hook-ok segítségével</li>
    <li>A komponensek state / props változáskor újrarenderelődnek
      <ul>
        <li>Ezzel együtt a teljes komponens logika újra lefut</li>
      </ul>
    </li>
    <li>Lehetnek olyan feladatok, amiket csak akkor szeretménk lefuttatni, amikor valami változik
      <ul>
        <li>Ezek a feladatok a side effect-ek</li>
      </ul>
    </li>
    <li>useEffect
      <ul>
        <pre>
  const Effect = (props) => &#123;
    console.log('Re-render');

    let [selectedButton, updateSelectedButton] = useState('HOME')

    const buttons = ['HOME', 'ABOUT', 'CONTACT'];

    /* const onButtonClick = (text) => &#123;
        updateSelectedButton(text);
    } */

    return (
        &#60;>
            &#123;
                buttons.map(b => &#123;
                    return (
                        &#60;button key=&#123;b} onClick=&#123;() => &#123; updateSelectedButton(b) }}>&#123;b}&#60;/button>
                        /* &#60;button key=&#123;b} value=&#123;b} onClick=&#123;(e) => &#123; onButtonClick(e.target.value) }}>&#123;b}&#60;/button> */ // eredmény szempontjából ugyanaz, csak szükséges egy frissítő fgv
                    )
                })
            }
            &#60;h5>&#123;selectedButton}&#60;/h5>
        &#60;/>
    )
  }

  export default Effect;
        </pre>
        <li>A fenti kóddal van egy kis probléma
          <ul>
            <li>A updateSelectedButton mindig új renderelést indít, akkor is, ha nem változik a selectedButton értéke,
              mert a React nem vizsgálja automatikusan, hogy a régi és az új állapot azonos-e</li>
            <li>Ugyanakkor a ugyanazt a gombot többször megnyomva a 'Re-render' szócska csak egyszer íródott ki a
              console-ba</li>
            <li>???</li>
          </ul>
        </li>
        <li>A useEffect függvény 2 argomentumot fogad
          <ol>
            <li>Callback function
              <ul>
                <li>Akkor hívódik meg, ha a bármelyik specifikált függőség megváltozik</li>
              </ul>
            </li>
            <li>Tömb
              <ul>
                <li>A useEffect függvény összes függőségének felsorolásához</li>
              </ul>
            </li>
          </ol>
        </li>
        <pre>
  useEffect(() => (
      console.log(selectedButton)
  ), [selectedButton])
        </pre>
        <li>Megadtuk, hogy a callback függvény akkor fusson le, amikor a selectedButton értéke változik, és ebben az
          esetben logoljuk ezt az értéket</li>
        <li>Változatlan érték esetén a nem történik újabb logolás</li>
        <li>Amennyiben csak az első rendereléskor szeretnék valamilyen logikát lefuttatni, akkor egyszerűen csak egy
          üres tömböt szükséges adnunk a useEffect második argomentumának</li>
        <pre>
  useEffect(() => (
      console.log('First render')
  ), [])
        </pre>
        <li>Mivel tömbről beszélünk, így több dependenciát is megadhatunk, amikre rendre lefut a callback függvény</li>
        <pre>
  useEffect(() => (
      console.log('Run')
  ), [var1, var2, var3])
        </pre>
      </ul>
    </li>
    <li>Nézzünk életközelibb példát
      <ul>
        <li>Az alkalmazást frissítve jelenleg elveszítjük a bejelentkezett státuszunkat</li>
        <li>A useEffect hook-ot használhatjuk arra, hogy eltároljuk az aktuális állapotot, és egy esetleges
          újratöltésnél visszatöltsük azt
          <ul>
            <li>Cookie-t, vagy localStorage-t használhatunk</li>
            <li>Fontos, hogy state-et mindig csak event handler függvényben frissítünk, különben infinite loop-ot hozunk
              létre</li>
            <li>localStorage-ba csak stringet tárolhatunk</li>
          </ul>
        </li>
        <pre>
  <b>// App.js</b>
  function App() &#123;
  const [isLoggedIn, updateLoginStatus] = useState(() => &#123; // függvény is megadható
    const savedStatus = localStorage.getItem('isLoggedIn');
    return savedStatus ? JSON.parse(savedStatus) : false;
  });

  useEffect(() => &#123;
    localStorage.setItem('isLoggedIn', JSON.stringify(isLoggedIn)); // az isLoggedIn változása frissíti a localStorage-t
  }, [isLoggedIn])

  const onLogin = (email, password) => &#123;
    updateLoginStatus(true);
  }

  const onLogout = () => &#123;
    updateLoginStatus(false);
  }


  return ()
    ...
    &#123;
      selectedApp === 3 && &#60;>
        &#60;LoginHeader isLoggedIn=&#123;isLoggedIn} logout=&#123;onLogout} /> // átadjuk az isLoggedIn aktuális értékét, és az onLogout függvény referenciáját
        &#123;!isLoggedIn && &#60;LoginForm login=&#123;onLogin} />} // átadjuk az onLogin függvény referenciáját
        &#123;isLoggedIn && &#60;Home />}
      &#60;/>
    }
  }
  <b>// LoginHeader.js</b>
  import './LoginApp.scss';

  const LoginHeader = (props) => &#123;
      const onLogout = () => &#123;
          props.logout();
      }

      return (
          &#60;>
              &#60;div className="d-flex justify-content-between align-items-center header">
                  &#60;div className='ps-2'>&#60;b>Demo login&#60;/b>&#60;/div>
                  &#123;
                      props.isLoggedIn &&
                      &#60;div className="buttons">
                          &#60;button className="btn btn-sm btn-info">Users&#60;/button>
                          &#60;button className="btn btn-sm btn-info">Admin&#60;/button>
                          &#60;button className="btn btn-sm btn-primary" onClick=&#123;onLogout}>Logout&#60;/button> // App logout függvényének meghívása
                      &#60;/div>
                  }
              &#60;/div>
          &#60;/>
      )
  }

  export default LoginHeader;

  <b>// Home.js</b>
  const Home = (props) => &#123;
    return (
        &#60;>
            &#60;div className="d-flex justify-content-center p-5">
                &#60;div>&#60;i>You are successfully logged in&#60;/i>&#60;/div>
            &#60;/div>
        &#60;/>
    )
  }
  
  export default Home;
        </pre>
        <li>Más megoldás is lehet jó</li>
        <pre>
  <b>// App.js</b>
  ...
  const [isLoggedIn, updateLoginStatus] = useState(false); / inicializálásnál kap egy false értéket az isLoggedIn

  useEffect(() => &#123;
    const savedStatus = JSON.parse(localStorage.getItem('isLoggedIn'));
    if (savedStatus) &#123;
      updateLoginStatus(savedStatus); // ha van mentett érték (true), beállítjuk 
    }
  }, []);

  useEffect(() => &#123; // az isLoggedIn változásakor frissül a localStorage
    if (isLoggedIn) &#123;
      localStorage.setItem('isLoggedIn', JSON.stringify(isLoggedIn));
    }
  }, [isLoggedIn]);

  const onLogin = (email, password) => &#123; // belépéskor beállítjuk az isLoggedIn állapotot true-ra
    updateLoginStatus(true); 
  };

  const onLogout = () => &#123;
    updateLoginStatus(false);  // belépéskor false-re állítjuk az isLoggedIn állapotát
    localStorage.removeItem('isLoggedIn'); // töröljük a localStorage megfelelő kulcsát
  };
  ...
        </pre>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #dependencies data-anchor="dependencies">Dependencies</h5>
  <ul>
    <li>A useEffect második argumentuma egy dependencia tömb</li>
    <li>Ha az üres tömböt adjuk meg, az effekt csak egyszer fog lefutni, az első renderelés után</li>
    <li>Ha nem adunk meg dependency tömböt, a useEffect minden renderelés után újra lefut</li>
    <li>A useEffect újra fog futni, ha bármelyik változó, amelyet a tömbbe teszünk, megváltozik</li>
    <li>Legtöbbször a dependenciák azok az állapotok, akiket a callback function-ben használunk</li>
    <li>React Hook liner
      <ul>
        <li>A React Hook linter egy olyan eszköz, amely az ESLint szabályain keresztül segít a React Hook-ok helyes
          használatában</li>
        <li>Automatikusan figyelmeztet a hibákra</li>
        <li>Segít elkerülni a hibákat, például a rosszul megadott dependency tömböket</li>
        <pre>
  npm install eslint-plugin-react-hooks
        </pre>
      </ul>
    </li>
    <li>Az email és a password mezők inicializáláskor nem kapják meg a feltételes style-t, viszont blur event-re,
      amennyiben érvénytelenek, megkapják</li>
    <pre>
  <b>// LoginForm.js</b>
  import &#123; useEffect, useState } from "react";

  const LoginForm = (props) => &#123;

      const [enteredEmail, setEnteredEmail] = useState(''); // email állapot, alapértelmezetten üres string
      const [emailIsValid, setEmailIsValid] = useState(); // nem adunk kezdeti értéket, hogy az email input mező-re ne kerüljön rá a conditional style
      const [enteredPassword, setEnteredPassword] = useState(''); // jelszó állapot, alapértelmezetten üres string
      const [passwordIsValid, setPasswordIsValid] = useState(); // nem adunk kezdeti értéket, hogy a password input mező-re ne kerüljön rá a conditional style
      const [formIsValid, setFormIsValid] = useState(false); // az egész űrlap validitásának állapota, a submit button engedélyezése)

      const emailChangeHandler = (value) => &#123;
          setEnteredEmail(value); // email változó frissítése
      }

      const validateEmailHandler = () => &#123;
          setEmailIsValid(!!enteredEmail.includes('@')); // ha van "@" a megadott email-ben, valid/true
      }

      const passwordChangeHandler = (value) => &#123;
          setEnteredPassword(value); // jelszó változó frissítése
      }

      const validatePasswordHandler = () => &#123;
          setPasswordIsValid(enteredPassword.trim().length > 6); // ha a jelszó több mint 6 karakter, valid/true
      }

      const onLogin = (event) => &#123;
          event.preventDefault(); // alapértelmezett form működés megakadályozása
          props.login(); // onLogin callback meghívása, szülő komponens függvény referencia által
      }

      useEffect(() => &#123;
          setFormIsValid(
              emailIsValid && passwordIsValid // ha mindkét mező valid, a form valid/true
          );
      }, [enteredEmail, enteredPassword]); // a useEffect minden email és jelszó változásnál lefut

      return (
          &#60;>
              &#60;form className="mt-3" onSubmit=&#123;(e) => onLogin(e)}> &#123;/* az űrlap submit eseménye */}
                  &#60;div className="input-group mb-3">
                      &#60;span className="input-group-text" id="basic-addon1">Username&#60;/span>
                      &#60;input
                          id="email"
                          type="email"
                          className="form-control"
                          style=&#123; &#123;
                              borderColor: emailIsValid === false ? 'red' : '', &#123;/* ha az email nem valid, piros szegély */}
                              backgroundColor: emailIsValid === false ? 'rgb(190, 170, 170)' : '', &#123;/* ha az email nem valid, pirossas a háttér */}
                          }}
                          value=&#123;enteredEmail}
                          onChange=&#123;(e) => emailChangeHandler(e.target.value)} &#123;/* email változás kezelése */}
                          onBlur=&#123;validateEmailHandler}> &#123;/* email validálás, amikor az input mezőből kikattintunk */}
                      &#60;/input>
                  &#60;/div>

                  &#60;div className="input-group mb-3">
                      &#60;span className="input-group-text" id="basic-addon1">Password&#60;/span>
                      &#60;input
                          id="password"
                          type="password"
                          className="form-control"
                          style=&#123; &#123;
                              borderColor: passwordIsValid === false ? 'red' : '', // ha a jelszó nem valid, piros szegély
                              backgroundColor: passwordIsValid === false ? 'rgb(190, 170, 170)' : '',  // ha a jelszó nem valid, pirossas a háttér
                          }}
                          value=&#123;enteredPassword}
                          onChange=&#123;(e) => passwordChangeHandler(e.target.value)} &#123;/* Jelszó változás kezelése */}
                          onBlur=&#123;validatePasswordHandler}> &#123;/* Jelszó validálás, amikor az input mezőről elhagyjuk */}
                      &#60;/input>
                  &#60;/div>

                  &#60;div className="d-flex justify-content-center">
                      &#60;button type="submit" className=&#123;`btn $&#123;formIsValid ? 'btn-success' : 'btn-secondary'}`} disabled=&#123;!formIsValid}>Login&#60;/button> &#123;/* a gomb akkor aktív, ha az űrlap érvényes */}
                  &#60;/div>
              &#60;/form>
          &#60;/>
      )
  }

  export default LoginForm;
    </pre>
  </ul>
  <br>
  <h5 #cleanupfunction data-anchor="cleanupfunction">Clean-up function</h5>
  <ul>
    <li>Akkor használjuk, ha az effektusnak olyan erőforrásokat kell kezelnie, amelyeket a komponens eltávolításakor
      vagy a következő rendereléskor "tisztítani" kell</li>
    <li>A clean-up funkciót a useEffect visszaadja, és akkor hajtódik végre, amikor az effektus újra fut (ha a useEffect
      új dependenciát kap), vagy amikor a komponens eltávolításra kerül</li>
    <li>A clean-up function hasznos
      <ol>
        <li>Eseménykezelők regisztrálásakor</li>
        <li>ID-t generálálsakor</li>
        <li>WebSocket kapcsolatokat kezelésénél</li>
      </ol>
    </li>
    <pre>
  useEffect(() => &#123;
    // effektus logika
  
    return () => &#123;
      // clean-up logika, amikor a komponens újra lefut, vagy eltűnik
    };
  }, [dependencies]);
    </pre>
    <li>A clean-up függvény segít a komponens élettartama alatt keletkező erőforrások kezelésében, biztosítva, hogy
      ne maradjanak meg nem szükséges műveletek vagy eseménykezelők a komponens eltűnése után</li>
    <li>A useEffect függvény minden email vagy password mezőben lévő változáskor lefut
      <ul>
        <li>Nem a legszerencsésebb, mert a LoginForm komponens minden billentyű leütésekor újrarenderelődik</li>
        <li>Ha HTTP kérésről lenne szó, akkor sem szeretnénk minden változásra request-et küldeni</li>
        <li>Két jó megoldás
          <ol>
            <li>Összegyűjtünk egy adott mennyiségű billentyűleütést, és csak utána futtatjuk le a logikánkat</li>
            <li>Adott ideig várunk, és csak utána futtatjuk le a logikánkat</li>
          </ol>
        </li>
        <li>Debouncing-ot érdemes alkalmazni
          <ul>
            <li>Technika, amely segít az események túl gyakori kezeléseinek minimalizálásában
              <ul>
                <li>Billentyűleütések</li>
                <li>Gombkattintások</li>
              </ul>
            </li>
            <li>Egy esemény feldolgozása csak akkor történik meg, ha egy meghatározott időintervallumban nem érkezik
              újabb esemény ugyanabból a típusból</li>
            <li>Segít csökkenteni a felesleges számú API hívást vagy eseménykezelést, ezzel javítva a teljesítményt</li>
          </ul>
        </li>
        <pre>
  useEffect(() => &#123; // továbbra is minden billentyűleütésre lefut a tartalma, csak 500ms-os késleltetéssel
    let timerValue = setTimeout(() => &#123; // minden bilentyűleütésre egy timer indul el
        console.log('timer'); // gombleütés után 1 másodperccel fut le
        setFormIsValid(
            emailIsValid && passwordIsValid
        );
    }, 1000);

  }, [enteredEmail, enteredPassword]);
        </pre>
        <li>A setTimeout egy egyedi szám értékkel tér vissza az</li>
        <li>Ha elmentjük a timer egyedi azonosítóját, akkor újabb billentyűleütéskor kitörölhetjük az előző timer-t
          <ul>
            <li>A useEffect callback függvénye vissza tud adni értéket</li>
            <li>Ennek az értéknek mindenképpen függvénynek kell lennie
              <ul>
                <li>Ez a clean-up function</li>
              </ul>
            </li>
            <li>A clean-up függvény a useEffect callback függvény előtt fut le
              <ul>
                <li>Kivéve az első alkalommal</li>
              </ul>
            </li>
          </ul>
        </li>
        <br>
        <br>
        <img src="assets/imgs/react_form_cleanup.png" width="100%">
        <br>
        <br>
        <li>Az input mezőbe a számok egymást követően, 1 másodpercen belül lettek begépelve
          <ul>
            <li>Látható a log-ból, hogy sikeresen összevártuk a leütéseket</li>
            <li>A useEffect alapból mindig lefut, amikor a komponens első alkalommal renderelődik
              <ul>
                <li>Ez akkor is megtörténik, ha a függőségek az inicializáláskor nem változtak</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #usereducer data-anchor="usereducer">useReducer</h3>
  <ul>
    <li>State managementre használjuk
      <ul>
        <li>Mint a useState-et</li>
        <li>De bonyolultabb logikát igényel</li>
        <li>Változáskor újrarenderelődik a komponens</li>
      </ul>
    </li>
    <pre>
  let [state, dispatch] = useReducer(reducer, initialState);
    </pre>
    <li>Tömbbel tér vissza
      <ul>
        <li>Array destructoring-ot érdemes használni a kezelésére</li>
      </ul>
    </li>
    <li>Két argomentumot vár
      <ol>
        <li>reducer: Függvény, amely megkapja a jelenlegi állapotot és egy akciót, majd visszaad egy új állapotot</li>
        <li>initialState: Kezdeti érték</li>
      </ol>
    </li>
    <li>A kezdeti éllapot mindig objektum</li>
    <li>A reducer függvényt a komponens function-ön kívül definiáljuk</li>
    <li>Amennyiben frissítjük a state értékét, azzal együtt meghívjuk a reducer függvényünket
      <ul>
        <li>A reducer függvény felelős a state update-ért</li>
        <li>Ha nem adunk meg semmit a függvényben, akkor a state undefined lesz</li>
      </ul>
    </li>
    <pre>
  const reducer = (currentState, action) => &#123;
    return ...
  }
    </pre>
    <li>A reducer függvénynek 2 argomentuma van
      <ol>
        <li>currentState: Az adott állapotot tárolja</li>
        <li>action: reducer függvénynek átadott paraméter</li>
      </ol>
    </li>
    <li>A reducer függvényből értékkel kell visszatérnünk</li>
    <li>A reducer függvényen belül használhatunk if-else statement-et, vagy switch-case-t</li>
    <li>Az action egy objektum szokott lenni
      <ul>
        <li>Rendelkezik egy type kulccsal, és ezen kívül tartalmazhat még más kulcsot, kulcsokat is</li>
      </ul>
    </li>
    <li>A currentState közvetlen módosítása tilos, új objektumot kell létrehozni</li>
    <pre>
  import './ReducerApp.scss';
  import &#123; useReducer } from 'react';

  const reducer = (currentState, action) => &#123;
      console.log(currentState, action);
      switch (action.type) &#123;
          case '-': &#123;
              return &#123; ...currentState, count: currentState.count - 1 };
              // return &#123;...currentState, count: --currentState.count}; // közvetlen változtatja az aktuális értéket, ami tilos
          }
          case '+': &#123;
              return &#123; ...currentState, count: currentState.count + 1 };
          }
          default: &#123;
              return currentState;
          }
      }
  }

  const ReducerApp = (props) => &#123;
      let [state, dispatcher] = useReducer(reducer, &#123; count: 0 });

      const decrementHandler = () => &#123;
          dispatcher(&#123; type: '-' });
      }

      const incrementHandler = () => &#123;
          dispatcher(&#123; type: '+' });
      }

      return (
          &#60;>
              &#60;div className="reducer-container">
                  &#60;button onClick=&#123;decrementHandler}>-&#60;/button>
                  &#60;span>&#123;state.count}&#60;/span>
                  &#60;button onClick=&#123;incrementHandler}>+&#60;/button>
              &#60;/div>
          &#60;/>
      )
  }

  export default ReducerApp;
    </pre>
    <li>A LoginApp példához térünk most vissza
      <ul>
        <li>Láthattuk, hogy az enteredEmail / emailIsValid és az enteredPassword / passwordIsValid párosok 1-1 input
          mezőhöz köthetők
          <ul>
            <li>Csakúgy, mint az emailIsValid / passwordIsValid is köthető a formIsValid state-hez</li>
          </ul>
        </li>
        <pre>
  const [enteredEmail, setEnteredEmail] = useState('');
  const [emailIsValid, setEmailIsValid] = useState();
  const [enteredPassword, setEnteredPassword] = useState('');
  const [passwordIsValid, setPasswordIsValid] = useState();
  const [formIsValid, setFormIsValid] = useState(false);
        </pre>
        <li>A useReducer React hook-ot is használhatjuk, hogy ezeket az állapotokat előállítsuk
          <ul>
            <li>Komplexebb state-eket tudunk előállítani vele</li>
            <li>A useEffect használatát mellőzzük</li>
            <li>A reducer függvények azért kerülnek a komponens függvények kívülre, mert semmilyen változót, vagy
              state-et sem fogunk használni bennük, ami komponensen belüli</li>
          </ul>
        </li>
        <pre>
  <b>// LoginForm.js</b>
  const emailReducer = (currentState, action) => &#123; // azért a komponens függvényen kívülre kerül, mert
    switch (action.type) &#123;
        case 'EMAIL_INPUT':
            return &#123; value: action.value, isValid: undefined };
        case 'EMAIL_VALID':
            // return &#123; value: state.value, isValid: state.value.includes('@') }; // így is jó
            return &#123; value: action.value, isValid: action.value.includes('@') };
        default:
            return currentState;
    }
  }

  const passwordReducer = (currentState, action) => &#123; // azért a komponens függvényen kívülre kerül, mert
      switch (action.type) &#123;
          case 'PASSWORD_INPUT':
              return &#123; value: action.value, isValid: undefined };
          case 'PASSWORD_VALID':
              // return &#123; value: state.value, isValid: state.value.trim().length > 6 }; // így is jó
              return &#123; value: action.value, isValid: action.value.trim().length > 6 };
          default:
              return currentState;
      }
  }

  const LoginForm = (props) => &#123;
    // const [enteredEmail, setEnteredEmail] = useState('');
    // const [emailIsValid, setEmailIsValid] = useState();
    // const [enteredPassword, setEnteredPassword] = useState('');
    // const [passwordIsValid, setPasswordIsValid] = useState();
    const [formIsValid, setFormIsValid] = useState(false);

    let [emailState, emailDispatcher] = useReducer(emailReducer, &#123; value: '', isValid: null }); // null hatására az első betöltésnél nem lesz invalid az input mező
    let [passwordState, passwordDispatcher] = useReducer(passwordReducer, &#123; value: '', isValid: null }); // null hatására az első betöltésnél nem lesz invalid az input mező

    const emailChangeHandler = (value) => &#123;
        // setEnteredEmail(value);
        emailDispatcher(&#123; value: value, type: 'EMAIL_INPUT' });
    }

    const validateEmailHandler = () => &#123;
        // setEmailIsValid(!!emailState.value.includes('@'));
        emailDispatcher(&#123; value: emailState.value, type: 'EMAIL_VALID' })
    }

    const passwordChangeHandler = (value) => &#123;
        // setEnteredPassword(value);
        passwordDispatcher(&#123; value: value, type: 'PASSWORD_INPUT' });
    }

    const validatePasswordHandler = () => &#123;
        // setPasswordIsValid(enteredPassword.trim().length > 6);
        passwordDispatcher(&#123; value: passwordState.value, type: 'PASSWORD_VALID' });
    }

    const onLogin = (event) => &#123;
        event.preventDefault();
        props.login(emailState.value, passwordState.value);
    }

    /* useEffect(() => &#123;
        let timerValue = setTimeout(() => &#123;
            setFormIsValid(
                emailIsValid && passwordIsValid
            );
        }, 1000);

        console.log(timerValue);

        return () => &#123;
            clearTimeout(timerValue);
        }

    }, [enteredEmail, enteredPassword]); */

    return (
        &#60;>
            &#60;form className="mt-3" onSubmit=&#123;(e) => onLogin(e)}>
                &#60;div className="input-group mb-3">
                    &#60;span className="input-group-text" id="basic-addon1">Username&#60;/span>
                    &#60;input
                        id="email"
                        type="email"
                        className="form-control"
                        style=&#123; &#123;
                            borderColor: emailState.isValid === false ? 'red' : '',
                            backgroundColor: emailState.isValid === false ? 'rgb(190, 170, 170)' : '',
                        }}
                        value=&#123;emailState.value}
                        onChange=&#123;(e) => emailChangeHandler(e.target.value)}
                        onBlur=&#123;validateEmailHandler}>
                    &#60;/input>
                &#60;/div>

                &#60;div className="input-group mb-3">
                    &#60;span className="input-group-text" id="basic-addon1">Password&#60;/span>
                    &#60;input
                        id="password"
                        type="password"
                        className="form-control"
                        style=&#123; &#123;
                            borderColor: passwordState.isValid === false ? 'red' : '',
                            backgroundColor: passwordState.isValid === false ? 'rgb(190, 170, 170)' : '',
                        }}
                        value=&#123;passwordState.value}
                        onChange=&#123;(e) => passwordChangeHandler(e.target.value)}
                        onBlur=&#123;validatePasswordHandler}>
                    &#60;/input>
                &#60;/div>

                &#60;div className="d-flex justify-content-center">
                    &#60;button type="submit" className=&#123;`btn $&#123;formIsValid ? 'btn-success' : 'btn-secondary'}`} disabled=&#123;!formIsValid}>Login&#60;/button>
                &#60;/div>
            &#60;/form>
        &#60;/>
    )
  }
        </pre>
        <li>A form validálás még hiányzik a fenti kódból, így a submit gomb mindig disabled lesz</li>
        <li>Az emailReducer és passwordReducer függvények akár össze is vonhatók, mivel sokban nem térnek el egymástól
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #combiningwithuseeffect data-anchor="combiningwithuseeffect">Combining with useEffect</h5>
  <ul>
    <li>A login gomb disabled attribútuma a formIsValid változó/state értékétől függ
      <ul>
        <li>A kezdeti állapota false</li>
        <li>Korábban a useEffect hookban frissítettük
          <ul>
            <li>Ezután is így teszünk, csak egy kis változtatással</li>
            <pre>
  <b>LoginForm.js</b>
  ...
  useEffect(() => &#123;
    let timerValue = setTimeout(() => &#123;
        setFormIsValid(
            //emailIsValid && passwordIsValid
            // emailState.isValid && passwordState.isValid // ebben az esetben csak a blur esemény után válik valid-dá a form
            emailState.value.includes('@') && passwordState.value.trim().length > 6
        );
    }, 1000);

    return () => &#123;
        clearTimeout(timerValue);
    }
    // }, [enteredEmail, enteredPassword]);
    // }, [emailState, passwordState]); // mindkét state &#123; value: *string* , isValid: *boolean* } objektum
  }, [emailState.isValid, passwordState.isValid]); // csak akkor fut le a useEffect callback függvénye, ha valamelyik isValid érték megváltozik
  ...
            </pre>
            <li>A useEffect csak akkor fog lefutni, ha valamelyik dependencia tömbben lévő objektum referenciája
              megváltozik
              <ul>
                <li>Az objektumot a megfelelő helyen dekonstruálni kell, és tulajdonképpen új objektumot létrehozni</li>
                <li>Ha csak az egyik kulcsának az értékét változtatjuk meg, nem fut le a useEffect
                  <ul>
                    <li>Kivéve, ha kifejezetten az adott kulcsot adtuk meg dependenciaként, nem pedig az egész
                      objektumot
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #usestatevsusereducer data-anchor="usestatevsusereducer">useState vs useReducer</h5>
  <ul>
    <li>Mindkettő a React Hookok közé tartozik, és a komponens állapotának kezelésére szolgálnak, de különböznek abban,
      hogy hogyan kezelik az állapotot és mikor érdemes őket használni</li>
    <li>useState
      <ul>
        <li>Kisebb, egyszerűbb állapotok kezelésére alkalmas, ahol az állapot egy egyszerű érték (szám, szöveg, boolean)
        </li>
        <pre>
  const [state, setState] = useState(initialValue);
        </pre>
      </ul>
    </li>
    <li>useReducer
      <ul>
        <li>Bonyolultabb állapotokat kezelhetünk, amelyek több értéket tartalmaznak, és/vagy összetettebb logikát
          igényelnek</li>
        <li>Akkor érdemes használni, ha az állapot több részből áll, és ezek közül a részek közötti interakciók
          összetettek</li>
        <pre>
  const [state, dispatch] = useReducer(reducer, initialState);
        </pre>
      </ul>
    </li>
    <table style="width: 100%; table-layout: fixed">
      <thead>
        <tr>
          <th></th>
          <th>useState</th>
          <th>useReducer</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Használati eset</td>
          <td>Egyszerű állapotokhoz (pl. számok, stringek, booleanek)</td>
          <td>Összetett állapotokhoz, amelyek több értéket vagy komplex logikát tartalmaznak</td>
        </tr>
        <tr>
          <td>API egyszerűsége</td>
          <td>Egyszerű és könnyen érthető</td>
          <td>Összetettebb: reducer függvényt kell írni</td>
        </tr>
        <tr>
          <td>Állapot inicializálása</td>
          <td>Az állapotot közvetlenül az `useState` paraméterében adod meg</td>
          <td>Kezdő állapotot a második paraméterként adod meg</td>
        </tr>
        <tr>
          <td>Állapot frissítés</td>
          <td>Az állapotot közvetlenül a `setState` segítségével módosítod</td>
          <td>Diszpécser (`dispatch`) hívásokon keresztül frissíted, az action-öket használva</td>
        </tr>
        <tr>
          <td>Olvashatóság</td>
          <td>Egyszerűbb logika, kevesebb boilerplate kód</td>
          <td>Jobban strukturált kód bonyolultabb logikáknál</td>
        </tr>
        <tr>
          <td>Teljesítmény</td>
          <td>Kisebb állapotoknál kevesebb overhead</td>
          <td>Bonyolultabb állapotkezelésnél hatékonyabb, mivel a reducer centralizálja a logikát</td>
        </tr>
        <tr>
          <td>Példa</td>
          <td>
            <pre>
  const [count, setCount] = useState(0);
  setCount(count + 1);
            </pre>
          </td>
          <td>
            <pre>
  const [state, dispatch] = useReducer(reducer, initialState);
  dispatch(&#123; type: 'increment' });
            </pre>
          </td>
        </tr>
      </tbody>
    </table>
  </ul>
</div>

<div>
  <h3 #usecontext data-anchor="usecontext">useContext</h3>
  <ul>
    <li>React context
      <ul>
        <li>Globális state kezelő</li>
        <li>Beépített funkció, amely lehetővé teszi, hogy a komponensek közötti adatokat anélkül osszuk meg, hogy azokat
          minden szinten prop-ként kellene továbbadni</li>
        <li>különösen hasznos, ha egy adatot vagy állapotot több, egymástól távoli komponens között kell megosztani</li>
        <li>Három fő lépéssel hozható létre
          <ol>
            <li>React.createContext()</li>
            <li>A Provider komponens "továbbadja" az adatokat a fa alatti komponensek számára</li>
            <li>A Consumer komponensek hozzáférnek a context által megosztott adatokhoz</li>
          </ol>
        </li>
        <li>A useContext hook használata a modern applikációkban már elterjedtebb</li>
        <pre>
  <b>// LoginApp.js</b>
  const LoginApp = (props) => &#123;
    const [isLoggedIn, updateLoginStatus] = useState(() => &#123;
        const savedStatus = localStorage.getItem('isLoggedIn');
        return savedStatus ? JSON.parse(savedStatus) : false;
    });
    ...
  }
        </pre>
        <li>Az isLoggedIn state csakis kizárólag a LoginApp komponensben létezik
          <ul>
            <li>Alapvetően props segítségével továbbadhatjuk a gyerek komponenseknek</li>
            <li>A gyerek komponensnek attribútumot adunk, és hozzákötjük az isLoggedIn state-et</li>
            <pre>
  <b>// LoginApp.js</b>
  return (
      &#60;>
          &#60;LoginHeader isLoggedIn=&#123;isLoggedIn} logout=&#123;onLogout} /> // itt
          ...
      &#60;/>
  )
            </pre>
            <li>A React Context segítségével globálissá tehetjük a state-eket
              <ul>
                <li>Így nem szükséges a state-eket props-on keresztül továbbadni a child komponenseknek ahhoz, hogy
                  használjuk őket a gyerekekben</li>
                <pre>
  import React from 'react';

  let AuthContext = React.createContext(&#123; isLoggedIn: false }); // kezdő értéket adhatunk meg argomentumnak (number, string, boolean, array, object)

  export default AuthContext;
                </pre>
                <li>Ezzel létre is hoztunk egy context-et</li>
                <li>A kezdőérték akkor hasznos, ha a context-et fogyasztó komponens nem egy Provider-en belül van, vagy
                  ha valamilyen alapértelmezett értéket szeretnénk biztosítani</li>
                <li>Ahhoz, hogy a LoginApp-ban használjuk ezt a kontextust, első lépésként wrappelnünk szükséges a
                  JSX-et</li>
                <pre>
  <b>// LoginApp.js</b>
  const LoginApp = (props) => &#123;
    ...
    return (
      &#60;> // megtartható, de nem szükséges
          &#60;AuthContext.Provider value=&#123; &#123;isLoggedIn: false}}>  &#123;/* az objektumban lévő isLoggedIn kulcs tárolja ezen komponens isLoggedIn state-jét*/}
              &#60;LoginHeader logout=&#123;onLogout} /> &#123;/* az isLoggedIn attribútummal való átadására nincs már szükség isLoggedIn=&#123;isLoggedIn} */}
              &#123;!isLoggedIn && &#60;LoginForm login=&#123;onLogin} />}
              &#123;isLoggedIn && &#60;Home />}
          &#60;/AuthContext.Provider>
      &#60;/>
  }
                </pre>
                <li>A Providernek megadhatunk value-t, ami az összes child komponensben (és azok gyerekeiben is)
                  elérhető lesz</li>
                <li>Létrehoztunk egy külön navigációs komponenst a LoginHeader.js-ben</li>
                <pre>
  <b>// LoginHeader.js</b>
  const LoginHeader = (props) => &#123;
    const onLogout = () => &#123;
        props.logout();
    }

    return (
        &#60;>
            &#60;div className="d-flex justify-content-between align-items-center header">
                &#60;div className='ps-2'>&#60;b>Demo login&#60;/b>&#60;/div>
                &#60;Navigation isLoggedIn=&#123;props.isLoggedIn} logout=&#123;onLogout} />
            &#60;/div>
        &#60;/>
    )
  }
  <b>// Navigation.js</b>
  const Navigation = (props) => &#123;
    const onLogout = () => &#123;
        props.logout();
    }

    return (
        &#60;>
            &#123;
                props.isLoggedIn &&
                &#60;div className="buttons">
                    &#60;button className="btn btn-sm btn-info">Users&#60;/button>
                    &#60;button className="btn btn-sm btn-info">Admin&#60;/button>
                    &#60;button className="btn btn-sm btn-primary" onClick=&#123;onLogout}>Logout&#60;/button>
                &#60;/div>
            }
        &#60;/>
    )
  }
                </pre>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #contextvsprops data-anchor="contextvsprops">Context vs props</h5>
  <ul>
    <li>React Context-et akkor használunk, ha state-et vagy event handler függvényt több komponens-szinten keresztül
      kell megosztani, és el akarjuk kerülni a prop drilling-et
      <ul>
        <li>A prop drilling egy olyan jelenség a React-ben, amikor egy komponensnek adatot (prop-okat) kell átadnia egy
          mélyen/mélyebben beágyazott gyermekkomponensnek, amihez köztes komponensen keresztül kell "továbbcsorgatni"
          (drill), még akkor is, ha a köztes komponensek nem használják az adatot</li>
        <li>Ha csak 1-2 szintet érint, és az adatszerkezet egyszerű, akkor nincs szükség Context-re vagy más bonyolult
          megoldásra</li>
        <li>A prop drilling önmagában nem hiba, csak bizonyos helyzetekben feleslegesen bonyolítja a kódot</li>
      </ul>
    </li>
    <li>Nem szükséges Context-et használni, ha az adatot vagy event handler-t közvetlenül tovább tudjuk adni
      szülőtől gyerek komponensnek</li>
    <pre>
  <b>LoginApp.js</b>
  return (
    &#60;>
        &#60;AuthContext.Provider value=&#123; &#123; isLoggedIn: isLoggedIn }}> &#123;/* a state-et itt adjuk át */}
            &#60;LoginHeader logout=&#123;onLogout} /> &#123;/* az isLoggedIn attribútummal való átadására nincs már szükség isLoggedIn=&#123;isLoggedIn} */}
            &#123;!isLoggedIn && &#60;LoginForm login=&#123;onLogin} />}
            &#123;isLoggedIn && &#60;Home />}
        &#60;/AuthContext.Provider>
    &#60;/>
  )

  ↓↓↓↓↓

  return (
    &#60;>
        &#60;AuthContext.Provider value=&#123; &#123; isLoggedIn: isLoggedIn, onLogout: onLogout }}> &#123;/* a state-et itt adjuk át */}
            &#60;LoginHeader /> &#123;/* az isLoggedIn attribútummal való átadására nincs már szükség isLoggedIn=&#123;isLoggedIn} */}
            &#123;!isLoggedIn && &#60;LoginForm login=&#123;onLogin} />}
            &#123;isLoggedIn && &#60;Home />}
        &#60;/AuthContext.Provider>
    &#60;/>
  )

  <b>// LoginHeader.js</b>
  const onLogout = () => &#123;
    props.logout();
  }

  return (
      &#60;>
          &#60;div className="d-flex justify-content-between align-items-center header">
              &#60;div className='ps-2'>&#60;b>Demo login&#60;/b>&#60;/div>
              &#60;Navigation logout=&#123;onLogout} /> &#123;/* kikerült a isLoggedIn=&#123;props.isLoggedIn} */}
          &#60;/div>
      &#60;/>
  )

  ↓↓↓↓↓

  return (
    &#60;>
        &#60;div className="d-flex justify-content-between align-items-center header">
            &#60;div className='ps-2'>&#60;b>Demo login&#60;/b>&#60;/div>
            &#60;Navigation /> &#123;/* kikerült a isLoggedIn=&#123;props.isLoggedIn} */}
        &#60;/div>
    &#60;/>
  )

  <b>// Navigation.js</b>
  let context = useContext(AuthContext); // objektumot ad vissza ( &#60;AuthContext.Provider value=&#123; &#123; isLoggedIn: isLoggedIn }}> )

  return (
    &#60;>
        &#123;
            context.isLoggedIn && // props.isLoggedIn helyett
            &#60;div className="buttons">
                &#60;button className="btn btn-sm btn-info">Users&#60;/button>
                &#60;button className="btn btn-sm btn-info">Admin&#60;/button>
                &#60;button className="btn btn-sm btn-primary" onClick=&#123;onLogout}>Logout&#60;/button>
            &#60;/div>
        }
    &#60;/>
  )

  ↓↓↓↓↓

  let context = useContext(AuthContext); // objektumot ad vissza ( &#60;AuthContext.Provider value=&#123; &#123; isLoggedIn: isLoggedIn }}> )

  return (
      &#60;>
          &#123;
              context.isLoggedIn && // props.isLoggedIn helyett
              &#60;div className="buttons">
                  &#60;button className="btn btn-sm btn-info">Users&#60;/button>
                  &#60;button className="btn btn-sm btn-info">Admin&#60;/button>
                  &#60;button className="btn btn-sm btn-primary" onClick=&#123;context.onLogout}>Logout&#60;/button>
              &#60;/div>
          }
      &#60;/>
  )
    </pre>
    <li>A contect.onLogout a LoginApp komponensben lévő onLogout függvényre fog mutatni
      <ul>
        <li>Így props helyett context-et használtunk</li>
        <li>A fejlesztőkörnyezet csak akkor fogja feldobni a context.onLogout-ot, ha az AuthContext komponensben
          definiáltuk az onLogout-ot</li>
        <pre>
  <b>// AuthContext.js</b>
  import React from 'react';

  let AuthContext = React.createContext(&#123; isLoggedIn: false, onLogout: undefined});

  export default AuthContext;
          </pre>
      </ul>
    </li>
    <li>Amennyiben nincs szükség arra, hogy továbbítsuk a state-et vagy event handler függvényt a gyerekek gyerekeinek,
      a props használata jobb választás
    </li>
    <li>Ha az adatot több komponensen keresztül kell továbbítanunk, ráadásul köztes komponensek is igénybe veszik, akkor
      a context-et érdemes használni</li>
  </ul>
  <br>
  <h5 #customcontextprovider data-anchor="customcontextprovider">Custom context provider</h5>
  <ul>
    <li>Tekintsük a LoginApp komponensünket root-nak
      <ul>
        <li>Ebben a komponensben oldjuk meg a ki- és a bejelentkezés logikáját</li>
        <li>Pedig a fő feladata tartalom megjelenítése a UI-on</li>
        <li>Érdemes minél "tisztábban" tartani a root komponenst
          <ul>
            <li>Ezesetben kiszervezni a login-logout logikát egy "context management" komponensbe</li>
          </ul>
        </li>
      </ul>
      <pre>
  <b>// index.js</b>
  import &#123; AuthContextProvider } from './components/Context/AuthContext';
  
  const root = ReactDOM.createRoot(document.getElementById('root'));

  root.render( 
    &#60;AuthContextProvider> // az App komponens az AuthContextProvider-en belül van, az App az AuthContextProvider "props.children-jében jelenik meg"
      &#60;App /> // az App, és annak alkomponensei hozzáférnek az auth kontextushoz
    &#60;/AuthContextProvider>
  );

  <b>// LoginApp.js</b>

  let authCtx = useContext(AuthContext);

  return (
      &#60;> // itt elhelyezve az AuthContextProvider-t valamiért nem frissül az authCtx
          &#60;LoginHeader />
          &#123;!authCtx.isLoggedIn && &#60;LoginForm />} // ha nem vagyunk bejelentkezve, ez jelenik meg
          &#123;authCtx.isLoggedIn && &#60;Home />} // ha be vagyunk bejelentkezve, ez jelenik meg
      &#60;/>
  )

  <b>// LoginForm.js</b>
  const LoginForm = (props) => &#123;
    ...
    let authCtx = useContext(AuthContext) // így érjük el az AuthContext-et

    const onLogin = (event) => &#123;
      event.preventDefault();
      authCtx.onLogin(emailState.value, passwordState.value); // az auth kontextus bejelentkezés metódusának meghívása
    }

    return (
      &#60;>
        &#60;form className="mt-3" onSubmit=&#123;(e) => onLogin(e)}>
          ...
        &#60;/form>
      &#60;/>
    )

    <b>// AuthContext.js</b>
    let AuthContext = React.createContext( // kezdő értéket adhatunk meg argomentumnak (number, string, boolean, array, object)
        &#123;
            isLoggedIn: false, // alapértelmezett állapot
            onLogin: undefined,
            onLogout: undefined
        }
    );

    export const AuthContextProvider = (props) => &#123;
        const [isLoggedIn, setIsLoggedIn] = useState(() => &#123; // állapot inicializálása a localStorage alapján
          const savedStatus = localStorage.getItem('isLoggedIn');
          return savedStatus ? JSON.parse(savedStatus) : false;
        });

        useEffect(() => &#123;
            localStorage.setItem('isLoggedIn', JSON.stringify(isLoggedIn));
        }, [isLoggedIn]);

        const loginHandler = () => &#123; // event handler function
            localStorage.setItem('isLoggedIn', JSON.stringify(isLoggedIn));
            setIsLoggedIn(true);
        }

        const logoutHandler = () => &#123; // event handler function
            localStorage.removeItem('isLoggedIn');
            setIsLoggedIn(false);
        }

        // a Provider felelős azért, hogy az alatta lévő komponensfában elérhetővé tegye a kontextus értékeit
        return &#60;AuthContext.Provider value=&#123; // a value egy objektum, amely tartalmazza azokat az adatokat, metódusokat, vagy értékeket, amelyeket elérhetővé akarunk tenni a kontextus számára
            &#123;
                isLoggedIn: isLoggedIn,
                onLogin: loginHandler,
                onLogout: logoutHandler,
            }
        }>
            &#123;props.children} // gyerek komponensek elhelyezése, esetünkben az App
        &#60;/AuthContext.Provider>
    }

    export default AuthContext;
      </pre>
    </li>
    <li>Létrehoztunk egy AuthContext-et, amely egy központi helyen tárolja a hitelesítéssel kapcsolatos állapotot
      (isLoggedIn), és a hitelesítési műveleteket (onLogin, onLogout)</li>
    <li>Az AuthContextProvider komponens biztosítja ezt az állapotot és funkciókat a komponensfa alatta lévő részeinek
    </li>
    <li>A prop drilling-et sikeresen elkerültük</li>
    <br>
    <li>Létrehoztunk az AuthContext.js fájlban egy új komponenst, amit exportáltunk is
      <ul>
        <li>Nem default export, hanem named export</li>
      </ul>
    </li>
    <li>Bármit is specifikálunk a AuthContextProvider komponensben, kirenderelődik</li>
    <li>Ezzel a teljes login state-et, és a context-et is kezeljük</li>
    <li>Bármely komponensben elérhetjük az AuthContext-et
      <ul>
        <pre>
  let authCtx = useContext(AuthContext);
        </pre>
        <li>Elérjük az isLoggedIn változót, és akár függvényt is hívhatunk bárhonnan</li>
        <pre>
  authCtx.onLogin(emailState.value, passwordState.value);
        </pre>
      </ul>
    </li>
    <li>A isLoggedIn állapot a useState segítségével kezelt</li>
    <li>A useEffect figyeli a isLoggedIn változását, és automatikusan frissíti a localStorage-ben lévő értéket, valamint
      biztosítja, hogy a felhasználó hitelesítési állapota fennmaradjon az oldalon belüli frissítések során
      <ul>
        <li>A tényleges visszatöltésről a AuthContextProvider első néhány sora gondoskodik</li>
      </ul>
    </li>
    <li>A loginHandler és logoutHandler funkciók kezelik a belépési és kilépési műveleteket, és frissítik az állapotot
    </li>
  </ul>
  <br>
  <h5 #contextlimitations data-anchor="contextlimitations">Context limitations</h5>
  <ul>
    <li>Context használatakor előfordulhat, hogy egy kompoenst újra fel nem használhatóvá teszünk
      <ul>
        <li>Ha például a Button.js-ben context-et használnánk, és onClick eseményre a fixen meghívnánk a
          context.onLogout függvényt, akkor az amúgy props.eventHandler-t kezelő/futtató logikánknak végleg oda lenne
        </li>
        <pre>
  function Button(props) &#123;
    return (
        &#60;button
            onClick=&#123;props.eventHandler}
            className="btn btn-primary"
            disabled=&#123;props.disable}
        >
            &#123;props.children}
        &#60;/button>
    )
  }
        </pre>
      </ul>
    </li>
    <li>A context nincs optimalizálva arra, hogy a kontextusban lévő értékek gyakran változnak
      <ul>
        <li>Folyamatos újrarendereléseket eredményez</li>
        <li>Amennyiben mégis app-szerte szükségünk van pl. változókra, más React tool-t hívunk segítségül
          <ul>
            <li>Ezt a tool-t Redux-nak nevezzük</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Azt se felejtsük el, hogy a kontextus nem helyettesít minden komponens kommunikációt, használata nem minden
      esetben a legoptimálisabb
      <ul>
        <li>Használhatunk props-t is</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #useimperativehandlerandforwardref data-anchor="useimperativehandlerandforwardref">
    useImperativeHandler & forwardRef</h3>
  <ul>
    <li>A useImperativeHandle hook lehetővé teszi, hogy a komponens kommunikáljon egy másik komponenssel imperatív módon
      <ul>
        <li>Tehát anélkül, hogy a React által megszokott deklaratív adatkezelést (pl. props, vagy state változásokat)
          használná</li>
        <li>A deklaratív módon átadott információ közvetlenül történik, props-on keresztül</li>
        <li>Imperatív esetben explicit módon meghívunk egy függvényt, vagy manipuláljuk az objektumot</li>
      </ul>
    </li>
    <li>A useImperativeHandle hozzáférést biztosít bizonyos funkciókhoz, vagy állapotokhoz egy másik komponens számára
      ref-en keresztül
      <ul>
        <li>A ref egy olyan JavaScript objektum, amely lehetővé teszi, hogy a komponens közvetlenül hozzáférjen egy
          másik komponenshez vagy DOM elemhez, így imperatív módon használhatjuk azt</li>
      </ul>
    </li>
    <li>Nem sűrűn használatos
      <ul>
        <li>Néha ugyanakkor hasznos</li>
      </ul>
    </li>
    <br>
    <pre>
  <b>// LoginForm.js (teljes file)</b>
  const emailReducer = (currentState, action) => &#123; // azért a komponens függvényen kívülre kerül, mert
    switch (action.type) &#123;
        case 'EMAIL_INPUT':
            return &#123; value: action.value, isValid: undefined };
        case 'EMAIL_VALID':
            // return &#123; value: state.value, isValid: state.value.includes('@') }; // így is jó
            return &#123; value: action.value, isValid: action.value.includes('@') }; // azért érzékel a useEffect változást, mert így új referenciát adunk vissza
        default:
            return currentState;
    }
  }

  const passwordReducer = (currentState, action) => &#123; // azért a komponens függvényen kívülre kerül, mert
      switch (action.type) &#123;
          case 'PASSWORD_INPUT':
              return &#123; value: action.value, isValid: undefined };
          case 'PASSWORD_VALID':
              // return &#123; value: state.value, isValid: state.value.trim().length > 6 }; // így is jó
              return &#123; value: action.value, isValid: action.value.trim().length > 6 };; // azért érzékel a useEffect változást, mert így új referenciát adunk vissza
          default:
              return currentState;
      }
  }

  const LoginForm = (props) => &#123;
    const [formIsValid, setFormIsValid] = useState(false);

    let [emailState, emailDispatcher] = useReducer(emailReducer, &#123; value: '', isValid: null }); // null hatására az első betöltésnél nem lesz invalid az input mező
    let [passwordState, passwordDispatcher] = useReducer(passwordReducer, &#123; value: '', isValid: null }); // null hatására az első betöltésnél nem lesz invalid az input mező

    let authCtx = useContext(AuthContext);

    let emailRef = useRef();
    let pwdRef = useRef();

    const emailChangeHandler = (value) => &#123;
        // setEnteredEmail(value);
        emailDispatcher(&#123; value: value, type: 'EMAIL_INPUT' });
    }

    const validateEmailHandler = () => &#123;
        // setEmailIsValid(!!emailState.value.includes('@'));
        emailDispatcher(&#123; value: emailState.value, type: 'EMAIL_VALID' })
    }

    const passwordChangeHandler = (value) => &#123;
        // setEnteredPassword(value);
        passwordDispatcher(&#123; value: value, type: 'PASSWORD_INPUT' });
    }

    const validatePasswordHandler = () => &#123;
        // setPasswordIsValid(enteredPassword.trim().length > 6);
        passwordDispatcher(&#123; value: passwordState.value, type: 'PASSWORD_VALID' });
    }

    const onLogin = (event) => &#123;
        event.preventDefault();
        if (formIsValid) &#123;
            authCtx.onLogin(emailState.value, passwordState.value);
        } else if (!emailState.isValid) &#123; // ha nem valid az email mező, belefókuszálunk
            emailRef.current.focus();
        } else &#123; // if (!passwordState.isValid) &#123; // ha nem valid a password mező, belefókuszálunk
            pwdRef.current.focus();
        }
    }

    useEffect(() => &#123;
        let timerValue = setTimeout(() => &#123;
            setFormIsValid(
                //emailIsValid && passwordIsValid
                // emailState.isValid && passwordState.isValid // ebben az esetben csak a blur esemény után válik valid-dá a form
                emailState.value.includes('@') && passwordState.value.trim().length > 6
            );
        }, 1000);

        return () => &#123;
            clearTimeout(timerValue);
        }
        // }, [enteredEmail, enteredPassword]);
        // }, [emailState, passwordState]); // mindkét state &#123; value: *string* , isValid: *boolean* } objektum
    }, [emailState.isValid, passwordState.isValid]); // csak akkor fut le a useEffect callback függvénye, ha valamelyik isValid érték megváltozik

    return (
        &#60;>
            &#60;form className="mt-3" onSubmit=&#123;(e) => onLogin(e)}>
                &#60;div className="input-group mb-3">
                    &#60;span className="input-group-text" id="basic-addon1">Username&#60;/span>
                    &#60;input
                        id="email"
                        type="email"
                        ref=&#123;emailRef}
                        className="form-control"
                        style=&#123; &#123;
                            borderColor: emailState.isValid === false ? 'red' : '',
                            backgroundColor: emailState.isValid === false ? 'rgb(190, 170, 170)' : '',
                        }}
                        value=&#123;emailState.value}
                        onChange=&#123;(e) => emailChangeHandler(e.target.value)}
                        onBlur=&#123;validateEmailHandler}>
                    &#60;/input>
                &#60;/div>

                &#60;div className="input-group mb-3">
                    &#60;span className="input-group-text" id="basic-addon1">Password&#60;/span>
                    &#60;input
                        id="password"
                        type="password"
                        ref=&#123;pwdRef}
                        className="form-control"
                        style=&#123; &#123;
                            borderColor: passwordState.isValid === false ? 'red' : '',
                            backgroundColor: passwordState.isValid === false ? 'rgb(190, 170, 170)' : '',
                        }}
                        value=&#123;passwordState.value}
                        onChange=&#123;(e) => passwordChangeHandler(e.target.value)}
                        onBlur=&#123;validatePasswordHandler}>
                    &#60;/input>
                &#60;/div>

                &#60;div className="d-flex justify-content-center">
                    &#123;/*&#60;button type="submit" className=&#123;`btn $&#123;formIsValid ? 'btn-success' : 'btn-secondary'}`} disabled=&#123;!formIsValid}>Login&#60;/button>*/}
                    &#60;button type="submit" className=&#123;`btn $&#123;formIsValid ? 'btn-success' : 'btn-secondary'}`}>Login&#60;/button>
                &#60;/div>
            &#60;/form>
        &#60;/>
    )
  }
  
  export default LoginForm;
    </pre>
    <li>A submit gombja a formnak mindig kattintható, lekerült róla a disabled attribútum</li>
    <li>Submit-eléskor megnézzük, hogy érvényes-e a form, és amennyiben nem, megvizsgáljuk, hogy melyik mezője invalid
      <ul>
        <li>Az első invalid mezőbe fókuszálunk, amit useRef segítségével teszünk meg</li>
        <li>Az emailRef és a pwdRef változókban a megfelelő input mezőhöz lesz referenciánk</li>
      </ul>
    </li>
    <li>Ezután nézzük meg, el tudjuk-e érni custom input element-tel ugyanezt a funkcionalitást
      <ul>
        <li>Custom komponensen nem használható a ref prop
          <ul>
            <li>Csak HTML elemeken használható</li>
          </ul>
        </li>
        <pre>
  ref=&#123; emailRef }
        </pre>
        <li>Ugyanakkor van rá mód, hogy működőképessé tegyük
          <ul>
            <li>forwardRef-et használhatunk
              <ul>
                <li>A React.forwardRef egy speciális React-függvény, amely lehetővé teszi, hogy egy komponens
                  továbbítson egy ref-et egy belső DOM-elemhez, vagy egy másik komponenshez</li>
                <li>A ref nem része a props-nak, hanem külön argumentumként van átadva</li>
              </ul>
            </li>
            <li>Ahelyett, hogy visszaadnánk a custom komponens függvényünket a szokott módon, odaadhatjuk a függvényt
              egy másik függvény argomentumának</li>
            <pre>
  const Input = (props) => &#123;
    return (
        &#60;>
            &#60;div className=&#123;`input-group mb-3 $&#123;styles.input_container}`}>
                &#60;span className="input-group-text" id="basic-addon1">&#123;props.label}&#60;/span>
                &#60;input
                    id=&#123;props.id}
                    type=&#123;props.type}
                    className='form-control'
                    style=&#123; &#123;
                        borderColor: props.emailState.isValid === false ? 'red' : '',
                        backgroundColor: props.emailState.isValid === false ? 'rgb(190, 170, 170)' : '',
                    }}
                    value=&#123;props.value}
                    onChange=&#123;(e) => props.onChangeHandler(e.target.value)}
                    onBlur=&#123;props.onBlurHandler}>
                &#60;/input>
            &#60;/div>
        &#60;/>
    )
  }

  ↓↓↓↓↓

  const Input = React.forwardRef((props, ref) => &#123; // második argomentuma a custom elemnek átadott ref
    return (
        &#60;>
            &#60;div className=&#123;`input-group mb-3 $&#123;styles.input_container}`}>
                &#60;span className="input-group-text" id="basic-addon1">&#123;props.label}&#60;/span>
                &#60;input
                    id=&#123;props.id}
                    type=&#123;props.type}
                    className='form-control'
                    style=&#123; &#123;
                        borderColor: props.emailState.isValid === false ? 'red' : '',
                        backgroundColor: props.emailState.isValid === false ? 'rgb(190, 170, 170)' : '',
                    }}
                    value=&#123;props.value}
                    onChange=&#123;(e) => props.onChangeHandler(e.target.value)}
                    onBlur=&#123;props.onBlurHandler}>
                &#60;/input>
            &#60;/div>
        &#60;/>
    )
  }
  )
            </pre>
            <li>Ezen a módon használhatunk ref attribútumot custom komponensen
              <ul>
                <li>Viszont ettől még custom input elemnek nem lesz .focus() metódusa</li>
                <li>Kilogolva az emailRef property-t, az eredmény undefined</li>
              </ul>
            </li>
            <li>useImperativeHandle hook
              <ul>
                <li>2 argomentumot fogad
                  <ol>
                    <li>ref props, ami a forwardRef második paramétere</li>
                    <li>callback függvény, ami objektummal tér vissza
                      <ul>
                        <li>Definiáljuk benne azokat az "adatokat", amiket a komponensen kívül használni kívánunk</li>
                      </ul>
                    </li>
                  </ol>
                </li>
                <pre>
  <b>// LoginForm.js</b>
  const LoginForm = (props) => &#123;
    ...
    let emailRef = useRef();
    ...
    const onLogin = (event) => &#123;
      event.preventDefault();
      if (formIsValid) &#123;
          authCtx.onLogin(emailState.value, passwordState.value);
      } else if (!emailState.isValid) &#123;
          // emailRef.current.focus();
          emailRef.current.onFocus(); // a custom Input komponens useImperativeHandle függvényének második paraméterénél található onFocus kulcs alatt található függvény hívódik meg
      } else &#123; // if (!passwordState.isValid) &#123;
          pwdRef.current.focus();
      }
    }
    ...

    return (
        &#60;>
            &#60;form className="mt-3" onSubmit=&#123;(e) => onLogin(e)}> 
                &#60;Input &#123;/* custom elem */}
                    ref=&#123;emailRef} // az emailRef tartalma: &#123; current.onFocus() }, az Input elemből származó onFocus
                    id=&#123;'email'}
                    type=&#123;'email'}
                    label=&#123;'Username'}
                    emailState=&#123;emailState}
                    value=&#123;emailState.value}
                    isValid=&#123;emailState.isValid}
                    onChangeHandler=&#123;emailChangeHandler}
                    onBlurHandler=&#123;validateEmailHandler}
                />

                &#60;div className="input-group mb-3">
                    &#60;span className="input-group-text" id="basic-addon1">Password&#60;/span>
                    &#60;input
                        id="password"
                        type="password"
                        ref=&#123;pwdRef}
                        className="form-control"
                        style=&#123; &#123;
                            borderColor: passwordState.isValid === false ? 'red' : '',
                            backgroundColor: passwordState.isValid === false ? 'rgb(190, 170, 170)' : '',
                        }}
                        value=&#123;passwordState.value}
                        onChange=&#123;(e) => passwordChangeHandler(e.target.value)}
                        onBlur=&#123;validatePasswordHandler}>
                    &#60;/input>
                &#60;/div>

                &#60;div className="d-flex justify-content-center">
                    &#123;/*&#60;button type="submit" className=&#123;`btn $&#123;formIsValid ? 'btn-success' : 'btn-secondary'}`} disabled=&#123;!formIsValid}>Login&#60;/button>*/}
                    &#60;button type="submit" className=&#123;`btn $&#123;formIsValid ? 'btn-success' : 'btn-secondary'}`}>Login&#60;/button>
                &#60;/div>
            &#60;/form>
        &#60;/>
    )
  }

  <b>Input.js</b>
  import React, &#123; useImperativeHandle, useRef } from 'react';

  const Input = React.forwardRef((props, ref) => &#123;
      const inputRef = useRef();

      useImperativeHandle(ref, () => &#123;
          return &#123;onFocus: customFocus}; // a onFocus property megkapja a customFocus függvény referenciáját
      })

      function customFocus() &#123; // a custom komponensben létrehozzuk a "saját" fókuszunkat
          inputRef.current.focus();
      }

      return (
          &#60;>
              &#60;div className=&#123;`input-group mb-3 $&#123;styles.input_container}`}>
                  &#60;span className="input-group-text" id="basic-addon1">&#123;props.label}&#60;/span>
                  &#60;input
                      ref=&#123;inputRef}
                      id=&#123;props.id}
                      type=&#123;props.type}
                      className='form-control'
                      style=&#123; &#123;
                          borderColor: props.emailState.isValid === false ? 'red' : '',
                          backgroundColor: props.emailState.isValid === false ? 'rgb(190, 170, 170)' : '',
                      }}
                      value=&#123;props.value}
                      onChange=&#123;(e) => props.onChangeHandler(e.target.value)}
                      onBlur=&#123;props.onBlurHandler}>
                  &#60;/input>
              &#60;/div>
          &#60;/>
      )
  }
  )
                </pre>
                <li>A useImperativeHandle hook-ot érdemes elkerülni, és csak akkor használni, ha tényleg muszály</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Amennyiben nem szeretnénk testreszabott, vagy több funkciót biztosítani a ref-en keresztül, elhagyhatjuk a
          useImperativeHandle hook-ot
          <ul>
            <li>A ref-et közvetlenül is "átirányíthatjuk" az input elemre</li>
            <li>A React.forwardRef automatikusan átadja a ref-et az alatta lévő HTML elemnek, amelyhez hozzá van kötve
            </li>
            <li>Az emailRef.current közvetlenül az input DOM elemre fog mutatni, és így a emailRef.current.focus() hívás
              automatikusan fókuszál az input mezőre</li>
            <li>A fentebbi kódban a useImperativeHandle-lel a ref nem az input DOM-elemre mutat, hanem
              egy általunk definiált objektumra, amely tartalmazza a customFocus függvényt</li>
            <pre>
  <b>// LoginForm.js</b>
  const LoginForm = (props) => &#123;
    ...
    let emailRef = useRef();
    ...
    const onLogin = (event) => &#123;
      event.preventDefault();
      if (formIsValid) &#123;
          authCtx.onLogin(emailState.value, passwordState.value);
      } else if (!emailState.isValid) &#123;
          emailRef.current.focus();
          // emailRef.current.onFocus(); // nem a useImperativeHandle segítségével átadott custom függvényt hívjuk meg
      } else &#123; // if (!passwordState.isValid) &#123;
          pwdRef.current.focus();
      }
    }
    ...

    return ( // a JSX változatlan maradt
        &#60;>
            &#60;form className="mt-3" onSubmit=&#123;(e) => onLogin(e)}> 
                &#60;Input &#123;/* custom elem */}
                    ref=&#123;emailRef} // az emailRef tartalma: &#123; current.onFocus() }, az Input elemből származó onFocus
                    id=&#123;'email'}
                    type=&#123;'email'}
                    label=&#123;'Username'}
                    emailState=&#123;emailState}
                    value=&#123;emailState.value}
                    isValid=&#123;emailState.isValid}
                    onChangeHandler=&#123;emailChangeHandler}
                    onBlurHandler=&#123;validateEmailHandler}
                />

                &#60;div className="input-group mb-3">
                    &#60;span className="input-group-text" id="basic-addon1">Password&#60;/span>
                    &#60;input
                        id="password"
                        type="password"
                        ref=&#123;pwdRef}
                        className="form-control"
                        style=&#123; &#123;
                            borderColor: passwordState.isValid === false ? 'red' : '',
                            backgroundColor: passwordState.isValid === false ? 'rgb(190, 170, 170)' : '',
                        }}
                        value=&#123;passwordState.value}
                        onChange=&#123;(e) => passwordChangeHandler(e.target.value)}
                        onBlur=&#123;validatePasswordHandler}>
                    &#60;/input>
                &#60;/div>

                &#60;div className="d-flex justify-content-center">
                    &#123;/*&#60;button type="submit" className=&#123;`btn $&#123;formIsValid ? 'btn-success' : 'btn-secondary'}`} disabled=&#123;!formIsValid}>Login&#60;/button>*/}
                    &#60;button type="submit" className=&#123;`btn $&#123;formIsValid ? 'btn-success' : 'btn-secondary'}`}>Login&#60;/button>
                &#60;/div>
            &#60;/form>
        &#60;/>
    )
  }

  <b>Input.js</b>
  import React, &#123; useImperativeHandle, useRef } from 'react';

  const Input = React.forwardRef((props, ref) => &#123;
      return (
          &#60;>
              &#60;div className=&#123;`input-group mb-3 $&#123;styles.input_container}`}>
                  &#60;span className="input-group-text" id="basic-addon1">&#123;props.label}&#60;/span>
                  &#60;input
                      ref=&#123;ref} // ezúttal közvetlenül a forwardRef második property-jét adjuk meg, nem hozunk létre useRef-et
                      id=&#123;props.id}
                      type=&#123;props.type}
                      className='form-control'
                      style=&#123; &#123;
                          borderColor: props.emailState.isValid === false ? 'red' : '',
                          backgroundColor: props.emailState.isValid === false ? 'rgb(190, 170, 170)' : '',
                      }}
                      value=&#123;props.value}
                      onChange=&#123;(e) => props.onChangeHandler(e.target.value)}
                      onBlur=&#123;props.onBlurHandler}>
                  &#60;/input>
              &#60;/div>
          &#60;/>
      )
  }
  )
              </pre>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #dom data-anchor="dom">DOM</h3>
  <ul>
    <li>A React egy Javascript könyvtár, UI készítéséhez</li>
    <li>A React komponenseket használ, és ezeket a komponenseket kombinálja, hogy létrejöjjön a User Interface
      <ul>
        <li>Változáskor frissíti a megfelelő komponenst, komponenseket</li>
      </ul>
    </li>
    <li>A kód nem renderelődik ki közvetlenül a böngésző DOM-jába</li>
    <li>A React a komponensekért, azok frissítéséért, a state-kért, és azok változásáért felelős
      <ul>
        <li>A DOM-ba való renderelésért viszont nem felelős</li>
      </ul>
    </li>
    <li>A React átadja a React DOM-nak, hogy mit kell megjeleníteni
      <ul>
        <li>A React DOM felelős azért, hogy a React komponensek által meghatározott felhasználói felület ténylegesen
          megjelenjen a böngésző DOM-jában</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #virtualdom data-anchor="virtualdom">Virtual DOM</h5>
  <ul>
    <li>A React DOM direkt módon tud kommunikálni a böngésző DOM-jával</li>
    <li>A React-ben írt kód nem közvetlenül hozza létre a böngésző DOM elemeit, hanem először egy Virtual DOM-ot épít
      fel
      <ul>
        <li>Memóriában tárolt reprezentációja a valódi DOM-nak</li>
      </ul>
    </li>
    <li>A ReactDOM.render(), vagy a modern createRoot metódus gondoskodik arról, hogy a komponens kimenete a böngésző
      DOM megfelelő részéhez legyen kötve</li>
    <li>Ha a React komponensek állapota (state) vagy propjai megváltoznak, a React DOM...
      <ol>
        <li>...újrarendereli a Virtual DOM-ot</li>
        <li>...összehasonlítja a régi és az új Virtual DOM állapotot</li>
        <li>...csak a szükséges változásokat alkalmazza a böngésző valódi DOM-ján</li>
      </ol>
    </li>
    <br>
    <br>
    <img src="assets/imgs/react_virtual_dom.png" width="100%">
    <br>
    <li>Az első rendereléskor a virtual DOM teljes mértékben leképződik a valódi DOM-ban</li>
    <li>Ha rákattintunk a count-ot növelő gombra, megváltozik a state, újrarenderelődik a teljes virtual DOM, majd ez
      után a React megvizsgálja, hogy milyen változás történt a virtuális, és a valós DOM között, és csak a változást
      rendereli újra a böngésző DOM-jával
      <ul>
        <li>A fenti példában ez azt jelenti, hogy csak a span tag-ben lévő értéket frissíti</li>
        <li>Emiatt a React app-ok igen gyorsan, hatékonyak tudnak lenni</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #rerenderchildcomponent data-anchor="rerenderchildcomponent">Re-render child component</h5>
  <ul>
    <pre>
  <b>// Demo.js</b>
  const Demo = (props) => &#123;
    let [count, setCount] = useState(0);

    const decrementHandler = () => &#123;
        setCount(count - 1);
    }

    const incrementHandler = () => &#123;
        setCount(count + 1);
    }

    return (
        &#60;>
            &#60;div className="demo-container">
                &#60;button onClick=&#123;decrementHandler}>-&#60;/button>
                &#60;Span>
                    &#123;count}
                &#60;/Span>
                &#60;button onClick=&#123;incrementHandler}>+&#60;/button>
            &#60;/div>
        &#60;/>
    )
  }
  
  export default Demo;
  
  <b>// Span.js</b>
  const Span = (props) => &#123;
    return (
        &#60;span>
            &#123;props.children}
        &#60;/span>
    )
  }
  
  export default Span;
    </pre>
    <li>Minden alkalommal, amikor a count state változik, a Demo komponenst újrarenderelődik
      <ul>
        <li>Ezt a state-et tovább adjuk egy gyerek komponensnek</li>
        <li>A child komponensben új érték jelenik meg</li>
        <li>A virtuális DOM frissül (mind a Demo, mind a Span komponens), de a valósi DOM-ban csak span element kerül
          újrarenderelésre</li>
      </ul>
    </li>
    <li>Amennyiben a Span komponens body-jába fix-en 10-et írunk be (tehát nem a count értéket), akkor is mindkét
      komponens virtuális DOM-ja frissítésre kerül, de a böngésző DOM-ja teljesen változatlan marad
      <ul>
        <li>Adott esetekben akár sok komponens is frissülhet feleslegesen a virtuális DOM-ban</li>
        <li>Teljesítményveszteséggel jár, amit érdemes kiküszöbölni</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #reactmemo data-anchor="reactmemo">React.memo</h5>
  <ul>
    <li>Egy nagyobb projektben, ahol meglehetősen nagy komponens fa is kialakulhat, érdemes optimalizációkat
      végrehajtani
      <ul>
        <li>Ilyen például a felesleges komponens frissítés, ahol valójában nem történt változás</li>
        <li>Megmondhatjuk a Reactnak, hogy csak akkor végezzen komponens újrarenderelést, amennyiben prop változás
          történik</li>
        <li>Ehhez semmi mást nem kell tennünk, mint a komponens exportálását React.memo függvénybe ágyazni</li>
        <pre>
  export default React.memo(Span);
        </pre>
        <li>A Demo.js komponens függvénye újra lefut, és frissül a virtuális DOM-ja, de a Span.js nem fut le</li>
        <li>A React.memo természetesen csak function komponensekkel működik
          <ul>
            <li>Class alapú komponensekkel nem</li>
          </ul>
        </li>
        <li>A React összehasonlítja a korábbi prop-okat az újonnan érkező prop-okkal</li>
      </ul>
    </li>
    <li>Jó kérdés lehet, hogy miért nem használjuk ezt a React hook-ot minden komponensünkön
      <ul>
        <li>Ennek az optimalizációnak ára van</li>
        <li>A React-nak egyrészt tárolnia szükséges a korábbi prop-okat, illetve az összehasonlítást is el kell végeznie
        </li>
        <li>Ennek a két feladatnak is meg van a maga teljesítményigénye</li>
      </ul>
    </li>
    <li>Kérdéses, hogy mikor használjuk, és mikor ne használjuk ezt a hook-ot
      <ul>
        <li>Amennyiben tudjuk azt, hogy a komponens fánkban gyakran változó prop-okkal operálunk, nincs értelme
          használnunk a React.memo-t
          <ul>
            <li>Csak extra teljesítményveszteséget okozunk</li>
          </ul>
        </li>
        <li>Kis komponens fával rendelkező app-ok esetében is érdemes kerülni
          <ul>
            <li>Ebből adódik, hogy "nagy" alkalmazásoknál érdemes használni</li>
          </ul>
        </li>
        <li>Nem szükséges minden komponensnél alkalmazni a hook-ot, inkább érdemes kiválasztani néhány kulcsfontosságút
        </li>
      </ul>
    </li>
    <li>Akadnak kivételek
      <ul>
        <li>A statikus referencia típusú változók esetében mégis megtörténik a frissítés
          <ul>
            <li>A primitív típusoknál nem</li>
          </ul>
        </li>
        <pre>
  <b>// Demo.js</b>
  const Demo = (props) => &#123;
    ...
    return (
        &#60;>
            &#60;div className="demo-container">
                &#60;button onClick=&#123;decrementHandler}>-&#60;/button>
                &#60;Span>
                    &#123;[10, 20]}
                &#60;/Span>
                &#60;button onClick=&#123;incrementHandler}>+&#60;/button>
            &#60;/div>
        &#60;/>
    )
  }

  <b>// Span.js</b>
  const Span = (props) => &#123;
    return (
        &#60;span>
            &#123;props.children[0]}
        &#60;/span>
    )
  }
  
  export default React.memo(Span);
        </pre>
        <li>A Span.js egy referenciát kap
          <ul>
            <li>Amikor a Demo komponensünk újra kreálódik, megváltozhat a tömb referenciája, a címe, ahol jelen van a
              memóriában</li>
            <li>Ezt a címet adjuk át a Span komponensnek, és a React.memo hook az összehasonlításkor változást érzékel,
              és újrafuttatja a Span komponens függvényt</li>
          </ul>
        </li>
        <pre>
  <b>// Demo.js</b>
  const Demo = (props) => &#123;
    let [count, setCount] = useState(0);

    const decrementHandler = () => &#123; // gombnyomásra state változás történik, újra lefut a Demo komponenst, és újra létrejönnek a Handler függvények, és megváltozik a referenciájuk
        setCount(count - 1);
    }

    const incrementHandler = () => &#123;
        setCount(count + 1);
    }

    return (
        &#60;>
            &#60;div className="demo-container">
                &#60;DemoButton clickHandler=&#123;decrementHandler}>-&#60;/DemoButton>
                &#60;Span>
                    &#123;10}
                &#60;/Span>
                &#60;DemoButton clickHandler=&#123;incrementHandler}>+&#60;/DemoButton>
            &#60;/div>
        &#60;/>
    )
  }

  <b>// DemoButton.js</b>
  const DemoButton = (props) => &#123;
    return (
        &#60;button onClick=&#123;props.clickHandler} className="btn btn-info">
            &#123;props.children}
        &#60;/button>
    )
  }
  
  export default React.memo(DemoButton);
        </pre>
        <li>Amikor a count állapota megváltozik, a Demo.js újrarenderelődik</li>
        <li>A Span.js-nek fixen - egy nem referencia típusú - számot adunk, és használjuk a komponensben a hook-ot, így
          nem frissül a Demo.js state változásakor</li>
        <li>A DemoButton.js-ben sem történik változás, prop.children-ben egyszer egy mínusz, máskor egy + jelet kap
          <ul>
            <li>A clickHandler függvények szintén nem változnak</li>
            <li>Ezek ellenére is újra lefut a komponens függvénye
              <ul>
                <li>A clickHandler-nek függvényt adtunk át</li>
                <li>A függvény a Javascriptben tulajdonképpen objektum</li>
                <li>Ez azt jelenti, hogy a függvény is referencia típusú, és a Demo.js újratöltésekor megváltozik a
                  memóriacím, amin szerepel a függvény, ezért a Button.js újra fog renderelődni</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Erre a problémakörre is van megoldás, a useCallback hook</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #usecallback data-anchor="usecallback">useCallback</h5>
  <ul>
    <li>Láthattuk a React.memo kapcsán, hogy nem működik megfelelően, ha referencia típusú változót adunk át props-on
      keresztül
      <ul>
        <li>Valamint azt is, hogy a függvény is referencia típus</li>
        <li>Az átadott függvények újra kreálódnak, és megváltozik a memóriában elfoglalt helyük, így a gyerek komponens
          komponens függvénye is újra lefut</li>
      </ul>
    </li>
    <li>Referencia típusú változó használatánál is működőképessé tudjuk tenni a React.memo-t</li>
    <li>useCallback
      <ul>
        <li>A tovább adott függvényt képes eltárolni, így megmondhatjuk a React-nak, hogy ne futtassa le újra a gyerek
          komponens függvényt</li>
        <li>Két argomentumot fogad
          <ol>
            <li>A első a függvény, amit szeretnénk eltárolni</li>
            <li>A második a dependenciák tömbje
              <ul>
                <li>Ugyanúgy, mint a useEffect-nél, definiálunk dependenciákat, amik között, ha van változás, akkor újra
                  létrehozza a függvényt a useCallback</li>
                <li>Üres tömb esetén csak egyszer fut le a függvény</li>
              </ul>
            </li>
          </ol>
        </li>
        <li>Ezzel megmarad a referencia, a memóriában tárolt hely
          <ul>
            <li>A useCallback-ben a függvénnyel együtt a state-ek is tárolásra kerülnek</li>
            <pre>
  let [count, setCount] = useState(0);

  const incrementHandler = useCallback(() => &#123;
          setCount(count + 1);
  }, [])
            </pre>
            <li>Az üres függőségi tömb miatt ez a függvény nem frissül új renderelések során, függetlenül attól, hogy
              a count változik-e, vagy sem</li>
            <li>A count state-ben a kezdeti állapota tárolódik el, így jelen példánkban a nullához fogunk egyet
              hozzáadni, aminek az eredménye mindig 1 lesz</li>
            <li>Alább pedig azt láthatjuk, hogy még, ha rá is kattintunk az Activate gombra, mivel szintén az
              inicializált állapotokat mentettük el, a két függvényben az activate state mindig false marad, mivel a
              dependencia tömb üres, így pedig nem frissül a függvény
              <ul>
                <pre>
  let [count, setCount] = useState(0);
  let [activate, setActivate] = useState(false);

  const decrementHandler = useCallback(() => &#123;
      if (activate) &#123;
          setCount(count - 1);
      }
  }, []); // amennyiben elhelyezzük az activate state-et a dependecy tömbben, frissülni tud a függvény

  const incrementHandler = useCallback(() => &#123;
      if (activate) &#123;
          setCount(count + 1);
      }
  }, []) // amennyiben elhelyezzük az activate state-et a dependecy tömbben, frissülni tud a függvény

  const activateHandler = () => &#123;
      setActivate(true);
  };

  ...

  &#60;DemoButton clickHandler=&#123;activateHandler}>Activate&#60;/DemoButton>
              </pre>
                <li>A count eggyel növelése, és csökkentése helyett sokkal célszerűbb az előző értékkel dolgozni</li>
                <pre>
  let [count, setCount] = useState(0);
  let [activate, setActivate] = useState(false);

  const decrementHandler = useCallback(() => &#123;
      if (activate) &#123;
          setCount((prevCount) => prevCount - 1);
      }
  }, [activate]);

  const incrementHandler = useCallback(() => &#123;
      if (activate) &#123;
          setCount((prevCount) => prevCount + 1);
      }
  }, [activate]);

  const activateHandler = () => &#123;
      setActivate(true);
  };

  &#60;DemoButton clickHandler=&#123;activateHandler}>Activate&#60;/DemoButton>
                </pre>
                <li>Az activate state-et muszály megadnunk a dependencia tömbben annak érdekében, hogy a count értékén
                  változtatni tudjunk</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #statescheduleandbatch data-anchor="statescheduleandbatch">State schedule & batch</h3>
  <ul>
    <li>Amennyiben egy komponens state-je megváltozik, a komponens függvény újra lefut
      <ul>
        <li>Azok a sorok is lefutnak, ahol inicializáljuk a state-eket, mégis a legfrissebb értéküket kapjuk meg minden
          újrafutáskor, nem pedig a kezdetit
          <ul>
            <li>Ez úgy lehetséges, hogy a React kezeli a state-eket, és gondoskodik róla, hogy létrejöjjön a state, de
              csak abban az esetben, ha még nem létezik</li>
            <li>Nem hozza őket újra létre, csak frissíti az aktuális értékükkel</li>
          </ul>
        </li>
        <li>A React kezeli, hogy melyik state melyik komponenshez tartozik</li>
        <li>Akkor, ha a komponens teljesen el lett távolítva a DOM-ból (például feltétel mentén), a komponensben lévő
          state-ek újra létrehozásra fognak kerülni a kezdeti értékükkel</li>
        <li>A useState-re, és a useReducer-re is igazak a fentiek</li>
        <pre>
  let [count, setCount] = useState(0);
  let [activate, setActivate] = useState(false);
        </pre>
        <li>A setCount és setActivate beütemez egy state frissítést az új adattal
          <ul>
            <li>A beütemezett frissítés az esetek döntő többségében elég gyorsan végrehajtódik, szinte azonnal</li>
            <li>Lehet, hogy a UI-on azonnalinak tűnik a változás, de a valóságban nem az
              <ul>
                <li>Ráadásul a React-nak meg van a joga, hogy elhalassza a frissítést, például, amikor több
                  teljesítményigényes feladat fut párhuzamosan</li>
                <li>A React priorizál</li>
              </ul>
            </li>
            <li>Azt viszont garantálja a React, hogy sorrendben frissíti a state-eket, azaz a változás sorrendjében</li>
            <li>Az érték frissíttése után újra lefut a komponens függvény</li>
          </ul>
        </li>
        <li>A frissítő függvénynél mindenképp használjuk az előző érték snapshot-ját, amennyiben függünk a korábbi
          értéktől</li>
        <pre>
  const decrementHandler = () => &#123;
        setCount((prevCount) => prevCount - 1); // függvény forma
  };
        </pre>
        <li>A (prevCount) => prevCount - 1 egy callback függvény, amely az aktuális állapotot (amit meg szeretnénk
          változtatni) megkapja paraméterként, majd ezt a callback függvényt átadjuk a setCount első argomentumaként
          <ul>
            <li>Ezzel (function form) azt is garantálni tudjuk, hogy biztosan a legutolsó state-en változtassunk</li>
          </ul>
        </li>
        <li>Mi történik akkoor, ha 2 state-et frissítő függvényt is meghívunk
          <ul>
            <pre>
  const activateHandler = () => &#123;
    setActivate(true);
    setCount(0);
  };
            </pre>
            <li>Amikor egy state frissítésre kerül, újra lefut a komponens függvény
              <ul>
                <li>Nem a függvény hívásakor, hanem a beütemezés szerint futnak le a frissítések</li>
                <li>Emiatt azonnal nem frissül a state, majd ezzel együtt a komponens</li>
                <li>Történik egy ütemezés a setActivate függvény miatt, majd meghívódik a setCount function</li>
              </ul>
            </li>
            <li>Nem frissül kétszer a komponenst a két egymás utáni state változás hatására
              <ul>
                <li>Ezekben a helyzetekben a React batch-eli (összerakja) a state update-eket egyetlen frissítéssé</li>
                <li>Fontos, hogy szinkron működésről beszélünk</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #usememo data-anchor="usememo">useMemo</h3>
  <ul>
    <li>React hook, amely lehetővé teszi, hogy értékeket eltároljunk, és újraszámoljunk akkor, ha a bemeneti
      függőségek változnak</li>
    <li>Elkerüli a felesleges számításokat, ha az adat, amit számolunk, nem változott</li>
    <li>Ha a második paramétereként megadott függőségi tömbben nem változik semmi, akkor a useMemo egyszerűen visszaadja
      az előzőleg kiszámított értéket ahelyett, hogy újra végrehajtaná a számítást</li>
    <li>React app optimalizációjára használjuk</li>
    <pre>
  <b>// Demo.js</b>
    const Demo = (props) => &#123;
      ...

      return (
        &#60;>
            &#60;div className="demo-container">
                ...
                &#60;Span>
                    &#123;[333, 555]}
                &#60;/Span>
                ...
            &#60;/div>
        &#60;/>
      )
    }

  <b>// Span.js</b>
  const Span = (props) => &#123;
    return (
        &#60;span>
            &#123;props.children[0]} // tömbnek a referenciáját kapjuk itt meg
        &#60;/span>
    )
  }
  
  export default React.memo(Span);
    </pre>
    <li>Referencia típust adunk át
      <ul>
        <li>A React.memo nem a kívánt módon működik</li>
        <li>A megfelelő működéshez függvények esetében a callback függvényt átadjuk a useCallback hook-nak</li>
        <li>Tömb esetében, ami szintén referencia típusú, nem ez a megoldás
          <ul>
            <li>A komponens függvény újra lefutásakor a beégetett kételemű tömb mindig más címet fog kapni, aminek
              hatására a Span.js újra lefut</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>useMemo
      <ul>
        <li>A fenti problémára ad megoldást</li>
        <pre>
  let numberArray = useMemo(() => [333, 555], []);

  &#60;Span>
    &#123;numberArray}
  &#60;/Span>
        </pre>
        <li>Callback függvényt adhatunk át neki, majd második argomentumnak szintén egy dependecia tömböt</li>
        <li>A React belső memóriájában eltárolódik a tömb a useMemo segítségével, és a tömb nem inicializálódik újra
        </li>
        <li>A numberArray property nem fog változni, ugyanaz marad a referencia, és emiatt a gyereke, a Span.js a
          props.children-ben mindig ugyanazt a referenciát fogja kapni, ezért nem fut le újra a komponens függvény</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #classbasedcomponent data-anchor="classbasedcomponent">Class based component</h3>
  <ul>
    <li>Az eddigiekben láthattuk, hogy a React-ban létrehozhatunk komponenst JavaScript függvény használatával
      <ul>
        <li>A function kulcsszóval készítjük el a komponenst</li>
        <li>Amikor így hozunk létre komponenst, functional component-nek, funkcionális komponensnek nevezzük</li>
        <li>Nem ez az egyetlen módja a komponens készítésnek</li>
      </ul>
    </li>
    <li>Javascript class-okat is használhatunk komponensek létrehozásához
      <ul>
        <li>Class-based component / Osztály alapú komponens</li>
        <li>A class-ban lehet konstruktorunk, property-k, metódusok</li>
        <pre>
  <b>// ClassApp.js</b>
  function ClassApp() &#123;
    return (
        &#60;div className="app">
            &#60;ClassDemo />
        &#60;/div>
    )
  }

  <b>// ClassDemo.js</b>
  import React, &#123; Component } from 'react';

  class ClassDemo extends Component &#123;
      title = 'Greetings!';

      customMethod() &#123;
          console.log('This is a custom method');
      }

      render() &#123;
          return (
              &#60;div>
                  &#60;h1>&#123;this.title}&#60;/h1>
                  &#60;button className='btn btn-primary' onClick=&#123;() => this.customMethod()}>
                      Call Method
                  &#60;/button>
              &#60;/div>
          );
      }
  }

  export default ClassDemo;
        </pre>
        <li>extends
          <ul>
            <li>Egy másik osztályból öröklődik a ClassDemo osztályunk</li>
            <li>A React osztály alapú komponensek csak úgy működnek, ha azokat a React.Component-ből származtatjuk</li>
            <li>A Component osztály néhány fontos funkcionalitás nyújt ahhoz, hogy a custom class-unk komponensként
              tudjon működni
              <ul>
                <li>A props, és a state-ek is tőle származnak</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>render()
          <ul>
            <li>Amennyiben a class-t HTML elemként használjuk ( &#60;ClassDemo> ), létrejön egy példány a ClassDemo
              osztályból</li>
            <li>Amint létrejött a példány, a React megkeresi a class-ban lévő render metódust</li>
            <li>JSX kóddal kell visszatérnünk a függvényből</li>
          </ul>
        </li>
        <li>export default
          <ul>
            <li>A class-t ugyanúgy, mint a függvényt, exportálni kell</li>
          </ul>
        </li>
        <pre>
  <b>// ClassApp.js</b>
  function ClassApp() &#123;
    return (
        &#60;div className="app">
            &#60;ClassDemo name="demo"> &#123;/* a name=&#123;'demo'} ugyanolyan jó */}
                &#60;p>Content of ClassDemo&#60;/p> &#123;/* props.children-be kerül */}
            &#60;/ClassDemo>
        &#60;/div>
    )
  }

  <b>// ClassDemo.js</b>
  render() &#123;
    return (
        &#60;div>
            &#60;h1>&#123;this.title}&#60;/h1>
            &#123;this.props.children} &#123;/* ilyen módon hozzáférhetünk a children-hez */}
            &#60;button className='btn btn-primary' onClick=&#123;() => this.customMethod()}>
                Call Method
            &#60;/button>
        &#60;/div>
    );
  }
        </pre>
        <li>Az osztály alapú komponensben a props elérhető a this kulcsszóval</li>
        <li>Éles projekteknél nem szokás a functional és a class-based komponensek keverékét használni
          <ul>
            <li>Vagy ezt, vagy azt érdemes használni</li>
            <li>Függvény használata elterjedtebb, modernebb</li>
          </ul>
        </li>
        <li>A functional komponens teljes mértékben kiváltható az osztály alapúval</li>
        <li>React 16.8-ig a functional komponensekben nem volt lehetséges a state-ek, és a side effektek menedzselése
          <ul>
            <li>Ezek kezeléséhez class alapú komponensekre volt szükség</li>
            <li>16.8-ban bemutatásra került a useState és a useEffect hook</li>
          </ul>
        </li>
        <li>React hook-ok nem használhatók class-based komponensekben</li>
        <li>Amennyiben konstruktort kívánunk használni, meg kell hívnunk a super-t
          <ul>
            <li>A JavaScript alapöröklési rendszerének része
              <ul>
                <li>Tehát Angularban is pont így működik extends esetében</li>
              </ul>
            </li>
            <li>A super az alaposztály konstruktora, amelyet az alosztályban hívhatunk meg</li>
            <li>Amikor egy osztály egy másik osztályból öröklődik (extends kulcsszóval), akkor az alaposztály (a
              szülőosztály) konstruktorát is inicializálnunk kell az alosztály konstruktorában</li>
            <li>A super meghívásával biztosítjuk, hogy az alaposztály inicializációja megtörténjen, és az összes
              funkciója (például React komponens funkciók, mint a state és a props) működjön</li>
            <li>Ha az osztályban nincs konstruktor, a super-t automatikusan meghívja a JavaScript.</li>
            <pre>
  <b>// Example</b>

  class Parent &#123;
    constructor(name) &#123;
      this.name = name;
    }
  }
  
  class Child extends Parent &#123;
    constructor(name, age) &#123;
      super(name); // itt hívjuk meg a szülő konstruktorát
      this.age = age;
    }
  }
  
  const child = new Child('John', 25);
  console.log(child.name); // 'John'
  console.log(child.age);  // 25
            </pre>
            <li>A ClassDemo komponensben az alábbiak szerint néz ki, ha létrehozzuk a konstruktort, és kilogoljuk a
              props-t</li>
            <pre>
  constructor(props) &#123;
    super(props); // szükséges, hogy az alap React.Component osztályt inicializálja
    console.log('props: ', props);
  }

  ↓↓↓↓↓

  &#123;
    "name": "demo",
    "children": &#123;
      "$$typeof": "Symbol(react.element)",
      "key": null,
      "props": &#123;
        "children": "Content of ClassDemo"
      },
      "ref": null,
      "type": "p",
      "_owner": &#123;
        "tag": 0,
        "key": null,
        "stateNode": null,
        "elementType": "ƒ",
        "type": "ƒ",
        "otherProperties": "..."
      },
      "_store": &#123;
        "validated": true
      },
      "_self": undefined,
      "_source": &#123;
        "fileName": "/Users/.../ClassApp.js",
        "lineNumber": 7,
        "columnNumber": 17
      }
    }
  }
            </pre>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #statesandevents data-anchor="statesandevents">States and events</h5>
  <ul>
    <li>Class-based komponens esetében nincsenek React hook-jaink</li>
    <li>State definiálásához első körben szükségünk van a konstruktorra
      <ul>
        <li>Azonnal meghívódik, amint példányosításra kerül a ClassDemo osztályunk</li>
        <li>Mivel a ClassDemo örököl (extends) a Component osztálytól, ezért a Component-nek is meg kell hívnunk a
          konstruktorát
          <ul>
            <li>Ezt a super függvény meghívásával érhetjük el
              <ol>
                <li>A szülőosztály konstruktora lefut, és ezzel inicializálja a szülő által definiált tulajdonságokat
                </li>
                <li>Lehetővé teszi, hogy az alosztály hozzáférjen a szülőosztály metódusaihoz és tulajdonságaihoz</li>
              </ol>
            </li>
          </ul>
        </li>
        <li>A this.state-tel hozhatunk létre state-et
          <ul>
            <li>Kötelező módon state-nek kell lennie, nem választható</li>
            <li>A state mindig egy objektum osztály alapú komponens esetében</li>
            <pre>
  constructor() &#123;
    super();
    this.state = &#123; showParagraph: true, count: 0 };
  }

  toggleParagraph() &#123;
    // this.state.showParagraph = !this.state.showParagraph; // hibás megközelítés
    this.setState(&#123; showParagraph: false });
  }

  render() &#123;
      return (
          &#60;div>
              &#60;h1>&#123;this.title} &#123;this.props.name}&#60;/h1>
              &#123;this.state.showParagraph && this.props.children}
              &#60;button className='btn btn-primary' onClick=&#123;() => this.toggleParagraph()}>
                  Hide &#60;p&#62;
              &#60;/button>
          &#60;/div>
      );
  }
            </pre>
            <li>A toggleParagraph függvény a Demo class metódusa, így a this szócskával érhetjük el / hívhatjuk meg
              <ul>
                <li>A this egy osztályban általában az aktuális osztály példányára (instance) mutat
                </li>
                <li>Ez az objektum tartalmazza az osztályhoz tartozó tulajdonságokat (properties) és metódusokat
                  (methods)</li>
              </ul>
            </li>
            <li>Az objektumban bármennyi state létrehozható</li>
            <li>Az osztálynak nem függvényei, hanem metódusai vannak</li>
            <pre>
  constructor(props) &#123;
    super(props);
    this.state = &#123; showParagraph: true, count: 0 };
  }

  toggleParagraph() &#123;
      console.log('toggle');
      // this.state.showParagraph = !this.state.showParagraph; // hibás megközelítés
      // this.setState(&#123; showParagraph: !this.state.showParagraph }); // biztonságosabb callback függvényt használni
      this.setState((prevState) => (&#123; // a callback függvény megkapja a state pillanatképét
          showParagraph: !prevState.showParagraph
      }));
  }

  render() &#123;
      return (
          &#60;div>
              &#60;h1>&#123;this.title} &#123;this.props.name}&#60;/h1>
              &#123;this.state.showParagraph && this.props.children}
              &#60;button className='btn btn-primary' onClick=&#123;() => this.toggleParagraph()}>
                  Toggle &#60;p&#62;
              &#60;/button>
          &#60;/div>
      );
  }
            </pre>
            <li>State-et a this-en meghívott setState függvény segítségével változtathatunk
              <ul>
                <li>Nagyon fontos, hogy a toggleParagraph függvényben beállított objektum ( &#123; showParagraph: false
                  } ) nem írja felül a konstruktorban lévő this.state-et
                  <ul>
                    <li>Tehát amelyik state-et megadjuk a setState-ben, azt frissítjük csak a this.state-ben</li>
                    <li>A fenti példában tehát a count: 0 érintetlen marad, miután lefutott a toggleParagraph</li>
                    <li>A színfalak mögött a React összefűzi a kulcs-érték párokat</li>
                  </ul>
                </li>
                <li>Ahogy a funkcionális komponensek esetében, itt is adhatunk callback függvényt a "beállító"
                  függvénynek</li>
              </ul>
            </li>
            <li>Amennyiben nem arrow functon-nel hívjuk meg a toggleParagraph metódust, úgy elveszítjük a this
              kontextusát, és undefined lesz az értéke
              <ul>
                <li>Tehát érdemes arrow function-t használni</li>
                <li>A másik megoldás, hogy metódus kötés használata</li>
                <pre>
  <b>// ClassDemo.js</b>
  class ClassDemo extends Component &#123;
    title = 'Greetings!';

    constructor(props) &#123; // így használhatjuk a komponensnek átadott prop-okat
        super(props);
        this.state = &#123; showParagraph: true, count: 0 };
        // this.toggleParagraph = this.toggleParagraph.bind(this); // a kötést itt is meg lehet tenni, és akkor ennyi marad: onClick=&#123;this.toggleParagraph}
    }

    toggleParagraph() &#123;
        console.log('toggle: ', this);
        this.setState((prevState) => (&#123;
            showParagraph: !prevState.showParagraph
        }));
    }

    render() &#123;
        return (
            &#60;div>
                &#60;h1>&#123;this.title} &#123;this.props.name}&#60;/h1>
                &#123;this.state.showParagraph && this.props.children}
                &#60;button className='btn btn-primary' onClick=&#123;this.toggleParagraph.bind(this)}>
                    &#123;this.state.showParagraph ? 'Hide' : 'Show'}
                &#60;/button>
            &#60;/div>
        );
    }
  }
  
  export default ClassDemo;

  ↓↓↓↓↓

  &#123;
    "ClassDemo": &#123;
      "props": &#123;
        "name": "demo",
        "children": &#123;
          "$$typeof": "Symbol(react.element)",
          "type": "p",
          "key": null,
          "ref": null,
          "props": &#123;
            "children": "Content of ClassDemo"
          },
          "_owner": "FiberNode",
          "_store": &#123;
            "validated": true
          }
        }
      },
      "context": &#123;},
      "refs": &#123;},
      "state": &#123;
        "showParagraph": false,
        "count": 0
      },
      "title": "Greetings!",
      "updater": &#123;
        "isMounted": "function",
        "enqueueSetState": "function",
        "enqueueReplaceState": "function",
        "enqueueForceUpdate": "function"
      },
      "_reactInternalInstance": &#123;
        "_processChildContext": "function"
      },
      "_reactInternals": &#123;
        "tag": 1,
        "key": null,
        "stateNode": "ClassDemo",
        "elementType": "function",
        "type": "function"
      }
    }
  }                  
                </pre>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #sideeffect data-anchor="sideeffect">Side effect</h5>
  <ul>
    <li>React hook-ot nem használhatunk class-based komponensben
      <ul>
        <li>Tehát a useEffect hook-ot sem</li>
      </ul>
    </li>
    <li>Az osztály alapú komponensek komponens életciklussal rendelkeznek
      <ul>
        <li>Néhány beépített metódust használva, az életciklus bizonyos szakaszaiban logika hajtható végre
        </li>
        <li>Csakis kizárólag osztály-alapú komponensekben elérhetőek</li>
        <li>A Component osztállyal való extendelés elengedhetetlen a használatukhoz</li>
      </ul>
    </li>
    <li>Életciklusok
      <ol>
        <li>componentDidMount()
          <ul>
            <li>Mounting-kor fut le, azaz, amikor a komponens először bekerül a DOM-ba</li>
            <li>Ez a metódus felel meg a useEffect hook-nak, csak dependencia tömb nélkül
              <ul>
                <li>Ha a useEffect dependencia tömbje üres, akkor az első argomentumban átadott callback függvény csak
                  egyszer fut le, amikor a komponens renderelésre kerül</li>
                <li>Ugyanezt az eredményt érhetjük el a componentDidMount metódussal</li>
              </ul>
            </li>
            <pre>
  componentDidMount() &#123;
    console.log('componentDidMount');
  }
            </pre>
          </ul>
        </li>
        <li>componentDidUpdate(prevProps, prevState, snapshot)
          <ul>
            <li>Akkor fut le, amikor a komponens frissítésre került
              <ul>
                <li>State vagy props változás történt</li>
              </ul>
            </li>
            <li>A useEffect-tel egyenértékű, néhány függőséggel
              <ul>
                <li>Ha válttozik a depeendencia, újra lefut</li>
              </ul>
            </li>
            <li>Első renderelésre nem fut le</li>
            <li>A metódusnak átadásra kerülnek a korábbi state-eek, és props-ok</li>
            <pre>
  componentDidUpdate(prevProps, prevState, snapshot) &#123;
    console.log('componentDidUpdate: ', prevProps, prevState, snapshot);
    if (prevState.count !== this.state.count) &#123;
        this.setState(&#123; count: this.count + 1 });
    }
  }

  ↓↓↓↓↓

  <b>// prevProps</b>
  &#123;
    "name": "demo",
    "children": &#123;
      "$$typeof": "Symbol(react.element)",
      "key": null,
      "props": &#123;
        "children": "Content of ClassDemo"
      },
      "ref": null,
      "type": "p",
      "_owner": &#123;
        "tag": 0,
        "key": null,
        "stateNode": null,
        "elementType": "ƒ",
        "type": "ƒ"
      },
      "_store": &#123;
        "validated": true
      },
      "_self": undefined,
      "_source": &#123;
        "fileName": "/Users/.../ClassApp.js",
        "lineNumber": 7,
        "columnNumber": 17
      }
    }
  }

  <b>// prevState</b>
  &#123;
    "showParagraph": false,
    "count": 0
  }              
            </pre>
            <li>A snapshot paraméter az értéket a getSnapshotBeforeUpdate metódusból kapja meg, ha ez a metódus nincs
              definiálva, vagy nem ad vissza semmit</li>
          </ul>
        </li>
        <li>componentWillUnmount()
          <ul>
            <li>Azelőtt hívódik meg, hogy a komponens eltávolításra kerülne a DOM-ból</li>
            <li>A useEffect cleanUp függvényével egyenértékű</li>
            <pre>
  <b>// ClassDemo.js</b>
  import React, &#123; Component } from 'react';
  import ParagraphDemo from './ParagraphDemo';

  class ClassDemo extends Component &#123;
    ...

    render() &#123;
      return (
          &#60;div>
              &#60;h1>&#123;this.title} &#123;this.props.name}&#60;/h1>
              &#123;/* this.state.showParagraph && this.props.children */}
              &#123;this.state.showParagraph && &#60;ParagraphDemo />}
              &#60;button className='btn btn-primary' onClick=&#123;() => this.toggleParagraph()}>
                  &#123;this.state.showParagraph ? 'Hide' : 'Show'}
              &#60;/button>
          &#60;/div>
      );
    }
  }

  <b>// ParagraphDemo.js</b>
  import &#123; Component } from "react";

  export default class ParagraphDemo extends Component &#123;
      componentWillUnmount() &#123;
          console.log('componentWillUnmount');
      }

      render() &#123;
          return &#60;p>This is a demo paragraph&#60;/p>
      }
  }

  // export default ParagraphDemo; // az exportálás fentebb megtörtént, így ez a sor már nem kell
            </pre>
            <li>Amint a showParagraph változó false-ba kerül, és ezáltal eltűnik a ParagraphDemo komponens, a benne lévő
              componentWillUnmount metódus lefut</li>
          </ul>
        </li>
      </ol>
    </li>
    <li>A fenti 3 metódust használhatjuk a side effect-ek kezelésére
      <ul>
        <li>Más lifecycle method-ok is léteznek, de azok kevésbé fontosak</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #handlingcontext data-anchor="handlingcontext">Handling context</h5>
  <ul>
    <pre>
  <b>// ContextDemo.js</b>
  let ContextDemo = React.createContext(&#123;
      contextValue: ''
  });

  export default ContextDemo;

  <b>// ClassApp.js</b>
  function ClassApp() &#123;
    return (
        &#60;ContextDemo.Provider value=&#123; &#123;contextValue: 'This value is coming from ContectDemo'}}>
            &#60;div className="app">
                &#60;ClassDemo name="demo">
                    &#60;p>Content of ClassDemo&#60;/p>
                &#60;/ClassDemo>
            &#60;/div>
        &#60;/ContextDemo.Provider>
    )
  }

  <b>// ClassDemo.js</b>
  class ClassDemo extends Component &#123;
    ...
    render() &#123;
      return (
          &#60;div>
            ...
            &#123;this.state.showParagraph && &#60;ParagraphDemo>&#60;/ParagraphDemo>}
            ...
          &#60;/div>
      )
    }
  }
    </pre>
    <li>A contextValue elérhető lesz a ClassApp komponensben, és az összes gyerek komponensben</li>
    <li>A context a state-et applikációszerte menedzseli</li>
    <li>Funkcionális komponensben a useContext függvénnyel érjük el a context-et
      <ul>
        <li>Class-based komponensben nem használhatjuk ezt a hook-ot</li>
      </ul>
    </li>
    <li>Osztály alapú komponensben két módon férhetünk hozzá a kontexthez
      <ol>
        <li>Consumer használata
          <ul>
            <pre>
  <b>// ParagraphDemo.js</b>
  export default class ParagraphDemo extends Component &#123;

  render() &#123;
      return (
          &#60;ContextDemo.Consumer>
              &#123;(ctx) => &#123; &#123;/* a ClassApp-ban provide-olt objektum */}
                  return (
                      &#60;p>&#123;ctx.contextValue}&#60;/p>
                  )
              }}
          &#60;/ContextDemo.Consumer>)
  }
            </pre>
            <li>JSX-be kerül a consumer, így function-based komponens esetében is használható</li>
          </ul>
        </li>
        <li>Static property
          <ul>
            <li>Ez sem megfelelője a useContext-nek</li>
            <li>A React osztály alapú komponensekben a static contextType tulajdonság lehetővé teszi, hogy a komponens
              közvetlenül hozzáférjen egy adott kontextus értékéhez a this.context segítségével</li>
            <li>Ezzel a módszerrel egy komponens csak egyetlen kontextushoz tud csatlakozni
              <ul>
                <li>Több kontextus esetén consumer-t kell használni</li>
                <li>useContext esetén több kontextus-ra is figyelhetünk</li>
              </ul>
            </li>
            <pre>
  <b>// ParagraphDemo.js</b>
  export default class ParagraphDemo extends Component &#123;
    static contextType = ContextDemo;
    
    render() &#123;
      return &#123;
          &#60;p>&#123;this.context.contextValue}&#60;/p>
      )
    }
  }
            </pre>
          </ul>
        </li>
      </ol>
    </li>
  </ul>
  <br>
  <h5 #errorboundaries data-anchor="errorboundaries">Error boundaries</h5>
  <ul>
    <li>Class-based komponens, amit a gyerek komponensek hibáinak kezelésére használunk</li>
    <li>Előfordul, hogy nem várt hibát szükséges kezelnünk
      <ul>
        <li>Például HTTP kérés esetén, ha a szerver valamilyen okból nem ad választ, vagy egyszerűen csak nincs internet
          kapcsolat</li>
        <li>Ezekre a helyzetekre érdemes felkészülnünk</li>
      </ul>
    </li>
    <pre>
  <b>// ClassDemo.js</b>
  class ClassDemo extends Component &#123;
    ...
    componentDidUpdate(prevProps, prevState, snapshot) &#123;
      throw new Error('Error just has happened');
    }
    ...
  }
    </pre>
    <li>Ennek hatására, amennyiben változás történik, és a komponens újrarenderelődik, hibát kapunk
      <ul>
        <li>"Uncaught runtime errors: Error just has happened at ClassDemo.componentDidUpdate"</li>
      </ul>
    </li>
    <li>Használhatjuk továbbra is a Javascript könyvtárat, hogy kezeljük a hibát
      <ul>
        <pre>
  <b>// ClassDemo.js</b>
  class ClassDemo extends Component &#123;
    ...
    componentDidUpdate(prevProps, prevState, snapshot) &#123;
      try &#123;
          throw new Error('Error just has happened');
      } catch (error) &#123; // a paraméterben megkapjuk az error objektumot
          alert(error.message);
      }
    }
    ...
  }
        </pre>
        <li>Így nem crash-el el az app</li>
      </ul>
    </li>
    <li>Nézzük meg, mi van akkor, ha a szülő komponensben szeretnénk kezelni a hibát
      <ul>
        <li>A try-catch blokk nem lesz megoldás a JSX kódban</li>
        <pre>
  <b>// ErrorBoundaries</b>
  import &#123; Component } from "react";

  export default class ErrorBoundaries extends Component &#123;
    componentDidCatch(error) &#123;

    }
    render() &#123;
      return this.props.children;
    }
  }
        </pre>
        <li>A componentDidCatch metódus meghívódik, akárhányszor a gyerek komponens hibát dob
          <ul>
            <li>Lifecycle metódus</li>
            <li>Szintén megkapja az error object-et</li>
            <li>Bármilyen osztály alapú komponensnek megadható
              <ul>
                <li>Onnantól kezdve a komponens error boundary-nek tekinthető</li>
              </ul>
            </li>
            <li>Funkionális komponensben nem használható</li>
            <li>Ezzel a komponenssel becsomagolhatunk bármely olyan komponenst, ami hibát dobhat</li>
            <pre>
  <b>// ClassApp</b>
  function ClassApp() &#123;
    return (
        &#60;ContextDemo.Provider value=&#123; &#123; contextValue: 'This value is coming through ContectDemo' }}>
            &#60;div className="app">
                &#60;ErrorBoundaries>
                    &#60;ClassDemo name="demo">
                        &#60;p>Content of ClassDemo&#60;/p>
                    &#60;/ClassDemo>
                &#60;/ErrorBoundaries>
            &#60;/div>
        &#60;/ContextDemo.Provider>
    )
  }
            </pre>
            <li>Amennyiben a ClassDemo komponens nem dob hibát, az ErrorBoundaries komponens visszaadja a ClassDemo
              komponenst
              <ul>
                <li>Hiszen a this.props.children-t adja vissza, ami jelen esetben a ClassDemo komponens</li>
              </ul>
            </li>
            <li>Ha mégis hiba történik, a componentDidCatch method meghívódik</li>
            <pre>
  <b>// ErrorBoundaries.js</b>
  export default class ErrorBoundaries extends Component &#123;
    constructor() &#123;
        super();
        this.state = &#123; hasError: false };
    }
    componentDidCatch(error) &#123;
        this.setState(&#123; hasError: true });
    }

    render() &#123;
        return (
            &#60;>
                &#123;!this.state.hasError && this.props.children}
                &#123;this.state.hasError && &#60;div>Something went wrong&#60;/div>}
            &#60;/>
        )
    }
  }
            </pre>
            <li>Létrehoztunk egy state-et, amibeen a hasError igazzá válik, amint változtatunk a ClassDemo komponensen
            </li>
            <li>Amennyiben a hibát kapunk, a 'Something went wrong' felirat fog megjelenni a ClassDemo tartalma helyett
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #httprequestsandresponses data-anchor="httprequestsandresponses">HTTP requests & responses</h3>
  <ul>
    <li>Nem szabad olyan Javascript kódot írni, ami direkt módon kommunikál az adatbázissal
      <ul>
        <li>A csatlakozáshoz credential-öket szükséges megadnunk</li>
        <li>A Javascript kód a böngészőben fut, így hozzáférhető mások számára is</li>
      </ul>
    </li>
    <li>Backend-en keresztül kommunikálunk az adatbázisokkal
      <ul>
        <li>Mivel szerveren fut, a user-ek nem férnek hozzá a backend kódhoz</li>
        <li>Az adatbázis credential-ök itt tárolódnak</li>
      </ul>
    </li>
    <li>Mi most nem fogunk backend applikációt építeni
      <ul>
        <li>Helyette a Google Firebase-t használjuk</li>
        <li>Nem csak adatbázis, teljes backend-et kínál, api-val együtt</li>
        <li>NoSQL adatbázis
          <ul>
            <li>Nincsenek táblák, kollekciókkal dolgozik</li>
            <li>A kollekciókban dokumentumokat tárolhatunk</li>
            <li>A dokumentum tulajdonképpen egy JSON objektum</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #postrequest data-anchor="postrequest">POST request</h5>
  <ul>
    <li>A kiindulási alapunk egy egyszerű felhasználó kezelő alkalmazás</li>
    <pre>
  <b>UserApp.js</b>
  export const UserApp = () => &#123;
    let [showForm, setShowForm] = useState(false);

    function addUserHandler() &#123;
        setShowForm(true);
    }

    function closeForm() &#123;
        setShowForm(false)
    }

    return (
        &#60;div>
            &#60;div className='page-header d-flex justify-content-end'>
                &#60;button className='btn btn-success' onClick=&#123;addUserHandler}>Add User&#60;/button>
                &#60;button className='btn btn-info'>Get Users&#60;/button>
            &#60;/div>
            &#60;UserDetails>&#60;/UserDetails>
            &#123;showForm && &#60;UserForm closeForm=&#123;closeForm}>&#60;/UserForm>}
        &#60;/div>
    );
  }

  <b>// UserDetails.js</b>
  function UserDetails() &#123;
    return (
      &#60;div className="user-details">
        &#60;table className="users-table">
          &#60;thead>
            &#60;tr>
              &#60;th>Full Name&#60;/th>
              &#60;th>Email&#60;/th>
              &#60;th>Date Of Birth&#60;/th>
              &#60;th>Gender&#60;/th>
              &#60;th>&#60;/th>
            &#60;/tr>
          &#60;/thead>
          &#60;tbody>
            &#60;tr>
              &#60;td>Mery Jane&#60;/td>
              &#60;td>meryjane@gmail.com&#60;/td>
              &#60;td>30 Aug 1991&#60;/td>
              &#60;td>Female&#60;/td>
              &#60;td>
                &#60;button className="btn btn-primary">Edit&#60;/button>
                &#60;button className="btn btn-danger">Delete &#60;/button>
              &#60;/td>
            &#60;/tr>
          &#60;/tbody>
        &#60;/table>
      &#60;/div>
    )
  }
  
  export default UserDetails;

  <b>// UserDetails.js</b>
  function UserForm(props)&#123;
    return &#60;>
            &#60;div id="myModal" className="modal">
                    &#60;div className="modal-content">
                        &#60;div className="close" onClick=&#123;props.closeForm}>&times;&#60;/div>
                        &#60;h3>Create new user&#60;/h3>
                        &#60;div className="user-form">
                            &#60;form>
                                &#60;div>
                                    &#60;input type="text" placeholder="First name" />
                                    &#60;input type="text" placeholder="Last name" />
                                &#60;/div>
                                &#60;div>
                                    &#60;input type="email" placeholder="Email" />
                                &#60;/div>
                                &#60;div>
                                    &#60;input type="password" placeholder="Password" />
                                    &#60;input type="password" placeholder="Confirm Password" />
                                &#60;/div>
                                &#60;div>
                                    &#60;select name="country">
                                        &#60;option value="Germany">Germany&#60;/option>
                                        &#60;option value="USA">USA&#60;/option>
                                        &#60;option value="UK">UK&#60;/option>
                                    &#60;/select>
                                    &#60;select name="city">
                                        &#60;option value="Berlin">Berlin&#60;/option>
                                        &#60;option value="New York">New York&#60;/option>
                                        &#60;option value="London">London&#60;/option>
                                    &#60;/select>
                                &#60;/div>
                                &#60;div>
                                    &#60;input type="date" placeholder="Date of Birth" />
                                    &#60;select name="gender">
                                        &#60;option value="Male">Male&#60;/option>
                                        &#60;option value="Female">Female&#60;/option>
                                        &#60;option value="Unknown">Unknown&#60;/option>
                                    &#60;/select>
                                &#60;/div>
                                &#60;button className='add-user-button'>Create User&#60;/button>
                            &#60;/form>
                        &#60;/div>
                    &#60;/div>
                &#60;/div>
            &#60;/>
  }

  export default UserForm;
    </pre>
    <li>Amikor a felhasználó rákattint az Add User gombra, a addUserHandler függvény beállítja a showForm állapotot
      true-ra, amely megjeleníti a UserForm modális ablakot</li>
    <li>A UserForm az új felhasználó adatainak bevitelére fog szolgálni</li>
    <li>A UserDetails jeleníti majd meg a Firebase-ben tárolt adatokat</li>
    <pre>
  <b>// UserForm.js</b>
  function UserForm(props) &#123;
    let formRefs = useRef(&#123;
        fname: null,
        lname: null,
        email: null,
        password: null,
        country: null,
        city: null,
        date: null,
        gender: null,
    });

    const onFormSubmit = (event) => &#123;
        event.preventDefault();
        let user = &#123;
            firstName: formRefs.current.fname.value,
            lastName: formRefs.current.lname.value,
            emailAddress: formRefs.current.email.value,
            Password: formRefs.current.password.value,
            country: formRefs.current.country.value,
            city: formRefs.current.city.value,
            dateOfBirth: formRefs.current.date.value,
            gender: formRefs.current.gender.value,
        }
        console.log(user);
    }

    return &#60;>
        &#60;div id="myModal" className="modal">
            &#60;div className="modal-content">
                &#60;div className="close" onClick=&#123;props.closeForm}>&times;&#60;/div>
                &#60;h3>Create new user&#60;/h3>
                &#60;div className="user-form">
                    &#60;form onSubmit=&#123;(event) => onFormSubmit(event)}>
                        &#60;div>
                            &#60;input type="text" placeholder="First name" ref=&#123;(el) => (formRefs.current.fname = el)} />
                            &#60;input type="text" placeholder="Last name" ref=&#123;(el) => (formRefs.current.lname = el)} />
                        &#60;/div>
                        &#60;div>
                            &#60;input type="email" placeholder="Email" ref=&#123;(el) => (formRefs.current.email = el)} />
                        &#60;/div>
                        &#60;div>
                            &#60;input type="password" placeholder="Password" ref=&#123;(el) => (formRefs.current.password = el)} />
                            &#60;input type="password" placeholder="Confirm Password" />
                        &#60;/div>
                        &#60;div>
                            &#60;select name="country" ref=&#123;(el) => (formRefs.current.country = el)}>
                                &#60;option value="Germany">Germany&#60;/option>
                                &#60;option value="USA">USA&#60;/option>
                                &#60;option value="UK">UK&#60;/option>
                            &#60;/select>
                            &#60;select name="city" ref=&#123;(el) => (formRefs.current.city = el)}>
                                &#60;option value="Berlin">Berlin&#60;/option>
                                &#60;option value="New York">New York&#60;/option>
                                &#60;option value="London">London&#60;/option>
                            &#60;/select>
                        &#60;/div>
                        &#60;div>
                            &#60;input type="date" placeholder="Date of Birth" ref=&#123;(el) => (formRefs.current.date = el)} />
                            &#60;select name="gender" ref=&#123;(el) => (formRefs.current.gender = el)}>
                                &#60;option value="Male">Male&#60;/option>
                                &#60;option value="Female">Female&#60;/option>
                                &#60;option value="Unknown">Unknown&#60;/option>
                            &#60;/select>
                        &#60;/div>
                        &#60;button className='add-user-button'>Create User&#60;/button>
                    &#60;/form>
                &#60;/div>
            &#60;/div>
        &#60;/div>
    &#60;/>
  }
    </pre>
    <li>A form beviteli mezőiknek referenciákat biztosítottunk, és form submit-re összeállítottunk egy objektumot, amit
      majd elküldünk a szerver felé</li>
    <li>A useRef működése
      <ul>
        <li>Különálló useRef esetén
          <ul>
            <li>A React automatikusan kezeli a current tulajdonságot, és minden ref-et közvetlenül összekapcsol a DOM
              elemmel</li>
            <pre>
  let fname = useRef(null);
  let lname = useRef(null);
  let email = useRef(null);
  let password = useRef(null);
  let country = useRef(null);
  let city = useRef(null);
  let date = useRef(null);
  let gender = useRef(null);

  ref=&#123;formRefs.current.fname}
  ref=&#123;formRefs.current.lname}
  ref=&#123;formRefs.current.email}
  ref=&#123;formRefs.current.password}
  ref=&#123;formRefs.current.country}
  ref=&#123;formRefs.current.city}
  ref=&#123;formRefs.current.date}
  ref=&#123;formRefs.current.gender}

  let user = &#123;
    firstName: fname.current.value,
    lastName: lname.current.value,
    emailAddress: email.current.value,
    Password: password.current.value,
    country: country.current.value,
    city: city.current.current.value,
    dateOfBirth: date.current.value,
    gender: gender.current.value
  }
              </pre>
          </ul>
        </li>
        <li>"Központi" useRef esetén
          <ul>
            <li>A React nem tudja automatikusan frissíteni az objektum current mezőit, ehhez explicit callback
              függvényre van szükség</li>
            <pre>
  let formRefs = useRef(&#123; // egy objektumban szerepel minden ref
    fname: null,
    lname: null,
    email: null,
    password: null,
    country: null,
    city: null,
    date: null,
    gender: null,
  });

  ref=&#123;(el) => (formRefs.current.fname = el)}
  ref=&#123;(el) => (formRefs.current.lname = el)}
  ref=&#123;(el) => (formRefs.current.email = el)}
  ref=&#123;(el) => (formRefs.current.password = el)}
  ref=&#123;(el) => (formRefs.current.country = el)}
  ref=&#123;(el) => (formRefs.current.city = el)}
  ref=&#123;(el) => (formRefs.current.date = el)}
  ref=&#123;(el) => (formRefs.current.gender = el)}

  let user = &#123;
    firstName: formRefs.current.fname.value,
    lastName: formRefs.current.lname.value,
    emailAddress: formRefs.current.email,
    Password: formRefs.current.password,
    country: formRefs.current.country,
    city: formRefs.current.city,
    dateOfBirth: formRefs.current.date,
    gender: formRefs.current.gender
  }
              </pre>
          </ul>
        </li>
      </ul>
    </li>
    <li>POST request-et több féle módon is lehet küldeni
      <ul>
        <li>Fetch API
          <ul>
            <li>A fetch egy beépített böngészői API (Application Programming Interface), ami lehetővé teszi a JavaScript
              számára, hogy kommunikáljon egy külső szerverrel HTTP-kéréseken keresztül</li>
            <li>A függvény paraméterei
              <ol>
                <li>URL
                  <ul>
                    <li>Ide küldjük a request-et</li>
                    <li>A Firebase URL-ünk: https://react-api-b8dfa-default-rtdb.firebaseio.com</li>
                    <li>Ezért, amennyiben a User kollekciónkat szeretnénk frissíteni:
                      https://react-api-b8dfa-default-rtdb.firebaseio.com/Users.json</li>
                  </ul>
                </li>
                <li>Opcionális objektum
                  <ul>
                    <li>Megadjuk a request-ünk típusát (POST)</li>
                    <li>Ide kerül a body
                      <ul>
                        <li>A Firebase JSON-t vár, így a Javascript objektumunkat (user) át szükséges alakítanunk</li>
                      </ul>
                    </li>
                    <li>Meghatározhatunk header-öket</li>
                  </ul>
                </li>
              </ol>
            </li>
            <li>A válasz nem érkezik meg azonnal
              <ul>
                <li>A fetch Promise-szal fog visszatérni</li>
                <li>Használhatjuk a then metódust
                  <ul>
                    <li>Callback függvényt vár</li>
                  </ul>
                </li>
              </ul>
            </li>
            <pre>
  <b>// UserForm.js</b>
  const onFormSubmit = (event) => &#123;
    event.preventDefault();
    let user = &#123;
        ...
    }
    props.createUser(user); // meghívjuk a szülőben található onCreateUser függvényt
  }

  <b>// UserApp.js</b>
  export const UserApp = () => &#123;
    ...
    const onCreateUser = (user) => &#123;
      console.log('user: ', user);
      fetch('https://react-api-b8dfa-default-rtdb.firebaseio.com/Users.json', &#123;
          method: 'POST',
          headers: &#123;
              'Content-Type': 'application/json' // default típus, csak a példa kedvéért szerepel itt
          },
          body: JSON.stringify(user)
      }).then((resp) => &#123; // a resp-ben érkezik a response a szervertől
          return resp.json(); // JSON-né alakítjuk a válasz body-ját, és továbbadjuk a következő then-nek
      }).then(respData => &#123;
          console.log(respData); // a tényleges visszakapott adat
      });
    }

    return (
        &#60;div>
            ...
            &#123;showForm && &#60;UserForm createUser=&#123;onCreateUser} closeForm=&#123;closeForm}>&#60;/UserForm>} 
        &#60;/div>
    );
  }
            </pre>
          </ul>
        </li>
        <li>Axios
          <ul>
            <li>Népszerű third-party könyvtár</li>
            <li>Promise-on alapuló HTTP kliens</li>
            <li>HTTP-kérések (GET, POST, PUT, DELETE, ...) küldésére és kezelésére használnak webes alkalmazásokban</li>
            <li>Gyakran használják React, Angular, vagy Vue projektekben</li>
            <li>Szintaxisa letisztultabb, és rövidebb, mint a natív fetch API-é</li>
            <li>npm install axios</li>
            <pre>
  const onCreateUser = (user) => &#123;
    axios.post('https://react-api-b8dfa-default-rtdb.firebaseio.com/Users.json', user)
        .then((resp) => &#123;
            console.log(resp);
            // console.log(resp.data); // amennyiben csak a body-ra vagyunk kíváncsiak
        });
  }
            </pre>
            <li>A POST metódus 2 argomentumot fogad
              <ol>
                <li>URL, ahova a request-et küldjük</li>
                <li>Az adat, amit el kívánunk küldeni
                  <ul>
                    <li>A javascript objektumot nem szükséges JSON formátummá alakítanunk, ezt az axios megoldja</li>
                  </ul>
                </li>
              </ol>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <table style="border-collapse: collapse; width: 100%;">
      <thead>
        <tr>
          <th></th>
          <th>Axios</th>
          <th>Fetch</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Szintaxis</td>
          <td>Könnyebb és rövidebb</td>
          <td>Hosszabb és manuális JSON kezelés</td>
        </tr>
        <tr>
          <td>JSON-kezelés</td>
          <td>Automatikus</td>
          <td>Kézzel kell parse-olni és stringify-elni</td>
        </tr>
        <tr>
          <td>Interceptors támogatás</td>
          <td>Beépített</td>
          <td>Nincs közvetlen támogatás</td>
        </tr>
        <tr>
          <td>Böngésző és Node.js</td>
          <td>Támogatja mindkettőt</td>
          <td>Csak böngésző (Node.js-re polyfill kell)</td>
        </tr>
        <tr>
          <td>Hiba kezelés</td>
          <td>Kényelmes (hibára dobott ígéret)</td>
          <td>Manuális ellenőrzés szükséges</td>
        </tr>
        <tr>
          <td>Időkorlát</td>
          <td>Könnyen beállítható</td>
          <td>Külön logikát igényel</td>
        </tr>
      </tbody>
    </table>
  </ul>
  <br>
  <h5 #getrequest data-anchor="getrequest">GET request</h5>
  <ul>
    <li>A GET metódust is megnézzük 2 féle módon, csak úgy, mint a POST-nál
      <ol>
        <li>Fetch API
          <ul>
            <li>Az első paraméter az endpoint URL, a második pedig egy opcionális objektum</li>
            <li>A fetch alapértelmezett metódusa a GET</li>
            <li>Promise-t ad vissza</li>
            <pre>
  <b>// UserApp.js</b>
  export const UserApp = () => &#123;
    ...
    let [users, setUsers] = useState([]);
    ...

    const onGetUsers = () => &#123;
      fetch('https://react-api-b8dfa-default-rtdb.firebaseio.com/Users.json', &#123;
          method: 'GET'
      }).then((users) => &#123; // a callback függvény megkapja a response-t, amikor a Promise feloldódik
          return users.json(); // visszaadja a users response body-ját, mint Promise
      }).then(userData => &#123;
          setUsers(Object.entries(userData).map(([key, user]) => &#123; // object destructuring
              return &#123;
                  id: key,
                  name: user.firstName.concat(' ', user.lastName),
                  // name: user.firstName + ' ' + user.lastName,
                  // name: `$&#123;user.firstName} $&#123;user.lastName}`,
                  // name: `$&#123;user.firstName ?? ''} $&#123;user.lastName ?? ''}`,
                  email: user.emailAddress,
                  dateOfBirth: user.dateOfBirth,
                  gender: user.gender,
              }
          }));

          /* let forInUsers = []; // ez is egy működő megoldás
          for (let key in userData) &#123;
              forInUsers.push(&#123;...userData[key], key});
          } */
      });
    }

    return (
        &#60;div>
            &#60;div className='page-header d-flex justify-content-end'>
                &#60;button className='btn btn-success' onClick=&#123;addUserHandler}>Add User&#60;/button>
                &#60;button className='btn btn-info' onClick=&#123;onGetUsers}>Get Users&#60;/button>
            &#60;/div>
            &#60;UserDetails users=&#123;users}>&#60;/UserDetails> &#123;/* users tömb átadásra kerül a UserDetails komponensnek */}
            &#123;showForm && &#60;UserForm createUser=&#123;onCreateUser} closeForm=&#123;closeForm}>&#60;/UserForm>}
        &#60;/div>
    );
  }

  <b>// UserDetails.js</b>
  function UserDetails(props) &#123;
    return (
      &#60;div className="user-details">
        &#60;table className="users-table">
          &#60;thead>
            &#60;tr>
              &#60;th>Full Name&#60;/th>
              &#60;th>Email&#60;/th>
              &#60;th>Date Of Birth&#60;/th>
              &#60;th>Gender&#60;/th>
              &#60;th>&#60;/th>
            &#60;/tr>
          &#60;/thead>
          &#60;tbody>
            &#123;props.users.map((user) => &#123;
              return (
                &#60;tr key=&#123;user.id}>
                  &#60;td>&#123;user.name}&#60;/td>
                  &#60;td>&#123;user.email}&#60;/td>
                  &#60;td>&#123;user.dateOfBirth}&#60;/td>
                  &#60;td>&#123;user.gender}&#60;/td>
                  &#60;td>
                    &#60;button className="btn btn-primary">Edit&#60;/button>
                    &#60;button className="btn btn-danger">Delete &#60;/button>
                  &#60;/td>
                &#60;/tr>
              )
            })}
          &#60;/tbody>
        &#60;/table>
      &#60;/div>
    )
  }
  
  export default UserDetails;
            </pre>
            <li>A Object.entries() metódus egy tömböt ad vissza, ahol minden elem egy kételemű tömb, ami a kulcs-érték
              párt tartalmazza
              <ul>
                <pre>
  <b>// Server response example (userData)</b>
  &#123;
    "-OHN1NTFvrP2LCXtpg9f": &#123;
        name: "Joe King",
        age: 30
    },
    "-OHNTRrRG2vAar4DRQqq": &#123;
        lastName: "Pink Floyd",
        age: 25
    },
    "-OHNXHO2drM2zqqEZj14": &#123;
        lastName: "Miss Sixty",
        age: 28
    }
  };

  let users = Object.entries(userData).map(userdata);
  console.log(users);

  ↓↓↓↓↓

  [
    [ "-OHN1NTFvrP2LCXtpg9f", &#123; name: "Joe King", age: 30 } ],
    [ "-OHNTRrRG2vAar4DRQqq", &#123; name: "Pink Floyd", age: 25 } ],
    [ "-OHNXHO2drM2zqqEZj14", &#123; name: "Miss Sixty", age: 28 } ]
  ]


  Object.entries(userData).map(([key, user]) => &#123;...}) // object destructuring
                </pre>
                <li>A 'key'-be kerül a tömb első eleme (korábban az objektum kulcsa), a Firebase ID, a 'user'-be pedig a
                  tömb második eleme (korábban az objektum értéke), a user adatok</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>axios
          <ul>
            <pre>
  axios.get('https://react-api-b8dfa-default-rtdb.firebaseio.com/Users.json')
    .then((resp) => &#123;
        return resp.data;
    }).then((userData) => &#123;
        setUsers(Object.entries(userData).map(([key, user]) => &#123; // object destructuring
            return &#123;
                id: key,
                name: user.firstName.concat(' ', user.lastName),
                // name: user.firstName + ' ' + user.lastName,
                // name: `$&#123;user.firstName} $&#123;user.lastName}`,
                // name: `$&#123;user.firstName ?? ''} $&#123;user.lastName ?? ''}`,
                email: user.emailAddress,
                dateOfBirth: user.dateOfBirth,
                gender: user.gender,
            }
        }));
    })
            </pre>
          </ul>
        </li>
      </ol>
    </li>
    <br>
    <br>
    <img src="assets/imgs/react_get_request.png" width="100%">
  </ul>
  <br>
  <h5 #loading data-anchor="loading">Loading</h5>
  <ul>
    <li>Egyszerűen létrehozhatunk töltőképernyőt</li>
    <pre>
  <b>// UserApp.js</b>
  export const UserApp = () => &#123;
    ...
    let [isLoading, setLoading] = useState(false);
    ...

    const onGetUsers = () => &#123;
      setLoading(true);

      axios.get('https://react-api-b8dfa-default-rtdb.firebaseio.com/Users.json')
          .then((resp) => &#123;
              return resp.data;
          }).then((userData) => &#123;
              setUsers(Object.entries(userData).map(([key, user]) => &#123; // object destructuring
                  return &#123;
                      id: key,
                      name: user.firstName.concat(' ', user.lastName),
                      email: user.emailAddress,
                      dateOfBirth: user.dateOfBirth,
                      gender: user.gender,
                  }
              }));
              setLoading(false);
          })
    }

    return (
      &#60;div>
          ...
          &#123;!isLoading && &#60;UserDetails users=&#123;users}>&#60;/UserDetails>}
          &#123;isLoading && &#60;p>Loading...&#60;/p>}
          ...
      &#60;/div>
    );
  }
    </pre>
    <li>Amennyiben komponenst szeretnénk használni, egyszerűen csak kicseréljük a &#60;p>Loading...&#60;/p> kódrészletet
    </li>
  </ul>
  <br>
  <h5 #fetchonpageload data-anchor="fetchonpageload">Fetch on page load</h5>
  <ul>
    <li>Ahhoz, hogy az oldal betöltésekor lekérjük a felhasználók listáját, useEffect hook-ot használhatunk
      <ul>
        <li>Side effect-et kell kezelnünk, és az API kérések ez a kategória</li>
        <pre>
  <b>// UserApp.js</b>
  export const UserApp = () => &#123;
    ...
    useEffect(() => &#123;
        onGetUsers();
    }, []);
    ...

    const onGetUsers = () => &#123;
      setLoading(true);

      axios.get('https://react-api-b8dfa-default-rtdb.firebaseio.com/Users.json')
          .then((resp) => &#123;
              return resp.data;
          }).then((userData) => &#123;
              setUsers(Object.entries(userData).map(([key, user]) => &#123; // object destructuring
                  return &#123;
                      id: key,
                      name: user.firstName.concat(' ', user.lastName),
                      email: user.emailAddress,
                      dateOfBirth: user.dateOfBirth,
                      gender: user.gender,
                  }
              }));
              setLoading(false);
          })
    }
  }
        </pre>
        <li>Bármikor, amikor a komponens első alkalommal töltődik be, a useEffect-ben lévő callback függvény meghívódik
          <ul>
            <li>Csak első betöltésre, mert a dependencia tömb üres</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Azt is elérhetjük, hogy miután hozzáadunk egy user-t a listához, automatikus frissítés történjen
      <ul>
        <pre>
  const onCreateUser = (user) => &#123;
    axios.post('https://react-api-b8dfa-default-rtdb.firebaseio.com/Users.json', user)
        .then((resp) => &#123;
            setShowForm(false); // miután megkaptuk a választ, bezárjuk a modal ablakot
            onGetUsers() // POST után frissítjük a listát
        });
  }
        </pre>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #errorhandling data-anchor="errorhandling">Error handling</h5>
  <ul>
    <li>Amikor HTTP request-et küldünk a szerver felé, kapunk egy státusz kódot a választban
      <ul>
        <li>Ha minden rendben történik, 200-as kódot kapunk ( &#123;status: 200, statusText: 'OK'} )</li>
        <li>Az 500-as hibakódok szerver oldali hibára utalnak</li>
      </ul>
    </li>
    <li>Hiba esetén a felhasználónak valamilyen számára is érthető üzenetet kell dobnunk</li>
    <li>Átírva a GET metódusunk URL-jét .json-ről .xml-re, 404-es hibát tudunk szimulálni
      <ul>
        <li>A console-ban axios hibát fogunk kapni</li>
        <pre>
  &#123;
    message: 'Request failed with status code 404',
    name: 'AxiosError',
    code: 'ERR_BAD_REQUEST',
    config: &#123;
      transitional: &#123; … },
      adapter: [Array(3)],
      transformRequest: [Array(1)],
      transformResponse: [Array(1)],
      timeout: 0,
      …
    },
    request: &#123;
      onreadystatechange: null,
      readyState: 4,
      timeout: 0,
      withCredentials: false,
      upload: XMLHttpRequestUpload &#123;},
      …
    },
    response: &#123;
      data: 'not found',
      status: 404,
      statusText: 'Not Found',
      headers: AxiosHeaders &#123;},
      config: &#123; … },
      …
    },
    status: 404,
    stack: "AxiosError: Request failed with status code 404\n    at settle (http://localhost:3000/static/js/bundle.js:60238:12)\n    at XMLHttpRequest.onloadend (http://localhost:3000/static/js/bundle.js:58885:66)\n    at Axios.request (http://localhost:3000/static/js/bundle.js:59384:41)"
  }          
        </pre>
        <li>A Promise vagy resolved lesz (adatot kapunk), vagy rejected (hibát kapunk)
          <ul>
            <li>A resolved Promise-t a then metódusban kapjuk mneg</li>
            <li>A catch blokkal pedig a hibákat kezelhetjük
              <ul>
                <li>A catch-nek paraméterként callback függvényt adunk</li>
                <li>A callback függvény paramétereként megkapjuk a hiba objektumot</li>
              </ul>
            </li>
            <pre>
  <b>// UserApp</b>
  export const UserApp = () => &#123;
    ...
    let [errorMessage, setErrorMessage] = useState(null);
    ...

    const onGetUsers = () => &#123;
      setErrorMessage(null);
      setLoading(true);

      axios.get('https://react-api-b8dfa-default-rtdb.firebaseio.com/Users.xml')
          .then((resp) => &#123;
              return resp.data;
          }).then((userData) => &#123;
              setUsers(Object.entries(userData).map(([key, user]) => &#123; // object destructuring
                  return &#123;
                      id: key,
                      name: user.firstName.concat(' ', user.lastName),
                      email: user.emailAddress,
                      dateOfBirth: user.dateOfBirth,
                      gender: user.gender,
                  }
              }));
              setErrorMessage(null);
              setLoading(false);
          })
          .catch((error) => &#123;
              setErrorMessage(error.message);
              setLoading(false);
          })
    }
  }

  return (
      &#60;div>
          ...
          &#123;!isLoading && !errorMessage && &#60;UserDetails users=&#123;users}>&#60;/UserDetails>}
          &#123;errorMessage && &#60;p>ERROR: &#123;errorMessage}&#60;/p>}
          &#123;isLoading && &#60;p>Loading...&#60;/p>}
          ...
      &#60;/div>
  );
            </pre>
          </ul>
        </li>
        <li>Async-await használatakor a catch metódust nem tudjuk használni
          <ul>
            <li>Try-catch-re van szükség</li>
            <pre>
  const onGetUsers = async () => &#60;
    setErrorMessage(null);
    setLoading(true);

    try &#60;
        const resp = await axios.get('https://react-api-b8dfa-default-rtdb.firebaseio.com/Users.xml');
        const userData = resp.data;

        const users = Object.entries(userData).map(([key, user]) => &#60;
            return &#60;
                id: key,
                name: user.firstName.concat(' ', user.lastName),
                email: user.emailAddress,
                dateOfBirth: user.dateOfBirth,
                gender: user.gender,
            };
        });

        setUsers(users);
        setErrorMessage(null);
    } catch (error) &#60;
        setErrorMessage(error.message);
    } finally &#60;
        setLoading(false);
    }
  };            
            </pre>
            <li>Az async kulcsszóval a függvény aszinkron lesz, az await-el pedig várakozhatunk az axios.get hívásra,
              amíg az le nem fut</li>
            <li>A try-catch blokkot a hiba kezelésére használjuk, hogy ha bármilyen hiba történik az aszinkron művelet
              során, azt elkapjuk és megfelelően kezeljük</li>
            <li>A finally blokk mindig végrehajtódik, akár a művelet sikerült, akár nem, itt biztosíthatjuk, hogy az
              isLoading mindig false-ra változzon</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Az axios a hibákat "valós" hibáknak tekinti, a fetch API viszont nem
      <ul>
        <li>A fetch API nem dob hibát HTTP hibák (például 404-es, 500-as) esetén, hanem csak akkor, ha maga a hálózati
          kérés nem sikerült
          <ul>
            <pre>
  GET https://react-api-b8dfa-default-rtdb.firebaseio.com/Users.xml 404 (Not Found)
            </pre>
            <li>Manuálisan szükséges hibát dobnunk</li>
            <pre>
  const onGetUsers = () => &#60;
    setErrorMessage(null);
    setLoading(true);

    fetch('https://react-api-b8dfa-default-rtdb.firebaseio.com/Users.xml', &#60;
        method: 'GET'
    }).then((response) => &#60; // a callback függvény megkapja a response-t, amikor a Promise feloldódik
        if (!response.ok) &#60;
            throw new Error('Something wrong has just happened'); // manuálisan dobunk hibát, ha a response.ok false
        }
        return response.json(); // visszaadja a response body-ját, mint Promise
    }).then(userData => &#60;
        setUsers(Object.entries(userData).map(([key, user]) => &#60; // object destructuring
            return &#60;
                id: key,
                name: user.firstName.concat(' ', user.lastName),
                email: user.emailAddress,
                dateOfBirth: user.dateOfBirth,
                gender: user.gender,
            }
        }));
        setLoading(false);
    }).catch(error => &#60; // a callback function megkapja az error object-et
        setErrorMessage(error.message);
        setLoading(false);
    });
  }
            </pre>
            <li>A catch az általunk dobott new Error objektumot kapja meg, a hibaüzenetünkkel</li>
          </ul>
        </li>
        <li>Az axios pedig alapértelmezés szerint dob hibát minden olyan válasz esetén, amely a 400-as, vagy magasabb
          státuszkóddal tér vissza, így azokat könnyebb hibaként kezelni</li>
        <li>Ha szeretnénk, hogy a fetch is automatikusan hibát dobjon a nem sikeres válaszokkal kapcsolatban (mint az
          axios), akkor manuálisan kell ellenőriznünk a válasz státuszkódját</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #filluserform data-anchor="filluserform">Fill user form</h5>
  <ul>
    <pre>
  <b>// UserApp.js</b>
  export const UserApp = () => &#123;
    ...
    let [editMode, setEditMode] = useState(false);
    let [selectedUser, setSelectedUser] = useState(null);
    ...
    const onEditUser = (user) => &#123;
      setEditMode(true);
      setSelectedUser(user);
      setShowForm(true);
    }
    ...
    return (
      &#60;div>
          &#60;div className='page-header d-flex justify-content-end'>
              &#60;button className='btn btn-success' onClick=&#123;addUserHandler}>Add User&#60;/button>
              &#60;button className='btn btn-info' onClick=&#123;onGetUsers}>Get Users&#60;/button>
          &#60;/div>

          &#123;!isLoading && !errorMessage && &#60;UserDetails users=&#123;users} onEditUser=&#123;onEditUser}>&#60;/UserDetails>}
          &#123;errorMessage && &#60;p>ERROR: &#123;errorMessage}&#60;/p>}
          &#123;isLoading && &#60;p>Loading...&#60;/p>}

          &#123;showForm &&
              &#60;UserForm
                  createUser=&#123;onCreateUser}
                  closeForm=&#123;closeForm}
                  editMode=&#123;editMode}
                  selectedUser=&#123;selectedUser}>
              &#60;/UserForm>}
      &#60;/div>
    );
  }

  <b>// UserDetails.js</b>
  function UserDetails(props) &#123;
    const onEditUser = (event, user) => &#123;
      props.onEditUser(user);
    }

    return (
      &#60;div className="user-details" >
        ...
        &#60;button className="btn btn-primary" onClick=&#123;(event) => onEditUser(event, user)}>Edit&#60;/button>
        &#60;button className="btn btn-danger">Delete &#60;/button>
      &#60;/div>
      )
  }

  <b>// UserForm.js</b>
  function UserForm(props) &#123;
    return &#60;>
      &#60;div id="myModal" className="modal">
          &#60;div className="modal-content">
              &#60;div className="close" onClick=&#123;props.closeForm}>&times;&#60;/div>
              &#60;h3>&#123;props.editMode ? 'Edit user' : 'Create new user'}&#60;/h3>
              &#60;div className="user-form">
                  &#60;form onSubmit=&#123;(event) => onFormSubmit(event)}>
                      &#60;div>
                          &#60;input type="text" placeholder="First name" ref=&#123;(el) => (formRefs.current.fname = el)}
                              defaultValue=&#123;props.editMode ? props.selectedUser.fname : ''} />
                          &#60;input type="text" placeholder="Last name" ref=&#123;(el) => (formRefs.current.lname = el)}
                              defaultValue=&#123;props.editMode ? props.selectedUser.lname : ''} />
                      &#60;/div>
                      &#60;div>
                          &#60;input type="email" placeholder="Email" ref=&#123;(el) => (formRefs.current.email = el)}
                              defaultValue=&#123;props.editMode ? props.selectedUser.email : ''} />
                      &#60;/div>
                      &#60;div>
                          &#60;input type="password" placeholder="Password" ref=&#123;(el) => (formRefs.current.password = el)}
                              defaultValue=&#123;props.editMode ? props.selectedUser.password : ''} />
                          &#60;input type="password" placeholder="Confirm Password"
                              defaultValue=&#123;props.editMode ? props.selectedUser.password : ''} />
                      &#60;/div>
                      &#60;div>
                          &#60;select name="country" ref=&#123;(el) => (formRefs.current.country = el)}
                              defaultValue=&#123;props.editMode ? props.selectedUser.country : ''}>
                              &#60;option value="Germany">Germany&#60;/option>
                              &#60;option value="USA">USA&#60;/option>
                              &#60;option value="UK">UK&#60;/option>
                          &#60;/select>
                          &#60;select name="city" ref=&#123;(el) => (formRefs.current.city = el)}
                              defaultValue=&#123;props.editMode ? props.selectedUser.city : ''}>
                              &#60;option value="Berlin">Berlin&#60;/option>
                              &#60;option value="New York">New York&#60;/option>
                              &#60;option value="London">London&#60;/option>
                          &#60;/select>
                      &#60;/div>
                      &#60;div>
                          &#60;input type="date" placeholder="Date of Birth" ref=&#123;(el) => (formRefs.current.date = el)}
                              defaultValue=&#123;props.editMode ? props.selectedUser.dateOfBirth : ''} />
                          &#60;select name="gender" ref=&#123;(el) => (formRefs.current.gender = el)}
                              defaultValue=&#123;props.editMode ? props.selectedUser.gender : ''}>
                              &#60;option value="Male">Male&#60;/option>
                              &#60;option value="Female">Female&#60;/option>
                              &#60;option value="Unknown">Unknown&#60;/option>
                          &#60;/select>
                      &#60;/div>
                      &#60;button className='add-user-button'>&#123;props.editMode ? 'Update user' : 'Create user'}&#60;/button>
                  &#60;/form>
              &#60;/div>
          &#60;/div>
      &#60;/div>
    &#60;/>
  }
    </pre>
    <li>Csakis kizárólag editMode esetén adjuk oda a form mezők defaultValue attribútumának a megfelelő user adatokat
    </li>
    <li>Érdemes lehet a UserDetails komponensben kezelni, ha üres a users tömb</li>
    <pre>
  return (
    &#60;div className="user-details" >
      &#123;props.users.length === 0 && &#60;p>No users!&#60;/p>}
      &#123;/* props.users.length && &#60;table ... */} &#123;/* megjelenít egy 0-át a DOM-ban */}
      &#123;props.users.length > 0 &&
        &#60;table className="users-table">
          ...
        &#60;/table>
      }
    &#60;/div>
  )
    </pre>
  </ul>
  <br>
  <h5 #putrequest data-anchor="putrequest">PUT request</h5>
  <ul>
    <pre>
  <b>// UserApp.js</b>
  export const UserApp = () => &#123;
    ...

    const onUpdateUser = (user, id) => &#123;
        fetch(`https://react-api-b8dfa-default-rtdb.firebaseio.com/Users/$&#123;id}/.json`, &#123;
          method: 'PUT',
          headers: &#123;
              'Content-Type': 'application/json'
          },
          body: JSON.stringify(&#123;
              firstName: user.firstName,
              lastName: user.lastName,
              emailAddress: user.emailAddress,
              Password: user.Password,
              dateOfBirth: user.dateOfBirth,
              city: user.city,
              country: user.country,
              gender: user.gender
          })
      }).then((resp) => &#123; // szándékos hiba esetén (.json --> .xml) nem jutunk el ebbe a blokkba, azonnal a catch ágban találjuk magunkat 'Failed to fetch' hibával
          if (!resp.ok) &#123;
              throw new Error('Failed to update user');
          }
          return resp.json();
      }).then((data) => &#123;
          setShowForm(false);
          onGetUsers() // PUT után frissítjük a listát
      }).catch((error) => &#123;
          setShowForm(false);
          setErrorMessage(error.message);
      })

      axios.put(`https://react-api-b8dfa-default-rtdb.firebaseio.com/Users/$&#123;id}/.json`, user)
        .then(resp => resp.data)
        .then(userData => &#123;
            console.log(userData);
            onGetUsers() // PUT után frissítjük a listát
        })
        .catch((error) => &#123;
            if (error.response) &#123;
                // error, ha van válasz
                throw new Error('Failed to update user', error.response.status);
            } else &#123;
                // ha nem volt válasz a szervertől
                console.error('Network Error', error);
                setErrorMessage('Network Error');
            }
        })
    }
  }

  <b>// UserForm.js</b>
  function UserForm(props) &#123;
    ...
    const onFormSubmit = (event) => &#123;
      ...
      props.editMode ? props.updateUser(user, props.selectedUser.id) : props.createUser(user);
    }
    ...
  }
    </pre>
    <li>A fetch esetében a body-t jóval le lehetne egyszerűsíteni
      <ul>
        <li>Mivel minden adatot fel kívánunk küldeni a user objektumból, és mivel a user objektumban minden kulcs
          megegyezik az adatbázisban lévő kulcsokkal</li>
        <li>Spread operátort használhatunk</li>
      </ul>
    </li>
    <pre>
  body: JSON.stringify(&#123;
    firstName: user.firstName,
    lastName: user.lastName,
    emailAddress: user.emailAddress,
    Password: user.Password,
    dateOfBirth: user.dateOfBirth,
    city: user.city,
    country: user.country,
    gender: user.gender
  })

  ↓↓↓↓↓

  body: JSON.stringify(&#123;...user})
    </pre>
  </ul>
  <br>
  <h5 #deleterequest data-anchor="deleterequest">DELETE request</h5>
  <ul>
    <pre>
  <b>// UserApp.js</b>
  export const UserApp = () => &#123;
    ...
    const onDeleteUser = (user) => &#123;
      let deleteUserConfirmation = window.confirm(`Do you want to delete $&#123;user.fname.concat(' ', user.lname)}?`);

    if (!deleteUserConfirmation) &#123;
        return;
    }

    /* fetch(`https://react-api-b8dfa-default-rtdb.firebaseio.com/Users/$&#123;user.id}/.json`, &#123;
        method: 'DELETE',
        headers: &#123;
            'Content-Type': 'application/json'
        }
    }).then((resp) => &#123;
        if (!resp.ok) &#123;
            throw new Error('Failed to delete user');
        }
        return resp.json();
    }).then((data) => &#123;
        onGetUsers() // PUT után frissítjük a listát
    }).catch((error) => &#123;
        setErrorMessage(error.message);
    }); */

    axios.delete(`https://react-api-b8dfa-default-rtdb.firebaseio.com/Users/$&#123;user.id}/.json`)
        .then(resp => &#123;
            console.log('User deleted successfully:', resp.data);
            onGetUsers();
        })
        .catch((error) => &#123;
            console.error('Error deleting user:', error.message);
            setErrorMessage(error.message);
        });
    }

    return (
      &#60;div>
          ...
          &#123;!isLoading && !errorMessage &&
              &#60;UserDetails
                  users=&#123;users}
                  onEditUser=&#123;onEditUser}
                  onDeleteUser=&#123;onDeleteUser}>
              &#60;/UserDetails>}
          &#123;errorMessage && &#60;p>ERROR: &#123;errorMessage}&#60;/p>}
          &#123;isLoading && &#60;p>Loading...&#60;/p>}
          ...
      &#60;/div>
      );
    }
  }

  <b>// UserDetails.js</b>
  function UserDetails(props) &#123;
    ...
    const onDeleteUser = (user) => &#123;
      props.onDeleteUser(user);
    }
    
    return (
      &#60;div className="user-details" >
        ...
        &#60;button className="btn btn-danger" onClick=&#123;() => onDeleteUser(user)}>Delete&#60;/button>
      &#60;/div>
    )
  }
    </pre>
  </ul>
</div>

<div>
  <h3 #customhook data-anchor="customhook">Custom hook</h3>
  <ul>
    <li>Kiindulási alap</li>
    <pre>
  <b>// CustomHookApp.js</b>
  export const CustomHookApp = () => &#123;
    return (
        &#60;>
            &#60;div className='d-flex justify-content-around'>
                &#60;Decrement>&#60;/Decrement>
                &#60;Increment>&#60;/Increment>
            &#60;/div>
        &#60;/>
    )
  }

  <b>// Increment.js</b>
  export const Increment = () => &#123;
    let [counter, setCounter] = useState(0);

    useEffect(() => &#123;
        const interval = setInterval(() => &#123; // a setInterval minden másodpercben egyel növeli a counter értékét
            setCounter(prevValue => prevValue + 1);
        }, 1000)
    }, []) // üres dependencia tömb, tehát a useEffect csak egyszer fog lefutni

    return (
        &#60;>
            &#60;div>&#123;counter}&#60;/div>
        &#60;/>
    )
  }

  <b>// Decrement.js</b>
  export const Decrement = () => &#123;
    let [counter, setCounter] = useState(0);

    useEffect(() => &#123;
        const interval = setInterval(() => &#123; // a setInterval minden másodpercben egyel növeli a counter értékét
            setCounter(prevValue => prevValue - 1);
        }, 1000);
        return () => clearInterval(interval); // elkerülendő a memóriaszivárgás
    }, []) // üres dependencia tömb, tehát a useEffect csak egyszer fog lefutni

    return (
        &#60;>
            &#60;div>&#123;counter}&#60;/div>
        &#60;/>
    )
  }
    </pre>
    <li>Jól láthatjuk, hogy az Increment, és a Decrement komponens szinte megegyezik
      <ul>
        <li>Érdemes az ilyesfajta duplikációkat elkerülni</li>
        <li>Csak funkcionális komponensben használhatunk React hook-ot</li>
      </ul>
    </li>
    <li>A kód duplikáció elkerülésére kiváló megoldás a custom hook</li>
    <li>A custom hook neve előtt a 'use' szócskát kell használnunk (prefix)
      <ul>
        <li>Ebből a szóból tudja a React, hogy egy custom React hook-kal van dolga</li>
      </ul>
    </li>
    <li>Custom React hook-ból visszatérhetünk "bármivel", legyen az number, string, boolean, array, object</li>
    <pre>
  <b>// Increment.js</b>
  export const Increment = () => &#123;
    let counter = useCounter(true); // itt/így kapjuk meg a use-counter.js return értékét

    return (
        &#60;>
            &#60;div>&#123;counter}&#60;/div>
        &#60;/>
    )
  }

  <b>// Decrement.js</b>
  export const Decrement = () => &#123;
    let counter = useCounter(false); // itt/így kapjuk meg a use-counter.js return értékét

    return (
        &#60;>
            &#60;div>&#123;counter}&#60;/div>
        &#60;/>
    )
  }

  <b>// useCounter.js</b>
  function useCounter(direction) &#123;
    console.log(direction);
    let [counter, setCounter] = useState(0);

    useEffect(() => &#123;
        const interval = setInterval(() => &#123; // a setInterval minden másodpercben egyel növeli a counter értékét
            setCounter(prevValue => prevValue + (direction ? 1 : -1));
        }, 1000);
        return () => clearInterval(interval);
    }, []) // üres dependencia tömb, tehát a useEffect csak egyszer fog lefutni

    return counter;
  }
    </pre>
    <li>Amennyiben később változna a a direction, a useEffect nem venné figyelembe, hiszen nincs ott a dependencia
      tömbben a direction</li>
    <pre>
  <b>// Increment.js</b>
  export const Increment = () => &#123;
    let counter = useCounter(true); // futási időben, ha megváltozna false-ra, a a custom hook-ban akkor is nőne az érték

    return (
        &#60;>
            &#60;div>&#123;counter}&#60;/div>
        &#60;/>
    )
  }

  <b>// Increment.js</b>
  function useCounter(direction) &#123;
    ...
    useEffect(() => &#123;
        const interval = setInterval(() => &#123;
            setCounter(prevValue => prevValue + (direction ? 1 : -1));
        }, 1000);
        return () => clearInterval(interval);
    }, []) // a useEffect nem figyel a változásokra

    return counter;
  }
    </pre>
    <li>Beállíthatunk a custom hook-nak alapértelmezett bemeneti értéket is, arra az esetre, ha nem adnánk át semmilyen
      argomentumot a hook-nak</li>
    <pre>
  <b>// useCounter.js</b>
  function useCounter(direction = true) &#123; // alapértelmezetten true, azaz növekvő lesz
    let [counter, setCounter] = useState(0);

    useEffect(() => &#123;
        const interval = setInterval(() => &#123; // a setInterval minden másodpercben egyel növeli a counter értékét
            setCounter(prevValue => prevValue + (direction ? 1 : -1));
        }, 1000);
        return () => clearInterval(interval);
    }, []) // üres dependencia tömb, tehát a useEffect csak egyszer fog lefutni

    return counter;
  }

  <b>// Increment.js</b>
  export const Increment = () => &#123;
    let counter = useCounter(); // nem adunk át értéket

    return (
        &#60;>
            &#60;div>&#123;counter}&#60;/div>
        &#60;/>
    )
  }

  <b>// Decrement.js</b>
  export const Decrement = () => &#123;
    let counter = useCounter(false); // átadunk értéket, hogy az alapértelmezett true-t felülírjuk a useCounter.js-ben

    return (
        &#60;>
            &#60;div>&#123;counter}&#60;/div>
        &#60;/>
    )
  }
      </pre>
  </ul>
  <br>
  <h5 #customhttphook data-anchor="customhttphook">Custom HTTP hook</h5>
  <ul>
    <li>Ezúttal is a custom React hook-kal foglalkozunk, csak egy praktikusabb megközelítéssel</li>
    <li>A kiindulási alapunk egy feladatlista, ahol listázunk, hozzáadhatunk, és törölhetünk feladatokat
      <ul>
        <li>Fetch API-val van megoldva, és működik is</li>
      </ul>
    </li>
    <pre>
      <b>// CustomHttpHook.js</b>
  import &#123; useState } from 'react';
  import style from './CustomHttpHook.module.scss';

  import &#123; useEffect, useRef, useState } from 'react';
  import style from './CustomHttpHook.module.scss';
  import &#123; Tasks } from './Tasks';

  export const CustomHttpHook = () => &#123;
      let [tasks, setTasks] = useState([]);
      let [errorMessage, setErrorMessage] = useState(null);

      let taskNameRef = useRef();

      useEffect(() => &#123;
          getTasks();
      }, []);

      const getTasks = () => &#123;
          console.log('getTasks');
          fetch('https://react-api-b8dfa-default-rtdb.firebaseio.com/Tasks.json', &#123;
              method: 'GET'
          })
              .then((resp) => &#123;
                  if (!resp.ok) &#123;
                      throw new Error('Something went wrong with getTasks');
                  }
                  return resp.json();
              })
              .then((tasks) => &#123;
                  let taskList = [];
                  for (let key in tasks) &#123; // objektumon egyszerűen for...in ciklussal mehetünk végig
                      taskList.push(&#123; id: key, name: tasks[key].name });
                  }
                  setTasks(taskList);
              })
              .catch(error => &#123;
                  setErrorMessage(error.message);
              })
      }

      const createTask = () => &#123;
          console.log('createTask');
          fetch('https://react-api-b8dfa-default-rtdb.firebaseio.com/Tasks.json', &#123;
              method: 'POST',
              body: JSON.stringify(&#123; name: taskNameRef.current.value })
          })
              .then((resp) => &#123;
                  if (!resp.ok) &#123;
                      throw new Error('Something went wrong with createTask');
                  }

                  getTasks();
              })
              .catch(error => &#123;
                  setErrorMessage(error.message);
              })
      }

      const deleteTask = (id) => &#123;
          console.log('deleteTask');
          fetch(`https://react-api-b8dfa-default-rtdb.firebaseio.com/Tasks/$&#123;id}.json`, &#123;
              method: 'DELETE'
          })
              .then((resp) => &#123;
                  if (!resp.ok) &#123;
                      throw new Error('Something went wrong with deleteTask');
                  }

                  getTasks();
              })
              .catch(error => &#123;
                  setErrorMessage(error.message);
              })
      };

      return (
          &#60;>
              &#60;div className=&#123;`$&#123;style.task_adder} d-flex align-items-center justify-content-center p-3 mb-1`}>
                  &#60;input type="text" placeholder="Task name" ref=&#123;taskNameRef}>&#60;/input>
                  &#60;button className='btn btn-success' onClick=&#123;createTask}>Create&#60;/button>
              &#60;/div>
              &#123;!errorMessage && &#60;Tasks tasks=&#123;tasks} onDeleteTask=&#123;deleteTask}>&#60;/Tasks>}
              &#123;errorMessage && &#60;p>ERROR: &#123;errorMessage}&#60;/p>}
          &#60;/>
      )
  }

  <b>// CustomHttpHook.js</b>
  import style from './CustomHttpHook.module.scss';

  export const Tasks = (props) => &#123;
      console.log(props);
      const onDeleteTask = (id) => &#123;
          props.onDeleteTask(id);
      }

      return (
          &#60;>
              &#123;props.tasks.length === 0 && &#60;p>No tasks!&#60;/p>}
              &#123;props.tasks.length > 0 &&
                  props.tasks.map((task, index) => &#123;
                      return (
                          &#60;div key=&#123;index}
                              className=&#123;`$&#123;style.task} d-flex align-items-center justify-content-center justify-content-around mb-1`}>
                              &#60;span>&#123;task.name}&#60;/span>
                              &#60;button className='btn btn-danger' onClick=&#123;() => onDeleteTask(task.id)}>Delete&#60;/button>
                          &#60;/div>
                      )
                  })}
          &#60;/>
      )
  }
    </pre>
    <li>Ezúttal is észrevehető, hogy a GET, POST, ÉS DELETE funkcionalitásokért felelős függvények nagyon hasonlóak
      egymáshoz</li>
    <li>A custom hook-unk fog felelni a metódusokért, az adatokért, a hibakezelésért</li>
  </ul>
  <br>
  <h5 #gethttphook data-anchor="gethttphook">GET HTTP hook</h5>
  <ul>
    <pre>
  <b>// CustomHttpHook.js</b>
  export const CustomHttpHook = () => &#123;
    ...
    //  GET
    let [sendRequest, error] = useApi( // a sendHttpRequest függvényt, és az errorMessage-t adja vissza
        'https://react-api-b8dfa-default-rtdb.firebaseio.com/Tasks.json',
        'GET',
        null,
        getTasks // callback függvény, amit akkor hív meg a kód, ha az API-hívás sikeresen lefutott
    );

    function getTasks(tasks) &#123; // arrow function esetében a useApi getTasks hívása panaszkodik, hogy előbb lett használva, mint definiálva
        // console.log(tasks) // az API válasza, a JSON adatokat fogja tartalmazni, Promise, így fel kell oldanunk
        tasks.then(data => &#123;
            let taskList = [];
            for (let key in data) &#123; // objektumon egyszerűen for...in ciklussal mehetünk végig
                taskList.push(&#123; id: key, name: data[key].name });
            }
            setTasks(taskList);
        });
        setErrorMessage(error);
    };

    useEffect(() => &#123;
        sendRequest();
    }, []);
    ...
  }

  <b>// use-api.js</b>
  export const useApi = (url, method, body, action) => &#123;
    let [errorMessage, setErrorMessage] = useState(null);

    const sendRequest = () => &#123;
        fetch(url, &#123;
            method: method,
            body: body ? JSON.stringify(body) : null
        })
            .then((resp) => &#123; // a fetch visszaad egy Response objektumot
                if (!resp.ok) &#123;
                    throw new Error('Something went wrong with createTask');
                }

                action(resp.json()); // a válasz JSON objektumot ad át az action callback függvénynek
            })
            .catch(error => &#123;
                setErrorMessage(error.message);
            })
    }

    return [sendRequest, errorMessage];
  }
    </pre>
    <li>Lépések
      <ol>
        <li>A useApi custom HTTP hook-ból visszatérő sendRequest függvény bemeneti paramétereket kap
          <ul>
            <li>URL, method, body, action (callback function)</li>
            <li>A sendRequest a useApi hook-ban definiált sendRequest függvényre mutat, amely magába foglalja
              az egész fetch logikát</li>
            <pre>
  let [sendRequest, error] = useApi(
    'https://react-api-b8dfa-default-rtdb.firebaseio.com/Tasks.json',
    'GET',
    null,
    getTasks
  )
            </pre>
          </ul>
        </li>
        <li>Miután a useApi hook lefutott, a sendRequest egy olyan függvényt ad vissza, amely szükség szerint
          bármikor meghívható, hogy egy új API kérést végrehajtson
          <ul>
            <li>A fetch API használatához a sendRequest függvény meghívására van szükség</li>
          </ul>
        </li>
        <li>Mivel az API hívást az oldal betöltődésekor szeretnénk megtenni, így ezúttal a useEffect hook a
          sendRequest függvényt fogja meghívni
          <pre>
  useEffect(() => &#123;
      sendRequest();
  }, []);
              </pre>
        </li>
        <li>Amikor definiáljuk a useApi paramétereit, a negyedik a paraméter egy callback függvény
          <ul>
            <li>Amennyiben a fetch API-val nem futunk error ágba, úgy az action függvényen keresztül meghívjuk a
              getTasks függvényt
              <ul>
                <pre>
  const sendRequest = () => &#123;
    fetch(url, &#123;
        method: method,
        body: body ? JSON.stringify(body) : null
    })
        .then((resp) => &#123;
            if (!resp.ok) &#123;
                throw new Error('Something went wrong');
            }

            action(resp.json());
        })
        .catch(error => &#123;
            setErrorMessage(error.message);
        })
  }
                    </pre>
                <li>Az action megkapja a kérés válaszát, és ezáltal meghívódik a getTasks</li>
                <pre>
  function getTasks(tasks) &#123; // a tasks egy promise
    // console.log(tasks)
    tasks.then(data => &#123;
        let taskList = [];
        for (let key in data) &#123;
            taskList.push(&#123; id: key, name: data[key].name });
        }
        setTasks(taskList);
    });
    setErrorMessage(error);
  };
                </pre>
              </ul>
            </li>
          </ul>
        </li>
      </ol>
    </li>
    <li>Átírva az endpoint URL-t, a use-api.js-ben kelekező error csak ott kerül bele state-be, nem gondoskodtunk arról,
      hogy megjelenítésre is kerüljön a user számára
      <ul>
        <li>Erre egy megoldás lehet hogy paraméterként egy újabb callback függvényt használunk</li>
        <pre>
  <b>// CustomHttpHook.js</b>
  export const CustomHttpHook = () => &#123;
    ...
    let [errorMessage, setErrorMessage] = useState(null);
    ...
    let [sendRequest, error] = useApi(
        'https://react-api-b8dfa-default-rtdb.firebaseio.com/Tasks.json',
        'GET',
        null,
        getTasks,
        onError // hibakezelő callback függvény, amit akkor hívunk meg, ha hiba történik a fetch során
    );
    ...
    function onError(error) &#123;
      setErrorMessage(error);
    }
    ...
    return (
        &#60;>
            ...
            &#123;!errorMessage && &#60;Tasks tasks=&#123;tasks} onDeleteTask=&#123;deleteTask}>&#60;/Tasks>}
            &#123;errorMessage && &#60;p>ERROR: &#123;errorMessage}&#60;/p>}
        &#60;/>
    )
  }

  <b>// use-api.js</b>
  export const useApi = (url, method, body, action, onError) => &#123;
    let [errorMessage, setErrorMessage] = useState(null);

    const sendRequest = () => &#123;
        fetch(url, &#123;
            method: method,
            body: body ? JSON.stringify(body) : null
        })
            .then((resp) => &#123;
                if (!resp.ok) &#123;
                    throw new Error('Something went wrong');
                }

                action(resp.json());
            })
            .catch(error => &#123;
                setErrorMessage(error.message); // ha hiba történt, beállítjuk az errorMessage state-et
                onError(error.message); // a hibaüzenetet átadjuk a komponensben definiált hibakezelő callback függvénynek
            })
    }

    return [sendRequest, errorMessage];
  }
        </pre>
        <li>Más megoldásokat is alkalmazhatunk, például try-catch-et is használhatunk</li>
        <pre>
  <b>// CustomHttpHook.js</b>
  export const CustomHttpHook = () => &#123;
    ...
    let sendRequest = useState(null);
    ...
    let [sendRequest, error] = useApi(
        'https://react-api-b8dfa-default-rtdb.firebaseio.com/Tasks.json',
        'GET',
        null,
        getTasks
    );
    ...
    useEffect(() => &#123;
      try &#123;
          sendRequest();
      } catch (error) &#123;
          setErrorMessage(error);
      }
    }, []);

    return (
        &#60;>
            ...
            &#123;!errorMessage && &#60;Tasks tasks=&#123;tasks} onDeleteTask=&#123;deleteTask}>&#60;/Tasks>}
            &#123;errorMessage && &#60;p>ERROR: &#123;errorMessage}&#60;/p>}
        &#60;/>
    )
  }

  <b>// use-api.js</b>
  export const useApi = (url, method, body, action) => &#123;
    let [errorMessage, setErrorMessage] = useState(null);

    const sendRequest = () => &#123;
        fetch(url, &#123;
            method: method,
            body: body ? JSON.stringify(body) : null
        })
            .then((resp) => &#123;
                if (!resp.ok) &#123;
                    throw new Error('Something went wrong');
                }

                action(resp.json());
            })
            .catch(error => &#123;
                throw error; // tovább "dobjuk" a hibát
            })
    }

    return sendRequest;
  }
        </pre>
        <li>További opcióink is vannak, úgy, mint
          <ol>
            <li>Context API</li>
            <li>useState helyett useReducer</li>
          </ol>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #posthttphook data-anchor="posthttphook">POST HTTP hook</h5>
  <ul>
    <pre>
  <b>// CustomHttpHook.js</b>
  let [sendPostRequest, postError] = useApi(
      `https://react-api-b8dfa-default-rtdb.firebaseio.com/Tasks.json`,
      'POST',
      taskNameRef.current.value, // nem a megfelelő hely, hogy body-t átadjunk
      createTask
  );

  function createTask(tasks) &#123;
      console.log(tasks);
      sendPostRequest();
      sendGetRequest();
      /* response.then(() => &#123;
          sendGetRequest();
      });
      setErrorMessage(postError); */
  }
    </pre>
    <li>Amikor létrehozzuk a POST custom hook-unkat, a taskNameRef.current.value undefined / nem létezik
      <ul>
        <li>A JSX kód még nem futott le, amikor a hook-ot létrehozzuk</li>
      </ul>
    </li>
    <li>Amikor a felhasználó rákattint a Create gombra (természetesen azt követően, hogy begépelt valamit, mint task
      név), akkor már van értéke az input elemnek</li>
    <li>Az egyik megoldás lehetne, hogy a createTask függvényben küldjük el a POST request-et, de a useApi custom
      hook-ot nem használhatjuk "normál" függvényben
      <ul>
        <li>Nem komponens függvény, és nem is custom React hook</li>
      </ul>
    </li>
    <li>Módosítsuk a custom hook-ot annak érdekében, hogy megoldjuk a problémát
      <ul>
        <li>Nem a useApi függvénynek adunk át paramétereket, hanem közvetlenül a benne található sendRequest függvénynek
        </li>
        <pre>
  <b>// CustomHttpHook.js</b>
  export const CustomHttpHook = () => &#123;
    let [tasks, setTasks] = useState([]);
    let [errorMessage, setErrorMessage] = useState(null);

    let taskNameRef = useRef();

    // ----- ----- ----- ----- ----- GET ----- ----- ----- ----- -----

    let [sendGetRequest, getError] = useApi(); // a sendHttpRequest függvényt, és az errorMessage-t adja vissza

    function getTasks(tasks) &#123; // arrow function esetében a useApi getTasks hívása panaszkodik, hogy előbb lett használva, mint definiálva
        tasks.then(data => &#123;
            let taskList = [];
            for (let key in data) &#123; // objektumon egyszerűen for...in ciklussal mehetünk végig
                taskList.push(&#123; id: key, name: data[key].name });
            }
            setTasks(taskList);
        });
        setErrorMessage(getError);
    };

    const onFetchTasks = () => &#123; // kiszerveztük a sendGetRequest-et, hogy mindenhonnan csak az onFetchTasks függvényt kelljen meghívni
        sendGetRequest(
            'https://react-api-b8dfa-default-rtdb.firebaseio.com/Tasks.json',
            'GET',
            null,
            getTasks // callback függvény, amit akkor hív meg a kód, ha az API-hívás sikeresen lefutott);
        )
    }

    useEffect(() => &#123;
        onFetchTasks();
    }, []);

    // ----- ----- ----- ----- ----- POST ----- ----- ----- ----- -----

    let [sendPostRequest, postError] = useApi();

    function postTask() &#123; // nem kap semmilyen adatot
        sendPostRequest(
            `https://react-api-b8dfa-default-rtdb.firebaseio.com/Tasks.json`,
            'POST',
            &#123; name: taskNameRef.current.value },
            createTask
        );
    }

    function createTask(task) &#123; // a POST request válaszát itt kapjuk meg
        task.then((data) => &#123;
            console.log('data: ', data); // az új task ID-ját kapjuk vissza, esetünkben name kulcs alatt (object)
            onFetchTasks();
        })
    }
    ...
    return (
        &#60;>
            ...
                &#60;button className='btn btn-success' onClick=&#123;postTask}>Create&#60;/button> // módosult az onClick függvényhívás
            ...
        &#60;/>
    )
  }
        </pre>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #deletehttphook data-anchor="deletehttphook">DELETE HTTP hook</h5>
  <ul>
    <pre>
  <b>// CustomHttpHook.js</b>
  export const CustomHttpHook = () => &#123;
    ...
    let [sendDeleteRequest, deleteError] = useApi();

    const deleteTask = (id) => &#123;
        sendDeleteRequest(
            `https://react-api-b8dfa-default-rtdb.firebaseio.com/Tasks/$&#123;id}.json`,
            'DELETE',
            null,
            deleteTaskResponse
        );
    }

    function deleteTaskResponse(task) &#123;
        console.log(task) // pending Promise
        task.then((data) => &#123;
            console.log('then: ', data);  // null
            onFetchTasks();
        })
    }

    return (
      &#60;>
        ...
          &#123;!errorMessage && &#60;Tasks tasks=&#123;tasks} onDeleteTask=&#123;deleteTask}>&#60;/Tasks>}
        ...
      &#60;/>
    )
  }
    </pre>
  </ul>
  <br>
  <h5 #completehttphook data-anchor="completehttphook">Complete HTTP hook</h5>
  <ul>
    <img src="assets/imgs/react_http_hook.png" width="100%">
    <pre>
  <b>// CustomHttpHook.js</b>
  import &#123; useEffect, useRef, useState } from 'react';
  import style from './CustomHttpHook.module.scss';
  import &#123; Tasks } from './Tasks';
  import &#123; useApi } from './use-api';

  export const CustomHttpHook = () => &#123;
      let [tasks, setTasks] = useState([]);
      let [errorMessage, setErrorMessage] = useState(null);

      let taskNameRef = useRef();

      // ----- ----- ----- ----- ----- GET ----- ----- ----- ----- -----

      let [sendGetRequest, getError] = useApi(); // a sendHttpRequest függvényt, és az errorMessage-t adja vissza

      function getTasks(tasks) &#123; // arrow function esetében a useApi getTasks hívása panaszkodik, hogy előbb lett használva, mint definiálva
          tasks.then(data => &#123;
              let taskList = [];
              for (let key in data) &#123; // objektumon egyszerűen for...in ciklussal mehetünk végig
                  taskList.push(&#123; id: key, name: data[key].name });
              }
              setTasks(taskList);
          });
          setErrorMessage(getError);
      };

      const onFetchTasks = () => &#123; // kiszerveztük a sendGetRequest-et, hogy mindenhonnan csak az onFetchTasks függvényt kelljen meghívni
          sendGetRequest(
              'https://react-api-b8dfa-default-rtdb.firebaseio.com/Tasks.json',
              'GET',
              null,
              getTasks // callback függvény, amit akkor hív meg a kód, ha az API-hívás sikeresen lefutott);
          )
      }

      useEffect(() => &#123;
          onFetchTasks();
      }, []);

      // ----- ----- ----- ----- ----- POST ----- ----- ----- ----- -----

      let [sendPostRequest, postError] = useApi();

      function postTask() &#123; // nem kap semmilyen adatot
          // console.log(tasks);
          sendPostRequest(
              `https://react-api-b8dfa-default-rtdb.firebaseio.com/Tasks.json`,
              'POST',
              &#123; name: taskNameRef.current.value },
              createTask
          );
      }

      function createTask(task) &#123; // a POST request válaszát itt kapjuk meg
          task.then((data) => &#123;
              // console.log('data: ', data); // az új task ID-ját kapjuk vissza, esetünkben name kulcs alatt (object)
              onFetchTasks();
          })
      }

      // ----- ----- ----- ----- ----- DELETE ----- ----- ----- ----- -----

      let [sendDeleteRequest, deleteError] = useApi();

      const deleteTask = (id) => &#123;
          sendDeleteRequest(
              `https://react-api-b8dfa-default-rtdb.firebaseio.com/Tasks/$&#123;id}.json`,
              'DELETE',
              null,
              onDeleteTask
          );
      }

      function onDeleteTask(task) &#123;
          console.log(task) // pending Promise
          task.then((data) => &#123;
              console.log('then: ', data); // null
              onFetchTasks();
          })
      }

      return (
          &#60;>
              &#60;div className=&#123;`$&#123;style.task_adder} d-flex align-items-center justify-content-center p-3 mb-1`}>
                  &#60;input type="text" placeholder="Task name" ref=&#123;taskNameRef}>&#60;/input>
                  &#60;button className='btn btn-success' onClick=&#123;postTask}>Create&#60;/button>
              &#60;/div>
              &#123;!errorMessage && &#60;Tasks tasks=&#123;tasks} onDeleteTask=&#123;deleteTask}>&#60;/Tasks>}
              &#123;errorMessage && &#60;p>ERROR: &#123;errorMessage}&#60;/p>}
          &#60;/>
      )
  }

  <b>// Tasks.js</b>
  import style from './CustomHttpHook.module.scss';

  export const Tasks = (props) => &#123;
      // console.log(props);
      const onDeleteTask = (id) => &#123;
          props.onDeleteTask(id);
      }

      return (
          &#60;>
              &#123;props.tasks.length === 0 && &#60;p>No tasks!&#60;/p>}
              &#123;props.tasks.length > 0 &&
                  props.tasks.map((task, index) => &#123;
                      return (
                          &#60;div key=&#123;index}
                              className=&#123;`$&#123;style.task} d-flex align-items-center justify-content-center justify-content-around mb-1`}>
                              &#60;span>&#123;task.name}&#60;/span>
                              &#60;button className='btn btn-danger' onClick=&#123;() => onDeleteTask(task.id)}>Delete&#60;/button>
                          &#60;/div>
                      )
                  })}
          &#60;/>
      )
  }

  <b>// use-api.js</b>
  import &#123; useState } from "react";

  export const useApi = () => &#123;
      let [errorMessage, setErrorMessage] = useState(null);

      const sendRequest = (url, method, body, action) => &#123;
          fetch(url, &#123;
              method: method,
              body: body ? JSON.stringify(body) : null
          })
              .then((resp) => &#123; // a fetch visszaad egy Response objektumot
                  if (!resp.ok) &#123;
                      throw new Error('Something went wrong');
                  }

                  action(resp.json()); // átadjuk a választ a megadott callback függvénynek (action)
              })
              .catch(error => &#123;
                  setErrorMessage(error.message);
              })
      }

      return [sendRequest, errorMessage];
  }

  <b>// CustomHttpHook.module.scss</b>
  .task_adder &#123;
    background-color: rgb(69, 69, 69);
    border-radius: 10px;
  }
  
  .task &#123;
      color: white;
      background-color: rgb(69, 69, 69);
      border-radius: 10px;
  }
    </pre>
  </ul>
</div>

<div>
  <h3 #workingwithforms data-anchor="workingwithforms">Working with forms</h3>
  <ul>
    <li>Ebben a témakörben összegyűjtjük a form mezőinek adatait, készítünk validációt, és különféle event-eket kezelünk
    </li>
  </ul>
  <h5 #fetchformdata data-anchor="fetchformdata">Fetch form data</h5>
  <ul>
    <li>Az input adatok kinyeréséhez egy már korábban látott user form-ot fogjuk alkalmazni</li>
    <pre>
  <b>// Forms.js</b>
  import style from './Forms.module.scss'

  export const Forms = () => &#123;

      const onFormSubmit = (event) => &#123;
          event.preventDefault();
          console.log(event);
      }

      return &#60;>
          &#60;div className=&#123;`$&#123;style.user_form}`}>
              &#60;h3>User form&#60;/h3>
              &#60;div >
                  &#60;form onSubmit=&#123;(event) => onFormSubmit(event)}>
                      &#60;div>
                          &#60;input type="text" placeholder="First name" />
                          &#60;input type="text" placeholder="Last name" />
                      &#60;/div>
                      &#60;div>
                          &#60;input type="email" placeholder="Email" />
                      &#60;/div>
                      &#60;div>
                          &#60;input type="password" placeholder="Password" />
                          &#60;input type="password" placeholder="Confirm Password" />
                      &#60;/div>
                      &#60;div>
                          &#60;select name="country" >
                              &#60;option value="Germany">Germany&#60;/option>
                              &#60;option value="USA">USA&#60;/option>
                              &#60;option value="UK">UK&#60;/option>
                          &#60;/select>
                          &#60;select name="city" >
                              &#60;option value="Berlin">Berlin&#60;/option>
                              &#60;option value="New York">New York&#60;/option>
                              &#60;option value="London">London&#60;/option>
                          &#60;/select>
                      &#60;/div>
                      &#60;div>
                          &#60;input type="date" placeholder="Date of Birth" />
                          &#60;select name="gender" >
                              &#60;option value="Male">Male&#60;/option>
                              &#60;option value="Female">Female&#60;/option>
                              &#60;option value="Unknown">Unknown&#60;/option>
                          &#60;/select>
                      &#60;/div>
                      &#60;div className='d-flex justify-content-end'>
                          &#60;button className='btn btn-secondary'>Submit user form&#60;/button>
                      &#60;/div>
                  &#60;/form>
              &#60;/div>
          &#60;/div>
      &#60;/>
  }
    </pre>
    <li>Input elem fetch-elése
      <ul>
        <li>State-tel és ref-fel is megvalósítható</li>
      </ul>
      <br>
      <ol>
        <li>State
          <ul>
            <pre>
  const onFirstNameChange = (event) => &#123;
    setFirstName(event.target.value); // a mező aktuális tartalma billentyűleütés után a event.target.value
  }

  const onFormSubmit = (event) => &#123;
    event.preventDefault();
    console.log(firstName); // submit-kor a rendelkezésünkre áll a mező tartalma
  }

  &#60;input type="text" placeholder="First name" onChange=&#123;onFirstNameChange} />
            </pre>
            <li>Ahányszor megváltozik a keresztnév mező, event objektum fog érkezni
              <ul>
                <li>Az objektumon keresztül hozzáférünk a mező tartalmához</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Ref
          <ul>
            <pre>
  let firstNameRef = useRef();

  const onFormSubmit = (event) => &#123;
    event.preventDefault();
    console.log(firstNameRef.current.value);  // submit-kor a rendelkezésünkre áll a mező tartalma
  }

  &#60;input type="text" placeholder="First name" ref=&#123;firstNameRef} />
            </pre>
          </ul>
        </li>
      </ol>
      <br>
      <ul>
        <li>Kérdés lehet, hogy melyik a jobb megoldás
          <ul>
            <li>Attól függ, mit akarunk kezdeni a begépelt értékekkel</li>
            <li>Amennyiben kizárólag a form elküldése a célunk, és csak e kapcsán van relevanciája a mezőknek, akkor
              ref-et érdemes használni, mert a minden change-re lefutó state változások feleslegesek</li>
            <li>Ha pedig minden leütés után kezdeni szeretnénk valamit az értékekkel, akkor state-et érdemes használni
              <ul>
                <li>Például, ha változás esetén azonnal validálni is szeretnénk</li>
                <li>Form reset-eléskor is jobban járunk vele
                  <ul>
                    <li>Egyszerűen csak az update függvényét használva a state-nek kinullázzuk az értéket / értékeket
                    </li>
                    <li>Emellett az értéket is bind-olnunk szükséges, különben nem járunk sikerrel</li>
                    <pre>
  let [firstName, setFirstName] = useState('');

  const onFormSubmit = (event) => &#123;
    event.preventDefault();
    setFirstName('');
  }

  &#60;input
    type="text"
    placeholder="First name"
    onChange=&#123;onFirstNameChange}
    value=&#123;firstName}
  />
                    </pre>
                  </ul>
                </li>
                <li>Ref-fel is megoldható a form reset
                  <ul>
                    <pre>
  let firstNameRef = useRef();

  const onFormSubmit = (event) => &#123;
    event.preventDefault();
    firstNameRef.current.value = '';
  }

  &#60;input type="text" placeholder="First name" ref=&#123;firstNameRef} />
                    </pre>
                    <li>Nem ideális, mert direkt módon módosítjuk a DOM-ot
                      <ul>
                        <li>Mindig kerülendő, meg kell hagyni, hogy a React végezze</li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #validateformdata data-anchor="validateformdata">Validate form data</h5>
  <ul>
    <li>A user-nek ideális esetben nem szabad tudni elküldeni a form-ot, ha van üres kötelező mező
      <ul>
        <li>Ezt most nem fogjuk megvalósítani</li>
      </ul>
    </li>
    <pre>
  export const Forms = () => &#123;
    let [firstName, setFirstName] = useState('');
    let [firstNameIsValid, setFirstNameIsValid] = useState(true);

    let firstNameRef = useRef();

    const onFirstNameChange = (event) => &#123;
        setFirstName(event.target.value); // a mező aktuális tartalma billentyűleütés után a event.target.value
    }

    const onFormSubmit = (event) => &#123;
        event.preventDefault();

        if (firstName.trim() === '') &#123; // üres keresztnév mező esetében visszatérünk a függvényből
            setFirstNameIsValid(false);
            return;
        }

        setFirstNameIsValid(true);

        // egyéb logika

        setFirstName('');
    }

    return &#60;>
        &#60;div className=&#123;`$&#123;style.user_form}`}>
            &#60;h3>User form&#60;/h3>
            &#60;div >
                &#60;form onSubmit=&#123;(event) => onFormSubmit(event)}>
                    &#60;div>
                        &#60;input type="text" placeholder="First name" onChange=&#123;onFirstNameChange} value=&#123;firstName} />
                        &#123;!firstNameIsValid && &#60;div>&#60;p>First name is required&#60;/p>&#60;/div>}
                        &#60;input type="text" placeholder="Last name" />
                    &#60;/div>
                    &#60;div>
                        &#60;input type="email" placeholder="Email" />
                    &#60;/div>
                    &#60;div>
                        &#60;input type="password" placeholder="Password" />
                        &#60;input type="password" placeholder="Confirm Password" />
                    &#60;/div>
                    &#60;div>
                        &#60;select name="country" >
                            &#60;option value="Germany">Germany&#60;/option>
                            &#60;option value="USA">USA&#60;/option>
                            &#60;option value="UK">UK&#60;/option>
                        &#60;/select>
                        &#60;select name="city" >
                            &#60;option value="Berlin">Berlin&#60;/option>
                            &#60;option value="New York">New York&#60;/option>
                            &#60;option value="London">London&#60;/option>
                        &#60;/select>
                    &#60;/div>
                    &#60;div>
                        &#60;input type="date" placeholder="Date of Birth" />
                        &#60;select name="gender" >
                            &#60;option value="Male">Male&#60;/option>
                            &#60;option value="Female">Female&#60;/option>
                            &#60;option value="Unknown">Unknown&#60;/option>
                        &#60;/select>
                    &#60;/div>
                    &#60;div className='d-flex justify-content-end'>
                        &#60;button className='btn btn-secondary'>Submit user form&#60;/button>
                    &#60;/div>
                &#60;/form>
            &#60;/div>
        &#60;/div>
    &#60;/>
  }
    </pre>
    <li>Könnyen kivitelezhető, hogy figyeljük a mezőt, és visszatérünk a függvényből tulajdonképpen elküldés nélkül, ha
      nem töltötte ki a user, de így még semmiféle visszajelzéset sem adtunk</li>
    <li>Ahhoz, hogy a form betöltődésekor ne legyen minden mező "hibás", a legegyszerűbb, ha a firstNameIsValid kezdeti
      értéke true
      <ul>
        <li>Ez persze nem feltétlen jó megoldás, a submit eseményt ehhez kötjük</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #cssscss data-anchor="cssscss">CSS / SCSS</h3>
  <ul>
    <li>SCSS installálása / használata
      <ol>
        <li>npm install sass --save-dev</li>
        <li>import '../scss/FileName.scss';</li>
      </ol>
    </li>
    <li>JSX-ben definiálhatunk inline stílusokat
      <ol>
        <pre>
  const buttonStyle = &#123;
    backgroundColor: "blue",
    color: "white",
    padding: "10px",
  };
  
  const Button = () => &#123;
    return &#60;button style=&#123;buttonStyle}>Click me&#60;/;button>;
  };
        </pre>
        <pre>
  &#60;button style=&#123; &#123; backgroundColor: "blue", color: "white" }}>Click me&#60;/button>;
        </pre>
      </ol>
    </li>
    <li>Ajánlott fájlstruktúra (lehetséges példa)
      <pre>
  src
  │── assets
  │   └── styles
  │       ├── base.scss         # Alapstílusok (reset, body, alap színek, fontok)
  │       ├── variables.scss    # Globális változók (színek, méretek, fontok)
  │       ├── mixins.scss       # Reusable mixinek, például breakpointok
  │       ├── typography.scss   # Betűstílusok, fejléc méretek
  │       ├── layout.scss       # Globális layout stílusok (grid, flex beállítások)
  |       ├── utilities.scss    # Hasznos helper osztályok (pl. .text-center, .hidden)
  |       ├── components/
  |       │       ├── button.scss    # Egyedi gombok
  |       │       ├── card.scss      # Kártya stílusok
  |       │       ├── modal.scss     # Modal ablak stílusok
  |       ├── pages/
  |       │       ├── home.scss      # Kezdőoldal specifikus stílusok
  |       │       │── about.scss     # Rólunk oldal specifikus stílusok
  │── components
  │   ├── Button
  │   │   ├── Button.js
  │   │   └── Button.module.scss  # Komponens saját stílusa
  │   ├── Card
  │   │   ├── Card.js
  │   │   └── Card.module.scss
  │── pages
  │   ├── Home
  │   │   ├── Home.js
  │   │   └── Home.scss
  │── App.js
  │── App.scss
  │── index.js
  │── index.scss
      </pre>
    </li>
    <li>Az index.scss-ben elhelyezhetjük a CSS reset-et, és az importálásokat</li>
    <pre>
  @import "./assets/styles/base";
  @import "./assets/styles/variables";
  @import "./assets/styles/typography";

  body &#123;
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
  }
    </pre>
  </ul>
  <br>
  <h5 #cssmodule data-anchor="cssmodule">Module</h5>
  <ul>
    <li>Scoped megoldás, vagyis a komponens saját stílusai nem keverednek más komponensekkel</li>
    <li>Használatos, ha az osztályneveket egy adott komponensre szeretnénk csak alkalmazni</li>
    <li>Az osztálynév automatikusan egy egyedi névvé alakul
      <ul>
        <li>Ez biztosítja, hogy más komponensek azonos nevű osztályai ne ütközzenek</li>
      </ul>
    </li>
    <pre>
  <b>// Input.js</b>
  import styles from './Input.module.scss'

  const Input = React.forwardRef((props, ref) => &#123;
    return (
          &#60;>
            &#60;div className=&#123;`input-group mb-3 $&#123;styles.input_container}`}>
              ...
            &#60;/div>
          &#60;/>
        )
      }
    )

  <b>// Input.module.scss</b>
  .input_container &#123;
    box-shadow: 10px 10px 10px 0px rgba(97,97,97,1);
  }

  ↓↓↓↓↓

  &#60;div class="input-group mb-3 Input_input_container__Yx18M">...&#60;/div>
    </pre>
  </ul>
</div>