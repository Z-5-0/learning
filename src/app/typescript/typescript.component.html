<h1>Typescript</h1>

<div class="anchor-navi-container">
  <div *ngFor="let mainButton of anchorButtons" class="btn-group">
    <button type="button" class="btn btn-primary btn-sm anchor" (click)="scrollToAnchor(mainButton?.anchor)">
      {{ mainButton.title }}
    </button>
    <button *ngIf="mainButton?.subtitles?.length" type="button"
      class="btn btn-primary dropdown-toggle dropdown-toggle-split btn-sm anchor" data-bs-toggle="dropdown"
      aria-expanded="false">
    </button>
    <ul *ngIf="mainButton.subtitles?.length" class="dropdown-menu dropdown-menu-dark">
      <li>
        <button *ngFor="let subButton of mainButton?.subtitles" class="dropdown-item"
          (click)="scrollToAnchor(subButton?.anchor)">
          {{ subButton?.title }}
        </button>
      </li>
    </ul>
  </div>
</div>

<div>
  <h3 #ts data-anchor="ts">Typescript</h3>
  <ul>
    <li>Kiegészíti a JavaScript-et</li>
    <li>Statikus típusosságot ad a javascripthez, tehát nem generál a böngésző JS engine-je által értelmezhető
      JS kódot, ha 2 különböző típussal (pl. szám és string) próbálunk meg műveletet (pl. szorzás)
      végrehajtani
    </li>
    <li>npm I -g typescript a compiler telepítése</li>
    <li>tsc --init tsconfig JSON filet- generál, itt a rootDir (src) és a outDir (public/dist) fontos</li>
    <li>Előbbiből utóbbiba compile-ol a typescript</li>
    <li>tsc -w watch-ot eredményez, változáskor/mentéskor javascriptet generál, amire pl html fájlból lehet
      hivatkozni, ilyen módon a typescript compilerrel generált JS fájlt fogunk majd futtatni
    </li>
  </ul>
</div>

<div>
  <h3 #typeinterface data-anchor="typeinterface">Type inference</h3>
  <ul>
    <li>A typescript abból, hogy pl. stringet adunk meg egy változónak, tudja, hogy a változó stringként
      definiált, így nem szükséges külön deklarálni a típusát
    </li>
    <li>Ha eltérünk a típustól, a typescript szól</li>
    <li>Függvények bemeneti paramétereinek típusa is megválasztható, pl function getText(bemenetiParameter:
      string) &#123;&#125; A függvény innentől megköveteli az ilyen típusú (string) paramétert bemenetként
    </li>
    <li>function fuggveny(bemenet: string): number &#123;return 15 string.length&#125; A number pedig a függvény
      kimeneti paramétere
    </li>
    <li>A length-re egyébként le van fektetve, hogy number, így a függvény végén a kimeneti típus tulajdonképpen
      redundáns, így az inference miatt felesleges
    </li>
  </ul>
</div>

<div>
  <h3 #union data-anchor="union">Union type</h3>
  <ul>
    <li>Típusok uniója</li>
    <li>Létre lehet hozni saját típus halmazt (string | number - az összes szám és betű halmaza)</li>
    <li>let valtozo = string | number = "szia" // A változó értéke mindkét halmazból kikerülhet</li>
    <li>A bemeneti érték deklarációjakor is használjuk // function fuggveny(bemenet: string | number) &#123;&#125;</li>
    <li>Ha ugyanígy a bemenet.length-tel térnénk vissza, hibát kapnánk</li>
    <li>typeof clothing.length === 'string' =&gt; false // Szóval a length típusa szám</li>
    <li>Ilyenkor kell narrowing-et (leszűkítés) használni</li>
    <li>Type guard: if (typeof val === "string") &#123;&#125;</li>
    <li>Ellenőrizzük az adott változó típusát</li>
    <pre>
  function fuggveny(bemenet: string | number) &#123;
    if (typeOf(bemenet) === "string") &#123;
            return bemenet.length // string a visszatérési érték
        &#125;
        return bemenet // Ezen a ponton a bemenet nem lehet más, mint number
  &#125;
    </pre>
  </ul>
</div>

<div>
  <h3 #literal data-anchor="literal">Literal type</h3>
  <ul>
    <li>A típus definicióban leszűkítünk mondjuk egy típust bizonyos részhalmazra</li>
    <li>let ertek: 1 | 42 | 3.2 = 42</li>
    <li>Halmazokat uniózunk össze, és ebben az esetben minden szám egy halmaz (1, 42, 3.2)</li>
  </ul>
</div>

<div>
  <h3 #typealias data-anchor="typealias">Type alias</h3>
  <ul>
    <li>Típus megfeleltetés</li>
    <li>Van lehetőségünk egy általunk megalkotott halmazt címkével ellátni, és a címkét referenciaként lehet
      használni
    </li>
    <li>Erre akkor lehet szükség, hogy ha egy típust több helyen akarjuk használni</li>
    <li>type Szamok: 1 | 42 | 3.2</li>
    <li>Innentől használhatók a fentiek így is:</li>
    <li>let ertek: Számok = 42</li>
    <li>function fuggveny(bemenet: Szamok): Szamok &#123;&#125;</li>
    <li>AJAX kérés esetében akár lehet type Status = "Elkezdett" | "Folyamatban..." | "Befejezett"', és akkor
      ennek megfelelő értéket vesz fel pl. egy progress változó (let progress: Status)
    </li>
  </ul>
</div>

<div>
  <h3 #array data-anchor="array">Tömb</h3>
  <ul>
    <li>Annotáció: Módszer, amellyel a változók, függvények és osztályok típusát nyilváníthatjuk ki kódbeli
      megjegyzésként
    </li>
    <pre>
  function calculateTotal(price: number, quantity: number): number &#123;
      return price * quantity;
  &#125;
      </pre>
    <li>A fenti példában a függvénynek két bemeneti paramétere van, amelyek típusát annotációk segítségével
      adjuk meg
    </li>
    <li>let szamok: Array&#60;number&#62; = [];</li>
    <li>Üres Tömb esetében érdemes megadni az Array&#60;number&#62;-t, ha azt mondjuk azt mondjuk, hogy let
      szamok = [42], akkor a Typescript tudni fogja, hogy ez egy számokból álló tömb
    </li>
    <li>Az Array&#60;number&#62; ugyanaz, mint a number[]</li>
  </ul>
</div>

<div>
  <h3 #tuple data-anchor="tuple">Tuple</h3>
  <ul>
    <li>Értéktöbbes</li>
    <li>Olyan tömb, ami típusaiban eltér, és kevés elemből áll</li>
    <li>let szemely: [string, number];</li>
    <li>type Szemely = [string, number] és let szemely1: Szemely = ["Kiss Péter", 25];</li>
    <li>szemely1[1] // Nem más, mint a 25</li>
    <li>A való életben distructuring révén lehet használni</li>
    <li>const [nev, eletkor] = szemely2</li>
    <li>A tuple definíciójához is be lehet építeni címkét, így egyértelművé válik, mit értünk string és number
      alatt
      <ul>
        <li>type Szemely = [nev: string, kor: number]</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #object data-anchor="object">Objektum</h3>
  <ul>
    <li>Ha 2-3 értéknél többünk van, objektumot használunk, nem tuplet</li>
    <pre>
  let album = &#123;
      id: 1,
      userID: 1,
      title: "lorem ipsum"
  &#125;
    </pre>
    <li>Innentől a TS tudni fogja, hogy melyik kulcshoz milyen értéket lehet megadni, szóval csak ilyen
      felépítésű objektumok adhatok meg az album objektumnak
    </li>
    <li>A TS a Structural Typing eljárást követi, tehát a felépítésre figyel</li>
    <li>Type alias készíthető:</li>
    <li>type Album: &#123;id: number, userID: number, title: string, photo: Photo&#125;</li>
    <li>Amikor egy ilyen objektum struktúráját fektetjük le, akkor van lehetőség interfacet létrehozni
      <pre>
  interface Photo: &#123;
    id: number;
    userID: number;
    title: string;
    thumbnailUrl?: string;
  }
    </pre>
    </li>
    <li>A ? azt jelenti, hogy nem kötelező</li>
    <li>Az interface bővíthető, ha leírjuk még egyszer, hogy interface Album2, és adunk neki egy újabb kulcsot,
      a type viszont nem bővíthető
    </li>
  </ul>
</div>

<div>
  <h3 #generictyping data-anchor="generictyping">Generic typing</h3>
  <ul>
    <li>A generikus típusmegadás a TypeScript egyik erőteljes eszköze, amely lehetővé teszi a típusok
      dinamikus, paraméterezett használatát, így rugalmasabb, újrahasznosítható és típusbiztos kódot írhatsz
    </li>
    <li>Generikus típusokat általában akkor használnak, ha egy függvénynek, osztálynak vagy interfésznek többféle
      típuson is működnie kell, de a típusokat előre nem akarod fixálni
    </li>
    <li>A generikus típusmegadás során a típusokat paraméterként adjuk meg a függvényeknek, osztályoknak vagy
      interfészeknek
    </li>
    <li>Ezeket a paramétereket általában T, U, V stb. szimbólumokkal jelöljük, de bármi lehet, ami
      beszédes a kontextusban
    </li>
    <li>Generikus típus előnyei
      <ul>
        <li>Típusbiztonság: A típusok helyessége futásidő előtt ellenőrizhető, csökkentve a hibákat</li>
        <li>Újrahasznosíthatóság: Ugyanazt a kódot több különböző típusra is használhatod, anélkül, hogy új függvényt
          vagy osztályt kellene írnod
        </li>
        <li>Rugalmasság: A generikus típusok lehetővé teszik, hogy a kód különböző típusokkal rugalmasan működjön</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #genericfunctions data-anchor="genericfunctions">Generic functions</h3>
  <ul>
    <li>Egy függvény, amely bármilyen típusú értéket vissza tud adni</li>
    <pre>
  function identity&#60;T>(arg: T): T &#123;
    return arg;
  }

  // Meghívás különböző típusokkal
  let numberValue = identity&#60;number>(42); // numberValue: number
  let stringValue = identity&#60;string>("Hello"); // stringValue: string
      </pre>
    <li>T itt egy generikus típus, amely bármi lehet, amit a függvény meghívásakor átadsz neki</li>
    <li>Ez a függvény bármilyen típusú adatot visszaad, amelyet megkap, de típusbiztosan</li>
  </ul>
</div>

<div>
  <h3 #genericclasses data-anchor="genericclasses">Generic classes</h3>
  <ul>
    <li>Generikus típusú osztály, amely különböző típusokkal is működhet</li>
    <pre>
  class Box&#60;T> &#123;
  content: T;

  constructor(content: T) &#123;
      this.content = content;
  }

  getContent(): T &#123;
      return this.content;
    }
  }

  // Osztály használata különböző típusokkal
  let numberBox = new Box&#60;number>(123); // numberBox.content: number
  let stringBox = new Box&#60;string>("Generics are cool!"); // stringBox.content: string
      </pre>
    <li>A Box&#60;T> osztály különböző típusú adatokat kezel, attól függően, hogy milyen típusú adatot adsz meg a
      példányosításnál
    </li>
  </ul>
</div>

<div>
  <h3 #genericinterface data-anchor="genericinterface">Generic interface</h3>
  <ul>
    <li>Interfészeknél is használhatsz generikus típusokat</li>
    <pre>
  interface Pair&#60;T, U> &#123;
      first: T;
      second: U;
  }

  const pair: Pair&#60;string, number> = &#123; first: "Hello", second: 42 };
    </pre>
    <li>A Pair interfész két különböző típusú értéket (például string és number) tartalmazhat</li>
  </ul>
</div>

<div>
  <h3 #typeassertion data-anchor="typeassertion">Type assertion</h3>
  <ul>
    <li>AJAX kérés indítás</li>
    <pre>
  fetch("https://jsonplaceholder.typicode/albums").then(response => &#123;&#125;)
    </pre>
    <li>A kimeneti adat Promise&#60;Response&#62;</li>
    <li>Promise: Valamilyen típus asszinkron művelet révén kerül a kezünkbe</li>
    <li>Promise-ok esetében az asszinkron adathoz a then()-nel lehet hozzájutni, ahol ténylegesen megkapjuk a
      Response objektumot
    </li>
    <li>Ha a response JSON tartalommal rendelkezik, akkor a json() függvény használatával kiszedhető a válaszból
      az adat
    </li>
    <pre>
  fetch("https://jsonplaceholder.typicode/albums").then(response => &#123;
      return &#60;Promise&#60;Album[]&#62;&#62;response.json();
  &#125;)
  .then(albumok => &#123;
      console.log(albumok);
  &#125;)
    </pre>
    <li>&#60;Promise&#60;Album[]&#62;&#62; Ezt nevezik type assertion-nek</li>
    <li>Kétféle megadási módja van
      <ul>
        <li>&#60;Promise&#60;Album[]&#62;&#62;response.json();</li>
        <li>response.json() as &#60;Promise&#60;Album[]&#62;&#62;</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #promiseandasync data-anchor="promiseandasync">Promise és Async függvény</h3>
  <ul>
    <li>Az async függvények visszatérési típusa Promise</li>
    <pre>
  album.map((album,i) => (&#123;...album&#125;)) // A ... a 'spread operátor'

  album.map((album,i) => (&#123;...album, id.i&#125;)) // Hozzáfűzzük az objektumhoz az id kulcsot, és i, mint index értéket
    </pre>
    <li>A fentieket egy async függvényen belül végezzük el</li>
    <pre>
  async getAlbums() &#123;
      fetch("https://jsonplaceholder.typicode/albums").then(response => &#123;
          return &#60;Promise&#60;Album[]&#62;&#62;response.json();
      &#125;)
  &#125;
    </pre>
    <li>Az async function visszatérési típusa mindig egy Promise (of valami)</li>
    <li>A fenti példában Promise of Album tömb (Promise&#60;Album[]&#62;)</li>
    <li>Mielőtt visszatérnénk vele, be kell kötni a Photo-t is</li>
    <pre>
  async getAlbums() &#123;
      fetch("https://jsonplaceholder.typicode/albums").then(response => &#123;
          return &#60;Promise&#60;Album[]&#62;&#62;response.json();
      &#125;)
  &#125;
      </pre>
    <li>TS fájlban a kód</li>
    <pre>
  async function getAlbums() &#123;
    const allAlbums = await fetch('https://jsonplaceholder.typicode.com/albums')
      .then(response => &#123;
          return response.json() as Promise&#60;Album[]&#62;; // A response-ból json() függvénnyel szedhető ki a JSON adat
              // return &#60;Promise&#60;Album[]&#62;&#62;response.json(); // Mindkettő type assertion
          &#125;)
      .then(albums => &#123; // Az albums már tudja, hogy albumok tömbjével tudunk majd visszatérni
          return albums.slice(0,5).map(async album => &#123;
              album.photos = await fetch(`https://jsonplaceholder.typicode.com/photos/?albumId=$&#123;album.id&#125;`).then(photo => photo.json() as Promise&#60;Photo[]&#62;);
              return album;
          &#125;);
      &#125;);

      return await Promise.all(allAlbums); // Megőrzi a sorrendet, tehát az indexek is maradnak
    &#125;
      </pre>
  </ul>
</div>

<div>
  <h3 #optionalchaining data-anchor="optionalchaining">Optional chaining operátor</h3>
  <ul>
    <li>TS fájlban a kód</li>
    <pre>
  albumContainer.innerHTML = `
      $&#123;albums.map(album => `
          &#60;div&#62;
            &#60;div&#62;
              &#60;span&#62;#$&#123;album.id&#125;&#60;/h4&#62;
                  &#60;span&#62;$&#123;album.title&#125;&#60;/span&#62;
              &#60;/div&#62;

              $&#123;album.photos?.map(photo => `
                  &#60;img src="$&#123;photo.thumbnailUrl&#125;"&#62;
              `).join('')&#125;

            &#60;/br&#62;
          &#60;/div&#62;
    `).join('')&#125;
  `;
    </pre>
    <li>Template literál az aposztróf (`karakterek`) és a benne lévő rész</li>
    <li>A ? neve az optional chaining operátor</li>
    <li>Ha egy adott kulcs nem létezik az adott objektumban, undefined-dal tér vissza, és nem hívja meg a
      mögötte lévő függvényt
    </li>
    <li>Join: A tömb miatt szeparátor karakterek (vessző) jelennének meg, ezt vesszük ki a renderelésből</li>
  </ul>
</div>

<div>
  <h3 #typescriptandrxjs data-anchor="typescriptandrxjs">TypeScript és RxJS</h3>
  <ul>
    <li>Tömb: Reprezentálja, hogy valamelyik másik típusból több van: &#60;Array&#60;T&#62;&#62;</li>
    <li>Promise: Reprezentálja, hogy valamelyik másik típus asszinkron időben érhető el
      &#60;Promise&#60;T&#62;&#62;
    </li>
    <li>Observable: Reprezentálja, hogy sok érték az idő múlásával adatcsomagok formájában érhető el, és
      mindegyik érték ugyanabba a típusba tartozik &#60;Observable&#60;T&#62;&#62;
    </li>
    <li>RxJS:
      <ul>
        <li>Third party library</li>
        <li>ES6 module formájában tudjuk használni (Typescript compiler kevés)</li>
        <li>Praktikusan webpack-et lehet használni, és azon keretein belül használni a typescript compilert
        </li>
        <li>npm i webpack webpack-cli ts-loader --save-dev</li>
        <li>Ennek hatására létrejött a könyvtárstruktúrában:
          <ul>
            <li>node_modules</li>
            <li>package.json</li>
            <li>package-lock.json</li>
          </ul>
        </li>
        <li>A package.json tartalma:
          <ul>
            <pre>
  &#123;
      "devDependencies": &#123;
        "ts-loader": "^9.4.4",
        "webpack": "^5.88.1",
        "webpack-cli": "^5.1.4"
      &#125;
  &#125;
            </pre>
            <li>A package.json-ben indító scripteket lehet létrehozni</li>
            <pre>
  &#123;
  "scripts": &#123;
    "dev": "webpack --mode development --watch"
  &#125;,
  "devDependencies": &#123;
    "ts-loader": "^9.4.4",
      "webpack": "^5.88.1",
      "webpack-cli": "^5.1.4"
    &#125;
  &#125;
            </pre>
            <li>A kulcs (dev) szabadon választható</li>
            <li>A parancs annyit tesz, hogy a webpack induljon el fejleszői üzemmódban, és figyelje a
              fájlrendszert, és minden változtatáskor futtassa a typescript compilert, másrészt
              illessze össze az összes ES6 modult egy darab javascript bundle-é
            </li>
            <li>Létre kell hoznunk a webpack konfig fájlját, hogy a webpack tudja, mit hol kell
              keresnie
            </li>
            <li>A webpack indítása, miután beállítottuk a webpack configot:
              <ul>
                <li>npm run dev</li>
              </ul>
            </li>
            <li>Ha működik, feltelepíthető például az RxJS
              <ul>
                <li>npm i rxjs</li>
                <li>Bekerül a package.json fájlunkba (dependencies)</li>
                <li>Innentől a teljes RxJS eszköztár rendelkezésre áll</li>
                <li>ajax function
                  <ul>
                    <li>import &#123; ajax &#125; from "rxjs/ajax"</li>
                    <li>Hasonló, mint az Angularban használt HTTPClient</li>
                    <li>basic-using-webpack.ts-ben látszik a használata</li>
                    <li>Az Observable-öket $ annotációval szokás ellátni (const albums$),
                      innentől tudjuk, hogy ez egy adatfolyam, amire fel lehet iratkozni
                    </li>
                    <li>Az Observable-ökhöz csőrendszert lehet illeszteni ( .pipe() ).</li>
                    <li>A csőrendszerben használhatjuk az RxJS-es operátorokat (pl.: map())</li>
                  </ul>
                </li>
                <li>A forkJoin ugyanarra jó (csak RxJS), mint a Promise.all(), tehát Observable-ök
                  tömbjét várja, és vissza fog térni egy Observable-lel, és akkor bocsát ki
                  adatot, ha az összes Observable benne complete állapotba futott
                </li>
                <li>A forkJoin bemetene: Array&#60;Observable&#62;</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <pre>
  const albums$ = ajax('https://jsonplaceholder.typicode.com/albums').pipe(
      map(response => (response.response as Album[]).splice(0,5)),
      // map(reduce => reduce.splice(0,5));
      switchMap(albums => forkJoin([
          of(albums),
          ...albums.map(album => ajax(`https://jsonplaceholder.typicode.com/photos/?albumId=$&#123;album.id&#125;`).pipe(
              map(response => &#60;Photo[]&#62;response.response)
          ))
      ])),
      map(([albums, ...allPhotos]) => &#123;
        return albums.map((album, index) => (&#123;...album, photos: allPhotos[index]&#125;))
      &#125;)
  );
    </pre>
    <li>A pipe után külön sorban is végezhetjük a splice-t, de egy sorban is meg lehet oldani</li>
    <li>switchMap-pel összekapcsoljuk az egyes Observable folyamatokat (ajax), a ForkJoin operátor pedig csak
      akkor fut le, ha minden fotó lekérdezésre került
    </li>
    <li>of:
      <ul>
        <li>RxJS operátor, amely létrehoz egy Observable folyamot, amely egyetlen értéket bocsát ki (az of
          operátor paraméterét), majd azonnal befejeződik (successful)
        </li>
        <li>Vesszővel elválasztva több érték is megadható egymás után, mint of paraméter</li>
        <li>Observable sorozatok előállításakor hasznos</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #promisevsobservable data-anchor="promisevsobservable">Promise vs Observable</h3>
  <ul>
    <li>Promise
      <ul>
        <li>Aszinkron műveletek végrehajtására való</li>
        <li>Csak egyszeri értéket ad vissza, amikor az Aszinkron művelet befejeződik, vagy hibára fut
          (reject / resolve)
        </li>
        <li>Csak két állapota lehet: teljesült és elutasított</li>
        <li>Létrejötte után azonnal megkezdi a működését, és ereményt, vagy hibát ad vissza</li>
        <li>Nem használhatók műveletek</li>
        <li>Nem lehet róla leiratkozni, akkor is lefur, ha esetleg már nincs rá szükség</li>
      </ul>
    </li>
    <li>Observable
      <ul>
        <li>Aszinkron műveletek végrehajtására való</li>
        <li>Több értéket képes visszaadni az idő múlásával</li>
        <li>Használható akkor is, ha az adatfolyam folyamatosan változik</li>
        <li>Lehetővé teszi az adatok kombinálását, transzformálását, szűrését</li>
        <li>subscribe() függvénnyel feliratkozva kapjuk meg az adatokat (le is kell iratkozni: unsubscribe()
          ), addig le sem fut (ezért lazy-nel is nevezik)
        </li>
        <li>Rugalmasabb a Promise-nál (gyakrabban használatos)</li>
        <li>Az operátorok segítségével műveletek lánca hozható létre, mielőtt megkapnánk az adatokat</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #albumswithpromise data-anchor="albumswithpromise">Albumok kirenderelése (Promise megoldással)</h3>
  <ul>
  <pre>
  &#60;div id="renderedAlbums"&#62;&#60;/div&#62;

  ngOnInit() &#123;
    this.PromiseSolution();
  &#125;

  async PromiseSolution() &#123;
    this.albums = await this.getAlbums();
    this.albumsAlter = await this.getAlbumsAlter();
    this.rendererFromPromise(this.albums);
  &#125;

  async getAlbums(): Promise&#60;Album[]&#62; &#123;
    const allAlbums = await fetch('https://jsonplaceholder.typicode.com/albums')
      .then(response => &#123;
        return response.json() as Promise&#60;Album[]&#62;; // A response-ból json() függvénnyel szedhető ki a JSON adat
        // return &#60;Promise&#60;Album[]&#62;&#62;response.json(); // Mindkettő type assertion
      &#125;)
      .then(albums => &#123; // Az albums már tudja, hogy albumok tömbjével tudunk majd visszatérni
        return albums.slice(0, 5).map(async album => &#123;
        album.photos = await fetch(`https://jsonplaceholder.typicode.com/photos/?albumId=$&#123;album.id&#125;`).then(photo => photo.json() as Promise&#60;Photo[]&#62;);
          return album;
        &#125;);
      &#125;);

    return await Promise.all(allAlbums); // Megőrzi a sorrendet, tehát az indexek is maradnak
  &#125;
  </pre>
  </ul>
  <div id="renderedAlbums" style="max-height: 250px;overflow-y: auto;"></div>
</div>

<div>
  <h3 #albumswithobservable data-anchor="albumswithobservable">Albumok kirenderelése 2 (Observable megoldással)</h3>
  <ul>
  <pre>
  &#60;div id="renderedAlbumsWithObservable"&#62;&#60;/div&#62;

  ngOnInit() &#123;
    this.ObservableSolution();
  &#125;

  ObservableSolution() &#123;
  this.albums$ = ajax('https://jsonplaceholder.typicode.com/albums').pipe(
      map(response => (response.response as Album[]).splice(0, 5)), // A lenti map az itteni splice-szal egyenértékű
      // map(reduce => reduce.splice(0,5))
      switchMap(albums => forkJoin([ // switchMap-pel összekapcsoljuk az egyes Observable folyamatokat (ajax), a ForkJoin operátor pedig csak akkor fut le, ha minden fotó lekérdezésre került
        of(albums), // Olyan observable lesz belőle, ami azonnal kibocsát adatcsomagot successful állapotban
        ...albums.map(album => ajax(`https://jsonplaceholder.typicode.com/photos/?albumId=$&#123;album.id&#125;`).pipe(
      map(response => &#60;Photo[]&#62;response.response)
      ))
    ])),
      map(([albums, ...allPhotos]) => &#123;
        return albums.map((album, index) => (&#123; ...album, photos: allPhotos[index] &#125;))
      &#125;)
    );

    this.albums$.subscribe(data => &#123;
      console.log('Obserable eredménye: ', data);
      this.rendererFromObservable(data);
    &#125;)
  &#125;

  rendererFromObservable(albums: Album[]) &#123;
        const albumContainer = document.getElementById('renderedAlbumsWithObservable');

        if (!albumContainer) &#123; // Narrowing technika
      return;
    &#125;

    albumContainer.innerHTML = `
        $&#123;albums.map(album => `
            &#60;div&#62;
                &#60;div&#62;
                    &#60;span&#62;#$&#123;album.id&#125;&#60;/h4&#62;
      &#60;span&#62;$&#123;album.title&#125;&#60;/span&#62;
                &#60;/div&#62;

                $&#123;album.photos?.map(photo => `
                &#60;img src="$&#123;photo.thumbnailUrl&#125;"&#62;
                `).join('')&#125;
              &#60;/br&#62;
            &#60;/div&#62;
        `).join('')&#125;
    `;
  &#125;
  </pre>
  </ul>
  <div id="renderedAlbumsWithObservable" style="max-height: 250px;overflow-y: auto;"></div>
</div>