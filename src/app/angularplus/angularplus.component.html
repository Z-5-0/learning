<h1>Angular+</h1>

<div class="anchor-navi-container">
  <div *ngFor="let mainButton of anchorButtons" class="btn-group">
    <button type="button" class="btn btn-primary btn-sm anchor" (click)="scrollToAnchor(mainButton?.anchor)">
      {{ mainButton.title }}
    </button>
    <button *ngIf="mainButton?.subtitles?.length" type="button"
      class="btn btn-primary dropdown-toggle dropdown-toggle-split btn-sm anchor" data-bs-toggle="dropdown"
      aria-expanded="false">
    </button>
    <ul *ngIf="mainButton.subtitles?.length" class="dropdown-menu dropdown-menu-dark">
      <li>
        <button *ngFor="let subButton of mainButton?.subtitles" class="dropdown-item"
          (click)="scrollToAnchor(subButton?.anchor)">
          {{ subButton?.title }}
        </button>
      </li>
    </ul>
  </div>
</div>

<div>
  <h3 #scrollpositionrestoration data-anchor="scrollpositionrestoration">scrollPositionRestoration</h3>
  <ul>
    <li>Navigálás közben, ha nem akarjuk, hogy minden oldalon az oldal tetejére ugorjunk, akkor az
      app-routingmodulets
      fájlban szükséges a scrollPositionRestoration: 'enabled'-re állítani
      <ul>
        <li>
          <pre>
            @NgModule(&#123;
              imports: [RouterModuleforRoot(routes, &#123;
                scrollPositionRestoration: 'enabled'
              &#125;)],
              exports: [RouterModule]
            &#125;)
          </pre>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #dependencyinjection data-anchor="dependencyinjection">Dependency Injection (private/public/protected)</h3>
  <ul>
    <li>Külső forrásból injektált objektum, amit az osztály használni tud</li>
    <li>private/public/protected
      <ul>
        <li>private
          <ul>
            <li>Az injektált szolgáltatás csak az osztályon belül érhető el</li>
            <li>Osztályon kívül, pl más osztályban, vagy a sablonban (html) nem elérhető</li>
          </ul>
        </li>
        <li>public
          <ul>
            <li>Az injektált szolgáltatás nem csak az osztályon belül érhető el</li>
            <li>Osztályon kívül, pl más osztályban, vagy a sablonban (html) is elérhető</li>
          </ul>
        </li>
        <li>protected
          <ul>
            <li>Az injektált szolgáltatás az osztályon belül és az osztály leszármazottai (al-osztályok) számára
              érhető el
            </li>
            <li>A sablonban (html), és más, nem leszármazott osztályokban nem elérhető</li>
            <pre>
                  export class DerivedComponent extends BaseComponent implements OnInit &#123;
                  serviceMessage: string;

                  ngOnInit() &#123;
                      thisserviceMessage = thisgetServiceMessage();
                    &#125;
                  &#125;
                </pre>
          </ul>
        </li>
        <li>A fentieket egyébként access modifier-nek hívják</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #modulewithrouting data-anchor="modulewithrouting">Create module with routing</h3>
  <ul>
    <li>ng g m module-name --routing</li>
    <li>Route in parent module
      <ul>
        <li>
          <pre>
                &#123;
                  path: 'spa',
                  loadChildren: () => import('/single-page-app/single-page-appmodule')then(m => mSinglePageAppModule)
                &#125;,
              </pre>
        </li>
      </ul>
    </li>
    <li>Route in new module
      <ul>
        <li>
          <pre>
                const routes: Routes = [
                  &#123;path: '', component: SinglePageAppComponent&#125;,
                ];
              </pre>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #functioninputoutputtypes data-anchor="functioninputoutputtypes">Function input-output type declaration</h3>
  <ul>
    <li>
      <pre>
        scroll(target: HTMLElement): any &#123; // A zárójelben a bemeneti típus, utána a visszatérési érték típusa
          consolelog(target);
          return targetscrollIntoView(&#123;behavior: 'smooth'});
        }
      </pre>
    </li>
  </ul>
</div>

<div>
  <h3 #ngiffunctioncall data-anchor="ngiffunctioncall">ngIf function call</h3>
  <ul>
    <li>Ha feltételben meghívunk egy függvényt, aminek van visszatérési értéke, akkor az 'as &#60;variable> opcióval
      kiírhatjuk a visszatérési értéket, értékeket
      <pre>
        &#60;div *ngIf="testFunction('ABC', '123') as obj">
          &#123; &#123; objvariable1 }} / &#123; &#123; objvariable2 }}
        &#60;/div>

        testFunction(variable1: string, variable2: string) &#123;
          return &#123;variable1, variable2};
        }
      </pre>
    </li>
    <li></li>
  </ul>
</div>

<div>
  <h3 #trackby data-anchor="trackby">TrackBy</h3>
  <ul>
    <li>A trackBy használatának célja, hogy Angular hatékonyabban kezelje a DOM elemeket, amikor a lista változik</li>
    <li>Ha nem használunk trackBy-t, Angular újra rendereli az összes elemet, amikor a lista változik</li>
    <li>trackBy segítségével Angular nyomon követheti, hogy mely elemek változtak, így csak a ténylegesen változott
      elemeket rendereli újra
    </li>
    <pre>
      &#60;div *ngFor="let phoneNumber of phoneNumbers; trackBy: tracker">

      &#60;/div>

      constructor() &#123;

        tracker = (index: number, item: string) => index;
      }
    </pre>
    <li>Az indexet adja vissza</li>
    <li>TODO</li>
  </ul>
</div>

<div>
  <h3 #ngswitchnote data-anchor="ngswitchnote">ngSwitch note</h3>
  <ul>
    <li>Amennyiben az ngSwitch attribútum direktívának nem boolean mezőt adunk, úgy a lenti (helyes) működéshez át kell
      alakítanunk boolean értékre:
    </li>
    <pre>
      &#60;div [ngSwitch]="!!hasText">
        &#60;div *ngSwitchCase="true">
          A változó tartalmaz szöveget
        &#60;/div>
        &#60;div *ngSwitchCase="false">
          A változó nem tartalmaz szöveget
        &#60;/div>
      &#60;/div>
    </pre>
  </ul>
</div>

<div>
  <h3 #prtoceduralvsreactivethinking data-anchor="prtoceduralvsreactivethinking">Procedural vs reactive thinking</h3>
  <div
    style="background-color: floralwhite; border: 2px solid saddlebrown; border-radius: 5px;color: black; padding: 10px; overflow: auto">
    <small>Procedural</small>
    <ng-container>
      <div *ngIf="isLoading; else list"
        style="background-color: rgba(100, 100, 100, 0.5);display: flex;align-items: center;justify-content: center">
        LOADING
      </div>
      <ng-template #list>
        <div style="display: flex; align-items: center; gap: 20px; justify-content: space-between">
          <h4 *ngIf="elems.length > 0; else noElems">{{ elems.length }} elem(s) exist(s)</h4>
          <span>
            <button [disabled]="elemLocalDeletion" (click)="elemLocalDeletion = !elemLocalDeletion">
              Local delete
            </button>
            <button [disabled]="!elemLocalDeletion" (click)="elemLocalDeletion = !elemLocalDeletion">
              API delete
            </button>
          </span>
        </div>

        <div *ngFor=" let elem of elems; let last=last; let i=index" style="display: flex;gap: 10px;">
          <span>
            {{ i + 1 }}. {{ elem }}
          </span>
          <span class="trash" (click)="elemLocalDeletion ? removeElem(i) : removeAPIelem(i)"></span>
          <hr *ngIf="!last">
        </div>

        <form *ngIf="elems.length < 5; else elemsLengthReachedMax"
          (submit)="elemLocalDeletion ? newElem($event) : newAPIElem($event)">
          <input #formInput name="title" value="" ngModel placeholder="New elem">
          <button type="submit" [disabled]="formInput.value === ''">Send</button>
        </form>

      </ng-template>
    </ng-container>
  </div>

  <ng-template #elemsLengthReachedMax>
    <h5>Max length of elems reached!</h5>
  </ng-template>

  <ng-template #noElems>
    <h4>Create an elem!</h4>
  </ng-template>

  <br>

  <!--ng-container *ngIf="isLoadingReactive$ | async as isLoadingReactive"-->
  <div *ngIf="elemsReactive$ | async as elemsReactive"
    style="background-color: floralwhite; border: 2px solid saddlebrown; border-radius: 5px;color: black; padding: 10px; overflow: auto">
    <small>Reactive</small>
    <ng-container *ngIf="isLoadingReactive$ | async; else listAlt">
      <div style="background-color: rgba(100, 100, 100, 0.5);display: flex;align-items: center;justify-content: center">
        LOADING
      </div>
    </ng-container>

    <ng-template #listAlt>
      <div style="display: flex; align-items: center; gap: 20px; justify-content: space-between">
        <h4 *ngIf="elemsReactive.length > 0; else noElemsReactive">
          {{ elemsReactive.length }} elem(s) exist(s)
        </h4>
        <span>
          <button [disabled]="true">
            API delete
          </button>
        </span>
      </div>

      <div *ngFor="let elem of elemsReactive; let last=last; let i=index" style="display: flex;gap: 10px;">
        <span>
          {{ i + 1 }}. {{ elem }}
        </span>
        <span class="trash" (click)="removeElemReactive(i)"></span>
        <hr *ngIf="!last">
      </div>

      <form *ngIf="elems.length < 5; else elemsLengthReachedMaxReactive" (submit)="newElemReactive($event)">
        <input #formInput name="title" value="" ngModel placeholder="New elem">
        <button type="submit" [disabled]="formInput.value === ''">Send</button>
      </form>
    </ng-template>
  </div>
  <!--/ng-container-->

  <ng-template #elemsLengthReachedMaxReactive>
    <h5>Max length of elems reached!</h5>
  </ng-template>

  <ng-template #noElemsReactive>
    <h4>Create an elem!</h4>
  </ng-template>

  <br>

  <h5>Procedural</h5>
  <pre>
  &#60;ng-container>
    &#60;div *ngIf="isLoading; else list">
      LOADING
    &#60;/div>

    &#60;ng-template #list>
      &#60;div>
        &#60;h4 *ngIf="elems.length > 0; else noElems">&#123; &#123; elems.length }} elem(s) exist(s)&#60;/h4>
        &#60;span>
          &#60;button [disabled]="elemLocalDeletion" (click)="elemLocalDeletion = !elemLocalDeletion">
            Local delete
          &#60;/button>
          &#60;button [disabled]="!elemLocalDeletion" (click)="elemLocalDeletion = !elemLocalDeletion">
            API delete
          &#60;/button>
        &#60;/span>
      &#60;/div>

      &#60;div *ngFor=" let elem of elems; let last=last; let i=index" style="display: flex;gap: 10px;">
        &#60;span>
          &#123; &#123; i + 1 }}. &#123; &#123; elem }}
        &#60;/span>
        &#60;span class="trash" (click)="elemLocalDeletion ? removeElem(i) : removeAPIelem(i)">&#60;/span>
        &#60;hr *ngIf="!last">
      &#60;/div>

      &#60;form *ngIf="elems.length &#60; 5; else elemsLengthReachedMax"
        (submit)="elemLocalDeletion ? newElem($event) : newAPIElem($event)">
        &#60;input #formInput name="title" value="" ngModel placeholder="New elem">
        &#60;button type="submit" [disabled]="formInput.value === ''">Send&#60;/button>
      &#60;/form>
    &#60;/ng-template>

  &#60;/ng-container>

  &#60;ng-template #elemsLengthReachedMaxReactive>
    &#60;h5>Max length of elems reached!&#60;/h5>
  &#60;/ng-template>

  &#60;ng-template #noElemsReactive>
    &#60;h4>Create an elem!&#60;/h4>
  &#60;/ng-template>

  elems: string[] = [];

  ngOnInit() &#123;
    this.getContent();
  }

  getContent() &#123;
    this.isLoading = true;
    fetch('https://kodbazis.hu/api/cimek')
      .then(res => res)
      .then(data => &#123;
        console.log(data);
        return data.json();
      })
      .then(content => &#123;
        console.log(content);
        this.elems = content;
      })
      .catch(error => &#123;
        console.error('Hiba történt:', error);
      })
      .finally(() => &#123;
        this.isLoading = false;
      });
  }

  newElem(event: any) &#123;
    event.preventDefault();
    console.log(event.target.elements.title.value);
    const newElem = event.target.elements.title.value;
    this.elems.push(newElem);
    event.target.reset();
  }

  newAPIElem(event: any) &#123;
    event.preventDefault();
    this.isLoading = true;
    console.log(event.target.elements.title.value);
    const newElem = event.target.elements.title.value;
    fetch('https://kodbazis.hu/api/cimek', &#123;
      method: 'POST',
      body: JSON.stringify(&#123;cim: (newElem)})
    })
      .then(() => &#123;
        this.getContent();
      });
    event.target.reset();
  }

  removeElem(index: number) &#123;
    this.elems.splice(index, 1);
  }

  removeAPIelem(index: number) &#123;
    this.isLoading = true;
    fetch('https://kodbazis.hu/api/cimek/' + index, &#123;method: 'DELETE'})
      .then(() => &#123;
        this.getContent();
      });
  }
</pre>

  <br>

  <h5>Reaktív</h5>
  <pre>
  &#60;div *ngIf="elemsReactive$ | async as elemsReactive">
    &#60;small>REAKTÍV&#60;/small>
    &#60;ng-container *ngIf="isLoadingReactive$ | async; else listAlt">
      &#60;div>
        LOADING
      &#60;/div>
    &#60;/ng-container>

    &#60;ng-template #listAlt>
      &#60;div>
        &#60;h4 *ngIf="elemsReactive.length > 0; else noElemsReactive">
          &#123; &#123; elemsReactive.length }} elem(s) exist(s)
        &#60;/h4>
        &#60;span>
          &#60;button [disabled]="true">
            API delete
          &#60;/button>
        &#60;/span>
      &#60;/div>

      &#60;div *ngFor="let elem of elemsReactive; let last=last; let i=index">
        &#60;span>
          &#123; &#123; i + 1 }}. &#123; &#123; elem }}
        &#60;/span>
        &#60;span class="trash" (click)="removeElemReactive(i)">&#60;/span>
        &#60;hr *ngIf="!last">
      &#60;/div>

      &#60;form *ngIf="elems.length &#60; 5; else elemsLengthReachedMaxReactive" (submit)="newElemReactive($event)">
        &#60;input #formInput name="title" value="" ngModel placeholder="New elem">
        &#60;button type="submit" [disabled]="formInput.value === ''">Send&#60;/button>
      &#60;/form>
    &#60;/ng-template>
  &#60;/div>

  &#60;ng-template #elemsLengthReachedMaxReactive>
    &#60;h5>Max length of elems reached!&#60;/h5>
  &#60;/ng-template>

  &#60;ng-template #noElemsReactive>
    &#60;h4>Create an elem!&#60;/h4>
  &#60;/ng-template>

  isLoadingReactive$ = new BehaviorSubject&#60;boolean>(true);

  refresh$ = new Subject().pipe(
    tap(() => &#123;
      this.isLoadingReactive$.next(true);
    }),
    switchMap(() => this.http.get('https://kodbazis.hu/api/cimek')),
    catchError((err) => of([])),
    tap((response) => &#123;
      this.isLoadingReactive$.next(false);
      this.elemsReactive$.next(response as string[]);
      console.log('http: ', response);
    })
  );

  delete$ = new Subject().pipe(
    tap(() => &#123;
      this.isLoadingReactive$.next(true);
    }),
    switchMap(index => this.http.delete(`https://kodbazis.hu/api/cimek/$&#123;index}`)),
    tap(() => &#123;
        // @ts-ignore
        this.refresh$.next("");
      }
    )
  );

  create$ = new Subject().pipe(
    tap(() => &#123;
      this.isLoadingReactive$.next(true);
    }),
    switchMap((input) => this.http.post(`https://kodbazis.hu/api/cimek`, &#123;cim: input})),
    tap(() => &#123;
        // @ts-ignore
        this.refresh$.next("");
      }
    )
  )

  subscriptions: Subscription[] = [];

  ngAfterViewInit() &#123; // ngOnInit helyett
    const refreshSub = this.refresh$.subscribe();
    const deleteSub = this.delete$.subscribe();
    const createSub = this.create$.subscribe();
    this.subscriptions = [...this.subscriptions, refreshSub, deleteSub, createSub];
    // @ts-ignore
    this.refresh$.next();
  }

  removeElemReactive(index: number) &#123;
    // @ts-ignore
    this.delete$.next(index);
  }

  newElemReactive(e: any) &#123;
    e.preventDefault();
    const newValue = e.target.elements.title.value;
    // @ts-ignore
    this.create$.next(newValue);
  }

  ngOnDestroy() &#123;
    for (let subscription of this.subscriptions) &#123;
      subscription.unsubscribe();
    }
  }
</pre>
</div>

<div>
  <h3 #locale data-anchor="locale">Locale</h3>
  <ul>
    <pre>
      <b>// settings.service.ts</b>
      @Injectable(&#123;
        providedIn: 'root'
      })
      export class SettingsService &#123;
      
          setLocale(language: string) &#123;
              localStorage.setItem('language', language);
              window.location.reload();
          }
      
          getLocale(): string &#123;
              return localStorage.getItem('language') || 'hu-HU';
          }
      }

      <b>// app.module.ts</b>
      import localeHu from '@angular/common/locales/hu';

      registerLocaleData(localeHu);

      @NgModule(&#123;
        ...
        providers: [
        &#123;
            provide: LOCALE_ID,
            deps: [SettingsService],
            useFactory: (settingsService: SettingsService) => settingsService.getLocale()
          }
        ],
      })
    </pre>
    <li>A LOCALE_ID-val központi locale-t állíthatunk be az egész alkalmazásra
      <ul>
        <li>Lokalizációs azonosító, ami a formátumok (dátum, számok, pénznemek stb.) helyi szabványainak beállítására
          szolgál az alkalmazás szintjén.</li>
        <li>A LOCALE_ID használatával az Angular megérti, hogy milyen lokalizációs beállításokat alkalmazzon az egész
          alkalmazásban</li>
        <li>a különböző formátumokat, például dátumokat, számokat és pénznemeket az adott LOCALE_ID alapján állítja be,
          és az Angular pipe-ok(DatePipe, CurrencyPipe, stb.) automatikusan a megadott locale-nak megfelelő formátumot
          fogják használni.</li>
      </ul>
    </li>
    <li>A fenti példakódban egy szolgáltatáson keresztül határozzuk meg a locale értékét</li>
    <li>Locale frissítéséhez újra kell tölteni az alkalmazást</li>
    <li>Akkor érdemes használni, ha többnyelvű alkalmazást fejlesztünk
      <ul>
        <li>Vagy mondjuk csak simán a saját lokációnkra szeretnénk szabni a formázásokat</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #restandspreadoperator data-anchor="restandspreadoperator">Rest operator</h3>
  <ul>
    <li>Ugyanúgy a ... szintaxissal használjuk őket, de eltérő módon</li>
    <li>Rest operator
      <ul>
        <li>A rest operátor (...) több értéket gyűjt össze egyetlen tömbbe vagy objektumba
          <ul>
            <li>Egy függvénynek több paramétert adunk át, illetve amikor egy objektum vagy tömb elemeit szeretnénk egy
              egységes struktúrába foglalni</li>
            <li>Különösen akkor hasznos, ha nem tudjuk előre a paraméterek számát, vagy csak bizonyos elemeket akarunk
              kiválasztani egy összetettebb struktúrából</li>
          </ul>
        </li>
        <li>A rest operátort gyakran használják függvények paraméterlistájában, ahol a paraméterek fennmaradó részét egy
          tömbbe gyűjti össze</li>
        <pre>
          function sum(...numbers) &#123;
            return numbers.reduce((total, num) => total + num, 0);
          }
          
          console.log(sum(1, 2, 3, 4)); // 10      
        </pre>
        <li>A rest operátorral objektumok és tömbök részeit különválaszthatjuk egy változónak, míg a többi elemet egy
          másik
          változóban gyűjtjük össze</li>
        <pre>
          <b>// object</b>
          const person = &#123; name: "Alice", age: 30, city: "Paris" };
          const &#123; name, ...rest } = person;
    
          console.log(name); // "Alice"
          console.log(rest); // &#123; age: 30, city: "Paris" }
    
          <b>// array</b>
          const numbers = [1, 2, 3, 4, 5];
          const [first, second, ...rest] = numbers;
    
          console.log(first);  // 1
          console.log(second); // 2
          console.log(rest);   // [3, 4, 5]
        </pre>
      </ul>
    </li>
    <li>Spread operator
      <ul>
        <li>Egy tömb vagy objektum elemeinek kiterjesztésére szolgál
          <ul>
            <li>egyes elemeket különálló elemekként "teríti ki"</li>
          </ul>
        </li>
        <li>Másolatok készítéséhez, elemek összefűzéséhez használjuk</li>
        <pre>
          <b>// tömb egyesítés</b>
          const array1 = [1, 2];
          const array2 = [3, 4];
          const combined = [...array1, ...array2];
          console.log(combined); // [1, 2, 3, 4]

          <b>// objektum másolás és egyesítés</b>
          const obj1 = &#123; a: 1, b: 2 };
          const obj2 = &#123; c: 3 };
          const combinedObj = &#123; ...obj1, ...obj2 };
          console.log(combinedObj); // &#123; a: 1, b: 2, c: 3 }
        </pre>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #shallowanddeepcopy data-anchor="shallowanddeepcopy">Shallow and deep copy</h3>
  <ul>
    <li>Objektumok másolásának két különböző módja, amelyek abban különböznek, hogy milyen mélységig másolják le az
      objektum struktúráját és annak beágyazott elemeit
      <ul>
        <li>A tömbök is objektumok JavaScript-ben</li>
      </ul>
    </li>
  </ul>
  <ol>
    <li>Shallow copy
      <ul>
        <li>Egy objektum első szintjét másolja le, de nem hoz létre külön példányokat a beágyazott objektumokról vagy
          tömbökről
          <ul>
            <li>Az eredeti objektum és a másolat is ugyanazokra a beágyazott objektumokra mutat</li>
            <li>Ha a beágyazott objektumokat vagy tömböket módosítjuk, akkor ezek a változások mind az eredeti, mind a
              másolatban megjelennek</li>
          </ul>
        </li>
        <li>Az Object.assign() metódus, illetve a spread operátor (...), amikor csak az első szinten történik másolás
        </li>
        <pre>
          const original = &#123; a: 1, b: &#123; c: 2 } };
          const shallowCopy = &#123; ...original };

          shallowCopy.b.c = 3;
          console.log(original.b.c); // 3, mert a másolatban lévő `b` objektum az eredetire mutat
        </pre>
      </ul>
    </li>
    <li>Deep copy
      <ul>
        <li>Az objektum minden szintjét lemásolja, tehát az eredeti objektumtól független, teljesen új példányokat hoz
          létre minden beágyazott objektumról és tömbről is
          <ul>
            <li>Az eredeti és a másolat egymástól teljesen függetlenek lesznek, így a másolat módosítása nem fogja
              befolyásolni az eredeti objektumot</li>
          </ul>
        </li>
        <li>Használhatjuk a structuredClone() metódust, illetve könyvtárakat, mint például a lodash (cloneDeep
          metódus)</li>
        <li>Alternatívaként JSON-alapú deep copy is használható</li>
        <pre>
          const original = &#123; a: 1, b: &#123; c: 2 } };
          const deepCopy = JSON.parse(JSON.stringify(original)); // JSON-alapú deep copy

          deepCopy.b.c = 3;
          console.log(original.b.c); // 2, mert a deep copy független másolatot hozott létre
        </pre>
      </ul>
    </li>
  </ol>
  <ul>
    <li>Ha csak egy egyszerű, nem beágyazott objektumot másolunk, a shallow copy általában elegendő</li>
  </ul>
</div>

<div>
  <h3 #datamodel data-anchor="datamodel">Data model</h3>
  <ul>
    <li>Az alábbi két class lényegében ugyanaz
      <ul>
        <li>Mindkettő ugyanazokat a mezőket és konstruktorparamétereket definiálja</li>
      </ul>
    </li>
    <pre>
      <b>// Class 1</b>
      export class Task &#123;
        name: string = '';
        description: string = '';
        user: string = '';
        date: string = '';
        priority: string = '';
        status: string = '';
    
        constructor(name: string, description: string, user: string, date: string, priority: string, status: string) &#123;
            this.name = name;
            this.description = description;
            this.user = user;
            this.date = date;
            this.priority = priority;
            this.status = status;
        }
      }

      <b>// Class 2</b>
      export class Task &#123;
        constructor(
            public name: string,
            public description: string,
            public user: string,
            public date: string,
            public priority: string,
            public status: string
        ) &#123;}
      }
    </pre>
    <li>Class 1
      <ul>
        <li>Külön deklarálja a property-ket az osztályon belül</li>
        <li>A property-k alapértelmezett értékeket kapnak (üres string), mielőtt a konstruktorban felülírnánk őket</li>
        <li>Hosszabb, de explicitebb, könnyebben érthető</li>
        <li>Amennyiben szükséges alapértelmezett deklaráció, ezt érdemes használni</li>
      </ul>
    </li>
    <li>Class 2
      <ul>
        <li>A public módosítóval a konstruktor paraméterei automatikusan az osztály property-jeivé válnak</li>
        <li>Rövidebb</li>
        <li>Kevésbé részletes, de kompaktabb, elegánsabb</li>
        <li>Amennyiben nem szükséges alapértelmezett deklaráció, ezt érdemes használni</li>
      </ul>
    </li>
    <li>Az osztály egyszerre szolgál típusként, és példányosítható konstrukcióként, az interfészt kizárólag
      típusdefinícióként használjuk
      <ul>
        <li>Objektumokat hozhatunk létre a new kulcsszóval</li>
        <pre>
          const newTask = new Task(
            'Example Task',
            'This is a description.',
            'John Doe',
            '2024-12-01',
            'high',
            'open'
          )
        </pre>
        <li>Típusellenőrzésre is alkalmazható</li>
        <pre>
          printTask(task: Task): void &#123;
            console.log(task.name);
          }
        </pre>
      </ul>
    </li>
    <li>Az interfészt csak típusdefinícióra használjuk
      <ul>
        <li>Nem példányosítható</li>
        <pre>
          interface Task &#123;
            name: string;
            description: string;
            user: string;
            date: string;
            priority: string;
            status: string;
          }

          function printTask(task: Task): void &#123;
            console.log(task.name);
          }
        </pre>
      </ul>
    </li>
    <li>Lehetőség szerint ne használjunk osztály abban az esetben, ha csak típusdefinícióra van szükségünk
      <ul>
        <li>A TypeScript fordító a JavaScript kimenetbe belegenerálja az osztályt</li>
        <li>Interfész használatakor viszont ez nem történik meg</li>
      </ul>
    </li>
    <li>Opcionális definiálhatóság</li>
    <pre>
      <b>// class</b>
      export class Task &#123;
        constructor(
            public name: string,
            public description: string,
            public user: string,
            public date: string,
            public priority: string,
            public status: string,
            public id?: string) &#123; // az id opcionális
        }
    }

    // Új példány létrehozása:
    const task1 = new Task('New Task', 'This is a description', 'John Doe', '2024-12-01', 'high', 'open');
    const task2 = new Task('Another Task', 'Another description', 'Jane Doe', '2024-12-02', 'medium', 'in progress', '12345');

    <b>// interface</b>
    export interface Task &#123;
        id?: string; // opcionális
        name: string;
        description: string;
        user: string;
        date: string;
        priority: string;
        status: string;
      }
    </pre>
  </ul>
</div>

<div>
  <h3 #environment data-anchor="environment">Environment</h3>
  <ul>
    <li>TODO</li>
  </ul>
</div>

<div>
  <h3 #authenticationandauthorization data-anchor="authenticationandauthorization">Authentication & authorization</h3>
  <ul>
    <li>Authentication
      <ul>
        <li>Hitelesítés</li>
        <li>Ellenőrzése, hogy valaki valóban az, akinek mondja magát</li>
        <li>Az első lépés egy rendszerhez való hozzáférés biztosításakor</li>
        <li>Pl. bejelentkezés egy weboldalra felhasználónévvel, és jelszóval</li>
      </ul>
    </li>
    <li>Authorization
      <ul>
        <li>Engedélyezés</li>
        <li>Célja annak meghatározása, hogy egy hitelesített felhasználónak milyen jogosultságai vannak az adott
          rendszerben</li>
        <li>Pl. a felhasználó hozzáférhet bizonyos oldalakhoz, másokhoz pedig nem</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #throwerror data-anchor="throwerror">throwError</h3>
  <ul>
    <pre>
      API.CALL
      .pipe(
        catchError((err) => &#123;
          return throwError(() => 'Email address already registered.');
        })
      );

      FUNCTION.CALL
      .subscribe(&#123;
        next: (val) => &#123; },
        error: (err) => &#123;
          console.log(err); // Email address already registered.
        }
      });
    </pre>
    <li>Közvetlenül egy string-et vagy más típusú értéket ad vissza</li>
    <li>Abban az esetben jő megoldás, ha pl. stringet szeretnénk feldoolgozni</li>
    <pre>
      API.CALL
      .pipe(
        catchError((err) => &#123;
          return throwError(() => new Error('Email address already registered.'));
        })
      );

      FUNCTION.CALL
      .subscribe(&#123;
        next: (val) => &#123; },
        error: (err) => &#123;
          console.log(err); // Error: Email address already registered. at auth-firebase.service.ts:46:34
          console.log(err.message); // Email address already registered.
        }
      });
    </pre>
    <li>Error objektumot hoz létre, amiben van egy message kulcs is</li>
    <li>szabványosabb megoldás JavaScript-ben/TypeScript-ben, különösen akkor, ha a hiba továbbadása során az Error
      objektumok mezőit (pl. name, stack, vagy message) szeretnénk használni</li>
    <li>Az Error objektum segít az egyértelmű hibakezelésben, különösen komplex alkalmazásokban</li>
  </ul>
</div>

<div>
  <h3 #angularperformanceincrease data-anchor="angularperformanceincrease">Angular performance increase</h3>
  <ol>
    <li>Tree Shaking
      <ul>
        <li>Csak azokat a kódokat tartalmazza a build, amelyeket ténylegesen használnak</li>
        <li>Az Angular CLI automatikusan támogatja a tree shaking-et, ha az alkalmazás modulárisan van felépítve
        </li>
        <li>Ne importáljunk teljes modulokat, ha csak egy részükre van szükség</li>
        <pre>
          // Rossz
          import * as _ from 'lodash';

          // Jó
          import &#123; debounce } from 'lodash';
        </pre>
        <li>Érdemes a szükségtelen, le nem futó kódokat kiszedni</li>
        <li>Csak azokat a könyvtárakat telepítsük és importáljuk, amelyekre ténylegesen szükség van</li>
        <li>Ne húzzunk be nagy könyvtárakat, ha csak egy kis részüket használjuk</li>
      </ul>
    </li>
    <li>Feature Module-ok használata
      <ul>
        <li>A nagyobb modulokat bontsd kisebb, funkcióalapú modulokra</li>
      </ul>
    </li>
    <li>SharedModule helyes használata
      <ul>
        <li>Csak azokat a komponenseket, direktívákat és pipe-okat oszd meg, amelyek valóban szükségesek több helyen
        </li>
      </ul>
    </li>
    <li>OnPush Change Detection
      <ul>
        <li>Alapértelmezésben az Angular minden változásra lefuttatja a teljes change detection ciklust</li>
        <li>Az ChangeDetectionStrategy.OnPush beállítása azt mondja az Angularnak, hogy csak akkor végezzen
          változásfigyelést, ha az input értékei megváltoznak</li>
      </ul>
    </li>
    <li>TrackBy használata *ngFor esetén
      <ul>
        <li>Nagy listák esetén az ngFor-hoz adjunk meg egy trackBy függvényt, hogy az Angular csak a változott
          elemeket
          renderelje újra</li>
      </ul>
    </li>
    <li>Component-Level Lazy Loading
      <ul>
        <li>Nem csak modulokat, hanem egyes komponenseket is betölthetünk aszinkron módon a loadComponent
          segítségével</li>
        <pre>
                @Component(&#123;
                  selector: 'app-root',
                  template: '&#60;ng-container *ngComponentOutlet="lazyComponent">&#60;/ng-container>',
                })
                export class AppComponent &#123;
                  lazyComponent = () => import('./lazy/lazy.component').then(m => m.LazyComponent);
                }
              </pre>
      </ul>
    </li>
    <li>PreloadingStrategy használata
      <ul>
        <li>Az Angular PreloadAllModules vagy egyedi preload stratégiával előre betölthet modulokat alacsonyabb
          prioritású háttérfolyamatként</li>
      </ul>
    </li>
    <li>Service Workers
      <ul>
        <li>Használjunk Angular PWA támogatást, hogy az alkalmazás gyorsabbá váljon azáltal, hogy az erőforrásokat
          előre cache-eli a böngészőben</li>
      </ul>
    </li>
    <li>Lazy Loading képek és médiafájlok esetén
      <ul>
        <li>Használjunk loading="lazy" attribútumot az &#60;img> tageknél</li>
      </ul>
    </li>
    <li>SVG helyett ikonkészlet használata
      <ul>
        <li>Inline SVG-k vagy harmadik fél által nyújtott ikonlibek gyorsítják az oldalak renderelését</li>
      </ul>
    </li>
    <li>CSS és JS Minifikáció
      <ul>
        <li>Az Angular CLI automatikusan minifikálja a buildelt fájlokat, de érdemes ellenőrizni az alkalmazott
          eszközök megfelelő konfigurációját</li>
      </ul>
    </li>
    <li>RxJS és optimalizált adatfolyamok
      <ul>
        <li>Használjunk megfelelő operátorokat, például debounceTime, distinctUntilChanged, hogy csökkentsd a
          felesleges API-hívásokat</li>
      </ul>
    </li>
    <li>NgRx vagy egyéb state management használata
      <ul>
        <li>Csökkenti az állapotfrissítésekkel kapcsolatos overhead-et és tisztább kódot biztosít</li>
      </ul>
    </li>
    <li>HTTP Caching
      <ul>
        <li>Az Angular HttpClient-et kombinálva cache-eléssel csökkenthetjük a hálózati kérések számát</li>
      </ul>
    </li>
    <li>Lazy Loaded Fonts
      <ul>
        <li>Használjunk modern betűkészleteket, és lazy loadingot a betűkészletek betöltéséhez</li>
      </ul>
    </li>
    <li>CDN használata
      <ul>
        <li>Tároljunk statikus erőforrásokat CDN-en keresztül a gyorsabb betöltés érdekében</li>
      </ul>
    </li>
    <li>Angular DevTools
      <ul>
        <li>Használj eszközöket, mint az Angular DevTools, hogy diagnosztizáld az esetleges teljesítményproblémákat
        </li>
      </ul>
    </li>
  </ol>
</div>

<div>
  <h3 #mutablevsimmutable data-anchor="mutablevsimmutable">Mutable vs immutable type</h3>
  <ul>
    <li>Az objektumok és adatok kezelésére vonatkoznak a programozásban</li>
    <li></li>
    <br>
    <li>Mutable (módosítható)
      <ul>
        <li>Az objektum tartalma módosítható, ami hatással van az eredeti példányra</li>
        <li>Értéke közvetlenül módosítható; az eredeti objektum maga módosul</li>
        <li>Ilyenek például a tömbök vagy objektumok a JavaScript-ben</li>
        <li>Példa
          <ul>
            <li>Tömbök: Egy tömbhöz új elemeket adhatunk hozzá anélkül, hogy új tömböt hoznánk létre</li>
            <li>Objektumok: Egy objektum kulcsait vagy értékeit módosíthatjuk anélkül, hogy új példányt hoznánk
              létre</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Immutable (nem módosítható)
      <ul>
        <li>Olyan objektumokat jelentenek, amelyek értéke nem módosítható</li>
        <li>A módosítások mindig új objektumot hoznak létre, az eredeti érintetlen marad</li>
        <li>Tehát, ha mondjuk egy szám értékét 5-ről 6-ra változtatjuk, akkor az 5 kitörlődik a memóriából, és új
          címen létrejön a 6-os szám, amire mutat a változó</li>
        <li>Példa
          <ul>
            <li>Primitív típusok: Mint például a számok, stringek, logikai értékek, amelyek mind immutable típusok
              JavaScript-ben</li>
            <li>Immutable könyvtárak: Ilyen például az Immutable.js, amely segít biztosítani az adatstruktúrák
              immutable jellegét</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <table style="width:100%; table-layout: fixed;">
      <thead>
        <tr>
          <th>Tulajdonság</th>
          <th>Mutable</th>
          <th>Immutable</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Jelentés</td>
          <td>Az érték <strong>módosítható</strong></td>
          <td>Az érték <strong>nem módosítható</strong>, csak új hozható létre</td>
        </tr>
        <tr>
          <td>Módosítás</td>
          <td>Az eredeti objektum módosítható</td>
          <td>Minden módosítás új objektumot eredményez</td>
        </tr>
        <tr>
          <td>Példák</td>
          <td>JavaScript objektumok, tömbök (<code>Array</code>, <code>Object</code>)</td>
          <td>JavaScript primitívek (<code>String</code>, <code>Number</code>, <code>Boolean</code>), és olyan
            könyvtárak, mint az <code>Immutable.js</code>
          </td>
        </tr>
        <tr>
          <td>Előnyök</td>
          <td>Gyorsabb változtatás (nincs új példány)</td>
          <td>Biztonságosabb, könnyebb hibakeresés</td>
        </tr>
        <tr>
          <td>Hátrányok</td>
          <td>Könnyebb hibázni, nehéz követni a változásokat</td>
          <td>Több memóriát használhat, lassabb másolás</td>
        </tr>
        <tr>
          <td>Példa kódban</td>
          <td>
            <ul>
              <li>const mutableArray = [1, 2, 3];</li>
              <li>mutableArray.push(4); // Az eredeti tömb módosul</li>
              <li>console.log(mutableArray); // [1, 2, 3, 4]</li>
            </ul>
          </td>
          <td>
            <ul>
              <li>const immutableArray = [1, 2, 3];</li>
              <li>const newArray = [...immutableArray, 4]; // Új tömböt hozunk létre</li>
              <li>console.log(immutableArray); // [1, 2, 3] (változatlan marad)</li>
              <li>console.log(newArray); // [1, 2, 3, 4]</li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
  </ul>
</div>

<div>
  <h3 #todo data-anchor="todo">TODO</h3>
  <ul>
    <li></li>
  </ul>
</div>

<div>
  <h3>+ témakörök</h3>
  <ol>
    <li>Animations</li>
    <li>Void type</li>
    <li>
      <pre>
      @NgModule(&#123; // Mi micsoda?
        declarations: [],
        imports: [
          CommonModule
        ],
        exports: [],
        providers: [
          ScrollingService
        ]
      })
    </pre>
    </li>
    <li>routernavigate</li>
    <li>const routes: Routes[] = []</li>
    <li>model / ngModel</li>
    <li>implements, extends</li>
    <li>getter, setter</li>
    <li>ng build</li>
    <li>@ViewChild / @ViewChildren</li>
    <li>ElementRef (+nativeElement)</li>
    <li>track vs trackBy</li>
    <li>signal</li>
    <li>specsts (tesztelés?)</li>
    <li>Bundles: vendorjs, polyfillsjs, stylescss-stylesjs, mainjs, runtimejs</li>
    <li>ng start / ng build / ng watch / ng test</li>
    <li>ViewEncapsulation</li>
    <li>CI/CD pipeline</li>
    <li>async / await
      <ul>
        <li>Amikor egy függvény async kulcsszóval van deklarálva, az azt jelenti, hogy a függvény mindig egy Promise-t
          ad vissza</li>
        <li>Az await kulcsszó a Promise-ok aszinkron kezelésére szolgál, megállítja a futást addig, amíg a Promise nem
          teljesül (vagy hibát nem dob)</li>
        <pre>
            async function testFunction() &#123;
              let result = await someAsyncFunction();
              console.log(result); // csak akkor fut le, ha a someAsyncFunction() Promise teljesült
          }
        </pre>
        <li>A then() egy Promise metódus, amely lehetővé teszi, hogy egy callback függvényt adjunk hozzá a Promise
          befejezéséhez, és ha a Promise teljesült, a then() által meghívott függvény lefut</li>
        <pre>
            someAsyncFunction().then(result => &#123;
              console.log(result); // akkor fut le, ha a someAsyncFunction() Promise teljesült
          });
        </pre>
        <li>Az async/await és a then() egymással kompatibilis, mivel mindkettő Promise-okkal dolgozik</li>
        <li>Ha az await egy Promise-t vár, akkor a Promise teljesülése után a futás folytatódik, és az eredmény
          közvetlenül visszatér (ez a Promise eredménye)</li>
        <li>Ha await-et használunk, akkor nem szükséges then()-t használni, de az is működni fog, mert az await egy
          befejezett Promise értéket ad vissza, amit a then() callback-eként is kezelhetünk</li>
      </ul>
    </li>
    <li>aria-label / aria-hidden / aria-expanded / aria-control (accessibility attributes)</li>
    <li>angularjson / stylePreprocessorOptions</li>
    <li>@Input() set changeToGreen(condition: boolean) &#123; }</li>
    <li>ngOnChanges</li>
    <li>Generic type</li>
    <li>eventpreventDefault() --> Az alapértelmezett HTML működést írja felül + eventstopPropogation()</li>
    <li>Angular v12-től v17-ig mik az újítások? (Signal)</li>
    <li>Design patterns (tervezési minták a szoftverfejlesztésben)
      <ul>
        <li>Singleton pattern
          <ul>
            <li>Biztosítja, hogy egy adott osztályból csak egy példány létezzen a program futása során, és globális
              hozzáférést biztosít ehhez a példányhoz</li>
          </ul>
        </li>
        <li>Observer pattern
          <ul>
            <li>Arra használnak, hogy objektumok között létrehozzanak egy egyirányú kapcsolatot</li>
          </ul>
        </li>
      </ul>
    </li>
    <li></li>
    <li>ES6</li>
    <li>Névtelen objektum
      <ul>
        <li>
          &#123;
          name: 'Bob',
          age: 30
          }
        </li>
      </ul>
    </li>
    <li>Anonym függvény</li>
    <li>Anonymous object</li>
    <li>CORS error</li>
    <li>Névtelen függvény</li>
    <li>Rekurzió</li>
    <li>JSONstringify() - JSONparse()</li>
    <li>callback function
      <ul>
        <li>
          A callback function egy olyan függvény, amelyet egy másik függvény paramétereként adunk át, és amelyet később,
          a hívó függvény egy bizonyos pontján hívunk meg</li>
        <li>A callback-ek különösen hasznosak aszinkron műveleteknél használjuk, vagy felhasználói interakcióknál</li>
        <pre>
          function greeting (name) &#123;
          alert('Hello 1 + name);
          }
          function process UserInput (callback) &#123;
                    var name = prompt('Please enter your name');
                    callback(name);
          }
          processUserInput (greeting);
        </pre>
      </ul>
    </li>
    <li>Empty típus</li>
    <li>Beépített pipe-ok</li>
    <li>Mikor referencia az érték, és mikor nem?</li>
    <li>@ViewChild --> TemplateRef --> ngTemplateOutlet</li>
    <li>Tabulátor sorrend</li>
    <li>providedIn: 'platform' / 'any'</li>
    <li>Array destruction</li>
    <li>stylePreprocessorOptions</li>
    <li>Mikor fut le a change detection cycle? (lehetőleg az összes eset)</li>
    <li>@Injectable(&#123;providedIn: 'root'})</li>
    <li>Type guard</li>
    <li>import &#123; Observable as Obs } from 'rxjs';</li>
    <li>imports: [RouterModule.forChild(routes)] / imports: [RouterModule.forRoot(routes)]</li>
    <li>Lazy load components</li>
    <li>Name conventions and cases
      <ul>
        <li>Property: propertyExample</li>
        <li>Private property: _privatePropertyExample</li>
        <li>Observable: observableExample$</li>
        <li>Subject: subjectExample$</li>
        <li>Function: exampleFunction()</li>
        <li>Getter/Setter: get propertyName() / set propertyName(value)</li>
        <li>Component / Service / Directive / Pipe: ExampleComponent / ExampleService / ExampleDirective / ExamplePipe
        </li>
        <li>Snake case: snake_case_example</li>
        <li>Camel case: camelCaseExample</li>
        <li>Pascal case: PascalCaseExample</li>
        <li>Kebab-case: kebab-case-example</li>
      </ul>
    </li>
    <li>Attribute binding vs property binding vs event binding vs data binding (vs directive)</li>
    <li>Class példányosítás</li>
    <li>RxJS
    <li>
      <ul>
        <li>exhaustMap()</li>
        <li>switchMap()</li>
        <li>mergeMap()</li>
        <li>concatMap()</li>
        <br>
        <table cellpadding="8" style="border-collapse: collapse;">
          <thead>
            <tr>
              <th>Operátor</th>
              <th>Több kérés?</th>
              <th>Megszakítja az előzőt?</th>
              <th>Feldolgozási sorrend</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>exhaustMap</td>
              <td>Nem</td>
              <td>Igen</td>
              <td>Nem számít</td>
            </tr>
            <tr>
              <td>switchMap</td>
              <td>Nem</td>
              <td>Igen</td>
              <td>Nem számít</td>
            </tr>
            <tr>
              <td>mergeMap</td>
              <td>Igen</td>
              <td>Nem</td>
              <td>Párhuzamos</td>
            </tr>
            <tr>
              <td>concatMap</td>
              <td>Nem</td>
              <td>Nem</td>
              <td>Sorrendben</td>
            </tr>
          </tbody>
        </table>
      </ul>
    </li>
    <li>A kettő közötti különbség:
      const user = JSON.parse(localStorage.getItem('user') || 'null');
      const user = JSON.parse(localStorage.getItem('user') ?? 'null');
    </li>

    <li></li>

    <li>Methodok (példák)
      <ul>
        <ul>
          <li>trim()</li>
          <li>eval()</li>
          <li>join()</li>
          <li>slice()</li>
          <li>splice()
            <ul>
              <li>method, ami a memóriában közvetlenül módosítja a tömb értékét</li>
              <li>egy indexet vár, és a törlendő elemek számát</li>
            </ul>
          </li>
          <li>indexOf()</li>
          <li>findIndex()</li>
          <li>length()</li>
          <li>push()
            <ul>
              <li>method, ami a memóriában közvetlenül módosítja a tömb értékét</li>
            </ul>
          </li>
          <li>Objectkeys()</li>
          <li>Objectvalues()</li>
          <li>ObjecthasOwn()</li>
          <li>concat()</li>
          <li>pop()</li>
          <li>at()</li>
          <li>reverse()</li>
          <li>flat()</li>
          <li>sort()
            <ul>
              <li>sorrendbe állítások</li>
            </ul>
          </li>
          <li>toUpperCase()</li>
          <li>flatMap()</li>
          <li>reduce()</li>
          <li>some()</li>
          <li>find()</li>
        </ul>
      </ul>
    </li>
  </ol>
</div>