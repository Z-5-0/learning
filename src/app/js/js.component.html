<h1>Javascript</h1>
<div>
  <h3>HTTP protokol</h3>
  <ul>
    <li>HyperText Transfer Protocol</li>
    <li>Protokoll, tehát szabályrendszer a kommunikációra</li>
    <li>Két fél kommunikál egymással (kliens és szerver)</li>
    <li>A kliens HTTP kéréseket (request) küld, és a szerver HTTP válaszokat (response) ad</li>
    <li>Kliens ebben a kommunikációban például a Google Chrome</li>
    <li>A böngészőben fut a Javascript Engine (interpreter), amibe bemenet a a JS nyelven írott kód vezérli a
      böngészőt
    </li>
    <li>Az Engine tudja vezérelni a HTML dokumentumot, például elemeket hozzon létre, vagy attribútumokat
      módosítson, és hozzáférése van a Console-hoz, ami egy interface, amin keresztül mi commandokat tudunk
      beküldeni az Engine-nek, és meg tudjuk nézni, amit az Engine válaszként visszaküld
    </li>
    <li>Az Engine HTTP kéréseket is tud küldeni, és a válaszokat fel tudja dolgozni (AJAX kérések)</li>
    <li>Az Engine-en keresztül adatot is tudunk tárolni (local storage), ahol elhelyezhetünk adatot, és onnan
      újabb oldalletöltéskor ki tudjuk olvasni
    </li>
    <ul>
      <li>Localstorage-ba tudunk tárolni számokat, szövegeket, logikai értékeket, tömböket, vagy objektumokat
      </li>
      <li>Objektum tárolása:
        <ul>
          <li>localStorage.setItem("user", JSON.stringify(userJSON));</li>
          <li>let userJSON = JSON.parse(localStorage.getItem("user"));</li>
          <li>A JSON.stringify() és JSON.parse() javascript függvények</li>
          <ul>
            <li>JSON.stringify() : JSON formátumba alakítható az objektum</li>
            <li>JSON.parse(): JSON formátumból JS objektumba alakítás</li>
          </ul>
          <li>localStorage.setItem("fruits", JSON.stringify(["alma", "banán", "narancs"]));</li>
        </ul>
      </li>
    </ul>
    <li>JS Engine ma már szerver oldalon is futtatható (nodejs), ami a kéréseket fogadja, és erre válaszokat
      küld, így feladatát tekintve merőben eltér a kliens oldali Engine-től
    </li>
    <li>A kliens oldalon a Javascriptnek 2 fő feladata van:
      <ul>
        <li>HTML elemek módosítása révén interakció fokozás</li>
        <li>AJAX kérésekkel küldése révén oldalletöltés nélkül tudunk kis mennyiségű adatért folyamodni a
          szerver felé
        </li>
      </ul>
    </li>
    <li>Létrehozhatunk olyan user interface-eket, amik oldalletöltés nélkül kommunikálnak a szerverrel, és
      interaktív hatásokat hoznak létre
    </li>
  </ul>
</div>

<div>
  <h3>Javascript és a Console</h3>
  <ul>
    <li>A fejlesztői eszközök közé tartozik a Console</li>
    <li>A Google kereső egyik id attribútumát leressük ki a DOM-ban
      <ul>
        <li>document.getElementById(ID).style.backgroundColor = "green";</li>
        <li>fetch("https://jsonplaceholder.typicode.com/posts").then(res => res.json()).then(res =>
          console.log(res));
          <ul>
            <li>Network fülön is látható a kérés</li>
            <li>JSON formátumú tartalom (nem HTML)</li>
            <li></li>
          </ul>
        </li>
        <li>fetch("https://jsonplaceholder.typicode.com/posts").then(res => res.json()).then(res =>
          document.getElementById(ID).innerHTML = res[0].title);
          <ul>
            <li>
              <pre>
                                    window.onload = async function () &#123;
                                  fetch("https://jsonplaceholder.typicode.com/posts")
                                  .then(res => res.json())
                                  .then(res => document.getElementById('fetchFirstPostTitle').innerHTML = res[0].title);
                                    &#125;
                                </pre>

            </li>
            <li>A body-ban elhelyezhető egy script tag:
              <ul>
                <li>
                  <pre>
                                            &#60;script&#62;
                                                fetch("https://jsonplaceholder.com.typicode.com/posts")
                                                .then(res => res.json()).then(console.log(res));
                                            &#60;/script&#62;
                                        </pre>
                </li>
              </ul>
            </li>
            <li>Az ilyen parancsokat külön script fájlban szokás tárolni, és a böngészőt utasítani arra,
              hogy a script fájlt szerezze meg a szerverről, és futtassa le
              <ul>
                <li>index.html-ben:
                  <ul>
                    <li>&#60;script src="./src/basic.js"&#62;&#60;/script&#62;</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Async nélkül nem kapjuk meg a HTML-be a fetch eredményét</li>
            <li>A fenti onloadra lefutó fetch az alábbi sort eredményezi:
              <ul>
                <li id="fetchFirstPostTitle"></li>
              </ul>
            </li>
            <li>A böngészőben megnyitva az index.html-t, láthatjuk, hogy kiment az AJAX kérés</li>
            <li>A böngésző fentről lefelé dolgozza fel a HTML dokumentumot, és amint script tagre fut,
              végrehajtja a benne lévő kódot
            </li>
            <li>Először a HTML töltődött be, majd megérkezett a script fájl (megérkezett a
              forrásfájljaink közé), majd vegrehajtódott, és lefutott az AJAX kérés
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>VSCodeban, üres HTML fájlban egy ! írva, majd a TAB-ot megnyomva a VSC létrehozz egy default HTML5
      snippetet
    </li>
  </ul>
</div>

<div>
  <h3>Adattípusok</h3>
  <ul>
    <li>Az adattípusokat halmazokként is elképzelhetjük
      <ul>
        <li>Az adat értékéből meg lehet mondani (determinálja), hogy milyen típus, és hogy milyen műveletek
          hajthatók végre rajta
        </li>
        <li>A boolean "dobozkából" true vagy false érték választható csak</li>
      </ul>
    </li>
    <br>
    <li>Komment
      <ul>
        <li>Végre nem hajtódó JS kód</li>
        <li>Két féle létezik:
          <ul>
            <li>Sor (line) komment //</li>
            <li>Blokk (block) komment /* */</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Szöveges adattipus (string)
      <ul>
        <li>Szimpla, vagy dupla (az engine-t nem érdekli) idézőjelek közé írt karakterlánc</li>
        <li>Műveletek például: karakterek megszámolása, szöveg hozzáfűzése, nagybetűssé tétel</li>
        <li>"Szia" => String típusú, szia értékű...érték</li>
      </ul>
    </li>
    <li>Szám (number) adattípus
      <ul>
        <li>JS nem tesz különbséget tört és egész szám között</li>
        <li>Műveletek például: hozzádás, kivonás, osztás utáni maradék számítás</li>
      </ul>
    </li>
    <li>Boolean adattípus
      <ul>
        <li>Igaz/hamis értékeket reprezentál</li>
        <li>Két értéket vehet fel: true/false</li>
        <li>Műveletek például:
          <ul>
            <li>Logikai és: Két boolean a bemenete, és akkor tér vissza true-val, ha mindkét bemeneti
              paraméter true
            </li>
            <li>Negálás: Az adott boolean értéket változtatja az ellentettjévé</li>
          </ul>
        </li>
        <li>Undefined adattípus
          <ul>
            <li>Egy érték a rendszerünkben nincs definiálva</li>
          </ul>
        </li>
        <li>null adattípus
          <ul>
            <li>Az érték definiálva van a rendszerünkben, csak null az értéke</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>A Javascriptben ezeket a típusokat nevezik primitív típusoknak</li>
  </ul>
</div>

<div>
  <h3>Tömb (array)</h3>
  <ul>
    <li>Nem primitív típus</li>
    <li>Azt reprezentálja, hogy valamiből sok van</li>
    <li>Kéz a kézben jár egy másik típussal</li>
    <li>Array&#60;T&#62; (pl.: Array&#60;string&#62; - tehát sok string)</li>
    <li>Szintaktika: ['a','b', 'c'] / [1, 2, 3]</li>
    <li>A benne lévő értékek a tömb elemei</li>
    <li>Indexált lista, mindegyik tömbelem rendelkezik indexel, ami 0-ról indul, egyesével növekszik</li>
    <li>Műveletek például:
      <ul>
        <li>Szűrés</li>
        <li>Sorba rendezés</li>
        <li>Új elem hozzáadása</li>
        <li>Aggregálás: Az adott tömb elemeit egyetlen értékbe vagy összefoglaló értékbe állítjuk össze</li>
        <li>Index alapú kikérés</li>
      </ul>
    </li>
    <li>A műveleteket nem érdekli, hogy a tömbben milyen típusú elemek vannak</li>
    <li>Javascriptben semmi sem akadályozza meg, hogy eltérő típusokkal tölts fel egy tömböt, de ez a tömbnek
      nem a tipikus felhasználása, sőt, veszélyes, más nyelveken ez hibára is fut
    </li>
    <li>Lehetnek többdimenziósak
      <ul>
        <li>A tömb elemei lehetnek további tömbök: Array&#60;Array&#60;number&#62;&#62;</li>
        <li>Olyan tömb, aminek az elemei számok tömbjek</li>
        <li>[ [1,2], [3,4], [5,6] ]</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3>Objektum</h3>
  <ul>
    <li>Kulcs-érték párok sorozata</li>
    <li>Tekinthetünk rá, mint egyfajta szótár (Pythonban dictionary a neve)</li>
    <li>A kulcsoknak egyedieknek kell lennie
      <ul>
        <li>
          <pre>
                            &#123;
                          firstName: 'Gábor',
                          lastName: 'Kenő',
                          age: 30
                            &#125;
                        </pre>
        </li>
      </ul>
    </li>
    <li>A tömbbel szemben látjuk, hogy nem indexünk van, ami asszociálva van egyetlen értékkel, hanem kulcsunk
    </li>
    <li>Az adat felcímkézhető, explicit kulcs lévén juthatunk hozzá az értékhez</li>
    <li>Műveletek például:
      <ul>
        <li>lookup: Magyarul kulcs alapú kikérés
          <ul>
            <li>
              Javascriptben kétféleképpen tehető meg
              <ul>
                <li>Pont szintaxis: user.lastName</li>
                <li>user['lastName']</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Összekombinálható az összes többi adattípussal
      <ul>
        <li>
          <pre>
                            &#123;
                          firstName: 'Gábor',
                          lastName: 'Kenő',
                          age: 30,
                          phoneNumbers: [
                          '+36501234567',
                          '+36508765432'
                          ]
                          address: &#123;
                                    street: 'Király utca',
                                    city: 'Budapest'
                                &#125;
                            &#125;
                        </pre>
        </li>
        <li>user.address.street / user['address']['street']</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3>Operátorok I.</h3>
  <ul>
    <li>Valami adaton műveletet végrehajtó nyelvi eszköz</li>
    <li>Kategorizálhatók
      <ul>
        <li>+ operátor
          <ul>
            <li>Aritmetikai operátor</li>
            <li>number típusú értékeken végez operációt</li>
            <li>console.log(2 + 3) - A számok az operandusok</li>
            <li>Fekete doboz, ami 2 értékből visszaad 1 értéket</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Csoportosíthatók
      <ul>
        <li>Operandusok száma szerint
          <ul>
            <li>unary operátor: egyoperandusú</li>
            <li>binary operátor: kétoperandusú</li>
            <li>ternary operátor: háromoperandusú</li>
          </ul>
        </li>
        <li>Operátor lexikális elhelyezkedése az operandusokhoz képest
          <ul>
            <li>prefix operátor: előtte van</li>
            <li>infix operátor: közötte van</li>
            <li>postfix operátor: utána van</li>
          </ul>
        </li>
        <li>Hajt-e végre mellékhatást (side effect)
          <ul>
            <li>Amellett, hogy leképez valamit, a rendszerben valami változást
              <ul>
                <li>Kiírhat a console-ba</li>
                <li>Beolvashat, vagy kiírhat adatot a memóriába</li>
              </ul>
            </li>
            <li>Nem determinisztikusan működik, van, amikor másképp működik, vagy a rendszer egészében
              valamilyen változást beállít
            </li>
            <li>Csoportosítása
              <ul>
                <li>Végrehajt mellékhatást</li>
                <li>Nem hajt végre mellékhatást</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Aritmetikai operátor
      <ul>
        <li>bináris, infix, side effectet nem végrehajtó
          <ul>
            <li>Következetesen jellemző rájuk, hogy két number-t vár bemenetként, és egy number-t ad
              vissza
            </li>
            <li>(number, number) => number</li>
          </ul>
        </li>
        <li>+ - * / %</li>
        <li>
          <pre>
                            console.log(2 + 4); => 6
                            console.log(2 - 4); => -2
                            console.log(2 * 4); => 8
                            console.log(2 / 4); => 0.5
                            console.log(7 % 3); => 1
                        </pre>
        </li>
        <li>A matematika szabályait követik, tehát a szorzás művelet előbb hajtósik végre, mint az
          összeadás, de zárójellel felülírható
        </li>
      </ul>
    </li>
    <li>Összehasonlító operátorok
      <ul>
        <li>Több fajta bemenetet is várhatnak típus szempontjából</li>
        <li>(any, any) => boolean</li>
        <br>
        <li>== (equality)
          <ul>
            <li>Megnézi, hogy két érték megegyezik-e, vagy sem</li>
            <li>Ha számot stringgel hasonlítunk össze, és egyezés van, akkor true-t kapunk vissza</li>
            <li>console.log(2 == '2') => true</li>
            <li>A nyelv gyenge típusosságából adódik, átkonvertálja a stringet számmá</li>
            <li>console.log(1 == true) => true, mert a true-t átalakítja 1-esre</li>
          </ul>
        </li>
        <li>!=
          <ul>
            <li>Azt vizsgálja, hogy a két érték nem egyenlő-e</li>
          </ul>
        </li>
        <li>=== (identity)
          <ul>
            <li>A típusátalakítást nem csinálja meg</li>
            <li>Szigorúbb, mint az equality</li>
            <li>console.log(2 == '2') => false</li>
            <li>Stringek összehasonlítására is lehet használni</li>
          </ul>
        </li>
        <li>!==
          <ul>
            <li>Az identitynél látott szigor ugyanúgy jellemző</li>
          </ul>
        </li>
        <li>&#62;
          <ul>
            <li>Nagyobb, mint</li>
            <li>Tipikusan számot vár</li>
          </ul>
        </li>
        <li>&#60;
          <ul>
            <li>Kisebb, mint</li>
            <li>Tipikusan számot vár</li>
          </ul>
        </li>
        <li>&#62;=
          <ul>
            <li>Nagyobb egyenlő, mint</li>
            <li>Tipikusan számot vár</li>
          </ul>
        </li>
        <li>&#60;=
          <ul>
            <li>Kisebb egyenlő, mint</li>
            <li>Tipikusan számot vár</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Logikai operátorok
      <ul>
        <li>Bemenetként booleant várnak, és a kimenetük is boolean</li>
        <li>(boolean, boolean) => boolean</li>
        <li>Lesz köztük egy, ami unary (boolean) => boolean</li>
        <br>
        <li>Logikai ÉS
          <ul>
            <li>console.log(true && false)</li>
            <li>Csak akkor ad vissza true-t, ha minden bemeneti értéke true</li>
          </ul>
        </li>
        <li>Logikai VAGY
          <ul>
            <li>console.log(true || false)</li>
            <li>Két pipe karakter</li>
            <li>A beérkező boolean-ok közül az egyik true, akkor a kimenet is true</li>
          </ul>
        </li>
        <li>Negálás
          <ul>
            <li>Prefix operátor</li>
            <li>A bemeneti értéket negálja</li>
            <li>false => true / true => false</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>String operátor
      <ul>
        <li>Szövegek összefűzésére/konkatenálás (concatenate)</li>
        <li>Tulajdonképpen az aritmetikai operátorok + jele, csak stringet fűz össze</li>
        <li>
          <pre>console.log('Hello' + ' World') => Hello World</pre>
        </li>
      </ul>
    </li>
    <li>Conditional operátor
      <ul>
        <li>Az egyetlen ternary operátor a nyelvben (háromoperandusú)</li>
        <li>Szokás ternary operátornak nevezni</li>
        <li>(boolean, any, any) => any</li>
        <li>A boolean dönti el, hogy a kimenet a második, vagy a harmadik bemeneti paraméter legyen</li>
        <li>
          <pre>console.log(true ? 'második' : 'harmadik') => "második"</pre>
          <pre>console.log(false ? 'második' : 'harmadik') => "harmadik"</pre>
        </li>
      </ul>
    </li>
    <br>
    <li>Az egyes operátor családok kompatibilisek lehetnek egymással
      <ul>
        <li>Több operátor felhasználásával nagyobb kifejezések is építhetők</li>
        <li>console.log(2 === 2 && 1 > 5) => console.log(true && false) => console.log(false)</li>
        <li>Ha több operátorral dolgozunk egyszerre, az operátoroknak van egy precedenciájuk
          <ul>
            <li>A Végrehajtódás sorrendje meg van határozva</li>
            <li>Az && operátor előbb hajtódik végre, mint az ||</li>
            <li>Zárójelekkel felülírható</li>
            <li>console.log(2 === 2 && (1 > 5) || true)</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3>Operátorok II.</h3>
  <ul>
    <li>A fenti operátorok mind determinisztikusak</li>
    <li>Nézzük azokat, amik a rendszer állapotát megmódosítják
      <ul>
        <li>Assignment operátor
          <ul>
            <li>A memóriába eltárol értéket</li>
            <li>Típus annotációját tekintve, vár egy változót, és egy bármilyen adattípust</li>
            <li>(var, any) => any</li>
            <li>Példa:</li>
            <li>
              <pre>var valtozo;</pre>
            </li>
            <li>A valtozo a memóriában létrehozott kulcs, amihez értékek fűzhetők hozzá</li>
            <li>Később, futásidőben elő lehet szedni a kulcs értékét</li>
            <li>A fenti változóhoz automatikusan hozzárendelődik egy undefined érték</li>
            <li>
              <pre>valtozo = 'hello'</pre>
            </li>
            <li>Innentől kezdve a változó már nem undefined, hanem egy string (hello)</li>
            <li>Az értéke nem determinisztikus</li>
            <li>Az assignment operátorral már az időt is bevittük a rendszerbe</li>
            <li>A Javascriptre jellemző, hogy dinamikus típusos nyelv
              <ul>
                <li>A változókba más típusú érték is beköthető</li>
                <li>Statikus típusú nyelvekben ilyet nem lehet</li>
                <li>
                  <pre>valtozo = 3</pre>
                </li>
                <li>Fentebb stringet helyeztünk a változóba, az imént pedig numbert</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Increment operátor
          <ul>
            <li>++</li>
            <li>postfix</li>
            <li>valtozo++</li>
            <li>A változó értékét növeli eggyel</li>
          </ul>
        </li>
        <li>Decrement operátor
          <ul>
            <li>--</li>
            <li>postfix</li>
            <li>valtozo--</li>
            <li>A változó értékét csökkenti eggyel</li>
          </ul>
        </li>
        <li>+=
          <ul>
            <li>
              <pre>var szam = 5</pre>
            </li>
            <li>A memóriában egy meghatározott, explicit értékkel változtatja meg az értéket</li>
            <li>
              <pre>szam += 10; => 15</pre>
            </li>
            <li>Tehát a szam valtozó értéke immáron 15</li>
            <li>Stringekkel is működik, olyan, mint a hozzáfűzés
              <ul>
                <li>var nemszam = 'hello'</li>
                <li>nemszam += ' world'</li>
                <li>Eredmény: hello world</li>
                <li>Egyenértékű ezzel: 'hello' + ' world'</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>-=
          <ul>
            <li>
              <pre>var szam = 5</pre>
            </li>
            <li>A memóriában egy meghatározott, explicit értékkel változtatja meg az értéket</li>
            <li>
              <pre>szam -= 2; => 3</pre>
            </li>
            <li>Tehát a szam valtozó értéke immáron 3</li>
          </ul>
        </li>
        <li>*=</li>
        <li>/=</li>
        <li>%=</li>
      </ul>
    </li>
    <li></li>
  </ul>
</div>

<div>
  <h3>Jegyvásárló alkalmazás</h3>
  <ul>
    <li>
      <button id="promptListener">Prompt</button>
      <ul>
        <li>
          <pre>
                            const promptButton = document.getElementById("promptListener");
                            promptButton.addEventListener("click", showPrompt);

                            function showPrompt() &#123;
                          prompt('Ez egy prompt');
                            &#125;
                        </pre>
        </li>
      </ul>
    </li>
    <li>
      <button id="alertListener">Alert</button>
      <ul>
        <li>
          <pre>
                            const alertButton = document.getElementById("alertListener");
                            promptButton.addEventListener("click", showAlert);

                            function showAlert() &#123;
                          alert('Ez egy alert');
                            &#125;
                        </pre>
        </li>
      </ul>
    </li>
    <li>
      <button id="ticketingListener">Jegyvásárlás</button>
      <ul>
        <li>Beolvastatjuk a prompt-tal a felhasználóval, hogy
          <ul>
            <li>Hány jegyet kér</li>
            <li>Milyen típusú jegyet kér (student | adult)</li>
          </ul>
        </li>
        <li>A diákjegy ára 300 Ft, a felnőtt jegy ára 350 Ft</li>
        <li>10-nél több jegy vásárlása esetén jár 10 % kedvezmény</li>
        <li>
          <pre>
                            function showTicketingPrompt() &#123;
                          const quantity = prompt('Hány darab jegyet szeretnél?');
                          const type = prompt('Felnőtt, vagy diákjegyet szeretnél vásárolni? (adult | student)');

                          var price = type === 'student' ? 300 : 350;
                          var discount = quantity > 10 ? 0.9 : 1;

                          var total = quantity * price * discount;

                          alert(total);
                            &#125;
                        </pre>
        </li>
        <li>Nyugdíjas jeggyel bővítés
          <pre>
                            function showTicketingPrompt() &#123;
            const quantity = prompt('Hány darab jegyet szeretnél?');
            const type = prompt('Felnőtt, vagy diákjegyet szeretnél vásárolni? (adult | student)');

            var types = &#123;
                                    student: 300,
                                    adult: 350,
                                    retired: 280
                                &#125;

                                var price = types[type]
                                var discount = quantity > 10 ? 0.9 : 1;

                                var total = quantity * price * discount;

                                alert(total);
                            &#125;
                        </pre>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3>Ciklusok</h3>
  <ul>
    <li>Kontroll stuktúra, avagy vezérkési szerkezet: Olyan nyelvi eszközök, amelyek a kód futását befolyásolja
      <ul>
        <li>Ciklikus működést eredményez</li>
        <li>Szabályozza, hogy bizonyos sorok lefussanak-e vagy sem</li>
      </ul>
    </li>
    <li>Adott egy tömb, amiben számok vannak, és mi szeretnénk megkapni azt, hogy hány darab páros számot
      tartalmaz a tömb
      <ul>
        <pre>var szamok = [2, 4, 13, 4, 6, 42];</pre>
        <pre>var parosakSzama = 0;</pre>
        <pre>parosakSzama += szamok[0] % 2 === 0 ? 1 : 0;</pre>
        <li>Ha lefolytatjuk az utolsó sort minden elemre, akkor megkapjuk az ereményt</li>
        <li>A probléma, hogy így a kódunk nagyon repetitív lett</li>
        <li>A kontroll struktúrák automatizálást valósítanak meg, tehát futtassa addig a kódot, amíg
          bizonyos feltétel meg nem valósul
        </li>
      </ul>
    </li>
    <li>A kontroll egyik családja
      <ul>
        <li>Ciklusok (loop)
          <ul>
            <li>While ciklus (loop)
              <ul>
                <li>
                  <pre>
                                            while() &#123;

                                          &#125;
                                        </pre>
                </li>
                <li>A kapcsos zárójelen belüli rész a ciklus bodyja</li>
                <li>A while-nak szüksége van egy bemeneti értékre</li>
                <li>Addig fogja a body-t futtatni, amíg a feltétel hamis nem lesz</li>
                <li>Végtelen ciklus hozható létre
                  <ul>
                    <li>
                      <pre>
                                                    while(true) &#123;

                                                  &#125;
                                                </pre>
                    </li>
                    <li>Annyira leterhetli a processzort, hogy tulajdonképpen megáll az oldal
                    </li>
                  </ul>
                </li>
                <li>Egyik helyes megoldás a szamok tömbre [2, 4, 13, 4, 6, 42], amennyiben páratlan
                  számokat keresünk
                  <ul>
                    <li>
                      <pre>
                                                    index = 0
                                                    var paratlanokSzama = 0;
                                                    while (index &#60; 6) &#123;
                                                  paratlanokSzama += szamok[index] % 2 === 1 ? 1 : 0;
                                                  index++;
                                                    &#125;
                                                </pre>
                    </li>
                    <li>Az eredmény 1 lesz</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>For ciklus (loop)
              <ul>
                <li>A while-hoz képest kissé specifikusabb</li>
                <li>Dedikáltan számok generálására jó</li>
                <li>
                  <pre>
                                            for (var i = 0; i &#60; 6; i++) &#123;

                                          &#125;
                                        </pre>
                  <ul>
                    <li>Inicializálni kell egy változót, hogy honnan induljon a számlálás
                      (tipikusan 0)
                    </li>
                    <li>A második paraméter a feltétel, hogy meddig tartson a ciklus</li>
                    <li>A harmadik paraméter, hogy milyen ütemben növekedjen a ciklusváltozó
                    </li>
                  </ul>
                </li>
                <li>Ha szintén a páratlan számok darabszámát keressük
                  <ul>
                    <li>
                      <pre>
                                                    var paratlanokSzamaUjra = 0;
                                                    for (var i = 0; i &#60; 6; i++) &#123;
                                                  paratlanokSzamaUjra += szamok[i] % 2 === 1 ? 1 : 0;
                                                    &#125;
                                                </pre>
                    </li>
                  </ul>
                </li>
                <li>Saját megoldás rá úgy, hogy a tömb elemeinek számát nézzük a ciklusnál
                  <ul>
                    <li>
                      <pre>
                                                    var paratlanokSzamaSajat = 0;
                                                    for (var i = 0; i &#60; (szamok.length); i++) &#123;
                                                  console.log(i); debugger;
                                                  paratlanokSzamaSajat += szamok[i] % 2 === 1 ? 1 : 0;
                                                    &#125;
                                                </pre>
                    </li>
                    <li>A debuggerrel a DevTools Source fülén követhetjük nyomon, hogy jelen
                      példa esetében milyen érték szerepel az i-ben
                    </li>
                    <li>A ciklus feltételét a videóban is megváltozott
                      <ul>
                        <li>Futásidőben hozzájuthatunk a tömbök elemszámához</li>
                        <li>A length kulcs alapú kikéréssel megkapjuk a tömb elemszámát
                          (szamok.length)
                        </li>
                        <li>While ciklus kapcsán is végrehajtható ez a praktikus művelet
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>For - of ciklus
              <ul>
                <li>A legspecifikusabb működésű ciklus</li>
                <li>Dedikáltan arra jó, hogy egy tömb elemein végigiteráljunk</li>
                <li>A struktúra minden elemet számba vesz, és biztosít egy változót, ahol hozzá
                  lehet jutni az adott tömbelemhez
                </li>
                <li>Dinamikusan működik, nem tud megállni a tömb közepén</li>
                <li>
                  <ul>
                    <li>
                      <pre>
                                                    for(var szam of szamok) &#123;

                                                  &#125;
                                                </pre>
                    </li>
                    <li>Egyes számban szokás leírni a tömb nevét a var után</li>
                    <li>Az iteráción belül rendelkezésre fog állni a szam, ami az aktuális
                      tömbelem értéke
                    </li>
                    <li>Szintaktikailag a legkedvezőbb megjelenés, hiszen az explicit kulcs
                      alapú kikérést már nem kell megtennünk
                    </li>
                    <li>
                      <ul>
                        <li>
                          <pre>
                                                            var paratlanokSzamaForOf = 0;
                                                            for(var szam of szamok) &#123;
                                                          paratlanokSzamaForOf += szam % 2 == 1 ? 1 : 0;
                                                            &#125;
                                                        </pre>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3>Elágazások</h3>
  <ul>
    <li>A kontroll stuktúrák másik családja</li>
    <li>Bizonyos sor kódok lefussanak-e, vagy sem</li>
    <li>Típusai
      <ul>
        <li>If - else statement
          <ul>
            <li>
              <pre>
                                    if () &#123;

                                  &#125; else &#123;

                                  &#125;
                                </pre>
            </li>
            <li>A zárójelek közé jön a boolean feltétel</li>
            <li>Amennyiben igaz, az if statement bodyja lefut</li>
            <li>Az else ág opcionális</li>
            <li>Boolean-ra kiértékelődő kifejezés kerül a feltételbe</li>
            <li>
              <button id="promptYourAge">Életkor propt</button>
            </li>
            <li>
              <pre>
                                    function promptYourAgeFunction() &#123;
                                  var age = prompt('Add meg az életkorod:')

                                  if (age &#60;= 20) &#123;
                                            alert('Fiatal vagy!');
                                            else if (age == 20) &#123; // Három egyenlőségjel esetén (identity) nem működik, ezekszerint a beírt érték string
                                                alert('Pont 20 éves vagy!');
                                            &#125;
                                            else &#123;
                                  alert('Öreg vagy!');
                                            &#125;
                                        &#125;
                                    &#125;
                                </pre>
            </li>
            <li>Az if statement kiegészíthető else if ágakkal
              <ul>
                <li>Fentről lefelé további ágakat jelent</li>
                <li>Ha az if feltétel nem teljesült, megnézi az első else if-et, és így megy tovább
                </li>
              </ul>
            </li>
            <li>Az else ág default case-ként is felfogható
              <ul>
                <li>Ha egyik feltétel sem teljesünk, ide futunk</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Switch statement
          <ul>
            <li>Nagyon hasonló az if statementhez</li>
            <li>Tulajdonképpen kapcsoló</li>
            <li>Esetszétválasztásra alkalmatos</li>
            <li>Két módon lehet használni
              <ul>
                <li>Explicit egyezőség vizsgálata
                  <ul>
                    <li>String vagy szám egyezőségét vizsgáljuk</li>
                    <li>A bemeneti értéket meg kell adni, majd az egyes eseteket megadni</li>
                    <li>
                      <pre>
                                                    function promptYourAgeWithSwitchFunction() &#123;
                                                  var age = prompt('Add meg az életkorod:')

                                                  switch (age) &#123;
                                                            case 18:
                                                                alert('18 éves vagy!')
                                                                break;
                                                            case 20:
                                                                alert('20 éves vagy!')
                                                                break;
                                                            default:
                                                                alert('Sem 18, sem 20 éves nem vagy!');
                                                        &#125;
                                                    &#125;
                                                </pre>
                    </li>
                    <li>
                      <button id="promptYourAgeWithSwitch">Switch age prompt</button>
                    </li>
                    <li>Az egyes state-ekbe break statementet kell írni, mert különben a
                      végrehajtódás
                      átesik a következő case-be
                    </li>
                    <li>A default case akkor fut le, ha a feltételek egyike sem valósul meg
                      (mint az if
                      esetében az else)
                    </li>
                    <li>Defaulthoz nem szükséges break;</li>
                    <li>Kilogolva az age-t, láthatjuk, hogy a prompt string értéket visz be
                      <ul>
                        <li>Vagy átalakítjuk a case-eket, hogy stringeket figyeljen ('18',
                          '20')
                        </li>
                        <li>Vagy az age-t alakítjuk át number típusra
                          <ul>
                            <li>Helytelen: switch (age as number) => Type assertion csak
                              typescriptben van
                            </li>
                            <li>Helyes: switch (Number(age))</li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>Másik féle mód, amikor true kerül a switch bemenetére, és a case-eknek
                  feltételeket adunk
                  <ul>
                    <li>
                      <button id="promptYourAgeWithSwitchNonExplicit">Switch age prompt
                        2
                      </button>
                    </li>
                    <li>
                      <pre>
                                                    function promptYourAgeWithSwitchNonExplicit() &#123;
                                                  var age = prompt('Add meg az életkorod:');

                                                  // SWITCH

                                                  switch (true) &#123;
                                                            case age &#60; 20:
                                                                alert('20 évnél fiatalabb vagy!');
                                                                break;
                                                            case age &#62; 20 && age &#60; 30:
                                                                alert('20 és 30 közötti az életkorod!');
                                                                break;
                                                            default:
                                                                alert('Idősebb vagy, mint 30!');
                                                        &#125;
                                                    &#125;
                                                </pre>
                    </li>
                    <li>A jegyvásárlós projekt felokosítása
                      <ul>
                        <li>
                          <button id="ticketingListenerWithSwitch">Ticketing
                            felokosítva
                          </button>
                        </li>
                        <li>
                          <pre>
                                                            function ticketingListenerWithSwitchFunction(firstTime = true) &#123;
                                                          var userExit;

                                                          if (!firstTime) &#123;
                                                                    userExit = prompt('Ki szeretnél lépni a promtból? Kilépéshez gépeld be az `igen` szót');
                                                                &#125;

                                                                if (userExit === 'igen') &#123;
                                                                    return;
                                                                &#125;

                                                                const quantity = prompt('Hány darab jegyet szeretnél?');
                                                                const type = prompt('Felnőtt, vagy diákjegyet szeretnél vásárolni? (adult | student | retired)');

                                                                var types = &#123;
                                                                    student: 300,
                                                                    adult: 350,
                                                                    retired: 280
                                                                &#125;

                                                                var price = types[type];

                                                                if (price === undefined) &#123;
                                                                    alert('Helytelen jegytípus! Add meg újra a jegyek számát, és a típust!');
                                                                    firstTime = false;
                                                                    ticketingListenerWithSwitchFunction(false);
                                                                &#125; else &#123;
                                                                    var discount = quantity > 10 ? 0.9 : 1;

                                                                    var total = quantity * price * discount;

                                                                    alert(total);
                                                                &#125;
                                                            &#125;
                                                        </pre>
                        </li>
                        <li>Ha nem adult, student, vagy retired közül választunk típust,
                          akkor a price-unk undefined
                        </li>
                        <li>Kiegészítettem függvény bemeneti értékkel, ami alapból true</li>
                        <li>Amennyiben rossz jegytípust választ a user, úgy újra meghívódik
                          a prompt függvény, viszont az első kérdés az, hogy ki akar-e
                          lépni
                        </li>

                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3>Function</h3>
  <ul>
    <li>Két fajta szemléletmód létezik
      <ul>
        <li>Alprogram (Subrutine)
          <ul>
            <li>Program a programban, ami futásra szólítható fel</li>
            <li>A memóriában eltárolunk egy "receptet", amit később lefuttatunk</li>
            <li>Procedurális lépések sorozatából álló algoritmus</li>
            <li>
              <pre>
                                    function susdMegARantottat() &#123;
                                  console.log('Önts olajat a serpenyőbe');
                                  console.log('Adj hozzá 3 tojást');
                                  console.log('Adj hozzá fűszereket');
                                  console.log('Süsd meg');
                                  console.log('Kész');
                                    &#125;
                                </pre>
            </li>
            <li>Elhelyeztük a procedurális utasításlistát a memóriába (létrehoztunk egy alprogramot)
            </li>
            <li>Amíg a program futása során nem szólítjuk fel a függvényt futásra, addig nem is fog
              futni
            </li>
            <li>A futásra felszólítás function call-lal, avagy függvény meghívással történik
              <ul>
                <li>susdMegARantottat()</li>
              </ul>
            </li>
            <li>Ha a program ráfut a függvényre, akkor sorról sorra elkezdi futtatni a benne lévő kódot
            </li>
            <li>A függvény lefutása után a program onnan folytatódik, ahonnan a függvény meg lett hívva
              <ul>
                <li>susdMegARantottat()</li>
                <li>***innen folytatódik***</li>
              </ul>
            </li>
            <li>Előnye, hogy a "receptet" csak egyszer tároltuk el a memóriába, innentől, ha szükségünk
              van rá, újra lefuttatjuk
            </li>
            <li>Azzal, hogy elneveztük a függvényt, az utasítások listája fölött egy absztrakciós réteg
              is készítettünk
            </li>
            <li>
              <ul>
                <li>
                  <pre>
                                            function adjHozzaFuszereket() &#123;
                                          console.log('Adj hozzá sót');
                                          console.log('Adj hozzá borsot');
                                          console.log('Adj hozzá paprikát');
                                            &#125;

                                            function susdMegARantottat() &#123;
                                          console.log('Önts olajat a serpenyőbe');
                                          console.log('Adj hozzá 3 tojást');
                                          console.log('Adj hozzá fűszereket'); => Kicserélhető: adjHozzaFuszereket();
                                          console.log('Süsd meg');
                                          console.log('Kész');
                                            &#125;
                                        </pre>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Function, mint matematikai függvény
          <ul>
            <li>Valamilyen input adatot kapnak, és valamilyen output adatot generálnak (fekete doboz)
            </li>
            <li>
              <ul>
                <li>
                  <pre>
                                            function addOne(szam) &#123;
                                          console.log(5);
                                            &#125;
                                        </pre>
                </li>
                <li>Meghatároztunk egy paramétert (szam)</li>
                <li>Aki meghívja a függvényt, adatot szolgáltat</li>
                <li>A paraméterek lokális változóként funkcionálnak, tehát csak a függvényen belül
                  használhatjuk őket (bármire)
                </li>
                <li></li>
              </ul>
            </li>
            <li>Erre a függvényre is igaz, hogy akárhányszor meg lehet hívni, és bármilyen értéket bele
              lehet dobni
            </li>
            <li>A függvényből vissza is lehet térni értékkel
              <ul>
                <li>
                  <pre>
                                            function addOne(szam) &#123;
                                          console.log(5);
                                          return szam + 1;
                                            &#125;

                                            addOne(5);
                                        </pre>
                </li>
                <li>Matematikai függény, beérkezik egy szám, és távozik egy szám</li>
                <li>(number) => number</li>
                <li>
                  <pre>
                                            console.log(addOne(5));
                                        </pre>
                </li>
                <li>A függvény csak leképezi az input adatot output adattá, nem lép interakcióba
                  semmivel
                </li>
                <li>A függvény hívásnál tér vissza a return értékkel, ott tudunk vele valamit
                  kezdeni
                </li>
                <li>Pipeline-ok is létrehozhatók
                  <ul>
                    <li>
                      <pre>
                                                    console.log(addOne(addOne(addOne(3))));
                                                </pre>
                    </li>
                    <li>A visszatérő értéket újra odaadjuk az addOne függvénynek</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Bizonyos tekintetben table lookup-ként is felfogható (táblázatból való kikeresést)
              <ul>
                <li>
                  <pre>
                                            function addTwo(szam)&#123;
                                          return &#123;
                                                    0: 2,
                                                    1: 3,
                                                    2: 4,
                                                &#125;[szam];
                                            &#125;
                                        </pre>
                </li>
                <li>Objektumból dinamikus kulcs alapján kikeresett értékkel térünk vissza</li>
                <li>Beérkezik a szám, és kikeresi a táblázatból, hogy mi a teendője, és
                  megkeresi a
                  megfelelő asszociációt
                </li>
                <li>Egyfajta kulcs alapú kikérés az objektumból</li>
                <li>Szintén építhető pipeline
                  <ul>
                    <li>
                      <pre>
                                                    console.log(addTwo(addTwo(0))); => 4 lesz az eredménye
                                                </pre>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <li>A javascriptben a function az egy úgynevezett first class citizen
    <ul>
      <li>A függvény úgy viselkedik, mint az összes több típus (number, string, object...)</li>
      <li>Tehát változóhoz köthetőek, anonim function formájában</li>
      <li>Egy függvény bemeneti paramétere lehet egy másik függvény</li>
      <li>Függvényből visszatérni is lehet függvénnyel</li>
      <li>Anonim function (névtelen függvény)
        <ul>
          <li>
            <pre>
                                    console.log(addThree(4)); // undefined

                                    var addThree = function(szam) &#123;
                              return szam + 3;
                                    &#125;

                                    console.log(addThree(4)); // 7
                                </pre>
          </li>
          <li>A különbség az a nem anonim függvényekkel szemben, hogy amíg a deklarált, névvel
            ellátott függvények bármikor meghívhatók, a névtelen függvények esetében csak a
            deklarálás után hívhatók meg, máskülönben a változó értéke undefined
          </li>
          <li>A DevTools Console ablakába beírva az addThree-t a következőt kapjuk (bekerült a
            memóriába)
            <ul>
              <li>
                <pre>
                                            addThree
                                            ƒ (szam) &#123;
                                      return szam + 3;
                                            &#125;
                                        </pre>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</div>

<div>
  <h3>Window object</h3>
  <ul>
    <li>A böngészőben biztosítva van egy adatstruktúra, ami ugyanazokból az elemekből épül fel, mint amiket
      átvettünk
    </li>
    <li>Interface-ként szolgál, hogy a böngésző egyes részeit vezérelni tudjuk</li>
    <li>A legkülső réteg a window.object
      <ul>
        <li>Reprezentálja az egész böngésző ablakot</li>
        <li>Ez egy object</li>
        <li>Hozzáférést ad a böngésző egyes komponenseihez</li>
        <li>Futásidőben él a memóriában, és hozzá lehet férni</li>
        <li>
          <pre>
                            console.log(window.object)
                        </pre>
          <ul>
            <li>Megtalálhatjuk a console nevű kulcsát</li>
            <li>A console.log() függvényt is itt található meg</li>
          </ul>
        </li>
        <li>Az egyes kulcsok által hozzáférhetünk egyes részlegekhez</li>
        <li>Egyes funkcionalitások a kulcsok alatt függvények formájában is megjelennek (hozzárendelhetjük
          változóhoz, be lehet dobni függvénybe, vissza lehet térni vele függvényből, vagy objektumban be
          lehet kötni kulcsként)
        </li>
        <li>
          <pre>
                            var window = &#123;
                          console: &#123;
                                    log: function(msg) &#123;
                          // kilogolja az üzenetet
                                    &#125;
                                &#125;
                            &#125;
                        </pre>
          <ul>
            <li>Ha meg akarnánk hívni ezt a függvényt</li>
            <li>
              <pre>
                                    window.console.log('Szia');
                                </pre>
            </li>
            <li>A window objektum kulcsaira nem kell külön hivatkoznunk, működik a console.log('Szia');
              is
            </li>
            <li>A window globális objektum a böngésző kontextusában</li>
            <li>Minden más funkcionalitás, ami a böngésző egy-egy részét vezérli, A window object alatt
              található meg
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <ul>
    <li>Document
      <ul>
        <li>A document kulcs alatt lévő objektum</li>
        <li>A HTML dokumentumot tudjuk vele vezérelni</li>
        <li>A document objecten keresztül minden egyes element minden egyes attribútumához hozzáférésük van
        </li>
        <li>Hozzunk létre a HTML body-jában egy div-et
          <div style="width: 100px; height: 100px; background-color: aqua">box1 (original)</div>
          <div style="width: 100px; height: 100px; background-color: aqua">box2 (modified)</div>
          <div style="width: 100px; height: 100px; background-color: aqua">box2 (click)</div>
          <ul>
            <li>
              <pre>
                                    &#60;div style="width: 100px; height: 100px; background-color: aqua"&#62;&#60;/div&#62;
                                </pre>
            </li>
            <li>Ha megvizsgáljuk a window.document alatt lévő értéket (console-ba: window), lejjebb
              görgőzve az all tartalmazza az összes HTML element javascriptes reprezentacióját
              <ul>
                <li>Köztük van a létrehozott a létrehozott element, aminek a style kulcsa alatt
                  láthatjuk a div-be írt stílusokat
                </li>
                <li>Ha javascript kóddal megváltoztatjuk a kulcsok alatt lévő értékeket, vagy
                  bármely más attribútum kapcsán valami értéket, a böngésző ezt észreveszi, és
                  újra renderelt az oldalt
                </li>
                <li>Az egyes kulcsok fölé húzva az egeret a DevTools Console fülén, miután beírtuk a
                  window parancsot, megjelenik a kulcsos index alapú kikéréseket
                </li>
                <li>JS fájlban változtassuk meg a dobozunk háttérszínét
                  <ul>
                    <li>document.all[647].style.backgroundColor = "red"</li>
                    <li>Megjegyzés: A módosítást settimeout-ba raktam</li>
                    <li>Villanás erejéig látszik, hogy kék színnel kezdte a doboz a
                      pályafutását, de mi javascript kóddal megmódosítottuk a színét ennek az
                      elemnek (settimeout nélkül is)
                    </li>
                    <li>Mindig arra van szükség, hogy hozzájussunk az adott elementet
                      reprezentáló objektumhoz, hogy bekössünk értékeket
                    </li>
                    <li>Function-t is beköthetünk kulcs alá, például, ha adott eseménykor
                      szeretnénk függvényt lefuttatni
                      <ul>
                        <li>Ilyen például az onclick kulcs</li>
                        <li>Ha azt szeretnénk, hogy gombnyomásra legyen piros a doboz:</li>
                        <li>
                          <pre>
                                                            document.all[648].onclick = function() &#123;
                                                          // Itt bármi futtatható
                                                          document.all[648].style.backgroundColor = "Red"
                                                            &#125;
                                                        </pre>
                        </li>
                        <li>Szintén kellett egy kis settimeout</li>
                        <li>Az elem onclick kulcsa alá bekötöttünk egy funkcionalitást, de
                          ez még nem futott le, nem lett még meghívva
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Bármikor, amikor interaktivitást szeretnél javascripttel, három dologra van szükség
          <ul>
            <li>Az adott element javascriptes reprezentációjára</li>
            <li>Milyen esemény kapcsán akarsz kódot futtatni</li>
            <li>Milyen kódot akarsz futtatni</li>
          </ul>
        </li>
        <li>A document.all[5] nem a legpraktikusabb módja az egyes elementek document object kiválasztására,
          mert beégetett index szerepel benne
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3>HTTP protokol</h3>
  <ul>
    <li>User interface
      <ul>
        <li>Amit a böngészőben látunk, az a User interface, avagy UI</li>
        <li>Az a felület, amivel a felhasználó interakcióba lép</li>
      </ul>
    </li>
    <li>State (alkalmazás állapot) / Controller
      <ul>
        <li>Tulajdonképpen egy adatstruktúra, amit az alkalmazás futtatása során a memóriában tartunk</li>
        <li>A lehető legminimálisabb módon leírja a UI-on megjelenő elemeket</li>
        <li>Tehát minden információt tartalmaz, hogy az interface kirajzolódhasson</li>
        <li>Egy egyszerű drag&drop esetén, ahol 3 dobozt húzogathatunk a képernyőn, a state tartalmazza a
          dobozok koordinátáit (x, y, z), és azt, hogy melyik van éppen drag-elve
        </li>
        <li>A programjainkban mindig van state definiálva, és a User interface-en változtatható dolgok a
          state leképződései
        </li>
        <li>Bármilyen adatstruktúra lehet, nem feltétlenül objektum</li>
        <li>A state nem egy statikus adatstruktúra, hanem futás időben a memóriában folyamatosan felülíródik
          a user interface eseményei alapján
        </li>
        <li>Ha a felhasználó különféle elemmel interakcióba lép, manipulálja az alkalmazás állapotát</li>
        <li>Nekünk kell megírni, hogy a felhasználó tevékenységei milyen értékváltozást okozzon</li>
        <li>Controller
          <ul>
            <li>Az eseménykezelőket, és a state-et nevezzük így</li>
            <li></li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Template (sablon)
      <ul>
        <li>Eléri, hogy az adatstruktúrából konkrét elemek legyenek</li>
        <li>Alapvetően HTML elemek vannak itt</li>
        <li>Az itt leírt elemek képzik a UI statikus részét, tehát a 3 dobozos drag&drop-ot tekintve a
          dobozokat, a dobozok színeit, méretét, tehát a kirajzolt tartalmat
        </li>
        <li>A dobozok pozíciója viszont változik, dinamikus</li>
        <li>String interpoláció
          <ul>
            <li>Amikor a state-ből a tartalom a sablon dinamikus részébe kerül</li>
          </ul>
        </li>
        <li>A sablonban egyszerű control struktúrák is lehetnek
          <ul>
            <li>Akár if statementek, ciklusok</li>
            <li>Tipikusan, ha az állapotban egy tömbnyi elem van jelen, akkor azok állapotát ciklussal
              szokás kirajzolni
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Renderelés
      <ul>
        <li>
          Az egész művelet sorozatot, tehát a state-et alapul véve, egy sablon összeollúzunk, dinamikus
          adatokat felhasználva, és akár control struktúrákat is futtatva
        </li>
      </ul>
    </li>
    <li>Komponens
      <ul>
        <li>A controllert és a sablon logikát összefoglalóan komponensnek hívjuk</li>
        <li>Angular
          <ul>
            <li>A controller és a template 2 külön fájlban van definiálva (tipikusan)</li>
          </ul>
        </li>
        <li>React
          <ul>
            <li>A controllert és a template-et 1 fáljban kell definiálni (tipikusan)</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A folyamat
      <ul>
        <li>Végfelhasználóként letöltve az oldalt az alábbi folyamatok játszódnak le
          <ul>
            <li>Először is, az alkalmazásnak van egy kiindulási állapota, megtörténik a renderelés,
              tehát a kezdeti state, és a meghatározott statikus sablon alapján megjelenik a User
              interface-en a tartalom
            </li>
            <li>A felhasználó interakcióba lép az oldallal, ami állapotmódosítást okoz, amit renderelés
              követ, a frissített adatokkal, aminek következtében a UI-on frissül a tartalom
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Megjegyzés: Javascript 3. gyakorló feladatsor a drag&drop</li>
  </ul>
</div>

<div>
  <h3>Dobozok</h3>
  <div class="container" style="display: inline-block; padding-bottom: 50px;">
    <div class="shape" id="element-one">
      <span class="text">
        1
      </span>
    </div>
    <div class="shape" id="element-two">
      <span class="text">
        2
      </span>
    </div>
    <div class="shape" id="element-three">
      <span class="text">
        3
      </span>
    </div>
    <div class="shape" id="element-four">
      <span class="text">
        4
      </span>
    </div>
    <div class="shape" id="element-five">
      <span class="text">
        5
      </span>
    </div>
    <div class="shape" id="element-six">
      <span class="text">
        6
      </span>
      <form id="box-6">
        <input class="w-95" type="number" name="boxNumber" style="width: 40%">
        <button class="w-100" type="submit" style="width: 50%;">Küldés</button>
      </form>
    </div>
    <div class="shape" id="element-seven">
      <span class="text">
        7
      </span>
      <input class="w-95" type="text" name="boxNumber" id="box7-input">
    </div>
    <div class="shape parent-table" id="element-eight">
      <span class="child-table">
        8
      </span>
    </div>
    <div class="shape" id="element-nine">
      <span class="text">
        9
      </span>
      <form id="box-9">
        <select name="operator">
          <option value="mult">×</option>
          <option value="div">/</option>
          <option value="add">+</option>
          <option value="sub">-</option>
        </select>
        <input class="w-95" type="number" name="operand" style="width: 50%">
        <button class="w-100" type="submit" style="width: 50%;">Küldés</button>
      </form>
    </div>
  </div>
  <ul>
    <li>Megjegyzések
      <ul>
        <li>Ha a scripteket a body után helyezzük el az index.html-ben, akkor a scriptek akkor fognak
          lefutni, ha a HTML elemek már kirajzolódtak
        </li>
        <li>Ha mindenképp a fájl elejére szeretnénk tenni a scripteket, akkor használhatunk a JS-ben
          DOMContentLoaded eseményt, ami szintén csak akkor fut le, amikor a DOM már betöltődött
        </li>
        <li>a console.log() egy adott változó vagy érték általános kimenetét adja meg, míg a console.dir()
          az objektumok részletes tulajdonságait és metódusait jeleníti meg
        </li>
        <li>getElementById() függvény esetében a console.log() a HTML elemet adja vissza
          <ul>
            <li>
              <pre>
                                    &#60;div class="shape" id="element-one"&#62;
                                        &#60;span class="text"&#62;
                                            1
                                        &#60;/span&#62;
                                    &#60;/div&#60;2
                                </pre>
            </li>
          </ul>
        </li>
        <li>getElementById() függvény esetében a console.dir() egy objektumot ad vissza (a DevTools-ban
          kinyitható)
          <ul>
            <li>
              <pre>
                                    div#element-one.shape
                                </pre>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <ul>
    <li>1. doboz:
      Kattintásra adjunk hozzá egy "blur" nevű class attribútumot, majd újabb kattintásra vegyük
      le róla azt.
      <ul>
        <li>document.getElementById('element-one');
          <ul>
            <li>Ha létezik ilyen ID-jú element, a getElementById() függvény vissza fog térni az elemmel
            </li>
            <li>Ha nem létezik ilyen ID-jú element, akkor null-al tér vissza</li>
          </ul>
        </li>
        <li>console.log(document.getElementById('element-one'));</li>
        <li>
          <pre>
                            var isBlured = false;

                            document.getElementById('element-one').onclick = function () &#123;
                          isBlured = !isBlured;

                          /* if (isBlured) &#123;
                                    document.getElementById('element-one').classList.add('blur');
                                &#125; else &#123;
                                    document.getElementById('element-one').classList.remove('blur');
                                &#125; */

                                isBlured ? document.getElementById('element-one').classList.add('blur') : document.getElementById('element-one').classList.remove('blur');
                            &#125;
                        </pre>
          <ul>
            <li>State-et hozunk létre a függvény scope-ján kívül, amiben eltároljuk, hogy rajta van-e a
              blur class az elemen, vagy sem
            </li>
            <li>Az isBlured állapotát módosítgatjuk</li>
            <li>Kint van a doboz a User interface-en, az alkalmazásunkban történik valami esemény
              (rákattintunk az 1-es számú dobozra), ennek hatására megváltozik az alkalmazásunk belső
              állapota (boolean-t negálunk), és ez után történik egy renderelés (a state change miatt)
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>2. doboz:
      Ha az egérrel fölé megyünk változzon meg a háttérszíne pirosra, ha levesszük róla az egeret
      változzon vissza az eredeti színére
      <ul>
        <li>
          <pre>
                            var isHovered = false;
                            var elementTwo = document.getElementById('element-two');

                            elementTwo.onmouseover = function () &#123;
                          isHovered = true;
                          renderSecondBox();
                            &#125;

                            elementTwo.onmouseout = function () &#123;
                          isHovered = false;
                          renderSecondBox();
                            &#125;

                            function renderSecondBox() &#123;
                          isHovered ? (elementTwo.style.backgroundColor = 'red') : (elementTwo.style.backgroundColor = '');
                            &#125;
                        </pre>
        </li>
        <li>Ha például a backgroundColor-hoz üres string kerül, akkor az eredeti CSS szabály fog
          alkalmazódni
        </li>
        <li>A state-et minden eseménykor megváltoztatjuk, és ezt mindig újra renderelés követi</li>
        <li>Tehát az action (mouseover és mouseout) bekövetkezésekor state change (isHovered megváltozik)
          történik, ami újra renderelést eredményez
        </li>
      </ul>
    </li>
    <br>
    <li>3. doboz:
      Dupla kattintással sorsoljon egy számot 1 és 20 között és módosítsa a kapott számmal a doboz tartalmát
      <ul>
        <li>
          <pre>
                            var elementThree = document.getElementById('element-three');

                            elementThree.ondblclick = function() &#123;
                          // document.getElementById('element-three').firstElementChild.innerHTML = randomNumberGenerator(1, 20);
                          elementThree.innerHTML = '&#60;span class="text"&#62;' + randomNumberGenerator(1, 20); + '&#60;/span&#62;'
                            &#125;

                            function randomNumberGenerator(min, max) &#123;
                          return Math.floor(Math.random() * (max - min) + min);
                            &#125;
                        </pre>
        </li>
        <li>A Math.floor() lefelé kerekíti az adott értéket</li>
        <li>Math.random() * (20 + 1) + 1 => 1 és 20 között generál nekünk számot</li>
        <li>A belső span-t is el lehetett volna látni ID-val, kiszelektálni, és ennek útján megváltoztatni a
          számot
        </li>
        <li>A kiszelektált 'element-three'-nek van egy olyan kulcsa, hogy firstElementChild (console.dir-rel
          láthatjuk), ezt is változtathatjuk a scriptben
          <ul>
            <li>A firstElementChild értéke egy referencia a belső értékre</li>
            <li>Általánosságban elmondható, hogy az elemek alatt találhatók olyan kulcsok, amikre
              további elemekre mutató referenciák vannak (pl.: childNodes)
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>4. doboz:
      Kattintásra tűnjön el, majd egy 1 másodperces várakozás után ismét jelenjen meg
      <ul>
        <li>
          <pre>
                            var elementFour = document.getElementById('element-four');

                            elementFour.onclick = function () &#123;
                          // elementFour.classList.add('hidden') ;
                          elementFour.style.visibility = 'hidden';
                          elementFourIsVisibleAgain();
                            &#125;

                            function elementFourIsVisibleAgain() &#123;
                          setTimeout(() => &#123;
                                    // elementFour.classList.remove('hidden');
                                    elementFour.style.visibility = 'visible';
                                &#125;, 1000);
                            &#125;
                        </pre>
        </li>
        <li>Szükségünk van egy olyan funkcionalitásra, ami késleltetni tudja egy függvény végrehajtását</li>
        <li>setTimeout
          <ul>
            <li>
              <pre>
                                    setTimeout(function () &#123;console.log('Hi')&#125;, 1000);
                                </pre>
            </li>
            <li>Bemenetként vár egy névtelen függvényt, és egy számértéket (number)</li>
            <li>A függvény akkor fog lefutni, ha letelt a milliszekundumban meghatározott</li>
            <li>Célszerűbb class-okat használni, mint az elemek style attribútumát piszkálni</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>5. doboz:
      Kattintásra alakítsa kör alakúra az összes dobozt
      <ul>
        <li>
          <pre>
                            var elementFive = document.getElementById('element-five');
                            var containerChildren = document.querySelector('.container').children;
                            var allElements = document.querySelectorAll('.shape');
                            var elements = document.getElementsByClassName('shape');

                            elementFive.onclick = function () &#123;
                          console.log('containerChildren HTMLCollection: ', containerChildren);
                          /* Array.from(elements).forEach(function (element) &#123;
                                    console.log('element',  element);
                                    element.classList.add('box5style');
                                &#125;); */

                                allElements.forEach(function (element) &#123;
                                    console.log('NodeList element: ', element);
                                    // element.style.borderRadius = '50%'; // Classal célszerűbb
                                    element.classList.add('box5style');
                                &#125;);

                                /* for (var element of allElements) &#123; // Szintén forEach()
                                    element.classList.add('box5style');
                                &#125; */
                            &#125;
                        </pre>
        </li>
        <li>Meg lehetett volna oldani úgy is, hogy a container class gyerekein hajtódik végre az átalakítás
          <ul>
            <li>A querySelector() függvény bármilyen alapú kikérésre használható</li>
            <li>querySelector(.class) / querySelector(#id)</li>
            <li>document.querySelector('.container').children;
              <ul>
                <li>Láthatjuk, hogy mivel tér vissza: &#60;div class="container"&#62;...&#60;/div&#62;
                  (HTMLCollection, nem tudunk rajta csak úgy végig iterálni!)
                </li>
                <li>Benne vannak a child elemek</li>
                <li>Tudjuk azt, hogy az elem rendelkezik olyan kulcsokkal, ami ilyen-olyan
                  referenciákat hordoz (más elementre mutat)
                </li>
                <li>A children kulcs egy HTMLCollection-t hordoz, az adott elem gyerekeit</li>
                <li>Innentől már csak át kell iterálni a listán, és megváltoztatni a gyerekek
                  alakját
                  <ul>
                    <li>HTMLCollection iteráció</li>
                    <li>
                      <pre>
                                                    Array.from(elements).forEach(function (element) &#123;
                                                  console.log('Array from elements: ', element);
                                                    &#125;);
                                                </pre>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>document.querySelectorAll('.shape');
              <ul>
                <li>NodeList-et eredményez</li>
                <li>Végig tudunk rajta iterálni mindenféle átalakítás nélkül</li>
                <li>Az első ciklus "tartalma"
                  <ul>
                    <li>
                      <pre>
                                                    &#60;div class="shape box5style" id="element-one"&#62;
                                                        #>60span class="text"&#62;
                                                            1
                                                        #>60/span&#62;
                                                    &#60;/div&#62;
                                            </pre>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Debugger toolal végigkövethető minden egyes változás
              <ul>
                <li>DevTools -> Sources -> boxes.js</li>
                <li>Majd azoknak a soroknak a számaira kell kattintani, ahol meg akarjuk állítani a
                  futást
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>6. doboz:
      Form submit eseményre módosítsuk a doboz tartalmát az input mezőbe írt értékkel
      <ul>
        <li>Felhasználói interakciót kívánnak meg a következő dobozok</li>
        <li>Meg kell tanulnunk, mi az az event object</li>
        <li>Event handler function
          <ul>
            <li>Amikor meghívódnál bármilyen esemény kapcsán, paramétert is kapnak</li>
            <li>Ez a paraméter az event object</li>
            <li>Adatcsomag, ami az adott esemény kapcsán generálódik ki, és tartalmaz mindenféle
              információt az esemény kapcsán
            </li>
            <li>
              <pre>
                                    elementSixFormItem.onsubmit = function (event) &#123;
                                  event.preventDefault();
                                  console.log('Element 6 event: ', event);
                                  console.log('Element 6 event: ', event.target);
                                    &#125;;
                                </pre>
              <ul>
                <li>A form submitolásával az oldalunk befrissülne, így az alap javascriptes működést
                  felül kell írnunk
                </li>
                <li>Tulajdonképpen egy HTTP kérés történne</li>
                <li>Jelenleg ez egy nemkívánatos effekt</li>
                <li>Az event.preventDefault(); megakadályozza a default javascriptes működést</li>
                <li>Az event object target kulcsa mutat azon elemre, amire az esemény bekövetkezett
                  <ul>
                    <li>Jelen esetben az egész form elementre</li>
                    <li>
                      <pre>
                                                    &#60;form id="box-6"&#62;
                                                        &#60;input class="w-95" type="number" name="boxNumber" style="width: 40%"&#62;
                                                        &#60;button class="w-100" type="submit" style="width: 50%;"&#62;Küldés&#60;/button&#62;
                                                    &#60;/form&#62;
                                                </pre>
                    </li>
                  </ul>
                </li>
                <br>
                <li>Nekünk az input mező értékére van szükségünk
                  <ul>
                    <li>Az event.target.elements kulcs tartalmaz egy
                      HTMLFormControlsCollection-t
                      <ul>
                        <li>Indexált formában benne van az input mező, és a gomb</li>
                        <li>A 0, és az 1 index mellett szerepel jelen esetben még egy kulcs:
                          boxNumber
                          <ul>
                            <li>Ez nem más, mint az input mező name attribútuma</li>
                            <li>event.target.elements.boxNumber.value => Így kérhető ki
                              az input értéke
                            </li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                    <li>Az input mező elérése: event.target.elements[0]
                      <ul>
                        <li>
                          <pre>
                                                            &#60;input class="w-95" type="number" name="boxNumber" style="width: 40%"&#62;
                                                        </pre>
                        </li>
                      </ul>
                    </li>
                    <li>A két kikérési mód ugyanúgy jó
                      <ul>
                        <li>event.target.elements[0].value (Az input mező a 0 index alatt
                          szerepel)
                        </li>
                        <li>event.target.elements.boxNumber.value</li>
                      </ul>
                    </li>
                    <li>
                      HTML:
                      <pre>
                                                    &#60;form id="box-6"&#62;
                                                        &#60;input class="w-95" type="number" name="boxNumber" style="width: 40%"&#62;
                                                        &#60;button class="w-100" type="submit" style="width: 50%;">Küldés&#60;/button&#62;
                                                    &#60;/form&#62;
                                                </pre>
                    </li>
                    <li>
                      <pre>
                                                    var elementSixFormItem = document.getElementById('box-6');

                                                    elementSixFormItem.onsubmit = function (event) &#123;
                                                  event.preventDefault();
                                                  console.log('Element 6 event / target / elements[0] / value: ', event.target.elements[0].value);
                                                  console.log('Element 6 event / target / boxName / value: ', event.target.elements.boxNumber.value);

                                                  elementSixFormItemInputValue = event.target.elements.boxNumber.value;

                                                  console.log('elementSixFormItem / parentElement / firstElementChild: ', elementSixFormItem.firstElementChild.firstChild);

                                                  elementSixFormItem.parentElement.firstElementChild.innerHTML = elementSixFormItemInputValue;
                                                    &#125;;
                                                </pre>
                      <ul>
                        <li>A parentElement.firstElement (ezzel próbálkoztam először) mást
                          ad vissza, és nem működik az innetHTML!
                        </li>
                        <li>A parentElement.firstElementChild a következőt adja vissza
                          <ul>
                            <li>
                              <pre>
                                                                    &#60;span class="text"&#62;1&#60;/span&#62;
                                                                </pre>
                            </li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>7. doboz:
      Keypress eseményre írjuk be a dobozba az adott karaktert, amit leütöttek
      <ul>
        <li>
          <pre>
                            var elementSevenFormInputValue = document.getElementById('box7-input');
                            var character = '';

                            elementSevenFormInputValue.onkeypress = function (event) &#123; // Az onkeypress deprecated!
                                var currentCharacter = event.key;
                                if (currentCharacter.length &#60; 2) &#123;
                                    elementSevenFormInputValue.parentElement.firstElementChild.innerHTML = currentCharacter;
                                    character = currentCharacter;
                                &#125;
                            &#125;

                            elementSevenFormInputValue.addEventListener('blur', function () &#123;
                          elementSevenFormInputValue.parentElement.firstElementChild.innerHTML = '7';
                          elementSevenFormInputValue.value = '';
                            &#125;);
                        </pre>
        </li>
        <li>Itt nincs formban az input mező, és az inputnak van ID-ja, így explicite kiszelektálhatjuk az
          input mezőt
        </li>
        <li>Közvetlenül az input mező event handler eseményére kell reagálnunk</li>
        <li>Az onkeypress-nek van eventje (KeyboardEvent object)</li>
        <li>Az eseményben key kulcs alatt érhető el a leütött billentyű</li>
        <br>
        <li>A feladatot annyival egészítettem ki, hogy egy karakternél többet nem lehet beírni a kockába,
          illetve kapott egy event listenert az input, és blur-re visszakerül a kocka eredeti értéke,
          illetve az input mező value-ja kap egy üres stringet
        </li>
      </ul>
    </li>
    <li>8. doboz:
      Egérmozdítás eseményre írjuk be az egér pozíciójának x és y koordinátáját,
      a következő séma szerint: "X: &#123;x-koordináta&#125;, Y: &#123;y-koordináta&#125;"
      <ul>
        <li>
          <pre>
                            var elementEightText = document.getElementById('element-eight').firstElementChild;

                            elementEightText.innerHTML = '10';

                            document.onmousemove = function (event) &#123;
                          elementEightText.innerHTML = '<div>X: ' + event.x + '</div><div>Y: ' + event.y + '</div>'
                            &#125;
                        </pre>
        </li>
        <li>Összekonkatenáltuk a doboz szövegének tartalmát</li>
      </ul>
    </li>
    <li>9. doboz:
      Submit eseményre módosítsuk a doboz tartalmát azzal az értékkel ami úgy áll elő,
      hogy végrehajtjuk a select inputban kiválasztott operációt,
      a state-en és number inputba beírt értéken

      Az előállt végeredményt tároljuk el új state-ként!

      Pl:
      Number input mezőbe írt érték: 5
      Select inputban kiválasztott érték: "mult"
      Aktuális state: 9

      Operáció: 9 * 5

      Dobozba és state-be beírandó érték: 45
      <ul>
        <li>
          <pre>
                            var state = 9;
                            var elementNineForm = document.getElementById('box-9');

                            elementNineForm.onsubmit = function (event) &#123;
                          event.preventDefault();
                          var operand = Number(event.target.elements.operand.value); // Inputba írt szám
                          var operator = event.target.elements.operator.value; // Művelet
                          var currentNumber = Number(elementNineForm.parentElement.firstElementChild.textContent.trim()); // vagy .innerHTML
                          elementNineForm.parentElement.firstElementChild.innerHTML = eredmeny(currentNumber, operator, operand);
                            &#125;

                            function eredmeny(currentNumber, muvelet, inputNumber) &#123;
                          switch(muvelet) &#123;
                            case 'mult':
                            state = currentNumber * inputNumber;
                            break;
                            case 'div':
                            state = currentNumber / inputNumber;
                            break;
                            case 'add':
                            state = currentNumber + inputNumber;
                            break;
                            case 'sub':
                            state = currentNumber - inputNumber;
                            break;
                            &#125;
                            return state;
                            &#125;
                            </pre>
        </li>
        <li> Az alap működést felülírjuk az event.preventDefault() függvénnyel</li>
        <li> A szám number inputból érkezik, mégis string
          <ul>
            <li> A számot a továbbiakban márpedig aritmetikai műveletekre akarjuk használni</li>
            <li> Number() függvénnyel a sting számmá alakítható (numberrel tér vissza a függvény)</li>
          </ul>
        </li>
        <li></li>
      </ul>
    </li>
  </ul>
</div>

<div class="template-literal-container">
  <div class="mb-3"></div>
  <div class="container">
    <div class="row">
      <div class="col-3">
      </div>
      <div class="col-6">
        <div id="photos-list-container">

        </div>
      </div>
      <div class="col-3">
      </div>
    </div>
  </div>
</div>

<div>
  <h3>Template literal</h3>
  <ul>
    <li> Nyelvi eszköz, amivel egyszerűen lehet HTML tartalmat összeállítani</li>
    <li> Javascript kóddal generáljuk a HTML - t</li>
    <li> Dinamikus tartalom csak a Javascript kód futásakor érhető el(nem statikus tartalom), tehát csak
      futásidőben lesz elérhető az adat
    </li>
    <li> Az ilyen adatok tipikusan szerver oldali kérések révén érkezik meg a klienshez</li>
    <li> A HTML - ben biztosítani kell egy belépési pontot(photo - list - container class)</li>
    <li>
      <pre>
      &#60;div class = "template-literal-container" &#62;
      &#60;div class = "mb-3" &#62; &#60; / div &#62;
      &#60;div class = "container" &#62;
      &#60;div class = "row" &#62;
      &#60;div class = "col-3" &#62;
      &#60; / div &#62;
      &#60;div class = "col-6" &#62;
      &#60;div id = "photos-list-container" &#62;

      &#60; / div &#62;
      &#60; / div &#62;
      &#60;div class = "col-3" &#62;
      &#60; / div &#62;
      &#60; / div &#62;
      &#60; / div &#62;
      &#60; / div &#62;
      </pre>
    </li>
    <li> Létrehozunk egy változót
      <ul>
        <li>
          <pre>
          var photoListTemplate = '';
          </pre>
        </li>
        <li> A string - et a javascript nyelvben nem lehet tördelni(szintaktikailag nem helyes), így
          kényelmetlen a következőképp dolgozni
          <ul>
            <li>
              <pre>
for(var photo of photos) &#123;
photoListTemplate = photoListTemplate + '&#60;div class="card p-5"&#62;' + card.title + '&#60;/div&#62;'
&#125;
</pre>
            </li>
          </ul>
        </li>
        <li> Nagyobb template esetén szükségünk van a tördelésre
          <ul>
            <li> Itt jön a képbe a template literal</li>
            <li> Két dologra jó
              <ul>
                <li> Betördelhető, tehát átláthatóbbá tehetők a string - ek</li>
                <li> A dinamikus adatokat könnyebb beleírni, nem kell + jelekkel folyamatosan
                  megszakítani a kódot
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li> Backtick karakter
          <ul>
            <li>Úgy néz ki, mint egy idézőjel, de nem az(ALT + 7)</li>
            <li> Két backtick közé jön a tartalom(template)</li>
            <li> A dinamikus tartalom $&#123;&#125; karakterek közé írt változóval valósítható meg</li>
            <li> Kifejezéseket is létre lehet hozni
              <ul>
                <li>
                  <pre>
                  ...
                  &#60;div class = "card p-5 $&#123;photo.id === 3 ? 'bg-light' : ''&#125;" &#62;
                  ...
                  </pre>
                </li>
                <li></li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
          <pre>
          var photoListTemplate = '';

          for(var photo of photos) &#123;
          photoListTemplate = photoListTemplate + `
          &#60;div id = "$&#123;photo.id&#125;" class = "card p-5"
          style = " border: 1px solid grey;
          border - radius: 5px;
          padding: 10px;
          $&#123;photo.id === 3 ? 'background-color: pink' : ''&#125;"&#62;
          &#60;div &#62;
          &#60;small &#62;$&#123;photo.title&#125;&#60; / small &#62;
          &#60; / div &#62;
          &#60;br &#62;
          &#60;img src = "$&#123;photo.thumbnailUrl&#125;" &#62;
          &#60; / div &#62;
          &#60;br &#62;
          `
          &#125;

          document.getElementById('photos-list-container').innerHTML = photoListTemplate;
          </pre>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3>Workshop project</h3>
  <ul>
    <li> CRUD
      <ul>
        <li> Create</li>
        <li> Read</li>
        <li> Update</li>
        <li> Delete</li>
      </ul>
    </li>
    <br>
    <li> Read
      <pre>
      var state = &#123;
      products: [
      &#123;name: 'Termék 1', price: 2500, isInStock: true&#125;,
      &#123;name: 'Termék 2', price: 3500, isInStock: true&#125;,
      &#123;name: 'Termék 3', price: 4500, isInStock: true&#125;,
      ]
      &#125;
      </pre>
      <ul>
        <li>Ez az alkalmazásunk alap belső állapota</li>
        <li>Ha a usernek meg akarjuk jeleníteni a termékeket, akkor a Read műveletet kell megvalósítani</li>
        <li>Létre kell hozni a renderelő függvényt, ami a termékeket kilistázza
          <ul>
            <li>
              <pre>
                        function renderProducts() &#123;
                                  const productListComponent = document.getElementById('product-list-component');

                                    productsHTML = ''
                                    for(var prod of state.products) &#123;
                                    productsHTML + = `
                                    &#60;div class = "card m-2 p-2 $&#123;!prod.isInStock ? 'bg-danger' : ''&#125;""&#62;
                                    &#60;i class = "fas fa-check" &#62; &#60; / i &#62;
                                  &#60;p &#62;Terméknév: $&#123;prod.name&#125;&#60; / p &#62;
                                  &#60;p &#62;Terméknév: $&#123;prod.price&#125;&#60; / p &#62;
                                  &#60; / div &#62;
                                    `
                                    &#125;

                                    productListComponent.innerHTML = productsHTML
                                    &#125;

                                    window.onload = renderProducts;
                                    </pre>
            </li>
            <li> A + = hozzáad a változó aktuális tartalmához</li>
            <li> A window.onload
              <ul>
                <li> Esemény</li>
                <li> A renderProducts függvény akkor fog lefutni, amikor az oldal betöltődött, és
                  minden
                  elem
                  rendelkezésre áll
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li> Create
      <ul>
        <li> A felhasználónak képesnek kell lennie új adatokat bevinni a rendszerbe</li>
        <li>
          <pre>
          document.getElementById('create-product').onsubmit = function(event) &#123;
          event.preventDefault();
          state.products.push(&#123;
          name: event.target.elements.name.value,
          price: Number(event.target.elements.price.value),
          isInStock: event.target.elements.isInStock.checked,
          &#125;);

          renderProducts();
          &#125;
          </pre>
        </li>
        <li> Form submit eseményhez bekötöttünk egy függvényt</li>
        <li> A price a kiszelektálás után string volt, ezért átkonvertáltuk számmá
        </li>
        <li> A state change után újra kell renderelnünk a listát</li>
      </ul>
    </li>
    <li> Delete
      <ul>
        <li> Ehhez megmódosítjuk a product tömbünk minden elemét, mégpedig úgy, hogy ellátjuk őket ID - val
        </li>
        <li>
          <pre>
          var state = &#123;
          products: [
          &#123;id: createRandomID(), name: 'Termék 1', price: 2500, isInStock: true&#125;,
          &#123;id: createRandomID(), name: 'Termék 2', price: 3500, isInStock: false&#125;,
          &#123;id: createRandomID(), name: 'Termék 3', price: 4500, isInStock: true&#125;,
          ]
          &#125;
          </pre>
        </li>
        <li>Hozzáadtunk egy button-t minden card-hoz, amiket elláttunk data-productid attribútummal
          <ul>
            <li>
              <pre>
                                productsHTML = ''
                                    for (var prod of state.products) &#123;
                                  productsHTML + = `
                                    &#60;div class = "card m-2 p-2 $&#123;!prod.isInStock ? 'bg-danger' : ''&#125;" &#62;
                                  &#60;i class = "fas fa-check" > &#60; / i &#62;
                                  &#60;p > ID: $&#123;prod.id&#125;&#60; / p &#62;
                                  &#60;p > Terméknév: $&#123;prod.name&#125;&#60; / p &#62;
                                  &#60;p >Ár: $&#123;prod.price&#125;&#60; / p &#62;
                                  &#60;button class = "btn btn-danger float-right delete-product" data - productid = "$&#123;prod.id&#125;" onclick = "deleteProduct('$&#123;prod.id&#125;')" > Törlés &#60; / button &#62;
                                  &#60; / div >
                                    `
                                    &#125;
                                    </pre>
              <ul>
                <li> A gombnak továbbá adtunk egy delete - product class - t</li>
                <li> Tömbből úgy tudunk törölni, ha megkeressük azt a tömbelem indexét, aminek az az
                  ID - ja,
                  amit a gombra nyomáskor kaptunk(data - productid)
                </li>
                <li>
                  <pre>
                  for(var delBtn of document.querySelectorAll('.delete-product')) &#123;
                  delBtn.onclick = function() &#123;
                  console.log(event.target.dataset);
                  console.log(event.target.dataset.productid);

                  var id = event.target.dataset.productid;

                  var foundIndex;
                  for(var i = 0; i &#60; state.products.length; i + +) &#123;
                  if (state.products[i].id === id) &#123;
                  foundIndex = i;
                  break;
                  &#125;
                  &#125;
                  state.products.splice(foundIndex, 1);
                  renderProducts();
                  &#125;
                  &#125;
                  </pre>
                </li>
                <li> Végigmegyünk a delete - product class - okon, és minden elem onclick - jéhez adunk egy
                  függvényt
                </li>
                <li> A datasetben az adott elem 'data-' - val kezdődő attribútumai vannak felsorolva
                </li>
                <li> Kikerestük az megfelelő ID - t</li>
                <li> Használhatunk egy statementet az iteráción belül
                  <ul>
                    <li> break;
                    </li>
                    <li> Kilépteti a ciklust a működésből</li>
                  </ul>
                </li>
                <li> Végül a splice függvény használatával unset - eljük a tömbelemet a tömbből</li>
                <li>.splice(hányadik elem, a hányadik elemtől hány elem)
                </li>
              </ul>
            </li>
            <li>Én külön egy onclick függvényt is hozzáadtam, így a deleteProduct függvénybe megérkezik
              az
              azonosító
              <ul>
                <li>
                  function deleteProduct(id) &#123;
                  state.products.splice(state.products.findIndex(f = > f.id === id), 1);
                  renderProducts();
                  &#125;
                </li>
                <li>A findIndex függvénnyel megkereshetjük a kattintott gombnak megfelelő termék
                  indexét
                  a tömbben, majd a splice függvénnyel kitörölhetjük a tömbből
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Update
      <ul>
        <li>Biztosítani kell egy eszközt a user interface-en, amivel a user tud frissíteni</li>
        <li>Szükség van egy szerkesztés gombra, amire ki kell renderelni egy form-ot, ahol frissíthető a
          state
        </li>
        <li>
          <pre>
                        productsHTML = ''
                            for (var prod of state.products) &#123;
                                productsHTML += `
                                &#60;div class="card m-2 p-2 $&#123;!prod.isInStock ? 'bg-danger' : ''&#125;">
                                    &#60;i class="fas fa-check">&#60;/i&#62;
                                    &#60;p&#62;ID: $&#123;prod.id&#125;&#60;/p&#62;
                                    &#60;p&#62;Terméknév: $&#123;prod.name&#125;&#60;/p&#62;
                                    &#60;p&#62;Ár: $&#123;prod.price&#125;&#60;/p&#62;
                                    &#60;button class="btn btn-success mb-1 float-right edit-product" data-productid="$&#123;prod.id&#125;" onclick="editProduct('$&#123;prod.id&#125;')">Szerkesztés&#60;/button&#62;
                                    &#60;button class="btn btn-danger float-right delete-product" data-productid="$&#123;prod.id&#125;" onclick="deleteProduct('$&#123;prod.id&#125;')">Törlés&#60;/button&#62;
                                &#60;/div>
                            `
                            &#125;

                        for (var editBtn of document.querySelectorAll('.edit-product')) &#123;
                            editBtn.onclick = function () &#123;
                                state.editId = event.target.dataset.productid;
                            &#125;
                        &#125;
                    </pre>
        <li>Azzal, hogy a gombok onclick kulcsának függvényt határozunk meg javascriptben, az inline írt
          onclick-et felülírjuk
        </li>
      </ul>
    </li>
    <li>A state-hez hozzáillesztettünk egy editId kulcsot
      <ul>
        <li>
          <pre>
                                var state = &#123;
                                    products: [
                                        &#123;id: createRandomID(), name: 'Termék 1', price: 2500, isInStock: true&#125;,
                                  &#123;id: createRandomID(), name: 'Termék 2', price: 3500, isInStock: false&#125;,
                                        &#123;id: createRandomID(), name: 'Termék 3', price: 4500, isInStock: true&#125;,
                                    ],
                                    editId: ''
                                &#125;
                            </pre>
        </li>
        <li>A célunk, hogy a egy formot az edit-product id-jú komponensbe beillesszünk, és ezt feldobjuk
          a UI-ban
          <ul>
            <li>
              <pre>
                                        function renderEditProduct() &#123;

                                  if (!state.editId) &#123;
                                                document.getElementById('edit-product').innerHTML = '';
                                                return;
                                            &#125;
                                            var foundProduct;

                                            for (var prod of state.products) &#123;
                                                if (prod.id === state.editId) &#123;
                                  foundProduct = prod;
                                  break;
                                                &#125;
                                            &#125;

                                            console.log('state.editId: ', state.editId);
                                            console.log('foundProduct: ', foundProduct);

                                            var editHTMLForm = `
                                            &#60;h3&#62;Termék szerkesztése&#60;/h3&#62;
                                            &#60;form id="update-product" class="p-5"&#62;
                                                &#60;label class="w-100"&#62;
                                                  Név:
                                                  &#60;input class="form-control" type="text" name="name" value="$&#123;foundProduct.name&#125;"&#62;
                                                &#60;/label&#62;
                                                &#60;label class="w-100"&#62;
                                                  Ár:
                                                  &#60;input class="form-control" type="number" name="price" value="$&#123;foundProduct.price&#125;"&#62;
                                                &#60;/label&#62;
                                                &#60;label class="w-100"&#62;
                                                  Van készleten?
                                                  &#60;input class="form-control" type="checkbox" name="isInStock" $&#123;foundProduct.isInStock ? 'checked' : ''&#125;"&#62;
                                                &#60;/label&#62;
                                                &#60;button class="btn btn-primary" type="submit"&#62;Módosítás&#60;/button&#62;
                                            &#60;/form&#62;
                                        `

                                            document.getElementById('edit-product').innerHTML = editHTMLForm;

                                            document.getElementById('update-product').onsubmit = function (event) &#123;
                                                event.preventDefault();

                                                console.log(event.target.elements);

                                                var name = event.target.elements.name.value;
                                                var price = event.target.elements.price.value;
                                                var isInStock = event.target.elements.isInStock.checked;

                                                var foundIndex;
                                                for (var i = 0; i &#60; state.products.length; i++) &#123;
                                  if (state.products[i].id === state.editId) &#123;
                                                        foundIndex = i;
                                                        break;
                                                    &#125;
                                                &#125;

                                                state.products[foundIndex] = &#123;
                                  id: state.editId,
                                  name,
                                  price,
                                  isInStock
                                                &#125;

                                                state.editId = '';

                                                renderProducts();
                                                renderEditProduct();
                                            &#125;
                                        &#125;
                                    </pre>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A renderEditProduct() függvényt meghívjuk a state változás után, ami kikeresi azt a tömbelemet,
      aminek az adatait változtatni szeretnénk
    </li>
    <li>A form megjelenítéséhez kimásolhatjuk a projektünk form részét</li>
    <li>A checked attribútum nálam valamiért nem működött, pedig a megfelelő helyen true értéket kaptam, még
      sem pipálódott be a checkbox...
    </li>
    <li>Az utolsó feladat, hogy a Módosítás gomb megnyomásakor át meg kell módosítanunk az adatokat a
      state-ben
      <ul>
        <li>Mivel a függvényben, ahol kicseréljük a tömbelem name, price, isInStock értékét, ugyanolyan
          nevű változókat használtunk, mint ami a tömbelemekben is szerepel, így nem kell kulcs-érték
          párokat megadni
        </li>
        <li>Ha egész blokknyi kódokat kell átmásolgatni egyik helyről a másikra, akkor vegyük észre,
          hogy ki tudjuk szervezni függvénybe, és minden helyen, ahol szükséges, meghívjuk
        </li>
        <li>A módosítás befejeztével kiürítjük az editId kulcsot a state-ben, és meghívjuk ugyanazt a
          függvényt, mint amiben éppen állunk, hiszen az elején szerepel egy olyan kód, ami azért
          felel, hogy ha üres az editId változónk, akkor ne rajzolódjon ki a termék szerkesztő
        </li>
        <li></li>
      </ul>
    </li>
  </ul>
  <br>
  <li>
    További feladatok
    <ul>
      <li>Gomb, amire kattintva kiíródik az összes termék ára összeadva
        <ul>
          <li>

          </li>
        </ul>
      </li>
      <li>Szűrés, 3 input mezővel, és keresés gombbal
        <ul>
          <li>Az első input mező névre keres</li>
          <li>Az második két input mező ár intervallumra keres</li>
        </ul>
      </li>
    </ul>
  </li>
</div>

<div>
  <h3>Call stack</h3>
  <ul>
    <li>A Javascript Engine felfogható úgy is, mint egy program a programban
      <ul>
        <li>A böngészőbe van beágyazva, és abban működik</li>
      </ul>
    </li>
    <li>A javascript nyelv szinkron végrehajtódású nyelv
      <ul>
        <li>Két programkód egyszerre sosem hajtódik végre (egy szálon futnak a dolgok)</li>
        <li>A kód fentről lefelé, sorról sorra hajtódik végre</li>
        <li>A script mindig a main (fő) kontextusban kezd el futni (a böngésző szűkebb kontextusa)</li>
        <li>Ha a mainben function hívás történik, a JS átadja a kontrollt annak a függvénynek, ami meg lett
          hívva
          <ul>
            <li>Ilyenkor a call stack-hez hozzáadósik ez a függvény</li>
            <li>Amennyiben a meghívott függvényben újabb függvényt hívunk meg, újabb függvény adódik
              hozzá a call stackhez
            </li>
            <li>Ha pedig az újabb függvény lefut, visszaadja a kontrollt a korábbi függvénynek, majd ha
              az a függvény is lefutott, akkor visszaadja a kontrollt a main-nek
            </li>
            <li>A mainben pedig történhet további kód futás, akár függvényhívás is</li>
            <li>Ha a teljes script lefutott, akkor a call stack-ből kikerül a main is, és a rendszerbe
              beáll egy alap állapot, ami nem zárja ki, hogy a későbbiekben a call stack-be újabb
              elemek kerüljenek
            </li>
          </ul>
        </li>
        <li>Fontos látni, hogy miután a végrehajtás szinkron, így a call stack-et nem blokkolhatja egy
          hosszan tartó művelet
          <ul>
            <li>Ha ez mégis megtörténik, addig, amíg a művelet le nem fut, további sor kódok nem
              hajtódhatnak végre
            </li>
            <li>A hosszan tartó művelet az összes interaktivitást megszünteti az oldalon (befagy az
              oldal)
            </li>
            <li>A szinkron végrehajtódást meg kell hagyni gyorsan végrehajtódó műveleteknek</li>
            <li>Ezzel együtt képesnek kell lenni a böngésző tágabb kontextusának kiadni feladatokat,
              amiket végre tud hajtani
              <ul>
                <li>A script folytathatja a gyors tevékenységét, és elég csak arról értesülni, hogy
                  a hosszabb folyamat befejezte a működését
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A böngésző tágabb kontextusába kihelyezhető párhuzamosan futó feladat
          <ul>
            <li>Legegyszerűbb példa a settimeout() függvény
              <ul>
                <li>Függvényt vár a bemenetére első paraméternek</li>
                <li>Aszinkron művelet
                  <ul>
                    <li>Az aszinkron műveletekre általánosságban is elmondható, hogy a
                      bemenetükre függvényt várnak
                    </li>
                    <li>Ha bizonyos esemény bekövetkezik a jövőben, akkor mi az a
                      funkcionalitás, amit futtatni kell
                    </li>
                    <li>A jövőbeli esemény a settimeout-nál az idő (második paraméter) lejárása
                    </li>
                    <li>A jövőbeli esemény lehet egy click event is, egy form submit, vagy egy
                      input mező keypress eseménye
                    </li>
                    <li>A fő szálon ezek futtatására nincs szükség, csak amikor mondjuk
                      bekövetkezett az esemény
                    </li>
                    <li>Ezek is belekerülnek a stack-be, de azon nyomban ki is kerülnek belőle,
                      kihelyeződik a main-ből a művelet, és a stack folytatja az adott
                      tevékenységét
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Ide tartoznak a szerver oldali kérések is (AJAX pl.)
              <ul>
                <li>Szintén nem szinkron időben akarjuk megvárni a választ</li>
                <li>Rábízzuk a böngészőre, ha majd kész a hívás, akkor szólj, és a funkcionalitást
                  (függvényt, amit megadtunk) rakd be a stackbe
                </li>
                <li>Amíg a call stack-ben nem hajtódott végre minden művelet, addig a "kihelyezett"
                  műveletek sem hajtódhatnak végre, akkor sem, ha már azok végrehajtódtak
                </li>
                <li>A Web API-k csak annyit csinálnak, hogy amint elvégeztek valami feladatot, az
                  adott elemet (amit visszaadnak) behelyezik egy úgynevezett callback queue-ba
                  <ul>
                    <li>Az oktató videó Web API-nak mutatja pl a settimeout-ot is</li>
                    <li>A queue ismérve, hogy az első elem, ami bekerült, az távozik először
                    </li>
                    <li>A Web API-k az egyik oldalon pakolják be az elemeket, a másik oldalon
                      pedig kerülnek ki az elemek a callback queue-ból
                    </li>
                    <li>Ennek körforgásáról az event loop gondoskodik
                      <ul>
                        <li>Az event loop ránéz a call stack-re, és amennyiben a szinkron
                          működés már lefutott, akkor amit a queue-ban talál, berakja a
                          stackbe
                        </li>
                        <li>Az így behelyezett művelet szintén le fog futni, és újra kiürül
                          a stack
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>settimeout(function, 0) használatakor, main futásakor a művelet/funkcionalitás
                  ugyanúgy kikerül (a Web API-k közé), majd, ha a settimeoutban lévő elem
                  végrehajtódott, bekerül a callback queue-ba, és az event loop csak abban az
                  esetben fogja berakni a funkcionalitást a stack-be, amennyiben a main műveletek
                  lefutottak
                  <ul>
                    <li>A különbség csak annyi 0ms-mal, hogy a Web API-k közé gyorsabban bekerül
                      az adott elem, hiszen a "hosszú ideig" tartó művelet 0ms alatt
                      bekövetkezik
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <button id="fetch-posts">Fetch posts with AJAX call</button>
  <div id="post-list-container" style="max-height: 200px; overflow: auto; border-radius: 5px;"></div>
</div>

<div>
  <h3>AJAX I.</h3>
  <ul>
    <li>Az AJAX kérések aszinkron műveletek, nem blokkolják a call stack-et, hanem a böngésző stack futásával
      párhuzamosan végeznek műveletet, és a szerver válasza után futtat további elemeket, amikor a szinkron
      működés véget ér
    </li>
    <li>Egy szerver oldali kérés akár több 100ms-ig is tarthat, és addig nem blokkolhatjuk a kód szinkron
      futását
    </li>
    <li>http://jsonplaceholder.typicode.com/posts
      <ul>
        <li>Nem HTML tartalmat tölt be az oldal, hanem javascriptes struktúrához hasonló szerkezet</li>
        <li>
          <pre>
                            [
                          &#123;
                          "userId": 1,
                          "id": 1,
                          "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",
                          "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"
                                &#125;,
                                ...
                            ]
                        </pre>
        </li>
        <li>Nyers adat, önmagában nem alkalmas a felhasználó felé megjelenítésnek</li>
        <li>Voltaképp JSON string
          <ul>
            <li>Olyan adatformátum, amit a Javascript ihletett</li>
            <li>Formai megkötése, hogy akulcsokat kötelező (kettős!) idézőjelbe tenni</li>
            <li>A neten tipikusan ebben a formátumban áramlik az adat</li>
            <li>Régebben az XML formátum volt elterjedve</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Feladatunk, hogy a gomb megnyomásakor kimenjen az AJAX (aszinkron) kérés
      <ul>
        <li>
          <pre>
                            document.getElementById('fetch-posts').onclick = function () &#123;
                          var xhr = new XMLHttpRequest;

                          xhr.onreadystatechange = function () &#123;
                                    if (xhr.readyState === 4 && xhr.status === 200) &#123;
                          const response = JSON.parse(xhr.responseText);
                          console.log(response);

                          var posts = '';

                          for (var res of response) &#123;
                                            posts += `
                                            &#60;div class="card" style="padding: 10px; margin: 10px; border: 1px solid gray; border-radius: 5px"&#62;
                                                &#60;div&#62;ID: $&#123;res.id&#125;&#60;/div&#62;
                                                &#60;div&#62;UserID: $&#123;res.userId&#125;&#60;/div&#62;
                                                &#60;div&#62;Title:  $&#123;res.title&#125;&#60;/div&#62;
                                                &#60;div&#62;Body:  $&#123;res.body&#125;&#60;/div&#62;
                                                &#60;/div&#62;
                                            `
                                        &#125;

                                        var postListContainer = document.getElementById('post-list-container');

                                        postListContainer.style.border = '1px solid black';
                                        postListContainer.innerHTML = posts;

                                    &#125;
                                &#125;

                                xhr.open('GET', 'http://jsonplaceholder.typicode.com/posts');

                                xhr.send();
                            &#125;
                        </pre>
        </li>
        <li>Létre kell hozni egy XMLHttpRequest object-et
          <ul>
            <li>A 'new XMLHttpRequest' objektum reprezentál egy szerver oldali kérést</li>
            <li>Ennek kulcsait / funkcionalitásait lehet felhasználni a kérés küldésére</li>
            <li>Az objektum 'onreadystatechange' eseményére kell reagálni
              <ul>
                <li>Mindig lefut akkor, amikor a kérés életciklusában valami változás történik</li>
                <li>Összesen 4 ciklusa van egy ilyen kérésnek (XMLHttpRequest.readyState)
                  <ol>
                    <li>0. - Ha a kérés nem inicializált</li>
                    <li>1. - Ha a kapcsolat létrejött a szerverrel</li>
                    <li>2. - Ha a kérés fogadva van</li>
                    <li>3. - Ha a kérés feldolgozása folyamatban van</li>
                    <li>4. - Ha a kérés kész, a válasz is kész</li>
                  </ol>
                </li>
                <li>Minket most az érdekel, ha kész a válasz</li>
                <li>Az onreadystatechange-hez bekötött függvény minden állapotváltozásnál lefut</li>
                <li>A XMLHttpRequest.readyState változik stádiumonként</li>
                <li>Kiegészíthető azzal, hogy az objektumban a status legyen egyenlő 200-zal (tehát
                  a response status sikeres)
                </li>
                <li>Az xhr.responseText értéke szintén változik az állapotváltozások során</li>
              </ul>
            </li>
            <li>xhr.open() függvényben adható meg, hogy hova akarjuk kiküldeni a kérésünket
              <ul>
                <li>Első paraméternek metódust vár, második paraméternek url-t</li>
                <li></li>
              </ul>
            </li>
            <li>Az xhr.send() függvény meghívásával kiküldhető a kérés</li>
          </ul>
        </li>
        <li>A válaszban, amit a console-log-gal kiírtunk, látható, hogy egy JSON stringet kaptunk vissza,
          tehát a Javascript részéről ez csak egy string
          <ul>
            <li>Át kell alakítanunk Javascriptes adatstruktúrává</li>
            <li>JSON.parse() függvény
              <ul>
                <li>JSON stringet parse-ol, és visszatér Javascriptes adatstruktúrával</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A függvényben végig iterálunk az immáron Javascriptes objektumunkon, és tetszés szerinti HTML-t
          készíthetünk belőle
        </li>
        <li>Ez egy olyan kérés volt, amihez nem kellett az oldalt befrissíteni, tehát az oldal újra
          letöltése nélkül jutunk hozzá az adathoz
          <ul>
            <li>A modern webapplikációknak ez egy alapvető működésbeli sajátosságuk</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <button id="fetch-anything">Fetch posts with AJAX call</button>
  <div id="anything-container" style="max-height: 200px; overflow: auto; border-radius: 5px;"></div>
</div>

<div>
  <h3>AJAX II.</h3>
  <ul>
    <li>A korábbiakban megírt AJAX kérést fogjuk kiszervezni egy külön függvénybe, amit felparaméterezünk, hogy
      bárhova tudjunk kéréseket küldeni
    </li>
    <li>
      <pre>
                    function sendRequest(url, method, body, callback) &#123;
                  document.getElementById('fetch-posts').onclick = function () &#123;
                            var xhr = new XMLHttpRequest;

                            xhr.onreadystatechange = function () &#123;
                  if (xhr.readyState === 4 && xhr.status === 200) &#123;
                                    callback(JSON.parse(xhr.responseText));
                                &#125;
                            &#125;

                            xhr.open(method, url);

                            xhr.send(body);
                        &#125;
                    &#125;
                </pre>
      <ul>
        <li>A függvényünk 4. paramétere a callback
          <ul>
            <li>Callback: function típusú; mit csináljon a függvény, ha készen van</li>
            <li>A sendRequest function meg fogja hívni a callback function-ünket, amikor eljön az ideje
            </li>
            <li>Ennek ideje jelen példában akkor jön el, amikor a readyState-ünk 4-es, és a status-unk
              200-as
            </li>
          </ul>
        </li>
        <li></li>
      </ul>
    </li>
    <li>A HTML összeállítását kívülről kell szolgáltatnunk, hogy a funkcionalitás általános maradhasson</li>
    <li>
      <pre>
                    document.getElementById('fetch-anything').onclick = function () &#123;
                  var url = 'http://jsonplaceholder.typicode.com/posts';
                  var method = 'GET';
                  var body = null;
                  var callback = function (posts) &#123;
                            var content = '';

                            for (var post of posts) &#123;
                  content += `
                      &#60;div class="card" style="padding: 10px; margin: 10px; border: 1px solid gray; border-radius: 5px"&#62;
                          &#60;div&#62;ID: $&#123;post.id&#125;&#60;/div&#62;
                                        &#60;div&#62;UserID: $&#123;post.userId&#125;&#60;/div&#62;
                                        &#60;div&#62;Title:  $&#123;post.title&#125;&#60;/div&#62;
                                        &#60;div&#62;Body:  $&#123;post.body&#125;&#60;/div&#62;
                                        &#60;/div&#62;
                                    `
                            &#125;

                            var anythingListContainer = document.getElementById('anything-container');

                            anythingListContainer.style.border = '1px solid black';
                            anythingListContainer.innerHTML = content;
                        &#125;;

                        sendRequest(url, method, body, callback);
                    &#125;

                    function sendRequest(url, method, body, callback) &#123;
                  var xhr = new XMLHttpRequest;

                  xhr.onreadystatechange = function () &#123;
                            if (xhr.readyState === 4 && xhr.status === 200) &#123;
                  callback(JSON.parse(xhr.responseText));
                            &#125;
                        &#125;

                        xhr.open(method, url);

                        xhr.send(body);
                    &#125;
                </pre>
      <ul>
        <li>A function-ben hajtódik végre a HTML összeállítása</li>
        <li>A callback function értéke a sendRequest függvény meghívásakor a posts-ban lesz elérhető (amit a
          function paraméterénél látunk)
        </li>
        <li>Jelen példánkban request body-t nem küldünk (nem is kell), csak azt adtuk meg a
          setRequestHeader-ben (beégetve), hogy a content-type az json
        </li>
        <li>Jelen példánkban nincs működésbeli különbség a többször felhasználhatóságot tekintve</li>
      </ul>
    </li>
    <li>Bejelentkezés flow

      <br>
      <br>
      <div>
        <button id="login">Bejelentkezés</button>
        <br>
        <br>
        Token: <span id="login-token-id"></span>
      </div>
      <br>

      <ul>
        <li>reqres.in oldal API-ját fogjuk felhasználni
          <ul>
            <li>/api/login => email és password megadása szükséges, cserébe token-nel válaszol a szerver
            </li>
            <li>A koncepció az, hogy védett erőforrásokhoz akarunk hozzáférni, ezt fogjuk tudni megtenni
              a token-nel
            </li>
            <li>A token meglétekor egy újabb kérést kell majd kiküldenünk, és meg kell szólítanunk a
              list users erőforrást
            </li>
            <li>A token-t hozzácsapva a header-ökhöz, érhető el általában a védett tartalom (jelen
              példában nem lesz hozzá szükségünk)
            </li>
          </ul>
        </li>
        <li>
          <pre>
                            document.getElementById('login').onclick = function () &#123;
                          var url = 'https://reqres.in/api/login';
                          var body = JSON.stringify(&#123;
                                    email: 'eve.holt@reqres.in',
                                    password: 'cityslicka'
                                &#125;);

                                sendRequest(url, 'POST', body, function (token) &#123;
                                    console.log(token);
                                    document.getElementById('login-token-id').innerHTML = token.token;
                                &#125;);
                            &#125;
                        </pre>
          <ul>
            <li>A body egy JSON-né alakított adat (Javascript objektumból)</li>
            <li>A loginhoz szükséges adatokat ezúttal beégettük</li>
            <li>A kérésből érkezett válasz (token) a callback function-ben jelenik meg</li>
            <li>Először szükséges meghívni az open() függvényt, és csak utána lehet a header információt
              bekötni
            </li>
            <li>Nagyon fontos, hogy a sendRequest függvény nem tér vissza értékkel, így változóba sem
              tárolható el, hogy máshol használjuk, csak egy callback function-t hív meg egy esemény
              kapcsán
            </li>
            <li>Tehát a token-t csak a callback függvényben használhatjuk, csak abban a scope-ban
              létezik
            </li>
          </ul>
        </li>
        <li>A további lekérdezésekhez abban a scope-ban kell meghívnunk (újra) a sendRequest függvényt, ahol
          a token-t megkaptuk
        </li>
        <li>
          <pre>
                            document.getElementById('login').onclick = function () &#123;
                          var url = 'https://reqres.in/api/login';
                          var body = JSON.stringify(&#123;
                                    email: 'eve.holt@reqres.in',
                                    password: 'cityslicka'
                                &#125;);

                                sendRequest(url, 'POST', body, function (token) &#123;
                                    console.log(token);
                                    document.getElementById('login-token-id').innerHTML = token.token;

                                    sendRequest('https://reqres.in/api/users', 'GET', null, function (users) &#123;
                          console.log(users);
                                    &#125;);
                                &#125;);
                            &#125;
                        </pre>
          <ul>
            <li>Két network kérés ment ki, sorrendben</li>
            <li>A token megléte után újra meghívtuk a sendRequest függvényt</li>
            <li>A user-ekkel semmi mást nem csináltunk, csak kilogoltuk console-ba</li>
            <li>A kódra jellemző a beágyazottság, mert az egymástól függő aszinkron kérésekre igaz, hogy
              mindig csak a bedobott callback function scope-jában tudunk dolgozni a végeredménnyel
            </li>
            <li>Ha újabb kérést kellene kiküldenünk, aminek előfeltétele a users erőforrás, az további
              beágyazottságot eredményezne
            </li>
            <li>Ez vezet át a következő témakörbe, a Promise-okhoz
              <ul>
                <li>Egy újabb nyelvi eszköz, aminek keretében megtanuljuk, hogyan lehet kiküszöbölni
                  a beágyazottságot, és szebb formába önteni a kódot
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Feladat:
      <ul>
        <li>Egy form (2 input mező: felhasználónév és jelszó) submit eseményére loginolni</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3>Promise</h3>
  <ul>
    <li>Az aszinkron kéréseim miatt a kódunk egy ilyen mintázatot kezd el követni:
      <ul>
        <li>
          <pre>
                            sendRequest(url, 'POST', body, function (token) &#123;
                          document.getElementById('login-token-id').innerHTML = token.token;

                          console.log(token);
                          sendRequest('https://reqres.in/api/users', 'GET', null, function (users) &#123;
                                    console.log(users);
                                    sendRequest('https://reqres.in/api/tovabbiEroforras1', 'GET', null, function (eroforras1) &#123;
                          console.log(eroforras1);
                          sendRequest('https://reqres.in/api/tovabbiEroforras2', 'GET', null, function (eroforras2) &#123;
                                            console.log(eroforras2);
                                        &#125;);
                                    &#125;);
                                &#125;);
                            &#125;);
                            </pre>
        </li>
        <li>Ez az elrendezés nevet is kapott:
          <ul>
            <li>callback hell</li>
            <li>pyramid of doom</li>
          </ul>
        </li>
        <li>Ezzel a beágyazott kóddal rendkívül nehéz dolgozni</li>
        <li>A kérések nem feltétlen sikeresek</li>
        <li>Minden egyes aszinkron művelet kapcsán csak a megadott callback function-ben van lehetőség további
          műveletekre
        </li>
        <li>A kód inkább így néz ki:
          <ul>
            <li>
              <pre>
                                    sendRequest(url, 'POST', body, function (token) &#123;
                                  document.getElementById('login-token-id').innerHTML = token.token;

                                  if (token) &#123;

                                            sendRequest('https://reqres.in/api/users', 'GET', null, function (users) &#123;

                                  if (users) &#123;

                                                    sendRequest('https://reqres.in/api/tovabbiEroforras1', 'GET', null, function (eroforras1) &#123;

                                  if (eroforras1) &#123;

                                                            sendRequest('https://reqres.in/api/tovabbiEroforras2', 'GET', null, function (eroforras2) &#123;

                                  if (eroforras2) &#123;

                                                                &#125; else &#123;
                                                                    alert('Error');
                                                                &#125;

                                                            &#125;);

                                                        &#125; else &#123;
                                                            alert('Error');
                                                        &#125;

                                                    &#125;);

                                                &#125; else &#123;
                                                    alert('Error');
                                                &#125;
                                            &#125;);

                                        &#125; else &#123;
                                            alert('Error');
                                        &#125;
                                    &#125;);
                                </pre>
            </li>
          </ul>
        </li>
        <li>Szükségessé vált egy nyelvi konstrukció, ami elejét veszi a kód ilyen módú beágyazásának
          <ul>
            <li>Elkéri csak a szükséges részeket, minimális információt</li>
            <li>A háttérben összefűzi a szükséges egységeket</li>
            <li>Ugyanezt a működést eredményezi</li>
            <li>Az absztrakció neve: Promise</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A promise jellemző
      <ul>
        <li>Csak úgy, mint a több, mindig kéz a kézben jár egy másik értékkel
          <ul>
            <li>Önmaga nem mondja, hogy milyen értéket fog szolgáltatni</li>
            <li>Promise&#60; _ &#62;</li>
            <li>Valami érték aszinkron működés révén szinkron időben a kezünkbe kerül</li>
            <li>Bármilyen típus megadható</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A sendRequest függvény becsomagolása promise-os interface-be:
      <ul>
        <li>Legyen egy függvényünk, ami vár paramétereket</li>
        <li>A callback function már nincs jelen</li>
        <li>Vissza kell térnünk egy Promise-szal, és adnunk kell neki egy "receptet"</li>
        <li>A recept azt hivatott megmondani, hogy mikor minősül sikeresnek a kérés</li>
        <li>A függvény megkap 2 paramétert
          <ul>
            <li>resolve és reject</li>
            <li>Ezek tulajdonképpen függvények</li>
            <li>Amikor meghívjuk őket a belső scope-ban, akkor futtatjuk a promise-t sikeres, vagy
              sikertelen állapotba
            </li>
          </ul>
        </li>
        <li>
          <pre>
                        function sendRequest2(url, method, body) &#123;
                      return new Promise(function (resolve, reject) &#123;
                                var xhr = new XMLHttpRequest;
                                xhr.onreadystatechange = function () &#123;
                      if (xhr.readyState === 4) &#123;
                                        if (xhr.status &#62;= 200 && xhr.status &#60; 300) &#123;
                      resolve(JSON.parse(xhr.responseText));
                                        &#125; else &#123;
                      reject(xhr.responseText);
                                        &#125;
                                    &#125;
                                &#125;

                                xhr.open(method, url);
                                xhr.setRequestHeader('content-type', 'application/json')
                                xhr.send(body);
                            &#125;);
                        &#125;
                    </pre>
          <ul>
            <li>Meg kell néznünk, hogy a status sikeres-e, azaz 2-essel kezdődik-e</li>
            <li>Ha ez teljesül, akkor a sikeres állapotba futást a resolve() függvénnyel hajthatjuk végre
            </li>
            <li>A resolve a futásidőben már elérhető, szerverről érkező választ kapja meg</li>
            <li>Reject esetén is átadjuk a szerverről érkező választ</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Hívjuk meg a sendRequest2 függvényt:
      <ul>
        <li>
          <pre>
                        sendRequest2(url, 'POST', body)
                        .then(function (response) &#123;
                      console.log(response);
                        &#125;)
                    </pre>
        </li>
        <li>A promise-t úgy tudjuk használni, hogy ami visszatér promise objektum, annak van egy 'then' kulcsa,
          amiben egy függvény van
        </li>
        <li>A függvényben adhatjuk meg, hogy az aszinkron művelet révén a kezünkbe került értékkel mi történjen
        </li>
        <li>A sendRequest2 then kulcsában megadott függvényben elérhető lesz a kérésből kapott válasz</li>
        <li>Ha a then()-ből visszatérünk, az mindenképp egy promise lesz</li>
      </ul>
    </li>
    <br>
    <li>
      <div>
        <button id="login2">Bejelentkezés</button>
        <br>
        <br>
        Token: <span id="login-token-id2"></span>
      </div>
    </li>
    <li>
      <pre>
                document.getElementById('login2').onclick = function () &#123;
              var url = 'https://reqres.in/api/login';
              var body = JSON.stringify(&#123;
                        email: 'eve.holt@reqres.in',
                        password: 'cityslicka'
                    &#125;);

                    sendRequest2(url, 'POST', body)
                        .then(function (response) &#123;
                            console.log('Promise response: ', response);
                            document.getElementById('login-token-id2').innerHTML = response.token;
                        &#125;);
                &#125;
                </pre>
      <ul>
        <li>Így néz ki a response: &#123;token: 'QpwL5tke4Pnpja7X4'&#125;</li>
      </ul>
    </li>
    <li>
      <pre>
                sendRequest2(url, 'POST', body)
                    .then(function (response) &#123;
              console.log(response);
              return 'Visszatérési érték';
                    &#125;)
                    .then(function (elozoThenVisszateresiErteke) &#123;
              console.log(elozoThenVisszateresiErteke);
                    &#125;);
            </pre>
      <ul>
        <li>A második then függvényben az első then visszatérési értékéhez jutunk hozzá</li>
      </ul>
    </li>
    <li>
      <pre>
                sendRequest2(url, 'POST', body)
                    .then(function (response) &#123;
              console.log('Promise response: ', response);
              document.getElementById('login-token-id2').innerHTML = response.token;
              return sendRequest2('https://reqres.in/api/users', 'GET', null);
                    &#125;)
                    .then(function (elozoThenVisszateresiErteke) &#123;
              console.log(elozoThenVisszateresiErteke);
                    &#125;);
            </pre>
      <ul>
        <li>Gondolhatnánk, hogy ebben az esetben az 'elozoThenVisszateresiErteke' egy
          Promise&#60;Promise&#60;any&#62;&#62;
        </li>
        <li>A gondolat téves, mert a then() function megszabadul egy rétegnyi promise-tól, tehát biztosítja,
          hogy ami a kezünkbe kerül, mindenképpen egy egyszeresen becsomagolt promise legyen
        </li>
      </ul>
    </li>
    <br>
    <li>A then() függvény tehát kétféleképpen tud működni:
      <ul>
        <li>Ha egyszerű adattal térünk vissza, ami nem promise, akkor becsomagolja promise-ba (a visszatérő
          értékre meg lehet hívni egy újabb then() függvényt)
        </li>
        <li>Ha pedig egy promise-szal térünk vissza, akkor megszabadul egy rétegnyi promise-tól (azaz ebben az
          esetben is Promise&#60;valami&#62;-vel térünk vissza)
        </li>
      </ul>
    </li>
    <br>
    <li>Promise chain:
      <ul>
        <li>A then() blokkokból felépített láncolatot hívjuk így</li>
        <li>Az adott then() blokkban dolgozhatunk az előző aszinkron művelet eredményével</li>
      </ul>
    </li>
    <br>
    <li>Hibakezelés:
      <ul>
        <li>Két lehetőségünk van:
          <ul>
            <li>Az adott then() blokkban kezeljük, egy újabb függvény megadásával
              <ul>
                <li>
                  <pre>
                                        sendRequest2(url, 'POST', body)
                                        .then(function (response) &#123;
                                      console.log('Promise response: ', response);
                                        &#125;, function(error) &#123;

                                      &#125; )
                                        </pre>
                </li>
                <li> Akkor fog lefutni, ha a promise hibára fut(reject)</li>
                <li>Átláthatatlanná teszi a kódot</li>
                <li> Nem használatos</li>
              </ul>
            </li>
            <li> Catch blokk
              <ul>
                <li>
                  <pre>
                  sendRequest2(url, 'POST', body)
                  .then(function(response) &#123;
                  console.log('Promise response: ', response);
                  &#125;)
                  .catch(function(error) &#123;
                  console.log(error);
                  &#125;);
                  </pre>
                </li>
                <li>Az összes hibaág lekezdehető egy bizonyos pontig vele</li>
                <li>A then() függvényhez nagyon hasonlatos</li>
                <li>Függvény, amit meg lehet hívni</li>
                <li>Bemeneti paraméterként függvényt fogad</li>
                <li>A függvény fogja paraméterként megkapni a hiba értékét (amit a promise a reject
                  során megkap)
                </li>
                <li>A catch() blokkot úgy helyezgetjük, ahogy akarjuk a chainben, és ahova tettük, addig
                  a pontig kezeli le a hibákat, legalábbis olyan módon, ahogy azt a bemeneti
                  függvényben megadjuk, tehát több catch is lehet egy chainben
                </li>
                <li>Több catch esetén, a hibára futást követően az összes catch() le fog futni</li>
                <li>A best practice, hogy a chain végén van egy darab catch()</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Lehetőségünk van explicite hibát feldobni
          <ul>
            <li>
              <pre>
                                sendRequest2(url, 'POST', body)
                                    .then(function (response) &#123;
                                        console.log(response);
                                        return Promise.reject('Hiba');
                                    &#125;)
                                    .catch(function(error) &#123;
                                        console.log(error);
                                    &#125;);
                            </pre>
            </li>
            <li>Vissza kell térnünk egy olyan Promise objektummal, ami reject-elve van</li>
            <li>A reject() függvénynek bármilyen értéket odaadhatunk, a catch() elkapja</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3>Fetch</h3>

  <ul>
    <li>
      <div>
        <div class="">
          <div class="row" style="display: grid; grid-template-columns: 1fr 1fr; margin-bottom: 20px">
            <div id="login-component">
            </div>
            <div>
              <div id="user-list-container">
              </div>
            </div>
          </div>
        </div>
      </div>
    </li>
    <li>Célunk, hogy login után lekérjük a user listát
      <ul>
        <li>A kérés elküldéséhez a beépített fetch függvényt fogjuk használni
          <ul>
            <li>A fetch első paramétere az URL</li>
            <li>A második paramétere pedig egy konfigurációs objektum</li>
            <li>A típus annotációját tekintve a fetch függvény visszatérése
              &#60;Promise&#60;Response&#62;&#62; (egy később elérhető Response objektummal)
            </li>
            <li>A szervertől érkező válasz több paramétert is tartalmaz(hat)</li>
            <li>A loginhoz a helyes email cím: eve.holt@reqres.in / a jelszó: `lehet akármi`
            </li>
            <li>Az első then() response-a a következőt adja vissza (console.log(response)):
              <ul>
                <li>
                  <pre>
                                        &#123;
                                        body: ReadableStream
                                        bodyUsed: false
                                        headers: Headers &#123;&#125;
                                        ok: false
                                        redirected: false
                                        status: 400
                                        statusText: ""
                                        type: "cors"
                                        url:"https://reqres.in/api/login"
                                        &#125;
                                    </pre>
                </li>
              </ul>
            </li>
            <li>A body egy úgynevezett ReadableStream, mert potenciálisan hatalmas adat is lehet
              (adatfolyamként van reprezentálva, amit ki lehet olvasni)
            </li>
            <li>Ha tudjuk, hogy JSON adatunk van, akkor a kiolvasás nagyon egyszerű</li>
            <li>A response.json() típusát tekintve Promise&#60;any&#62;
              <ul>
                <li>Tudjuk, hogy a promise így működik, ha a then() blokkba bedobott functionben
                  visszatérünk egy újabb promise-szal ( return response.json() ), akkor a következő
                  then() blokkban tudjuk használni az abból az előző promise-ból resolválódó értéket
                </li>
              </ul>
            </li>
            <li>Hibás email vagy jelszó esetén egy &#123;error: string&#125; objektumot kapunk
              <ul>
                <li>400-as státusz kódot kapunk, a fetch() függvény úgy működik, hogy nem futtatja a
                  rendszert promise szintjén hibára, ezért lehet szükség egy catch() blokkra
                </li>
                <li>Az 'ok' kulcsot kell használnunk, hogy belefuttassuk a rendszert a catch() blokkba,
                  és a promise-t így tudjuk rejected állapotba átállítani, amit egy Promise.reject()
                  függvénnyel tudunk megtenni
                </li>
                <li>A reject függvénybe bedobhatunk hibakezelésre alkalmas információt
                  <ul>
                    <li>Promise.reject('login error')</li>
                    <li>Ez a string fog kibukkanni a catch() blokk függvényének paramétereként</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>A második then() blokkban a kezünkbe kerül a user token, és lehetőségünk nyílik a második
              API hívás kiküldésére
            </li>
            <li>Visszatérhetünk fetch() függvény által visszaküldött promise-szal
              <ul>
                <li>A fetch() függvény esetében a 'GET' method a default, 'GET' esetében body sincs, és
                  header információt sem akarunk küldeni, így nincs szükség megadni
                  semmi mást, csak a userek url-jét
                </li>
                <li>A válasz a következő then() blokkban lesz elérhető</li>
                <li>A kapott választ ki kell parse-olnunk</li>
                <li>A rá következő then() blokkban tudjuk ténylegesen használni</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Következő lépésben a form mellett található userelek listáját töltjük fel a kérésünknek
          megfelelően
          <ul>
            <li>Ennek megvalósításához deklarálunk egy state-et a rendszerünkbe
              <ul>
                <li>var state = []</li>
              </ul>
            </li>
            <li>A user lista lejövetelét tekinthetjük state change-nek, ekkor akarjuk megváltoztatni a
              kirenderelt userek listáját
              <ul>
                <li>state = userPage.data</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A végeredmény:
          <ul>
            <li>
              <pre>
                                var state = [];
                                var fetchSubmitButton = document.getElementById('log-in');

                                fetchSubmitButton.onsubmit = function (event) &#123;
                                    event.preventDefault();

                                    renderErrors('');

                                    var email = event.target.elements.email.value;
                                    var password = event.target.elements.password.value;

                                    var body = JSON.stringify(&#123;email, password&#125;);

                                    fetch('https://reqres.in/api/login', &#123;
                                      method: 'POST',
                                        body,
                                        headers: &#123;
                                        'Content-type': 'application/json'
                                          &#125;
                                      &#125;).then(function (response) &#123;
                                      if (!response.ok) &#123;
                                        return Promise.reject(&#123;error: 'Login failed'&#125;);
                                          &#125;
                                          return response.json();
                                      &#125;).then(function (response) &#123;
                                      return fetch('https://reqres.in/api/users')
                                      &#125;).then(function (response) &#123;
                                      if (!response.ok) &#123;
                                        return Promise.reject(&#123;error: 'Get user list failed'&#125;);
                                          &#125;
                                          return response.json();
                                      &#125;).then(function (userPage) &#123;
                                      state = userPage.data;
                                        renderUsers();
                                      &#125;).catch(function (error) &#123;
                                      console.log(error);
                                        renderErrors(error.error);
                                      &#125;);
                                      &#125;

                                      function renderUsers() &#123;
                                      var userListContainer = document.getElementById('user-list-container');

                                        var newList = '';

                                        newList = '&#60;ul class="list-group"&#62;'
                                        for(var s of state) &#123;
                                        newList + = `&#60;li class = "list-group-item" > $&#123;s.first_name&#125; $&#123;s.last_name&#125;&#60; / li &#62;`;
                                        &#125;
                                        newList + = '&#60;/ul&#62;';

                                        userListContainer.innerHTML = newList;

                                        console.log('state: ', state);
                                &#125;

                                function renderErrors(errorMsg) &#123;
                                    var errorContainer = document.getElementById('fetchErrorMessage');
                                    errorContainer.innerHTML = errorMsg;
                                &#125;
                            </pre>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3>Az async function</h3>
  <ul>
    <li>Eddig két módszert tanultunk, amivel elérjük azt, hogy a stack blokkolása nélkül a hosszú ideig tartó
      műveleteink sikeresen befejeződjenek
      <ul>
        <li>Callback function
          <ul>
            <li>Legrégebbi, a javascript készülésétől kezdve elérhető megoldás</li>
          </ul>
        </li>
        <li>Promise láncolat
          <ul>
            <li>A kódunk Promise chain formát ölt, és ezáltal megszűnt a kódban a beágyazottság</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Az async egy szintaktikai könnyítés</li>
    <li>A motorháztető alatt ugyanúgy promise-okat használ</li>
    <li>Ha egy függvényt async kulcsszóval deklarálunk, akkor a body-n belül használni lehet az await kulcsszót
      <ul>
        <li>
          <pre>async function loginAndFetchUsers() &#123;
                            // await
                        &#125;
                    </pre>
        </li>
        <li>A fejlesztő számára azt a látszatot kelti az await, mintha szinkron időben leblokkolnánk a kód
          futását
        </li>
        <li> (Szinkron időben ugye nem blokkolhatjuk a futást, hiszen a js engine egyszerre csak egy dolgot tud
          végrehajtani)
        </li>
      </ul>
    </li>
    <br>
    <li style="display: flex; gap: 20px;">
      <div class="card p-6">
        <b id="log-in-title" style="display: block;padding-bottom: 20px">Belépés</b>
        <form id="log-in-2">
          <div>
            <label class="w-100">Email:
              <input type="text" name="email" class="form-control" />
            </label>
          </div>
          <div>
            <label class="w-100">Jelszó:
              <input type="password" name="password" class="form-control" />
            </label>
          </div>
          <div>
            <button id="fetchSubmit" type="submit" style="margin-top: 20px">
              Bejelentkezés
            </button>
          </div>

        </form>
      </div>
      <div class="card p-6">
        <div id="user-list"></div>
      </div>
    </li>
    <br>
    <li>
      <pre>async function loginAndFetchUsers() &#123;
                            var loginResponse = await fetch('https://reqres.in/api/login', &#123;
                                      method: 'POST',
                                        body,
                                        headers: &#123;
                                        'Content-type': 'application/json'
                                          &#125;
                                      &#125;);
                                      &#125;
                    </pre>
      <ul>
        <li>A fetch function egy Promise of response-zal tér vissza</li>
        <li>Az await kulcsszó megvárja, amíg a Promise resolve-álódik
          <ul>
            <li>Promise&#60;T&#62; típusból csinál T típust</li>
            <li>Tehát végrehajtja az aszinkron műveletet</li>
            <li>A loginResponse változóban szinkron formában tudjuk kezelni</li>
          </ul>
        </li>
        <li>A callback function nem engedi meg, hogy bekössük változóba a visszatérési értéket</li>
        <br>
        <li>A loginResponse változónk megléte után szinkron időben tudjuk a választ kezelni</li>
      </ul>
    </li>
    <br>
    <li>
      <pre>
                async function loginAndFetchUsers() &#123;
              // await

              var body = JSON.stringify(&#123;email, password&#125;);
                    var loginResponse = await fetch('https://reqres.in/api/login', &#123;
                        method: 'POST',
                        body,
                        headers: &#123;
              'Content-type': 'application/json'
                        &#125;
                    &#125;);

                    console.log('async - await loginResponse: ', loginResponse);

                    if (!loginResponse.ok) &#123;
                        alert('Bejelentkezés sikertelen (ERROR)');
                        return;
                    &#125; else &#123;
                        alert('Sikeres bejelentkezés (OK)');
                    &#125;

                    var tokenObj = await loginResponse.json();

                    console.log('token: ', tokenObj.token);

                    var usersResponse = await fetch('https://reqres.in/api/users');

                    if (!usersResponse.ok) &#123;
                        alert('Nincsenek userek (ERROR)');
                        return;
                    &#125; else &#123;
                        alert('Userek letöltés indul (OK)');
                    &#125;

                    var usersPage = await usersResponse.json();

                    var listOfUsers = document.getElementById('user-list');

                    usersPage.data.map(m => &#123;
                        console.log(m);
                        listOfUsers.innerHTML += `&#60;div&#62;$&#123;m.first_name&#125; $&#123;m.last_name&#125;&#60;/div&#62;`
                    &#125;);
                &#125;
            </pre>
    </li>
  </ul>
</div>

<div>
  <h3>Movie project</h3>
  <br>
  <ul>
    <li>A keresésre használhatunk callback function-t, Promise-t, vagy async function-t
      <ul>
        <li>Callback megvalósítás:
          <ul>
            <li>
              <form class="search-movie-form" id="callback-search">
                <input type="search" name="title" placeholder="Title" value="vinny" />
                <input type="text" maxlength="4" name="year" placeholder="Year" value="1992" />
                <button type="submit" id="callback-submit" class="movie-search-button">search</button>
              </form>
            </li>
            <li>
              <pre>
                                var callbackSubmitButton = document.getElementById('callback-search');
                                var searchObj = &#123;&#125;;

                                callbackSubmitButton.onsubmit = function (event) &#123;
                              event.preventDefault();

                              searchObj = &#123;
                                        title: encodeURI(event.target.elements.title.value),
                                        year: event.target.elements.year.value
                                    &#125;

                                    fetchData(searchObj.title, searchObj.year, function (error, data) &#123;
                                        if (error) &#123;
                              console.error('Error: ', error);
                              document.getElementById('movie-list').textContent = 'Error fetching data';
                                        &#125; else &#123;
                              console.error('Data: ', data);
                              console.log(data);
                              if (!data.Response) &#123;
                                                document.getElementById('movie-list').textContent = JSON.stringify(data.Error, null, 2);
                                            &#125; else &#123;
                                                renderMovies(data.Search);
                                            &#125;
                                        &#125;
                                    &#125;);
                                &#125;

                                function fetchData(title, year, callback) &#123;
                              const url = `http://www.omdbapi.com/?s=$&#123;title&#125;&y=$&#123;year&#125;&apikey=9606ae0f`;

                                    // fetch(`http://www.omdbapi.com/?s=$&#123;searchObj.title&#125;&y=$&#123;searchObj.year&#125;&apikey=9606ae0f`);

                                    var xhr = new XMLHttpRequest();
                                    xhr.open("GET", url, true);
                                    xhr.onreadystatechange = function () &#123;
                                        if (xhr.readyState === 4) &#123; // A kérés befejeződött
                                            if (xhr.status === 200) &#123; // A válasz státusza OK
                                                var data = JSON.parse(xhr.responseText);
                                                callback(null, data);
                                            &#125; else &#123;
                                                callback(new Error("Error fetching data"));
                                            &#125;
                                        &#125;
                                    &#125;;
                                    xhr.send();
                                &#125;
                            </pre>
            </li>
            <li>A fetchData 3. bemeneti paramétere callback function</li>
            <br>
          </ul>
        </li>
        <li>Promise megvalósítás:
          <ul>
            <li>
              <form class="search-movie-form" id="promise-search">
                <input type="search" name="title" placeholder="Title" value="beverly" />
                <input type="text" maxlength="4" name="year" placeholder="Year" value="2024" />
                <button type="submit" id="promise-submit" class="movie-search-button">search</button>
              </form>
            </li>
            <li>
              <pre>
                                var promiseSubmitButton = document.getElementById('promise-search');
                                var searchObj = &#123;&#125;;

                                promiseSubmitButton.onsubmit = function (event) &#123;
                              event.preventDefault();

                              searchObj = &#123;
                                        title: encodeURI(event.target.elements.title.value),
                                        year: event.target.elements.year.value
                                    &#125;

                                    getData(searchObj.title, searchObj.year)
                                        .then((data) => &#123;
                                            renderMovies(data.Search);
                                        &#125;)
                                        .catch((error) => &#123;
                                            console.log(error);
                                        &#125;);
                                &#125;

                                function getData(title, year) &#123;
                              return new Promise((resolve, reject) => &#123;
                                        fetch(`http://www.omdbapi.com/?s=$&#123;title&#125;&y = $&#123;year&#125; & apikey = 9606ae0f`)
                              .then(response = > &#123;
                              if (!response.ok) &#123;
                              throw new Error('Network response was not ok');
                            &#125;
                              return response.json();
                              &#125;)
                              .then(data = > &#123;
                              resolve(data);
                            &#125;)
                              .catch(error = > &#123;
                              reject(error);
                            &#125;);
                              &#125;);
                              &#125;
                              </pre>
            </li>
          </ul>
        </li>
        <li> Async megvalósítás:
          <ul>
            <li>
              <div class="main-header">
                <div class="inner">
                  <form class="search-movie-form" id="async-movie">
                    <input type="search" name="title" placeholder="Title" value="back to the future" />
                    <input type="text" maxlength="4" name="year" placeholder="Year" value="1989" />
                    <button type="submit" id="async-submit" class="movie-search-button"> search
                    </button>
                  </form>
                </div>
              </div>
            </li>
            <li>
              <pre>
              movieSubmitButton.onsubmit = async(event) => &#123;
              event.preventDefault();

              searchObj = &#123;
              title: encodeURI(event.target.elements.title.value),
              year: event.target.elements.year.value
              &#125;

              if (!searchObj.title || !searchObj.year) &#123;
              alert('Hiányzik a cím, vagy az év!');
              return;
              &#125;

              const response = await fetch(`http://www.omdbapi.com/?s=$&#123;searchObj.title&#125;&y=$&#123;searchObj.year&#125;&apikey=9606ae0f`);
              const movies = await response.json();

              if (movies.Response === 'False') &#123;
              alert(movies.Error);
              return;
              &#125;
              renderMovies(movies.Search);
              &#125;
              </pre>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <div id="movie-list" style="display: flex; gap: 30px"></div>
    <li>A renderMovies függvény
      <ul>
        <li>
          <pre>
                        function getMovies() &#123;
                            return fetch(`http://www.omdbapi.com/?s=$&#123;searchObj.title&#125;&y=$&#123;searchObj.year&#125;&apikey=9606ae0f`);
                        &#125;
                    </pre>
        </li>
        <li>
          <pre>
                    function renderMovies(movies) &#123;
                        var list = document.getElementById('movie-list');

                        list.innerHTML = '';

                        movies.map(m => &#123;
                            var hasPoster = (m.Poster !== 'N/A');
                            list.innerHTML +=
                                `&#60;div style="display: grid; width: min-content;"&#62;
                                    &#60;span&#62;
                                        $&#123;hasPoster ? `&#60;img src="$&#123;m.Poster&#125;" height="240px" width="162px"&#62;` : `&#60;div
                                            style="height:240px; width: 162px; background: gray"&#62;&#60;/div&#62;`&#125;
                                    &#60;/span&#62;
                                    &#60;span&#62;
                                        &#60;a href="https://imdb.com/title/$&#123;m.imdbID&#125;"
                                           style="text-decoration: none; font-weight: bold"
                                           target="_blank"&#62;
                                            $&#123;m.Title&#125;
                                        &#60;/a&#62;
                                        ($&#123;m.Year&#125;)
                                        &#60;div data-imdbid="$&#123;m.imdbID&#125;" class="movie-info-button" style="
                                            text-align: CENTER;
                                            cursor: pointer;
                                            MARGIN-TOP: 10px;
                                            border-radius: 5px;
                                            border: 1px solid grey;"&#62;INFO&#60;/div&#62;
                                    &#60;/span&#62;
                                &#60;/div&#62;`;
                        &#125;);

                        const clearPostersButton = document.getElementById('clear-posters');

                        if (!clearPostersButton) &#123;
                            list.insertAdjacentHTML('afterend', `
                                    &#60;div style="text-align: center;padding: 20px;"&#62;
                                        &#60;button id="clear-posters"
                                                style="background: red;border-color: red;box-shadow: none;color: white;"&#62;CLEAR&#60;/button&#62;
                                    &#60;/div&#62;
                                `);
                        &#125;

                        document.getElementById('clear-posters').addEventListener('click', () => &#123;
                            list.innerHTML = '';
                            const clearPostersButton = document.getElementById('clear-posters');
                            clearPostersButton.remove();
                        &#125;);

                        const allMovieButtons = document.querySelectorAll('.movie-info-button');

                        allMovieButtons.forEach(f => &#123;
                            f.onclick = async (event) => &#123;
                                var url = `http://www.omdbapi.com/?i=$&#123;event.target.dataset.imdbid&#125;&apiKey=9606ae0f`;

                                const movieInfo = await fetch(url);

                                if (!movieInfo.ok) &#123;
                                    alert('Hiba történt!');
                                    return;
                                &#125;

                                movieInfoData = await movieInfo.json();

                                console.log(movieInfoData);

                                const modalElem = document.createElement('div', &#123;is: "imdb-movie-info-box"&#125;);
                              modalElem.setAttribute('id', 'imdb-movie-info-box');
                                modalElem.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                                    width: 50%; height: 50%; background: #f5c519; border-radius: 5px; border: 3px solid black;
                                    padding: 10px; z-index: 2;';
                                document.body.appendChild(modalElem);

                                modalElem.innerHTML = `
                                    &#60;div style="display: grid; grid-gap: 20px;"&#62;
                                        &#60;div style="display: grid; grid-template-columns: 1fr auto; justify-content: space-between; font-size: 20px; font-weight: bold"&#62;
                                            &#60;div&#62;IMDB&#60;/div&#62;
                                            &#60;div id="close-imdb-movie-info-box" style="cursor: pointer">&#9447;&#60;/div&#62;
                                        &#60;/div&#62;
                                        &#60;div&#62;$&#123;movieInfoData.Title&#125;&#60;/div&#62;
                                        &#60;div style="display: grid; grid-gap: 5px"&#62;
                                            &#60;span style="display: grid; grid-template-columns: 25px 1fr"&#62;
                                                &#60;span&#62;&#9202;&#60;/span&#62;
                                                &#60;span&#62;$&#123;movieInfoData.Runtime&#125;&#60;/span&#62;
                                            &#60;/span&#62;
                                            &#60;span style="display: grid; grid-template-columns: 25px 1fr"&#62;
                                                &#60;span&#62;&#127909;&#60;/span&#62;
                                                &#60;span&#62;$&#123;movieInfoData.Genre&#125;&#60;/span&#62;
                                            &#60;/span&#62;
                                            &#60;span style="display: grid; grid-template-columns: 25px 1fr"&#62;
                                                &#60;span&#62;&#128197;&#60;/span&#62;
                                                &#60;span&#62;$&#123;movieInfoData.Year&#125;&#60;/span&#62;
                                            &#60;/span&#62;
                                            &#60;span style="display: grid; grid-template-columns: 25px 1fr"&#62;
                                                &#60;span&#62;&#9733;&#60;/span&#62;
                                                &#60;span&#62;$&#123;movieInfoData.imdbRating&#125;&#60;/span&#62;
                                            &#60;/span&#62;
                                        &#60;/div&#62;
                                        &#60;div style="display: grid; grid-gap: 5px"&#62;$&#123;movieInfoData.Plot&#125;&#60;/div&#62;
                                    &#60;/div&#62;
                                `;

                                const modalOverlayElem = document.createElement('div', &#123;is: "imdb-movie-info-box-overlay"&#125;);
                                modalOverlayElem.setAttribute('id', 'imdb-movie-info-box-overlay');
                                modalOverlayElem.style.cssText = 'position: fixed; top: 0; left: 0; bottom: 0; right:0; background: #000000; opacity: .7; z-index: 1';
                                document.body.appendChild(modalOverlayElem);

                                document.getElementById('close-imdb-movie-info-box').onclick = (event) => &#123;
                                    modalElem.remove();
                                    modalOverlayElem.remove();
                                &#125;
                                document.getElementById('imdb-movie-info-box-overlay').onclick = (event) => &#123;
                                    modalElem.remove();
                                    modalOverlayElem.remove();
                                &#125;
                            &#125;
                        &#125;);
                    </pre>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3>Paradigmák</h3>
  <br>
  <ul>
    <li>A programozás során felmerölő problémákra szemlélet(ek)</li>
    <li>Mindegyik merőben eltérő megközelítést alkalmaz, a maga eszközeivel, előnyeivel, hátrányaival</li>
    <li>3 típusát különböztetjük meg
      <ul>
        <li>Procedurális
          <ul>
            <li>Ez van a legközelebb a hardverher</li>
            <li>Legvékonyabb absztrakciós réteg</li>
            <li>Ez van a legközelebb ahhoz, ami valójában történik (a számítógépnek utasításokat adunk)</li>
            <li>
              <ul>
                <li>
                  <pre>
                                        var product = &#123;
                                            name: 'Fűnyíró',
                                            price: 45000,
                                            isInStock: true,
                                        &#125;
                                    </pre>
                </li>
                <li>Két operációt fogunk megvalósítani
                  <ul>
                    <li>Leértékelés és üzenet előállítás
                      <ul>
                        <li>Közvetlenül a memóriában módosítást hajtunk végre</li>
                        <li>
                          <pre>product.price *= 0.9;</pre>
                        </li>
                        <li>
                          <pre>var message = `A termék neve: $&#123;product.name&#125;, ára: $&#123;product.price&#125;
                                                    és $&#123;product.isInStock ? 'elérhető' : 'nem elérhető'&#125;`
                                                    </pre>
                        </li>
                        <li>A kód sorrendiségének nagyon nagy szerepe van</li>
                        <li>Nyelvek, amik ilyenek
                          <ul>
                            <li>C</li>
                            <li>Php</li>
                            <li>Javascript</li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Funkcionális
          <ul>
            <li>A programunkat pure function-ökből építjük fel, tehát side-effekt nélküli függvényekből,
              fekete dobozok, amik valami értékből generálnak valami kimenő értéket
            </li>
            <li>A rendszer állapotán nem hajt végre változtatást</li>
            <li>Ilyen nyelvek például:
              <ul>
                <li>Lisk</li>
                <li>Haskell</li>
                <li>Clojure</li>
                <li>F#</li>
                <li>(Javascript)</li>
              </ul>
            </li>
            <li>Akár változók használata nélkül, és side-effektek nélkül lehet az egész kódot megírni,
              úgynevezett moládok segítségével
            </li>
            <li>Javascriptben pipeline-okat építünk, amik tulajdonképpen pure-function-ökből összerakott
              csővezetékek, mint például a Promise chain, vagy az Array methodok (pl.: map, filter,
              reduce), ahol higher order függvények segítségével egy csővezetéket hozunk létre, amiben az
              adat átalakul
            </li>
            <li>
              <pre>
                                function withDiscount(product, discount) &#123;
                                return &#123;
                              name: product.name,
                              price: product.price * discount,
                              isInStock: product.isInStock,
                                &#125;
                            &#125;
                            </pre>
            </li>
            <li>
              <pre>
                                function withDiscount(product, discount) &#123;
                                    return &#123;
                              name: product.name,
                              price: product.price * discount,
                              isInStock: product.isInStock,
                                    &#125;
                                &#125;
                            </pre>
              <ul>
                <li>Stringet képez a bemenő termék objektumból</li>
              </ul>
            </li>
            <li>Az így összeállt "legókockákat" akár össze is építhetjük
              <ul>
                <li>
                  <pre>console.log(toMessage(withDiscount(product, 0.9)));</pre>
                </li>
                <li>A futási időnek nincs akkora szerepe</li>
                <li>Ugyanaz állt elő, mint procedurális szemlélettel</li>
                <li>A sorrendiséget nem lehet felcserélni</li>
                <li>Nem a memóriában változnak az értékek</li>
                <li>A koncepció, hogy kisebb darabokból összeépítesz egy nagyobb egységet</li>
                <li>Az egyes "darabok" / "részegységek" között a kapcsolatot a function-ök típus
                  annotációi teremtik meg
                </li>
                <li>Nem módosíthatunk értéket, csak a régiből hozhatunk létre újat</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>OOP / Objektum orientált
          <ul>
            <li>Jellemző nyelvek
              <ul>
                <li>Java</li>
                <li>C#</li>
                <li>Php</li>
                <li>Javascript</li>
              </ul>
            </li>
            <li>Az adatokat, és a műveleteket "összezárja" egy kontextusba, tehát az adatot ruházza fel az
              operációkkat
            </li>
            <li>Ez azt jelenti, hogy a product objektumunk nem csak a primitív adatokat tartalmazza, hanem
              egyúttal az ezeken az adatokon dolgozó műveleteket is
            </li>
            <li>Ilyen módon olyan egységeket lehet létrehozni, amik fel vannak ruházva adattal, tehát belső
              állapottal rendelkeznek, és saját maguk ki tudnak számolni ezekből az adatokból értékeket,
              és tudják szolgáltatni
            </li>
            <li>Konvenció szerint nagybetűvel írjuk a változót
              <ul>
                <li>
                  <pre>
                                        var Product = &#123;
                                            name: 'Fűnyíró',
                                            price: 45000,
                                            isInStock: true,
                                            applyDiscount: function (discount) &#123; // function (discount) &#123;&#125;

                                            &#125;
                                        &#125;
                                    </pre>
                </li>
                <li>A megközelítés lényege, hogy ő saját magán belül ki tudja számolni a leértékelést
                </li>
                <li>Az applyDiscount egy olyan függvény, ami vár egy számot, és nem küld vissza semmit
                  (number -> void)
                </li>
                <li>Belső állapotváltozást hoz létre magán belül, és a külvilág felé nem közvetít
                  semmit
                </li>
                <li>A getMessage pedig egy olyan függvény, ami nem vár paramétert, és stringet ad vissza
                  ( () -> string )
                </li>
                <li>A két függvény operáció, ami össze van zárva az adattal</li>
                <li>Az adatmezőket az objektuk 'property'-jeinek, vagy más nével 'field'-jeinek, a
                  függvényeket, amik pedig rá vannak csatlakoztatva az adatokra, 'method'-oknak
                  nevezik
                </li>
                <li>A method-ok a 'this' kulcsszóval tudnak dolgozni az adaton
                  <ul>
                    <li>A this kulcsszó mindig az egész objektumra mutat</li>
                    <li>A this kulcsszóval a többi method-hoz is hozzá lehet férni</li>
                  </ul>
                </li>
                <li>
                  <pre>
                                        applyDiscount: function (discount) &#123; // function (discount) &#123;&#125;
                                            this.price = this.price * discount;
                                        &#125;,
                                    </pre>
                  <ul>
                    <li>Az objektum megváltozik, de mi nem kapunk belőle értéket</li>
                  </ul>
                  <pre>
                                        getMessage: function () &#123;// function () &#123;&#125;
                                            return `A termék neve: $&#123;this.name&#125;, ára: $&#123;this.price&#125; és $&#123;
                              this.isInStock ? 'elérhető' : 'nem elérhető'&#125;`
                                        &#125;
                                    </pre>
                </li>
                <li>Ha használni szeretnénk az objektum methodjait, meg kell őket hívni
                  <ul>
                    <li>
                      <pre>
                                                Product.applyDiscount(0.8)
                                                console.log('getMessage: ', Product.getMessage());
                                            </pre>
                    </li>
                  </ul>
                </li>
                <li>Arrow function-ök (() => &#123; &#125;) esetén a this nem a globális vagy objektum kontextusra
                  mutat, hanem a létrehozásukkor érvényes környezetre
                </li>
                <li>Ezért objektum metódusainál általában hagyományos function definíciót használunk, hogy biztosítsuk a
                  helyes this kontextust
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A javascript többparadigmás nyelv, mindhármat támogatja</li>
  </ul>
</div>

<div>
  <h3>Objektum tervrajz</h3>
  <br>
  <ul>
    <li>Két módon valósítható meg
      <ul>
        <li>1) Constructor function létrehozása
          <ul>
            <li>A Javascript létrejötte óta elérhető</li>
            <li>Egyszerű mezei függvény, amit koncepció szerint nagybetűvel szokás elnevezni</li>
            <li>A függvény mindig lefut, amikor tervrajz alapján példányosítani akarunk egy új objecktumot,
              tehát hozzájutni egy adatokkal felpopulált egységhez
            </li>
            <li>Bemenetként várni a kell az adott objektumra specifikus adatokat</li>
            <ul>
              <li>
                <pre>
                                        function Termek(name, price, isInStock) &#123;
                                            this.name = name;
                                            this.price = price;
                                            this.isInStock = isInStock;
                                        &#125;
                                    </pre>
              </li>
              <li>A függvényből nem kell this-el return-ölni, a Javascript automatikusan megcsinálja</li>
              <ul>
                <li>
                  console.log(new Termek('kolbasz', 1000, true));
                </li>
              </ul>
              <li>Egyszerűvé válik mindenenfajta entitás létrehozása</li>
              <li>A cél, hogy ne csak a property-k egyezzenek meg, hanem az entitások kapcsán definiált
                funkcionalitás/method-ok is
                <ul>
                  <li>A method-okat futás időben lehet rácsatlakoztatni</li>
                  <li>
                    <pre>Termek.prototype.applyDiscount = function (discount) &#123;
                                                this.price = this.price * discount;
                                            &#125;

                                            Termek.prototype.getMessage = function () &#123;
                                                return `A termék neve: $&#123;this.name&#125;, ára: $&#123;this.price&#125; és $&#123;
                              this.isInStock ? 'elérhető' : 'nem elérhető'&#125;`
                                            &#125;
                                        </pre>
                  </li>
                  <li>Ha ugyanabba a kontextusba helyezzük el, mint a Termek() függvényt, akkor a
                    methodnak hozzáférése van a property-khez, tud velük dolozni
                  </li>
                  <li>
                    <pre>
                                            var termekek = [
                                                new Termek('kolbasz', 1000, true),
                                                new Termek('kenyér', 800, true),
                                                new Termek('hagyma', 300, true),
                                            ]
                                        </pre>
                    <ul>
                      <li>Biztosak lehetünk benne, hogy a method-ok minden elemre elérhetők</li>
                    </ul>
                    <pre>
                                            for (var product of termekek) &#123;
                                                console.log(product.getMessage());
                                            &#125;
                                        </pre>
                    <ul>
                      <li>Így minden termék nevét, árát, és elérhetőségét kiírtuk console log-ba
                      </li>
                    </ul>
                  </li>
                  <li>new Termek('kolbasz', 1000, true)
                    <ul>
                      <li>Létrehoztunk egy új instance-t, avagy új példányt (instantiation =
                        példányosítás)
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </ul>
        </li>
        <li>2) Class declaration
          <ul>
            <li>Az ES6 létrejötte óta elérhető</li>
            <li>Szintaktikai könnyítés, de a motorháztető alatt ugyanazt a módszert használja, mint a
              Constructor function
            </li>
            <li>
              <pre>
                                class Termek_ &#123;

                                    quantity = 1;

                                    constructor(name, price, isInStock) &#123;
                              this.name = name;
                              this.name = price;
                              this.name = isInStock;
                                    &#125;

                                    applyDiscount(discount) &#123;
                              this.price = this.price * discount;
                                    &#125;

                                    getMessage() &#123;
                              return `A termék neve: $&#123;this.name&#125;, ára: $&#123;this.price&#125; és $&#123;this.isInStock ? 'elérhető' : 'nem elérhető'&#125;`
                                    &#125;
                                &#125;
                            </pre>
              <ul>
                <li>Egy kontextusban leírható, amit Constructor function esetében leírtunk</li>
                <li>Nem kell szétválasztani constructorra, és egyéb function-ökre</li>
                <li>Baráti az objektum orientált szemléletű fejlesztők számára</li>
                <li>A construtor dedikált megnevezésű függvény</li>
                <li>Ugyanúgy lehet példányosítani
                  <ul>
                    <li>
                      <pre>
                                                const paprika = new Termek_('paprika', 600, false);
                                                console.log(paprika);
                                            </pre>
                    </li>
                  </ul>
                </li>
                <li>A constructor előtt property-ket is felsorolhatunk
                  <ul>
                    <li>Futási időben később használható
                      <ul>
                        <li>
                          <pre>
                                                        paprika.quantity = 3;
                                                    </pre>
                        </li>
                      </ul>
                    </li>
                    <li>A quantity 1 default érték</li>
                  </ul>
                </li>
                <li>A method-ok a constructor alatti függvények
                  <ul>
                    <li>Nincs szükség a function és prototype kulcsszóra</li>
                    <li>
                      <pre>
                                                paprika.applyDiscount(0.8);
                                                console.log('Paaprika aktuálisan: ', paprika.getMessage());
                                            </pre>
                      <ul>
                        <li></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A tervrajzok komplexebb egységeket is reprezentálhatnak
      <ul>
        <li>Az Angular, a React, és a Vue előszeretettel használnak class deklarációkat arra, hogy a programnak
          a moduláris felépítését elérjék
        </li>
        <li>Ezekben a rendszerekben tipikusan class deklarációkkal lehet leírni azt, hogy a user interface-ek
          egyes komponensei hogyan működjenek, hogyan nézzenek ki
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3>Arrow function</h3>
  <br>
  <ul>
    <li>Alternatív függvény deklarálási lehetőség</li>
    <li>Könnyedebb szintaxissal lehet leírni ugyanazt, mint amit a normál függvény deklarációval leírunk</li>
    <li>Csak anonym függvény lehet</li>
    <li>Futási időben lehet létrehozni könnyed függvénykifejezéseket, amelyek változókhoz köthetők, vagy átadhatók
      más függvényeknek
    </li>
    <li>Akkor a leghasználatosabb, amikor egyszerű, könnyed műveletekről (pure műveletekről) van szó
      <ul>
        <li>
          <pre>
                        var addOne = function (szam) &#123;
                            return szam + 1;
                        &#125;
                    </pre>
          <ul>
            <li>Arrow function használatával ez a következőképpen néz ki:</li>
            <li>
              <pre>var addTwo = szam => szam + 2;</pre>
            </li>
          </ul>
        </li>
        <li>A function és a return szótól is megszabadultunk, de ugyanazt a funkcionalitást értük el</li>
        <li>Promise chainben nagyon hasznos
          <ul>
            <li>
              <pre>
                                fetch('https://reqres.in/api/users')
                                    .then(function (response) &#123;
                                        return response.json();
                                    &#125;).then(function (content) &#123;
                                    console.log(content)
                                &#125;);
                            </pre>
            </li>
            <li>Átláthatóbbá, rövidebbé lehet tenni arrow function használatával</li>
            <li>
              <pre>
                                fetch('https://reqres.in/api/users')
                                    .then(response => response.json())
                                    .then(content => &#123;
                                    console.log(content)
                                &#125;);
                            </pre>
            </li>
            <li>További .then() blokkok ugyanígy leírhatók
              <ul>
                <li>
                  fetch('https://reqres.in/api/users')
                  .then(response => response.json())
                  .then(page => page.data[0])
                  .then(user => `$&#123;user.first_name&#125; $&#123;user.last_name&#125;`)
                  .then(content => &#123;
                  console.log(content)
                  &#125;);
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Az arrow function-nek is lehet body-ja
          <ul>
            <li>
              <pre>
                                // ...
                                .then((content) => &#123;
                                    console.log(content)
                                &#125;);
                                // ...
                            </pre>
            </li>
            <li>Body nélküli:
              <ul>
                <li>
                  <pre>
                                        // ...
                                        .then(page => page.data[0])
                                        // ...
                                    </pre>
                </li>
              </ul>
            </li>
            <li>Body-val nem return-ölünk egyből az értékkel, ehhez szükséges a return kulcsszó
              <ul>
                <li>
                  <pre>
                                        // ...
                                        .then((content) => &#123;
                                            console.log(content)
                                            return content;
                                        &#125;);
                                        // ...
                                    </pre>
                </li>
              </ul>
            </li>
            <li>Használatos, ha valamilyen kalkulációhoz egy részeredményt létre akarunk hozni, deklarálni
              változóként csak a függvény scope-ján belül
              <ul>
                <li>
                  <pre>
                                        // ...
                                        .then(user => &#123;
                                            const name = `$&#123;user.first_name&#125; $&#123;user.last_name&#125;`;
                                            return name;
                                        &#125;)
                                        // ...
                                    </pre>
                </li>
                <li>Arrow function esetében, amennyiben egyetlen egy paramétere van a függvényünknek,
                  úgy nem
                  kötelező kitenni a zárójelet
                </li>
              </ul>
            </li>
            <li>Mi történik akkor, ha arrow function esetén object-tel szeretnénk return-ölni?
              <ul>
                <li>A &#123;&#125; alkalmas az objektum leírására, viszont jelen esetben megnyitjuk vele a
                  function body-t
                </li>
                <li>
                  <pre>fetch("https://reqres.in/api/users")
                                            .then(response => response.json())
                                            .then(page => page.data[0])
                                            .then(user => &#123;
                                                const name = `$&#123;user.first_name&#125; $&#123;user.last_name&#125;`;
                                                return name;
                                            &#125;)
                                            .then(name => (&#123;userName: name&#125;))
                                            .then((content) => &#123;
                                                console.log(content);
                                            &#125;);
                                    </pre>
                </li>
                <li>Fontos, hogy a name-mel megyünk tovább</li>
              </ul>
            </li>
            <li>Array műveleteknél is hasznát vesszük
              <ul>
                <li>
                  <pre>
                                        var vegeredmeny = [1, 3, 4, 6, 45, 56]
                                            .filter(szam => szam % 2 === 0)
                                            .map(szam => szam / 2)
                                            .reduce((acc, cr) => acc + cr);
                                    </pre>
                </li>
                <li>A filter functionbe bedobott függvény is lehet arrow függvény</li>
                <li>A filterrel kiszedjük a tömbből a páros számokat</li>
                <li>a map-pel az összes így kapott páros számot elosztjuk kettővel</li>
                <li>Végül, ha az összegét akarnánk kiszámolni, használhatnánk a redure function-t
                  <ul>
                    <li>Mindig, amikor érkezik egy szám (acc), azt hozzáadjuk az addig összeadott
                      számokhoz
                    </li>
                    <li>Aggregált (különböző részekből összegyűjtött) értéket hozunk létre</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3>Try/Catch</h3>
  <br>
  <ul>
    <li>Hibakezelés, amivel szinkron futási időben keletkező hibákat lehet lekezelni</li>
    <li>Ahol a hiba történik - legyen ez a call stack-en bárhol - ott az egész kód futás megáll, és a call stack-en
      a keletkezett hibát elkezdi visszafelé passzolgatni, a hiba elkezd visszafelé propagálódni
    </li>
    <li>Amennyiben a hiba a call stack egyik elemében sincs lekezelve, végül visszakerülünk a main-be (legfelsőbb
      futási szintre), és fatális hibára futunk (uncaught error, "senki sem kapta el")
    </li>
    <li>Megkapjuk a stack trace-t, vagyis, hogy a call stack-en hol keletkezett ez a hiba</li>
    <li>
      <pre>
                try &#123;

                &#125; catch (error) &#123;

                &#125;
            </pre>
      <ul>
        <li>Ezzel a szintaktikával kell körülvenni azt a kódrészletet, amit le akarunk kezelni</li>
        <li>Így a hiba nem propagálódik fel a main-be, hanem a hibát a megfelelő scope-ban elkapjuk</li>
        <li>A catch blockban lévő kód fut le</li>
        <li>A hiba lekezelése után a kód futása folytatódik sorról sorra</li>
        <li>A kód futása a catch blokk futása után folytatódik sorról sorra, így nagyon nem mindegy, hova
          teszünk try/catch hibakezelést
        </li>
      </ul>
    </li>
    <li>Mi történik, ha a hiba aszinkron működéskor keletkezik?
      <ul>
        <li>Mivel a try/catch szinkron hibakezelésre alkalmas, és az aszinkron művelet (pl.: setTimeout())
          sokkal később keletkezik, így nem lehet lekezelni, kifutunk a mainbe
        </li>
        <li>A hiba csakis kizárólag az aszinkron művelet scope-jában kezelhető le</li>
        <li>
          <pre>
                        setTimeout(function() &#123;
                            try &#123;
                              hiba // hibára fut
                            &#125;
                            catch (error) &#123;
                              console.log(error);
                            &#125;
                        &#125;, 0);
                    </pre>
        </li>
      </ul>
    </li>
    <li>Mi magunk is generálhatunk hibák
      <ul>
        <li>
          <pre>
                        throw 'Fatális hiba';
                    </pre>
        </li>
        <li>Ilyenkor a catch ág error-jába bekerül a "bedobott" szöveg</li>
        <li>Error object-et is előállíthatunk
          <ul>
            <li>
              <pre>
                                throw new Error('Totális hiba');
                            </pre>
            </li>
            <li>Error objektum példányosítása történik, ami egy message-t vár bemeneti paraméternek</li>
            <li>Az ilyen módú hibára futtatást minden esetben valamilyen feltételhez kell kötni</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A try/catch a program flow-ját nagyon megbonyolíthatja, ha túlzásba visszük, hiszen a kód lineáris futása
      helyett össze-vissza ugráló futást kapunk
    </li>
  </ul>
</div>

<div>
  <h3>Mozijegy foglaló</h3>
  <br>
  <div class="theater"
    style="display: grid; gap: 5px; width: 600px; max-width: 100%; height: 700px; background-color: #1e2b37; border-radius: 5px; padding: 10px">
    <div style="text-align: center">
      <label for="movie-select">
        <select id="movie-select" style="width: 50%; padding: 5px">
          <option value="" disabled selected>Válassz egy filmet</option>
        </select>
      </label>
    </div>
    <div style="width: 75%;perspective: 1000px;justify-self: center;">
      <div
        style="background-color: aliceblue;height: 70px;width: 100%;margin: 15px 0;transform: rotateX(-45deg);box-shadow: 0 3px 10px rgba(255, 255, 255, 0.75);">
      </div>
    </div>
    <div id="auditorium" class="auditorium" style="min-height: 200px;">
    </div>
    <div>
      <div class="legend">
        <div>Szabad <span></span></div>
        <div>Foglalt <span></span></div>
        <div>Kiválasztva <span></span></div>
      </div>
    </div>
    <div id="user-info" style="text-align: center; color: white">
      Kiválasztottál <span id="seat-number">0</span> széket, aminek a teljes ára <span id="seat-price">0</span>
      forint
    </div>
    <div style="text-align: center;">
      <form id="send-reservation" method="post">
        <input id="person-count" placeholder="Név">
        <button type="submit">Foglalás</button>
      </form>
    </div>
  </div>
  <ul>
    <li>Az ES2015-ös verziója óta az objektum megőrzi a sorrendiséget, kivéve, hogy ha valamilyen numerikus kulcs
      fordul elő
    </li>
    <li>A Map() class példányosításával lehet reprezentálni olyan kulcs-érték párok sorozatát, ahol a sorrend is
      meg van őrizve
      <ul>
        <li>
          <pre>
                        const test = new Map();
                        test.set("A", 123); // A Map-nek a set() egy method-ja
                    </pre>
        </li>
        <li>Így numerikus érték esetén is megmarad a sorrend
          <ul>
            <li>
              <pre>
                                test.set("A", 123);
                                test.set("999", 456); // Mindig a második helyen fog elhelyezkedni
                                test.set("B", 789);
                            </pre>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3>Boxes</h3>
  <app-color-chooser (newColorSelected)="newColorHasBeenSelected($event)"></app-color-chooser>

  <div style="position: relative; width: 100%; height: 500px;">
    <div #box class="box" [ngClass]="isBoxGrabbed ? 'grabbed' : 'not-grabbed'"
      [ngClass]="isBoxGrabbed ? 'grabbed' : 'not-grabbed'" [ngStyle]="{
         'position': 'absolute',
         'left.px': xPosition,
         'top.px': yPosition,
         'border': '1px solid black'
       }" (mousedown)="toggleGrab($event)" (mouseup)="toggleGrab($event)" (mousemove)="isGrabbed($event)">
      <h3 style="text-align: center">grab-it</h3>
    </div>

    <div>{{ isBoxGrabbed }}</div>
    <div>{{ xPosition }}</div>
    <div>{{ yPosition }}</div>

    <app-box [xPosition]="100" [yPosition]="300" [color]="color"></app-box>
    <app-box [xPosition]="150" [yPosition]="400" [color]="color"></app-box>
    <app-box [xPosition]="200" [yPosition]="450" [color]="color"></app-box>
  </div>

</div>

<div>
  <h3>Kiegészítések</h3>
  <br>
  <ul>
    <li>Object destructuring
      <ul>
        <li>Lehetővé teszi az objektumok tulajdonságainak egyszerű és hatékony kinyerését és hozzárendelését
          változókhoz
        </li>
        <li>
          <pre>
                        const user = &#123;
                          name: 'John Doe',
                          age: 30,
                          email: 'john.doe@example.com'
                        &#125;;

                        // Alapvető használat
                        const &#123; name, age, email &#125; = user;
                        console.log(name);  // John Doe
                        console.log(age);   // 30
                        console.log(email); // john.doe@example.com

                        // Átnevezés
                        const &#123; name: userName, age: userAge, email: userEmail &#125; = user;
                        console.log(userName);  // John Doe
                        console.log(userAge);   // 30
                        console.log(userEmail); // john.doe@example.com

                        // Alapértelmezett érték
                        const &#123; name, age, email, gender = 'male' &#125; = user;

                        // Beágyazott objektum

                        const user = &#123;
                          name: 'John Doe',
                          address: &#123;
                              city: 'New York',
                              country: 'USA'
                          &#125;
                        &#125;;
                        const &#123; name, address: &#123; city, country &#125; &#125; = user;

                        console.log(name);   // John Doe
                        console.log(city);   // New York
                        console.log(country); // USA

                    </pre>
        </li>
      </ul>
    </li>
    <br>
    <li>Console log színezés
      <ul>
        <li>Érdekesség, hogy a console.log képes a megadott színnel megjeleníteni a szöveget
          <ul>
            <li>
              <pre>console.log('%c ' + color, 'color: ' + color);</pre>
            </li>
            <li>Az első rész a szöveg: '%c ' + color</li>
            <li>A második rész a szín: 'color: ' + color</li>
            <li>A fenti esetben maga a szín, és a szín neve megegyezik</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Array destructuring
      <ul>
        <li>lehetővé teszi, hogy egy tömb elemeit egyszerű módon külön változókba bontsuk</li>
        <li>
          <pre>
            const array = [1, 2, 3];

            // Alapvető használat
            const [a, b, c] = array;
            console.log(a); // 1
            console.log(b); // 2
            console.log(c); // 3

            // Értékek kihagyása
            const [a, , b] = array;
            console.log(a); // 1
            console.log(b); // 3

            // Alapértelmezett értékek
            const array = [1];

            const [a, b = 5] = array;
            console.log(a); // 1
            console.log(b); // 5

            // Maradék elemek kezelése
            const array = [1, 2, 3, 4, 5];

            const [a, b, ...rest] = array;
            console.log(a); // 1
            console.log(b); // 2
            console.log(rest); // [3, 4, 5]
          </pre>
        </li>
      </ul>
    </li>
    <li>Spread Syntax
      <ul>
        <li>Lehetővé teszi egy iterálható objektum (mint például egy tömb vagy egy objektum) elemeinek kibontását</li>
        <li>Tömböknél
          <ul>
            <li>tömbök egyesítése
              <ul>
                <li>
                  <pre>
                    const arr1 = [1, 2, 3];
                    const arr2 = [4, 5, 6];
                    const combined = [...arr1, ...arr2];
                    console.log(combined); // [1, 2, 3, 4, 5, 6]

                    // OR

                    const parts = ["shoulders", "knees"];
                    const lyrics = ["head", ...parts, "and", "toes"];
                    console.log(lyrics) //   ["head", "shoulders", "knees", "and", "toes"]
                  </pre>
                </li>
              </ul>
            </li>
            <li>tömb elemeinek másolása
              <ul>
                <li>
                  <pre>
                    const original = [1, 2, 3];
                    const copy = [...original];
                    console.log(copy); // [1, 2, 3]
                  </pre>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Objektumoknál
          <ul>
            <li>objektumok egyesítése
              <ul>
                <li>
                  <pre>
                    const obj1 = &#123; a: 1, b: 2 &#125;;
                    const obj2 = &#123; c: 3, d: 4 &#125;;
                    const combinedObj = &#123; ...obj1, ...obj2 &#125;;
                    console.log(combinedObj); // &#123; a: 1, b: 2, c: 3, d: 4 &#125;
                  </pre>
                </li>
              </ul>
            </li>
            <li>objektum elemeinek másolása
              <ul>
                <li>
                  <pre>
                    const originalObj = &#123; a: 1, b: 2 &#125;;
                    const copyObj = &#123; ...originalObj &#125;;
                    console.log(copyObj); // &#123; a: 1, b: 2 &#125;
                  </pre>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Nullish coalescing
      <ul>
        <li>Logikai operátor, ami a jobb oldalt adja vissza, ha a bal oldal értéke null, vagy undefined</li>
        <pre>
          let myValue = someVariable ?? "default value";
        </pre>
        <li>Abban különbözik a logikai vagy ( || ) operátortól, hogy ha a bal oldal 0, üres string, vagy false, akkor a
          nem a jobb oldal fog érvényesülni
        </li>
      </ul>
    </li>
  </ul>
</div>