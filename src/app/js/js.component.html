<h1 class="info-header">JavaScript
  <span placement="end" ngbTooltip="A console.log()-ok nem kerültek kikommentezésre"></span>
  <span placement="end" ngbTooltip="A reqres.in 100 request-et engedélyez napnta ingyenesen"></span>
</h1>

<div class="anchor-navi-container">
  <div *ngFor="let mainButton of anchorButtons" class="btn-group">
    <button type="button" class="btn btn-primary btn-sm anchor" (click)="scrollToAnchor(mainButton?.anchor)">
      {{ mainButton.title }}
    </button>
    <button *ngIf="mainButton?.subtitles?.length" type="button"
      class="btn btn-primary dropdown-toggle dropdown-toggle-split btn-sm anchor" data-bs-toggle="dropdown"
      aria-expanded="false">
    </button>
    <ul *ngIf="mainButton.subtitles?.length" class="dropdown-menu dropdown-menu-dark">
      <li>
        <button *ngFor="let subButton of mainButton?.subtitles" class="dropdown-item"
          (click)="scrollToAnchor(subButton?.anchor)">
          {{ subButton?.title }}
        </button>
      </li>
    </ul>
  </div>
</div>

<div>
  <h3 #httpprotocol data-anchor="httpprotocol">HTTP protocol</h3>
  <ul>
    <li>HyperText Transfer Protocol</li>
    <li>Protokoll, tehát szabályrendszer a kommunikációra</li>
    <li>Két fél kommunikál egymással (kliens és szerver)</li>
    <li>A kliens HTTP kéréseket (request) küld, és a szerver HTTP válaszokat (response) ad</li>
    <li>Kliens ebben a kommunikációban például a Google Chrome</li>
    <li>A böngészőben fut a JavaScript engine (interpreter), amely a JavaScript nyelven írt kódot végrehajtja,
      és ezen keresztül vezérli a böngészőt
    </li>
    <li>Az Engine tudja vezérelni a HTML dokumentumot, például elemeket hozzon létre, vagy attribútumokat
      módosítson, és hozzáférése van a Console-hoz, ami egy interface, amin keresztül mi commandokat tudunk
      beküldeni az Engine-nek, és meg tudjuk nézni, amit az Engine válaszként visszaküld
    </li>
    <li>Az Engine HTTP kéréseket is tud küldeni, és a válaszokat fel tudja dolgozni (AJAX kérések)</li>
    <li>Az Engine-en keresztül adatot is tudunk tárolni (localStorage), ahol elhelyezhetünk adatot, és onnan
      újabb oldalletöltéskor ki tudjuk olvasni
    </li>
    <ul>
      <li>Localstorage-ba tudunk tárolni számokat, szövegeket, logikai értékeket, tömböket, vagy objektumokat
      </li>
      <li>Objektum tárolása
        <ul>
          <pre>
  let userJSON = &#123; name: "Johnny", age: 30 };
  localStorage.setItem("user", JSON.stringify(userJSON));

  let savedUser = JSON.parse(localStorage.getItem("user"));

  console.log(savedUser);

  ↓↓↓↓↓

  &#123; name: "Johnny", age: 30 }
          </pre>
          <li>A JSON.stringify() és JSON.parse() JavaScript függvények
            <ul>
              <li>JSON.stringify()
                <ul>
                  <li>JSON formátumba alakítása az objektumnak</li>
                </ul>
              </li>
              <li>JSON.parse()
                <ul>
                  <li>JSON formátumból JS objektumba alakítás</li>
                </ul>
              </li>
            </ul>
          </li>
          <pre>
  localStorage.setItem("fruits", JSON.stringify(["alma", "banán", "narancs"]));
          </pre>
        </ul>
      </li>
    </ul>
    <li>JS Engine ma már szerver oldalon is futtatható (Node.js), ami a kéréseket fogadja, és erre válaszokat
      küld, így feladatát tekintve merőben eltér a kliens oldali Engine-től
    </li>
    <li>A kliens oldalon a JavaScript-nek 2 fő feladata van
      <ul>
        <li>HTML elemek módosítása révén interakció fokozás</li>
        <li>AJAX kérések küldése révén oldalletöltés nélkül tudunk kis mennyiségű adatért folyamodni a
          szerver felé
        </li>
      </ul>
    </li>
    <li>Létrehozhatunk olyan User Interface-eket, amik oldalletöltés nélkül kommunikálnak a szerverrel, és
      interaktív hatásokat hoznak létre
    </li>
  </ul>
</div>

<div>
  <h3 #javascriptandconsole data-anchor="javascriptandconsole">JavaScript & Console</h3>
  <ul>
    <li>A fejlesztői eszközök közé tartozik a Console</li>
    <li>A <a href="http://google.com" target="_blank">Google kereső</a> egyik id attribútumát keressük ki a DOM-ban
      (Inspect),
      vagy ha nincs, adjunk hozzá valamelyik DOM elemhez egy tetszőleges id attribútumot
      <ul>
        <li>document.getElementById(ID).style.backgroundColor = "green";
          <ul>
            <li>Zöldre fog változni a háttér</li>
          </ul>
        </li>
        <li>fetch("https://jsonplaceholder.typicode.com/posts").then(res => res.json()).then(res =>
          console.log(res));
          <ul>
            <li>Network fülön is látható a kérés</li>
            <li>JSON formátumú tartalom (nem HTML)</li>
          </ul>
        </li>
        <li>fetch("https://jsonplaceholder.typicode.com/posts").then(res => res.json()).then(res =>
          document.getElementById(ID).innerHTML = res[0].title);
          <ul>
            <li>A zöld hátteret követően pedig egy kis szöveget is kiírtunk</li>
          </ul>
        </li>
        <pre>
  window.onload = async function () &#123;
      fetch("https://jsonplaceholder.typicode.com/posts")
      .then(res => res.json())
      .then(res => document.getElementById('fetchFirstPostTitle').innerHTML = res[0].title);
  &#125;
            </pre>

        <li>A body-ban elhelyezhető egy script tag
          <pre>
  &#60;script&#62;
      fetch("https://jsonplaceholder.com.typicode.com/posts")
      .then(res => res.json()).then(console.log(res));
  &#60;/script&#62;
            </pre>
        </li>
        <li>Az ilyen parancsokat külön script fájlban szokás tárolni, és a böngészőt utasítani arra,
          hogy a script fájlt szerezze meg a szerverről, és futtassa le
          <ul>
            <li>index.html-ben
              <pre>
  &#60;script src="./src/basic.js"&#62;&#60;/script&#62;
                </pre>
            </li>
          </ul>
        </li>
        <li>Async nélkül nem kapjuk meg a fetch eredményét</li>
        <li>A fenti onload-ra lefutó fetch az alábbi sort eredményezi
          <ul>
            <li id="fetchFirstPostTitle"></li>
            <pre>
  &#60;li id="fetchFirstPostTitle">&#60;/li>
            </pre>
            <li>Ehhez persze Angularban el kellett távolítani a basic.js fájlból az onload függvényt
              <ul>
                <li>Ennek oka, hogy nem fog már lefutni
                  <ol>
                    <li>Az Angular inicializálódik, betölt az oldal</li>
                    <li>Valamelyik lifecycle hook-ban hozzáadjuk egy új &#60;script>-et a DOM-hoz</li>
                    <li>A böngésző már rég túl van az onload eseményen, így a script tartalma már sosem fog lefutni</li>
                    <pre>
  this.loadScript('assets/scripts/basic.js');

  private loadScript(src: string) &#123;
    const script = document.createElement('script');
    script.src = src;
    script.onload = () => &#123;
      console.log('Script loaded and ready.', src);
    };
    document.body.appendChild(script);
  }

  // window.onload = async function () &#123;
    fetch("https://jsonplaceholder.typicode.com/posts").then(res => res.json()).then(res => document.getElementById('fetchFirstPostTitle').innerHTML = res[0].title);
  // }
                    </pre>
                  </ol>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A böngészőben megnyitva az index.html-t, láthatjuk, hogy kiment az AJAX kérés</li>
        <li>A böngésző fentről lefelé dolgozza fel a HTML dokumentumot, és amint script tagre fut,
          végrehajtja a benne lévő kódot
        </li>
        <li>Először a HTML töltődött be, majd megérkezett a script fájl (megérkezett a
          forrásfájljaink közé), majd végrehajtódott, lefutott az AJAX kérés
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #datatypes data-anchor="datatypes">Data types</h3>
  <ul>
    <li>Az adattípusokat halmazokként is elképzelhetjük
      <ul>
        <li>Az adat értékéből meg lehet mondani (determinálja), hogy milyen típus, és hogy milyen műveletek
          hajthatók végre rajta
        </li>
        <li>A boolean "dobozkából" true, vagy false érték választható csak</li>
      </ul>
    </li>
    <br>
    <li>Komment
      <ul>
        <li>Végre nem hajtódó JS kód</li>
        <li>Két féle létezik
          <ul>
            <li>Sor (line) komment //</li>
            <li>Blokk (block) komment /* */</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Primitív adattípusok
      <ul>
        <li>Szöveges adattípus (string)
          <ul>
            <li>Szimpla, vagy dupla (az engine-t nem érdekli) idézőjelek közé írt karakterlánc</li>
            <li>Műveletek például: karakterek megszámolása, szöveg hozzáfűzése, nagybetűssé tétel</li>
            <li>"Szia" => String típusú, szia értékű...érték</li>
          </ul>
        </li>
        <li>Szám (number) adattípus
          <ul>
            <li>JS nem tesz különbséget tört, és egész szám között</li>
            <li>Műveletek például: hozzádás, kivonás, osztás utáni maradék számítás</li>
          </ul>
        </li>
        <li>Boolean adattípus
          <ul>
            <li>Igaz/hamis értékeket reprezentál</li>
            <li>Két értéket vehet fel: true/false</li>
            <li>Műveletek például
              <ul>
                <li>Logikai és
                  <ul>
                    <li>Két boolean a bemenete, és akkor tér vissza true-val, ha mindkét bemeneti
                      paraméter true</li>
                  </ul>
                </li>
                <li>Negálás
                  <ul>
                    <li>Az adott boolean értéket változtatja az ellentettjévé</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Undefined adattípus
              <ul>
                <li>Egy érték a rendszerünkben nincs definiálva</li>
              </ul>
            </li>
            <li>Null adattípus
              <ul>
                <li>Az érték definiálva van a rendszerünkben, csak null az értéke</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #array data-anchor="array">Array</h3>
  <ul>
    <li>Nem primitív típus</li>
    <li>Azt reprezentálja, hogy valamiből sok van</li>
    <li>Kéz a kézben jár egy másik típussal</li>
    <li>Array&#60;T&#62; (például Array&#60;string&#62; - tehát sok string)</li>
    <li>Szintaktika: ['a', 'b', 'c'] / [1, 2, 3]</li>
    <li>A benne lévő értékek a tömb elemei</li>
    <li>Indexált lista, mindegyik tömbelem rendelkezik index-szel, ami 0-ról indul, egyesével növekszik</li>
    <li>Műveletek például
      <ul>
        <li>Szűrés</li>
        <li>Sorba rendezés</li>
        <li>Új elem hozzáadása</li>
        <li>Aggregálás
          <ul>
            <li>Az adott tömb elemeit egyetlen értékbe vagy összefoglaló értékbe állítjuk össze</li>
          </ul>
        </li>
        <li>Index alapú kikérés</li>
      </ul>
    </li>
    <li>A műveleteket nem érdekli, hogy a tömbben milyen típusú elemek vannak</li>
    <li>JavaScript-ben semmi sem akadályozza meg, hogy eltérő típusokkal töltsünk fel egy tömböt, de ez a tömbnek
      nem a tipikus felhasználása, sőt, veszélyes, más nyelveken ez hibára is fut
    </li>
    <li>Lehetnek többdimenziósak
      <ul>
        <li>A tömb elemei lehetnek további tömbök: Array&#60;Array&#60;number&#62;&#62;</li>
        <li>Olyan tömb, aminek az elemei számok tömbjei</li>
        <li>[ [1, 2], [3, 4], [5, 6] ]</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #object data-anchor="object">Object</h3>
  <ul>
    <li>Kulcs-érték párok sorozata</li>
    <li>Tekinthetünk rá, mint egyfajta szótár (Python-ban dictionary a neve)</li>
    <li>A kulcsoknak egyedieknek kell lennie</li>
    <pre>
  &#123;
      firstName: 'Gábor',
      lastName: 'Kenő',
      age: 30
  &#125;
     </pre>
    <li>A tömbbel szemben látjuk, hogy nem indexünk van, ami asszociálva van egyetlen értékkel, hanem kulcsunk
    </li>
    <li>Az adat felcímkézhető, explicit kulcs lévén juthatunk hozzá az értékhez</li>
    <li>Műveletek például
      <ul>
        <li>"lookup"
          <ul>
            <li>Magyarul kulcs alapú kikérés
              <ul>
                <li> JavaScript-ben kétféleképpen tehető meg
                  <ul>
                    <li>Pont szintaxis: user.lastName</li>
                    <li>user['lastName']</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Összekombinálható az összes többi adattípussal
      <ul>
        <pre>
  &#123;
      firstName: 'Gábor',
      lastName: 'Kenő',
      age: 30,
      single: false,
      phoneNumbers: [
        '+36501234567',
        '+36508765432'
      ]
      address: &#123;
          street: 'Király utca',
          city: 'Budapest'
      &#125;
  &#125;
        </pre>
        <li>user.address.street / user['address']['street']</li>
      </ul>
    </li>
    <li>Részben garantált a kulcsok sorrendje (ES6-től), de nem 100%-ig
      <ul>
        <li>Általános szabály
          <ul>
            <li>Szám kulcsok növekvő sorrendben (de stringként), szöveg kulcsok a beszúrás sorrendjében, szimbólumok a
              legvégén</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #operators1 data-anchor="operators1">Operators I.</h3>
  <ul>
    <li>Valami adaton műveletet végrehajtó nyelvi eszköz</li>
    <li>Kategorizálhatók
      <ul>
        <li>+ operátor
          <ul>
            <li>Aritmetikai operátor</li>
            <li>number típusú értékeken végez operációt</li>
            <li>console.log(2 + 3) - A számok az operandusok</li>
            <li>Fekete doboz, ami 2 értékből visszaad 1 értéket</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Csoportosíthatók
      <ul>
        <li>Operandusok száma szerint
          <ul>
            <li>unary operátor: egyoperandusú</li>
            <li>binary operátor: kétoperandusú</li>
            <li>ternary operátor: háromoperandusú</li>
          </ul>
        </li>
        <li>Operátor lexikális elhelyezkedése az operandusokhoz képest
          <ul>
            <li>prefix operátor: előtte van</li>
            <li>infix operátor: közötte van</li>
            <li>postfix operátor: utána van</li>
          </ul>
        </li>
        <li>Hajt-e végre mellékhatást (side effect)
          <ul>
            <li>Amellett, hogy leképez valamit, a rendszerben valami változást okoz
              <ul>
                <li>Kiírhat a console-ba</li>
                <li>Beolvashat, vagy kiírhat adatot a memóriába</li>
              </ul>
            </li>
            <li>Nem determinisztikusan működik, van, amikor másképp működik, vagy a rendszer egészében
              valamilyen változást beállít
            </li>
            <li>Csoportosítása
              <ul>
                <li>Végrehajt mellékhatást</li>
                <li>Nem hajt végre mellékhatást</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Aritmetikai operátor
      <ul>
        <li>bináris, infix, side effect-et nem végrehajtó
          <ul>
            <li>Következetesen jellemző rájuk, hogy két number-t vár bemenetként, és egy number-t ad
              vissza
            </li>
            <li>(number, number) => number</li>
          </ul>
        </li>
        <li>+ - * / %</li>
        <li>
          <pre>
  console.log(2 + 4); => 6
  console.log(2 - 4); => -2
  console.log(2 * 4); => 8
  console.log(2 / 4); => 0.5
  console.log(7 % 3); => 1    // maradék = 1
           </pre>
        </li>
        <li>A matematika szabályait követik, tehát a szorzás művelet előbb hajtósik végre, mint az
          összeadás, de zárójellel felülírható
        </li>
      </ul>
    </li>
    <li>Összehasonlító operátorok
      <ul>
        <li>Több fajta bemenetet is várhatnak típus szempontjából</li>
        <li>(any, any) => boolean</li>
        <br>
        <li>== (equality)
          <ul>
            <li>Megnézi, hogy két érték megegyezik-e, vagy sem</li>
            <li>Ha számot string-gel hasonlítunk össze, és egyezés van, akkor true-t kapunk vissza</li>
            <li>console.log(2 == '2') => true</li>
            <li>A nyelv gyenge típusosságából adódik, átkonvertálja a -et számmá</li>
            <li>console.log(1 == true) => true, mert a true-t átalakítja 1-esre
              <ul>
                <li>A false értéke pedig 0-vá alakul</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>!=
          <ul>
            <li>Azt vizsgálja, hogy a két érték nem egyenlő-e (tehát eltér)</li>
          </ul>
        </li>
        <li>=== (identity)
          <ul>
            <li>A típusátalakítást nem csinálja meg</li>
            <li>Szigorúbb, mint az equality</li>
            <li>console.log(2 === '2') => false</li>
            <li>String-ek összehasonlítására is lehet használni</li>
          </ul>
        </li>
        <li>!==
          <ul>
            <li>Az identitynél látott szigor ugyanúgy jellemző</li>
          </ul>
        </li>
        <li>&#62;
          <ul>
            <li>Nagyobb, mint</li>
            <li>Tipikusan számot vár</li>
          </ul>
        </li>
        <li>&#60;
          <ul>
            <li>Kisebb, mint</li>
            <li>Tipikusan számot vár</li>
          </ul>
        </li>
        <li>&#62;=
          <ul>
            <li>Nagyobb egyenlő, mint</li>
            <li>Tipikusan számot vár</li>
          </ul>
        </li>
        <li>&#60;=
          <ul>
            <li>Kisebb egyenlő, mint</li>
            <li>Tipikusan számot vár</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Logikai operátorok
      <ul>
        <li>Bemenetként boolean-t várnak, és a kimenetük is boolean</li>
        <li>(boolean, boolean) => boolean</li>
        <li>Lesz köztük egy, ami unary (boolean) => boolean</li>
        <br>
        <li>Logikai ÉS
          <ul>
            <li>console.log(true && false) (false)</li>
            <li>Csak akkor ad vissza true-t, ha minden bemeneti értéke true</li>
          </ul>
        </li>
        <li>Logikai VAGY
          <ul>
            <li>console.log(true || false) (true)</li>
            <li>Két pipe karakter</li>
            <li>A beérkező boolean-ok közül az egyik true, akkor a kimenet is true</li>
          </ul>
        </li>
        <li>Negálás
          <ul>
            <li>Prefix operátor</li>
            <li>A bemeneti értéket negálja</li>
            <li>false => true / true => false</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>String operátor
      <ul>
        <li>Szövegek összefűzésére/konkatenálására (concatenate) alkalmas</li>
        <li>Tulajdonképpen az aritmetikai operátorok + jele, csak string-et fűz össze</li>
        <li>
          <pre>
  console.log('Hello' + ' World') => Hello World
          </pre>
        </li>
      </ul>
    </li>
    <li>Conditional operátor
      <ul>
        <li>Az egyetlen ternary operátor a nyelvben (háromoperandusú)</li>
        <li>Szokás ternary operátornak nevezni</li>
        <li>(boolean, any, any) => any</li>
        <li>A boolean dönti el, hogy a kimenet a második, vagy a harmadik bemeneti paraméter legyen</li>
        <li>
          <pre>
  console.log(true ? 'második' : 'harmadik') => "második"

  console.log(false ? 'második' : 'harmadik') => "harmadik"
          </pre>
        </li>
      </ul>
    </li>
    <li>Az egyes operátor családok kompatibilisek lehetnek egymással
      <ul>
        <li>Több operátor felhasználásával nagyobb kifejezések is építhetők</li>
        <li>console.log(2 === 2 && 1 > 5) => console.log(true && false) => false</li>
        <li>Ha több operátorral dolgozunk egyszerre, az operátoroknak van egy precedenciájuk (elsőség)
          <ul>
            <li>A végrehajtódás sorrendje meg van határozva</li>
            <li>Az && operátor előbb hajtódik végre, mint az ||</li>
            <li>Zárójelekkel felülírható</li>
            <li>console.log(2 === 2 && (1 > 5) || true) ==> console.log(true && false || true) ==> console.log(false ||
              true) ==> true</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #operators2 data-anchor="operators2">Operators II.</h3>
  <ul>
    <li>A fenti operátorok mind determinisztikusak</li>
    <li>Nézzük azokat, amik a rendszer állapotát megmódosítják
      <ul>
        <li>Assignment operátor
          <ul>
            <li>A memóriába eltárol értéket</li>
            <li>Típus annotációját tekintve, vár egy változót, és egy bármilyen adattípust</li>
            <li>(var, any) => any</li>
            <li>Példa</li>
            <pre>
  var valtozo;
            </pre>
            <li>A valtozo a memóriában létrehozott kulcs, amihez értékek fűzhetők hozzá</li>
            <li>Később, futásidőben elő lehet szedni a kulcs értékét</li>
            <li>A fenti változóhoz automatikusan hozzárendelődik egy undefined érték</li>
            <pre>
  valtozo = 'hello'
            </pre>
            <li>Innentől kezdve a változó már nem undefined, hanem egy string (hello)</li>
            <li>Az értéke nem determinisztikus</li>
            <li>Az assignment operátorral már az időt is bevittük a rendszerbe</li>
            <li>A JavaScript-re jellemző, hogy dinamikus típusos nyelv
              <ul>
                <li>A változókba más típusú érték is beköthető</li>
                <li>Statikus típusú nyelvekben ilyet nem lehet</li>
                <pre>
  valtozo = 3
                </pre>
                <li>Fentebb string-et helyeztünk a változóba, az imént pedig number-t</li>
              </ul>
            </li>
          </ul>
        </li>
        <br>
        <li>Increment operátor
          <ul>
            <li>++</li>
            <li>postfix</li>
            <li>valtozo++</li>
            <li>A változó értékét növeli eggyel</li>
          </ul>
        </li>
        <li>Decrement operátor
          <ul>
            <li>--</li>
            <li>postfix</li>
            <li>valtozo--</li>
            <li>A változó értékét csökkenti eggyel</li>
            <li>Pre-dekrementális operáció is létezik (csak úgy, mint pre-inkrementális)
              <ul>
                <pre>
  let valtozo = 5;
  console.log(valtozo--);  // a kimenet: 5, mert először használja az értéket, és csak utána csökkenti
  console.log(valtozo);    // a kimenet: 4, mert utána csökkentette
                </pre>
              </ul>
            </li>
          </ul>
        </li>
        <li>+=
          <ul>
            <pre>var szam = 5</pre>
            <li>A memóriában egy meghatározott, explicit értékkel változtatja meg az értéket</li>
            <pre>szam += 10; => 15</pre>
            <li>Tehát a szam valtozó értéke immáron 15</li>
            <li>String-ekkel is működik, olyan, mint a hozzáfűzés
              <ul>
                <li>var nemszam = 'hello'</li>
                <li>nemszam += ' world'</li>
                <li>Eredmény: hello world</li>
                <li>Egyenértékű ezzel: 'hello' + ' world'</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>-=
          <ul>
            <pre>var szam = 5</pre>
            <li>A memóriában egy meghatározott, explicit értékkel változtatja meg az értéket</li>
            <pre>szam -= 2; => 3</pre>
            <li>Tehát a szam valtozó értéke immáron 3</li>
          </ul>
        </li>
        <li>*=</li>
        <li>/=</li>
        <li>%=</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #ticketbuyingapp data-anchor="ticketbuyingapp">Ticket app</h3>
  <ul>
    <li>
      <button class="btn btn-secondary" id="promptListener">Prompt</button>
      <pre>
  const promptButton = document.getElementById("promptListener");
  promptButton.addEventListener("click", showPrompt);

  function showPrompt() &#123;
      prompt('Ez egy prompt');
  &#125;
      </pre>
    </li>
    <li>
      <button class="btn btn-secondary" id="alertListener">Alert</button>
      <pre>
  const alertButton = document.getElementById("alertListener");
  promptButton.addEventListener("click", showAlert);

  function showAlert() &#123;
      alert('Ez egy alert');
  &#125;
      </pre>
    </li>
    <li>
      <button class="btn btn-secondary" id="ticketingListener">Jegyvásárlás</button>
      <br>
      <ul>
        <li>Beolvastatjuk a prompt-tal a felhasználóval, hogy
          <ul>
            <li>Hány jegyet kér</li>
            <li>Milyen típusú jegyet kér (student | adult)</li>
          </ul>
        </li>
        <li>A diákjegy ára 300 Ft, a felnőtt jegy ára 350 Ft</li>
        <li>10-nél több jegy vásárlása esetén jár 10 % kedvezmény</li>
        <pre>
  function showTicketingPrompt() &#123;
      const quantity = prompt('Hány darab jegyet szeretnél?');
      const type = prompt('Felnőtt, vagy diákjegyet szeretnél vásárolni? (adult | student)');

      var price = type === 'student' ? 300 : 350;
      var discount = quantity > 10 ? 0.9 : 1;

      var total = quantity * price * discount;

      alert(total);
  &#125;
        </pre>
        <li>Nyugdíjas jeggyel bővítés
          <pre>
  function showTicketingPrompt() &#123;
    const quantity = prompt('Hány darab jegyet szeretnél?');
    const type = prompt('Felnőtt, diák, vagy nyugdíjas jegyet szeretnél vásárolni? (adult | student | retired)');

    var types = &#123;
          student: 300,
          adult: 350,
          retired: 250
      &#125;

      var price = types[type]
      var discount = quantity > 10 ? 0.9 : 1;

      var total = quantity * price * discount;

      alert(total);
  &#125;
          </pre>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #loops data-anchor="loops">Loops</h3>
  <ul>
    <li>Kontroll struktúra, avagy vezérlési szerkezet
      <ul>
        <li>Olyan nyelvi eszközök, amelyek a kód futását befolyásolják</li>
        <li>Ciklikus működést eredményez</li>
        <li>Szabályozza, hogy bizonyos sorok lefussanak-e, vagy sem</li>
      </ul>
    </li>
    <li>Adott egy tömb, amiben számok vannak, és szeretnénk megkapni azt, hogy hány darab páros számot
      tartalmaz a tömb
      <ul>
        <pre>
  var szamok = [2, 4, 13, 4, 6, 42];

  var parosakSzama = 0;

  parosakSzama += szamok[0] % 2 === 0 ? 1 : 0;

  console.log(parosakSzama);

  ↓↓↓↓↓

  1
        </pre>
        <li>Ha lefuttatjuk az utolsó sort minden elemre, akkor megkapjuk az ereményt</li>
        <li>A probléma, hogy így a kódunk nagyon repetitív lesz</li>
        <li>A kontroll struktúrák automatizálást valósítanak meg, tehát addig futtatják kódot, amíg bizonyos feltétel
          meg nem valósul</li>
      </ul>
    </li>
    <br>
    <li>A kontroll egyik családja
      <ul>
        <li>Ciklusok (loops)
          <ul>
            <li>While ciklus (loop)
              <ul>
                <pre>
  while() &#123;

  &#125;
                </pre>
                <li>A kapcsos zárójelen belüli rész a ciklus body-ja</li>
                <li>A while-nak szüksége van egy bemeneti értékre</li>
                <li>Addig fogja a body-t futtatni, amíg a feltétel hamis nem lesz</li>
                <li>Végtelen ciklus hozható létre
                  <ul>
                    <pre>
  while(true) &#123;

  &#125;
                    </pre>
                    <li>Annyira leterhetli a processzort, hogy tulajdonképpen megáll az oldal</li>
                  </ul>
                </li>
                <li>Egyik helyes megoldás a szamok tömbre [2, 4, 13, 4, 6, 42], amennyiben páratlan
                  számokat keresünk
                  <ul>
                    <pre>
  index = 0
  var paratlanokSzama = 0;
  
  while (index &#60; 6) &#123;
    paratlanokSzama += szamok[index] % 2 === 1 ? 1 : 0;
    index++;
  &#125;

  console.log(paratlanokSzama);

  ↓↓↓↓↓

  1
                    </pre>
                    <li>Az eredmény 1 lesz</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>For ciklus (loop)
              <ul>
                <li>A while-hoz képest kissé specifikusabb</li>
                <li>Dedikáltan számok generálására jó</li>
                <pre>
  for (var i = 0; i &#60; 6; i++) &#123;

  &#125;
                </pre>
                <ul>
                  <li>Inicializálni kell egy változót, hogy honnan induljon a számlálás
                    (tipikusan 0)
                  </li>
                  <li>A második paraméter a feltétel, hogy meddig tartson a ciklus</li>
                  <li>A harmadik paraméter, hogy milyen ütemben növekedjen a ciklusváltozó
                  </li>
                </ul>
                <li>Ha szintén a páratlan számok darabszámát keressük
                  <pre>
  var paratlanokSzamaUjra = 0;
  
  for (var i = 0; i &#60; 6; i++) &#123;
    paratlanokSzamaUjra += szamok[i] % 2 === 1 ? 1 : 0;
  &#125;

  console.log(paratlanokSzamaUjra);

  ↓↓↓↓↓

  1
                  </pre>
                </li>
                <li>Saját megoldás rá úgy, hogy a tömb elemeinek számát nézzük a ciklusnál
                  <ul>
                    <pre>
  var paratlanokSzamaSajat = 0;
  
  for (var i = 0; i &#60; (szamok.length); i++) &#123;
      console.log(i);
      debugger;         // itt fog megállni a futás
      paratlanokSzamaSajat += szamok[i] % 2 === 1 ? 1 : 0;
  &#125;
                    </pre>
                    <li>A debugger-rel a DevTools Source fülén követhetjük nyomon a ciklust
                      <ul>
                        <li>A Source fülön a Global accordion-t lenyitva látható, hogy az i értéke növekszik
                          ciklusonként</li>
                      </ul>
                    </li>
                    <li>Futásidőben hozzájuthatunk a tömbök elemszámához</li>
                    <li>A length kulcs alapú kikéréssel megkapjuk a tömb elemszámát (szamok.length)</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>For - of ciklus
              <ul>
                <li>A legspecifikusabb működésű ciklus</li>
                <li>Dedikáltan arra jó, hogy egy tömb elemein végig iteráljunk</li>
                <li>A struktúra minden elemet számba vesz, és biztosít egy változót, ahol hozzá
                  lehet jutni az adott tömbelemhez
                </li>
                <li>Dinamikusan működik, nem tud megállni a tömb közepén</li>
                <li>
                  <ul>
                    <pre>
  for(var szam of szamok) &#123;

  &#125;
                    </pre>
                    <li>Egyes számban szokás leírni a tömb nevét a var után</li>
                    <li>Az iteráción belül rendelkezésre fog állni a szam, ami az aktuális
                      tömbelem értéke
                    </li>
                    <li>Szintaktikailag a legkedvezőbb megjelenés, hiszen az explicit kulcs
                      alapú kikérést már nem kell megtennünk
                    </li>
                    <li>
                      <pre>
  var paratlanokSzamaForOf = 0; 
  
  for(var szam of szamok) &#123;
      paratlanokSzamaForOf += szam % 2 == 1 ? 1 : 0;
  &#125;
                    </pre>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #conditionalstatements data-anchor="conditionalstatements">Conditional statements</h3>
  <ul>
    <li>A kontroll struktúrák másik családja</li>
    <li>Bizonyos sor kódok lefussanak-e, vagy sem</li>
    <li>Típusai
      <ul>
        <li>If - else statement
          <ul>
            <pre>
  if () &#123;

  &#125; else &#123;

  &#125;
            </pre>
            <li>A zárójelek közé jön a boolean feltétel</li>
            <li>Amennyiben igaz, az if statement body-ja lefut</li>
            <li>Az else ág opcionális</li>
            <li>Boolean-ra kiértékelődő kifejezés kerül a feltételbe</li>
            <br>
            <button class="btn btn-secondary" id="promptYourAge">Életkor propt</button>
            <pre>
  function promptYourAgeFunction() &#123;
      var age = prompt('Add meg az életkorod:')

      if (age &#60;= 20) &#123;
          alert('Fiatal vagy!');

          else if (age == 20) &#123; // Három egyenlőségjel esetén (identity) nem működik, ezekszerint a beírt érték string
              alert('Pont 20 éves vagy!');
          &#125; else &#123;
              alert('Öreg vagy!');
          &#125;
      &#125;
  &#125;
            </pre>
            <li>Az if statement kiegészíthető else if ágakkal
              <ul>
                <li>Fentről lefelé további ágakat jelent</li>
                <li>Ha az if feltétel nem teljesült, megnézi az első else if-et, és így megy tovább
                </li>
              </ul>
            </li>
            <li>Az else ág default case-ként is felfogható
              <ul>
                <li>Ha egyik feltétel sem teljesünk, ide futunk</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Switch statement
          <ul>
            <li>Nagyon hasonló az if statement-hez</li>
            <li>Tulajdonképpen kapcsoló</li>
            <li>Esetszétválasztásra alkalmatos</li>
            <li>Két módon lehet használni
              <ul>
                <li>Explicit egyezőség vizsgálata
                  <ul>
                    <li>String, vagy szám egyezőségét vizsgáljuk</li>
                    <li>A bemeneti értéket, majd az egyes eseteket meg kell adni</li>
                    <pre>
  function promptYourAgeWithSwitchFunction() &#123;
      var age = prompt('Add meg az életkorod:')

      switch (age) &#123;
          case 18:
            alert('18 éves vagy!')
            break;
          case 20:
            alert('20 éves vagy!')
            break;
          default:
             alert('Sem 18, sem 20 éves nem vagy!');
      &#125;
  &#125;
                    </pre>
                    <button class="btn btn-secondary" id="promptYourAgeWithSwitch">Switch age prompt</button>
                    <br>
                    <br>
                    <li>Az egyes state-ekbe break statement-et kell írni, mert különben a
                      végrehajtódás
                      átesik a következő case-be
                    </li>
                    <li>A default case akkor fut le, ha a feltételek egyike sem valósul meg
                      (mint az if
                      esetében az else)
                    </li>
                    <li>Defaulthoz nem szükséges break;</li>
                    <li>Kilogolva az age-et, láthatjuk, hogy a prompt string értéket visz be
                      <ul>
                        <li>Vagy átalakítjuk a case-eket, hogy string-eket figyeljen ('18',
                          '20')
                        </li>
                        <li>Vagy az age-et alakítjuk át number típusra
                          <ul>
                            <li>Helytelen
                              <ul>
                                <li>switch (age as number)
                                  <ul>
                                    <li>Type Assertion csak TypeScript-ben van</li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li>Helyes
                              <ul>
                                <li>switch (Number(age))</li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>Másik féle mód, amikor true kerül a switch bemenetére, és a case-eknek
                  feltételeket adunk
                  <br>
                  <br>
                  <ul>
                    <button class="btn btn-secondary" id="promptYourAgeWithSwitchNonExplicit">
                      Switch age prompt 2
                    </button>
                    <pre>
  function promptYourAgeWithSwitchNonExplicit() &#123;
        var age = prompt('Add meg az életkorod:');

        // SWITCH

        switch (true) &#123;
          case age &#60; 20:
              alert('20 évnél fiatalabb vagy!');
              break;
          case age &#62; 20 && age &#60; 30:
              alert('20 és 30 közötti az életkorod!');
              break;
          default:
              alert('Idősebb vagy, mint 30!');
      &#125;
  &#125;
                    </pre>
                    <li>A jegyvásárlós projekt felokosítása
                      <ul>
                        <br>
                        <button class="btn btn-secondary" id="ticketingListenerWithSwitch">
                          Ticketing felokosítva
                        </button>
                        <pre>
  function ticketingListenerWithSwitchFunction(firstTime = true) &#123;
      var userExit;

      if (!firstTime) &#123;
          userExit = prompt('Ki szeretnél lépni a promtból? Kilépéshez gépeld be az `igen` szót');
      &#125;

      if (userExit === 'igen') &#123;
          return;
      &#125;

      const quantity = prompt('Hány darab jegyet szeretnél?');
      const type = prompt('Felnőtt, vagy diákjegyet szeretnél vásárolni? (adult | student | retired)');

      var types = &#123;
          student: 300,
          adult: 350,
          retired: 280
      &#125;

      var price = types[type];

      if (price === undefined) &#123;
          alert('Helytelen jegytípus! Add meg újra a jegyek számát, és a típust!');
          firstTime = false;
          ticketingListenerWithSwitchFunction(false);
      &#125; else &#123;
          var discount = quantity > 10 ? 0.9 : 1;

          var total = quantity * price * discount;

          alert(total);
      &#125;
  &#125;
                        </pre>
                        <li>Ha nem adult, student, vagy retired közül választunk típust,
                          akkor a price-unk undefined
                        </li>
                        <li>Kiegészíthető a függvény bemeneti értékkel, ami alapból true</li>
                        <li>Amennyiben rossz jegytípust választ a user, úgy újra meghívódik
                          a prompt függvény, viszont az első kérdés az, hogy ki akar-e
                          lépni
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #functions data-anchor="functions">Functions</h3>
  <ul>
    <li>Két fajta szemléletmód létezik
      <ul>
        <li>Alprogram (Subrutine)
          <ul>
            <li>Program a programban, ami futásra szólítható fel</li>
            <li>A memóriában eltárolunk egy "receptet", amit később lefuttatunk</li>
            <li>Procedurális lépések sorozatából álló algoritmus</li>
            <pre>
  function susdMegARantottat() &#123;
      console.log('Önts olajat a serpenyőbe');
      console.log('Adj hozzá 3 tojást');
      console.log('Adj hozzá fűszereket');
      console.log('Süsd meg');
      console.log('Kész');
  &#125;
            </pre>
            <li>Elhelyeztük a procedurális utasításlistát a memóriába (létrehoztunk egy alprogramot)
            </li>
            <li>Amíg a program futása során nem szólítjuk fel a függvényt futásra, addig nem is fog
              futni
            </li>
            <li>A futásra felszólítás function call-lal, avagy függvény meghívással történik
              <ul>
                <li>susdMegARantottat()</li>
              </ul>
            </li>
            <li>Ha a program ráfut a függvényre, akkor sorról sorra elkezdi futtatni a benne lévő kódot
            </li>
            <li>A függvény lefutása után a program onnan folytatódik, ahonnan a függvény meg lett hívva
              <ul>
                <li>susdMegARantottat()</li>
                <li>***innen folytatódik***</li>
              </ul>
            </li>
            <li>Előnye, hogy a "receptet" csak egyszer tároltuk el a memóriába, innentől, ha szükségünk
              van rá, újra lefuttatjuk
            </li>
            <li>Azzal, hogy elneveztük a függvényt, az utasítások listája fölött egy absztrakciós réteget
              is készítettünk
            </li>
            <li>
              <pre>
  function adjHozzaFuszereket() &#123;
      console.log('Adj hozzá sót');
      console.log('Adj hozzá borsot');
      console.log('Adj hozzá paprikát');
  &#125;

  function susdMegARantottat() &#123;
      console.log('Önts olajat a serpenyőbe');
      console.log('Adj hozzá 3 tojást');
      console.log('Adj hozzá fűszereket');      // Kicserélhető: adjHozzaFuszereket();
      console.log('Süsd meg');
      console.log('Kész');
  &#125;
             </pre>
            </li>
          </ul>
        </li>
        <li>Function, mint matematikai függvény
          <ul>
            <li>Valamilyen input adatot kapnak, és valamilyen output adatot generálnak (fekete doboz)
            </li>
            <li>
              <ul>
                <pre>
  function addOne(szam) &#123;
      console.log(5);
  &#125;
                </pre>
                <li>Meghatároztunk egy paramétert (szam)</li>
                <li>Aki meghívja a függvényt, adatot szolgáltat</li>
                <li>A paraméterek lokális változóként funkcionálnak, tehát csak a függvényen belül
                  használhatjuk őket (bármire)
                </li>
              </ul>
            </li>
            <li>Erre a függvényre is igaz, hogy akárhányszor meg lehet hívni, és bármilyen értéket bele
              lehet dobni
            </li>
            <li>A függvényből vissza is lehet térni értékkel
              <ul>
                <pre>
  function addOne(szam) &#123;
      console.log(5);
      return szam + 1;
  &#125;

  addOne(5);
                 </pre>
                <li>Matematikai függény, beérkezik egy szám, és távozik egy szám</li>
                <li>(number) => number</li>
                <pre>
  console.log(addOne(5));

  ↓↓↓↓↓

  6
                 </pre>
                <li>A függvény csak leképezi az input adatot output adattá, nem lép interakcióba
                  semmivel
                </li>
                <li>A függvény hívásnál tér vissza a return értékkel, ott tudunk vele valamit
                  kezdeni
                </li>
                <li>Pipeline-ok is létrehozhatók
                  <ul>
                    <pre>
  console.log(addOne(addOne(addOne(3))));

  ↓↓↓↓↓

  6
                    </pre>
                    <li>A visszatérő értéket újra odaadjuk az addOne függvénynek</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Bizonyos tekintetben table lookup-ként is felfogható (táblázatból való kikeresés)
              <ul>
                <pre>
  function addTwo(szam)&#123;
      return &#123;
          0: 2,
          1: 3,
          2: 4,
      &#125;[szam];
  &#125;

  // SAME AS

  anonimObj = &#123;
    0: 2,
    1: 3,
    2: 4,
  }

  console.log(anonimObj[1])

  ↓↓↓↓↓

  3
                </pre>
                <li>Objektumból dinamikus kulcs alapján kikeresett értékkel térünk vissza</li>
                <li>Beérkezik a szám, és kikeresi a táblázatból, hogy mi a teendője, és
                  megkeresi a
                  megfelelő asszociációt
                </li>
                <li>Egyfajta kulcs alapú kikérés az objektumból</li>
                <li>Szintén építhető pipeline
                  <pre>
  console.log(addTwo(addTwo(0)));

  ↓↓↓↓↓

  4
                </pre>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <li>A JavaScript-ben a function az egy úgynevezett First Class Citizen
    <ul>
      <li>A függvény úgy viselkedik, mint az összes többi típus (number, string, object, stb...)</li>
      <li>Tehát változóhoz köthetőek, anonim function formájában</li>
      <li>Egy függvény bemeneti paramétere lehet egy másik függvény</li>
      <li>Függvényből visszatérni is lehet függvénnyel</li>
      <li>Anonim function (névtelen függvény)
        <ul>
          <pre>
  console.log(addThree(4)); // undefined

  var addThree = function(szam) &#123;
      return szam + 3;
  &#125;

  console.log(addThree(4));
  
  ↓↓↓↓↓

  7
           </pre>
          <li>A különbség az a nem anonim függvényekkel szemben, hogy amíg a deklarált, névvel
            ellátott függvények bármikor meghívhatók, a névtelen függvények esetében csak a
            deklarálás után hívhatók meg, máskülönben a változó értéke undefined
          </li>
          <li>A DevTools Console ablakába beírva az addThree-t a következőt kapjuk (bekerült a
            memóriába)
            <pre>
  // addThree

  ƒ (szam) &#123;
      return szam + 3;
  &#125;
          </pre>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</div>

<div>
  <h3 #windowobject data-anchor="windowobject">Window object</h3>
  <ul>
    <li>A böngészőben biztosítva van egy adatstruktúra, ami ugyanazokból az elemekből épül fel, mint amiket
      átvettünk
    </li>
    <li>Interface-ként szolgál, hogy a böngésző egyes részeit vezérelni tudjuk</li>
    <li>A legkülső réteg a window.object
      <ul>
        <li>Reprezentálja az egész böngésző ablakot</li>
        <li>Ez egy object</li>
        <li>Hozzáférést ad a böngésző egyes komponenseihez</li>
        <li>Futásidőben él a memóriában, és hozzá lehet férni</li>
        <pre>
  console.log(window)   // objektum
        </pre>
        <ul>
          <li>Megtalálhatjuk a console nevű kulcsát</li>
          <li>A console.log() függvényt is itt található meg</li>
          <br>
          <img src="assets/imgs/js_window_console.png" width="100%">
          <br>
          <br>
        </ul>
        <li>Az egyes kulcsok által hozzáférhetünk egyes részlegekhez</li>
        <li>Egyes funkcionalitások a kulcsok alatt függvények formájában is megjelennek (hozzárendelhetjük
          változóhoz, be lehet dobni függvénybe, vissza lehet térni vele függvényből, vagy objektumban be
          lehet kötni kulcsként)
        </li>
        <pre>
  var window = &#123;
      console: &#123;
          log: function(msg) &#123;
              // kilogolja az üzenetet
          &#125;
      &#125;
  &#125;
          </pre>
        <li>Ha meg akarnánk hívni ezt a függvényt</li>
        <pre>
  window.console.log('Szia');
            </pre>
        <li>A window objektum kulcsaira nem kell külön hivatkoznunk, működik a console.log('Szia');
          is
        </li>
        <li>A window globális objektum a böngésző kontextusában</li>
        <li>Minden más funkcionalitás, ami a böngésző egy-egy részét vezérli, a window object alatt
          található meg
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #document data-anchor="document">Document</h5>
  <ul>
    <li>A document kulcs alatt lévő objektum</li>
    <li>A HTML dokumentumot tudjuk vele vezérelni</li>
    <li>A document object-en keresztül minden egyes element minden egyes attribútumához hozzáférésük van
    </li>
    <li>Hozzunk létre a HTML body-jában egy div-et
      <br>
      <br>
      <div style="width: 100px; height: 100px; background-color: aqua">box1 (original)</div>
      <div style="width: 100px; height: 100px; background-color: aqua">box2 (modified)</div>
      <div style="width: 100px; height: 100px; background-color: aqua">box2 (click)</div>
      <ul>
        <pre>
  &#60;div style="width: 100px; height: 100px; background-color: aqua"&#62;&#60;/div&#62;
        </pre>
        <li>Ha megvizsgáljuk a window.document alatt lévő értéket (console-ba: window), lejjebb
          görgőzve az all tartalmazza az összes HTML element JavaScript-es reprezentacióját
          <ul>
            <pre>
  window // a document kulcs alatti all kulcsban találjuk az összes elemet
            </pre>
            <li>Köztük van a létrehozott (box1) element is, aminek a style kulcsa alatt
              láthatjuk a div-be írt inline stílust, az aqua háttérszínt
            </li>
            <br>
            <img src="assets/imgs/js_document_box1.png" width="100%">
            <br>
            <br>
            <li>Ha JavaScript kóddal megváltoztatjuk a kulcsok alatt lévő értékeket, vagy
              bármely más attribútum kapcsán valami értéket, a böngésző ezt észreveszi, és
              újra rendereli az oldalt
            </li>
            <li>Az egyes kulcsok fölé húzva az egeret a DevTools Console fülén, miután beírtuk a
              window parancsot, megjelenik a kulcsos index alapú kikérés
            </li>
            <li>JS fájlban változtassuk meg a dobozunk háttérszínét
              <ul>
                <pre>
  document.all[800].style.backgroundColor = "red";
                </pre>
                <li>A stílusmódosítás a valóságban setTimeout-ba került</li>
                <li>Villanás erejéig látszik, hogy kék színnel kezdte a doboz a
                  pályafutását, de mi JavaScript kóddal megmódosítottuk a színét ennek az
                  elemnek (setTimeout nélkül is)
                </li>
                <li>Mindig arra van szükség, hogy hozzájussunk az adott elementet
                  reprezentáló objektumhoz, hogy bekössünk értékeket
                </li>
                <li>Function-t is beköthetünk kulcs alá, például, ha adott eseménykor
                  szeretnénk függvényt lefuttatni
                  <ul>
                    <li>Ilyen például az onclick kulcs</li>
                    <li>Ha azt szeretnénk, hogy gombnyomásra legyen piros a doboz</li>
                    <pre>
  document.all[801].onclick = function() &#123;
      // itt bármi futtatható
      document.all[801].style.backgroundColor = "green"
  &#125;
                    </pre>
                    <li>Szintén kellett egy kis setTimeout</li>
                    <li>Az elem onclick kulcsa alá bekötöttünk egy funkcionalitást, de ez még nem futott le, nem lett
                      még meghívva
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Bármikor, amikor interaktivitást szeretnénk JavaScript-tel, három dologra van szükség
      <ul>
        <li>Az adott element JavaScript-es reprezentációjára</li>
        <li>Milyen esemény kapcsán akarunk kódot futtatni</li>
        <li>Milyen kódot akarunk futtatni</li>
      </ul>
    </li>
    <li>A document.all[5] nem a legpraktikusabb módja az egyes elementek document object kiválasztására,
      mert beégetett index szerepel benne
    </li>
  </ul>
</div>

<div>
  <h3 #uiflow data-anchor="uiflow">UI flow</h3>
  <ul>
    <li>User Interface
      <ul>
        <li>Amit a böngészőben látunk, az a User Interface, avagy UI</li>
        <li>Az a felület, amivel a felhasználó interakcióba lép</li>
      </ul>
    </li>
    <li>State (alkalmazás állapot) / Controller
      <ul>
        <li>Tulajdonképpen egy adatstruktúra, amit az alkalmazás futtatása során a memóriában tartunk</li>
        <li>A lehető legminimálisabb módon leírja a UI-on megjelenő elemeket</li>
        <li>Tehát minden információt tartalmaz, hogy az interface kirajzolódhasson</li>
        <li>Egy egyszerű drag&drop esetén, ahol 3 dobozt húzogathatunk a képernyőn, a state tartalmazza a
          dobozok koordinátáit (x, y, z), és azt, hogy melyik van éppen drag-elve
        </li>
        <li>A programjainkban mindig van state definiálva, és a User Interface-en változtatható dolgok a
          state leképződései
        </li>
        <li>Bármilyen adatstruktúra lehet, nem feltétlenül objektum</li>
        <li>A state nem egy statikus adatstruktúra, hanem futás időben a memóriában folyamatosan felülíródik
          a User Interface eseményei alapján
        </li>
        <li>Ha a felhasználó különféle elemmel interakcióba lép, manipulálja az alkalmazás állapotát</li>
        <li>Nekünk kell megírni, hogy a felhasználó tevékenységei milyen értékváltozást okozzanak</li>
        <li>Controller
          <ul>
            <li>Az eseménykezelőket, és a state-et nevezzük így</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Template (sablon)
      <ul>
        <li>Eléri, hogy az adatstruktúrából konkrét elemek legyenek</li>
        <li>Alapvetően HTML elemek vannak itt</li>
        <li>Az leírt elemek képzik a UI statikus részét, tehát a 3 dobozos drag&drop-ot tekintve a
          dobozokat, a dobozok színeit, méretét, tehát a kirajzolt tartalmat
        </li>
        <li>A dobozok pozíciója viszont változik, dinamikus</li>
        <li>String interpoláció
          <ul>
            <li>Amikor a state-ből a tartalom a sablon dinamikus részébe kerül</li>
          </ul>
        </li>
        <li>A sablonban egyszerű control struktúrák is lehetnek
          <ul>
            <li>Akár if statement-ek, ciklusok</li>
            <li>Tipikusan, ha az állapotban egy tömbnyi elem van jelen, akkor azok állapotát ciklussal
              szokás kirajzolni
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Renderelés
      <ul>
        <li>Művelet sorozat</li>
        <li>A state-et alapul véve egy sablont összeollózunk, dinamikus adatokat felhasználva, és akár control
          struktúrákat is futtatva
        </li>
      </ul>
    </li>
    <br>
    <li>Komponens
      <ul>
        <li>A controller-t, és a sablon logikát összefoglalóan komponensnek hívjuk</li>
        <li>Angular
          <ul>
            <li>A controller, és a template 2 külön fájlban van definiálva (tipikusan)</li>
          </ul>
        </li>
        <li>React
          <ul>
            <li>A controller-t, és a template-et 1 fáljban kell definiálni (tipikusan)</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>A folyamat
      <ul>
        <li>Végfelhasználóként letöltve az oldalt az alábbi folyamatok játszódnak le
          <ul>
            <li>Először is, az alkalmazásnak van egy kiindulási állapota, megtörténik a renderelés,
              tehát a kezdeti state, és a meghatározott statikus sablon alapján megjelenik a User
              interface-en a tartalom
            </li>
            <li>A felhasználó interakcióba lép az oldallal, ami állapotmódosítást okoz, amit renderelés
              követ a frissített adatokkal, aminek következtében a UI-on frissül a tartalom
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #boxes1 data-anchor="boxes1">Boxes I</h3>
  <div class="container" style="row-gap: 70px; column-gap: 35px; margin-bottom: 70px; padding-bottom: 70px;">
    <div class="shape" id="element-one">
      <span class="text">
        1
      </span>
    </div>
    <div class="shape" id="element-two">
      <span class="text">
        2
      </span>
    </div>
    <div class="shape" id="element-three">
      <span class="text">
        3
      </span>
    </div>
    <div class="shape" id="element-four">
      <span class="text">
        4
      </span>
    </div>
    <div class="shape" id="element-five">
      <span class="text">
        5
      </span>
    </div>
    <div class="shape" id="element-six">
      <span class="text">
        6
      </span>
      <form id="box-6">
        <input class="w-95" type="number" name="boxNumber" class="form-control">
        <button class="w-100" type="submit" class="btn btn-secondary w-100">Küldés</button>
      </form>
    </div>
    <div class="shape" id="element-seven">
      <span class="text">
        7
      </span>
      <input class="form-control" type="text" name="boxNumber" id="box7-input">
    </div>
    <div class="shape parent-table" id="element-eight">
      <span class="child-table">
        8
      </span>
    </div>
    <div class="shape" id="element-nine">
      <span class="text">
        9
      </span>
      <form id="box-9">
        <select class="form-select w-100" name="operator">
          <option value="mult">×</option>
          <option value="div">/</option>
          <option value="add">+</option>
          <option value="sub">-</option>
        </select>
        <input type="number" name="operand" class="form-control w-100">
        <button type="submit" class="btn btn-secondary w-100">Küldés</button>
      </form>
    </div>
  </div>
  <ul>
    <li>Megjegyzések
      <ul>
        <li>Ha a script-eket a body után helyezzük el az index.html-ben, akkor a script-ek akkor fognak
          lefutni, ha a HTML elemek már kirajzolódtak
        </li>
        <li>Ha mindenképp a fájl elejére szeretnénk tenni a script-eket, akkor használhatunk a JS-ben
          DOMContentLoaded eseményt, ami szintén csak akkor fut le, amikor a DOM már betöltődött
        </li>
        <li>A console.log() egy adott változó, vagy érték általános kimenetét adja meg, míg a console.dir()
          az objektumok részletes tulajdonságait és metódusait jeleníti meg
        </li>
        <li>A getElementById() függvény esetében a console.log() a HTML elemet adja vissza
          <pre>
  &#60;div class="shape" id="element-one"&#62;
      &#60;span class="text"&#62;
          1
      &#60;/span&#62;
  &#60;/div&#60;2
         </pre>
        </li>
        <li>getElementById() függvény esetében a console.dir() egy objektumot ad vissza (a DevTools-ban
          kinyitható)
          <pre>
  div#element-one.shape
        </pre>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <ul>
    <li>1. doboz
      <ul>
        <li>Kattintásra adjunk hozzá egy "blur" nevű class attribútumot, majd újabb kattintásra vegyük le róla azt</li>
        <li>document.getElementById('element-one');
          <ul>
            <li>Ha létezik ilyen ID-jú element, a getElementById() függvény vissza fog térni az elemmel
            </li>
            <li>Ha nem létezik ilyen ID-jú element, akkor null-al tér vissza</li>
          </ul>
        </li>
        <li>console.log(document.getElementById('element-one'));</li>
        <pre>
  var isBlured = false;

  document.getElementById('element-one').onclick = function () &#123;
  isBlured = !isBlured;

  /* if (isBlured) &#123;
          document.getElementById('element-one').classList.add('blur');
      &#125; else &#123;
          document.getElementById('element-one').classList.remove('blur');
      &#125; */

      isBlured ? document.getElementById('element-one').classList.add('blur') : document.getElementById('element-one').classList.remove('blur');
  &#125;
        </pre>
        <ul>
          <li>State-et hozunk létre a függvény scope-ján kívül, amiben eltároljuk, hogy rajta van-e a
            blur class az elemen, vagy sem
          </li>
          <li>Az isBlured állapotát módosítgatjuk</li>
          <li>Kint van a doboz a User Interface-en, az alkalmazásunkban történik valami esemény
            (rákattintunk az 1-es számú dobozra), ennek hatására megváltozik az alkalmazásunk belső
            állapota (boolean-t negálunk), és ez után történik egy renderelés (a state change miatt)
          </li>
        </ul>
      </ul>
    </li>
    <br>
    <li>2. doboz
      <ul>
        <li>Ha az egérrel fölé megyünk változzon meg a háttérszíne pirosra, ha levesszük róla az egeret változzon vissza
          az eredeti színére</li>
        <pre>
  var isHovered = false;
  var elementTwo = document.getElementById('element-two');

  elementTwo.onmouseover = function () &#123;
      isHovered = true;
      renderSecondBox();
  &#125;

  elementTwo.onmouseout = function () &#123;
      isHovered = false;
      renderSecondBox();
  &#125;

  function renderSecondBox() &#123;
      isHovered ? (elementTwo.style.backgroundColor = 'red') : (elementTwo.style.backgroundColor = '');
  &#125;
      </pre>
        <li>Ha például a backgroundColor-hoz üres string kerül, akkor az eredeti CSS szabály fog
          alkalmazódni
        </li>
        <li>A state-et minden eseménykor megváltoztatjuk, és ezt mindig újra renderelés követi</li>
        <li>Tehát az action (mouseover és mouseout) bekövetkezésekor state change (isHovered megváltozik)
          történik, ami újra renderelést eredményez
        </li>
      </ul>
    </li>
    <br>
    <li>3. doboz
      <ul>
        <li>Dupla kattintással sorsoljon egy számot 1 és 20 között és módosítsa a kapott számmal a doboz tartalmát</li>
        <pre>
  var elementThree = document.getElementById('element-three');

  elementThree.ondblclick = function() &#123;
      // document.getElementById('element-three').firstElementChild.innerHTML = randomNumberGenerator(1, 20);
      elementThree.innerHTML = '&#60;span class="text"&#62;' + randomNumberGenerator(1, 20); + '&#60;/span&#62;'
  &#125;

  function randomNumberGenerator(min, max) &#123;
      return Math.floor(Math.random() * (max - min) + min);
  &#125;
      </pre>
        <li>A Math.floor() lefelé kerekíti az adott értéket</li>
        <li>Math.random() * (20 + 1) + 1 => 1 és 20 között generál nekünk számot</li>
        <li>A belső span-t is el lehetett volna látni ID-val, kiszelektálni, és ennek útján megváltoztatni a
          számot
        </li>
        <li>A kiszelektált 'element-three'-nek van egy olyan kulcsa, hogy firstElementChild (console.dir-rel
          láthatjuk), ezt is változtathatjuk a script-ben
          <ul>
            <li>A firstElementChild értéke egy referencia a belső értékre</li>
            <li>Általánosságban elmondható, hogy az elemek alatt találhatók olyan kulcsok, amikben
              további elemekre mutató referenciák vannak (például childNodes)
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>4. doboz
      <ul>
        <li>Kattintásra tűnjön el, majd egy 1 másodperces várakozás után ismét jelenjen meg</li>
        <pre>
  var elementFour = document.getElementById('element-four');

  elementFour.onclick = function () &#123;
      // elementFour.classList.add('hidden') ;
      elementFour.style.visibility = 'hidden';
      elementFourIsVisibleAgain();
  &#125;

  function elementFourIsVisibleAgain() &#123;
      setTimeout(() => &#123;
          // elementFour.classList.remove('hidden');
          elementFour.style.visibility = 'visible';
      &#125;, 1000);
  &#125;
       </pre>
        <li>Szükségünk van egy olyan funkcionalitásra, ami késleltetni tudja egy függvény végrehajtását</li>
        <li>setTimeout
          <ul>
            <pre>
  setTimeout(function () &#123;console.log('Hi')&#125;, 1000);
           </pre>
            <li>Bemenetként vár egy névtelen függvényt, és egy számértéket (number)</li>
            <li>A függvény akkor fog lefutni, ha letelt a milliszekundumban meghatározott érték</li>
            <li>Célszerűbb class-okat használni, mint az elemek style attribútumát piszkálni</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>5. doboz
      <ul>
        <li>Kattintásra alakítsa kör alakúra az összes dobozt</li>
        <pre>
  var elementFive = document.getElementById('element-five');
  var containerChildren = document.querySelector('.container').children;
  var allElements = document.querySelectorAll('.shape');
  var elements = document.getElementsByClassName('shape');

  elementFive.onclick = function () &#123;
      console.log('containerChildren HTMLCollection: ', containerChildren);
      /* Array.from(elements).forEach(function (element) &#123;
          console.log('element',  element);
          element.classList.add('box5style');
      &#125;); */

      allElements.forEach(function (element) &#123;
          console.log('NodeList element: ', element);
          // element.style.borderRadius = '50%'; // Classal célszerűbb
          element.classList.add('box5style');
      &#125;);

      /* for (var element of allElements) &#123; // Szintén forEach()
          element.classList.add('box5style');
      &#125; */
  &#125;
       </pre>
        <li>Meg lehetett volna oldani úgy is, hogy a container class gyerekein hajtódik végre az átalakítás
          <ul>
            <li>A querySelector() függvény bármilyen alapú kikérésre használható</li>
            <li>querySelector(.class) / querySelector(#id)</li>
            <li>document.querySelector('.container').children;
              <ul>
                <li>Láthatjuk, hogy mivel tér vissza
                  <ul>
                    <li>&#60;div class="container"&#62;...&#60;/div&#62;</li>
                    <li>HTMLCollection, nem tudunk rajta csak úgy végig iterálni</li>
                  </ul>
                </li>
                <li>Benne vannak a child elemek</li>
                <li>Tudjuk azt, hogy az elem rendelkezik olyan kulcsokkal, ami ilyen-olyan
                  referenciákat hordoz (más elementre mutat)
                </li>
                <li>A children kulcs egy HTMLCollection-t hordoz, az adott elem gyerekeit</li>
                <li>Innentől már csak át kell iterálni a listán, és megváltoztatni a gyerekek
                  alakját
                  <ul>
                    <li>HTMLCollection iteráció</li>
                    <pre>
  Array.from(elements).forEach(function (element) &#123;
      console.log('Array from elements: ', element);
  &#125;);
                   </pre>
                  </ul>
                </li>
              </ul>
            </li>
            <li>document.querySelectorAll('.shape');
              <ul>
                <li>NodeList-et eredményez</li>
                <li>Végig tudunk rajta iterálni mindenféle átalakítás nélkül</li>
                <li>Az első ciklus "tartalma"
                  <pre>
  &#60;div class="shape box5style" id="element-one"&#62;
      &#60;span class="text"&#62;
          1
      &#60;/span&#62;
  &#60;/div&#62;
               </pre>
                </li>
              </ul>
            </li>
            <li>Debugger tool-al végigkövethető minden egyes változás
              <ul>
                <li>DevTools -> Sources -> boxes.js</li>
                <li>Majd azoknak a soroknak a számaira kell kattintani, ahol meg akarjuk állítani a
                  futást
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>6. doboz
      <ul>
        <li>Form submit eseményre módosítsuk a doboz tartalmát az input mezőbe írt értékkel</li>
        <li>Felhasználói interakciót kívánnak meg a következő dobozok</li>
        <li>Meg kell tanulnunk, mi az az event object</li>
        <li>Event handler function
          <ul>
            <li>Amikor meghívódnak bármilyen esemény kapcsán, paramétert is kapnak</li>
            <li>Ez a paraméter az event object</li>
            <li>Adatcsomag, ami az adott esemény kapcsán generálódik ki, és tartalmaz mindenféle
              információt az esemény kapcsán
            </li>
            <pre>
    elementSixFormItem.onsubmit = function (event) &#123;
        event.preventDefault();
        console.log('Element 6 event: ', event);
        console.log('Element 6 event: ', event.target);
    &#125;;
             </pre>
            <li>A form submitolásával az oldalunk befrissülne, így az alap JavaScript-es működést
              felül kell írnunk
            </li>
            <li>Tulajdonképpen egy HTTP kérés történne</li>
            <li>Jelenleg ez egy nemkívánatos effekt</li>
            <li>Az event.preventDefault(); megakadályozza a default JavaScript-es működést</li>
            <li>Az event object target kulcsa mutat azon elemre, amire az esemény bekövetkezett
              <ul>
                <li>Jelen esetben az egész form elementre</li>
                <pre>
  &#60;form id="box-6"&#62;
      &#60;input class="w-95" type="number" name="boxNumber" style="width: 40%"&#62;
      &#60;button class="w-100" type="submit" style="width: 50%;"&#62;Küldés&#60;/button&#62;
  &#60;/form&#62;
                   </pre>
              </ul>
            </li>
            <br>
            <li>Nekünk az input mező értékére van szükségünk
              <ul>
                <li>Az event.target.elements kulcs tartalmaz egy
                  HTMLFormControlsCollection-t
                  <ul>
                    <li>Indexált formában benne van az input mező, és a gomb</li>
                    <li>A 0, és az 1 index mellett szerepel jelen esetben még egy kulcs:
                      boxNumber
                      <ul>
                        <li>Ez nem más, mint az input mező name attribútuma</li>
                        <li>event.target.elements.boxNumber.value => Így kérhető ki
                          az input értéke
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>Az input mező elérése: event.target.elements[0]
                  <pre>
  &#60;input class="w-95" type="number" name="boxNumber" style="width: 40%"&#62;
                   </pre>
                </li>
                <li>A két kikérési mód ugyanúgy jó
                  <ul>
                    <li>event.target.elements[0].value (Az input mező a 0 index alatt
                      szerepel)
                    </li>
                    <li>event.target.elements.boxNumber.value</li>
                  </ul>
                </li>
                <li> HTML
                  <pre>
  &#60;form id="box-6"&#62;
      &#60;input class="w-95" type="number" name="boxNumber" style="width: 40%"&#62;
      &#60;button class="w-100" type="submit" style="width: 50%;">Küldés&#60;/button&#62;
  &#60;/form&#62;
                    </pre>
                </li>
                <pre>
  var elementSixFormItem = document.getElementById('box-6');

  elementSixFormItem.onsubmit = function (event) &#123;
      event.preventDefault();
      console.log('Element 6 event / target / elements[0] / value: ', event.target.elements[0].value);
      console.log('Element 6 event / target / boxName / value: ', event.target.elements.boxNumber.value);

      elementSixFormItemInputValue = event.target.elements.boxNumber.value;

      console.log('elementSixFormItem / parentElement / firstElementChild: ', elementSixFormItem.firstElementChild.firstChild);

      elementSixFormItem.parentElement.firstElementChild.innerHTML = elementSixFormItemInputValue;
  &#125;;
                      </pre>
                <li>A parentElement.firstElement mást ad vissza, és nem működik az innerHTML
                </li>
                <li>A parentElement.firstElementChild a következőt adja vissza
                  <pre>
  &#60;span class="text"&#62;1&#60;/span&#62;
                        </pre>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>7. doboz
      <ul>
        <li>Keypress eseményre írjuk be a dobozba az adott karaktert, amit leütöttek</li>
        <pre>
  var elementSevenFormInputValue = document.getElementById('box7-input');
  var character = '';

  elementSevenFormInputValue.onkeypress = function (event) &#123; // az onkeypress deprecated
      var currentCharacter = event.key;
      if (currentCharacter.length &#60; 2) &#123;
          elementSevenFormInputValue.parentElement.firstElementChild.innerHTML = currentCharacter;
          character = currentCharacter;
      &#125;
  &#125;

  elementSevenFormInputValue.addEventListener('blur', function () &#123;
      elementSevenFormInputValue.parentElement.firstElementChild.innerHTML = '7';
      elementSevenFormInputValue.value = '';
  &#125;);
      </pre>
        <li>Itt nincs form-ban az input mező, és az input-nak van ID-ja, így explicite kiszelektálhatjuk az
          input mezőt
        </li>
        <li>Közvetlenül az input mező event handler eseményére kell reagálnunk</li>
        <li>Az onkeypress-nek van event-je (KeyboardEvent object)</li>
        <li>Az eseményben key kulcs alatt érhető el a leütött billentyű</li>
        <br>
        <li>A feladatot annyival van kiegészítve, hogy EventListener segítségével blur-re visszakerül a kocka eredeti
          értéke,
          illetve az input mező value-ja kap egy üres string-et
        </li>
      </ul>
    </li>
    <br>
    <li>8. doboz
      <ul>
        <li>Egérmozdítás eseményre írjuk be az egér pozíciójának x és y koordinátáját, a következő séma szerint
          <ul>
            <li>
              "X: &#123;x-koordináta&#125;, Y: &#123;y-koordináta&#125;"</li>
          </ul>
        </li>
        <pre>
  var elementEightText = document.getElementById('element-eight').firstElementChild;

  elementEightText.innerHTML = '10';

  document.onmousemove = function (event) &#123;
      elementEightText.innerHTML = '&#60;div>X: ' + event.x + '&#60;/div>&#60;div>Y: ' + event.y + '&#60;/div>'
  &#125;
       </pre>
        <li>Összekonkatenáltuk a doboz szövegének tartalmát</li>
      </ul>
    </li>
    <br>
    <li>9. doboz
      <ul>
        <li>Submit eseményre módosítsuk a doboz tartalmát azzal az értékkel ami úgy áll elő, hogy végrehajtjuk a select
          input-ban kiválasztott operációt a state-en és number input-ba beírt értéken</li>
        <li>Az előállt végeredményt tároljuk el új state-ként</li>
        <li>Például
          <ul>
            <li>Number input mezőbe írt érték: 5</li>
            <li>Select input-ban kiválasztott érték: "mult" (multiplication)</li>
            <li>Aktuális state: 9</li>
            <li>Operáció: 9 * 5</li>
            <li>Dobozba és state-be beírandó érték: 45</li>
          </ul>
        </li>
        <li>
          <pre>
  var state = 9;
  var elementNineForm = document.getElementById('box-9');

  elementNineForm.onsubmit = function (event) &#123;
      event.preventDefault();
      var operand = Number(event.target.elements.operand.value); // inputba írt szám
      var operator = event.target.elements.operator.value; // művelet
      var currentNumber = Number(elementNineForm.parentElement.firstElementChild.textContent.trim()); // vagy .innerHTML
      elementNineForm.parentElement.firstElementChild.innerHTML = eredmeny(currentNumber, operator, operand);
  &#125;

  function eredmeny(currentNumber, muvelet, inputNumber) &#123;
      switch(muvelet) &#123;
        case 'mult':
        state = currentNumber * inputNumber;
        break;
        case 'div':
        state = currentNumber / inputNumber;
        break;
        case 'add':
        state = currentNumber + inputNumber;
        break;
        case 'sub':
        state = currentNumber - inputNumber;
        break;
        &#125;
      return state;
  &#125;
      </pre>
        </li>
        <li> Az alap működést felülírjuk az event.preventDefault() függvénnyel</li>
        <li> A szám number input-ból érkezik, mégis string
          <ul>
            <li> A számot a továbbiakban márpedig aritmetikai műveletekre akarjuk használni</li>
            <li> Number() függvénnyel a sting számmá alakítható (numberrel tér vissza a függvény)</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #templateliteral data-anchor="templateliteral">Template literal</h3>
  <ul>
    <li> Nyelvi eszköz, amivel egyszerűen lehet HTML tartalmat összeállítani</li>
    <li> JavaScript kóddal generáljuk a HTML-t</li>
    <li> Dinamikus tartalom csak a JavaScript kód futásakor érhető el (nem statikus tartalom), tehát csak
      futásidőben lesz elérhető az adat
    </li>
    <li> Az ilyen adatok tipikusan szerver oldali kérések révén érkeznek meg a klienshez</li>
    <li> A HTML-ben biztosítani kell egy belépési pontot(photo-list-container class)</li>
    <br>
    <li> Létrehozunk egy változót
      <ul>
        <pre>
  var photoListTemplate = '';
        </pre>
        <li> A string-et JavaScript nyelvben nem lehet tördelni (szintaktikailag nem helyes), így
          kényelmetlen vagyunk a következőképp dolgozni</li>
        <pre>
  for(var photo of photos) &#123;
      photoListTemplate = photoListTemplate + '&#60;div class="card p-5"&#62;' + card.title + '&#60;/div&#62;'
  &#125;
        </pre>
        <li> Nagyobb template esetén szükségünk van a tördelésre
          <ul>
            <li> Itt jön a képbe a template literal</li>
            <li> Két dologra jó
              <ul>
                <li>Betördelhető, tehát átláthatóbbá tehetők a string-ek</li>
                <li>A dinamikus adatokat könnyebb beleírni, nem kell + jelekkel folyamatosan megszakítani a kódot</li>
              </ul>
            </li>
          </ul>
        </li>
        <li> Backtick karakter (ALT + 7)
          <ul>
            <li>Úgy néz ki, mint egy idézőjel, de nem az</li>
            <li> Két backtick közé jön a tartalom (template)</li>
            <li> A dinamikus tartalom $&#123;&#125; karakterek közé írt változóval valósítható meg
              <ul>
                <li>` $&#123; var &#125; `</li>
              </ul>
            </li>
            <li> Kifejezéseket is létre lehet hozni</li>
            <pre>
  ...
  &#60;div class = "card p-5 $&#123;photo.id === 3 ? 'bg-light' : ''&#125;" &#62;
  ...
            </pre>
          </ul>
        </li>
        <br>
        <li>Példa használatra
          <ul>
            <div class="template-literal-container">
              <div class="mb-3"></div>
              <div class="container">
                <div class="row" style="border: 1px solid black; border-radius: 3px;">
                  <div class="col-3">col-3</div>
                  <div class="col-6">
                    <div>col-6 - photos-list-container</div>
                    <div id="photos-list-container">

                    </div>
                  </div>
                  <div class="col-3">col-3</div>
                </div>
              </div>
            </div>
            <pre>
  <b>// html</b>

  &#60;div class="template-literal-container">
    &#60;div class="mb-3">&#60;/div>
    &#60;div class="container">
        &#60;div class="row">
            &#60;div class="col-3">col-3&#60;/div>

            &#60;div class="col-6">
                col-6 - photos-list-container class
                &#60;div id="photos-list-container">&#60;/div>
            &#60;/div>

            &#60;div class="col-3">col-3&#60;/div>
        &#60;/div>
    &#60;/div>
  &#60;/div>

  <b>// js</b>

  var photos = [
      &#123;
          id: 1,
          title: "accusamus beatae ad facilis cum similique qui sunt",
          thumbnailUrl: "https://picsum.photos/id/99/150/150/?blur=2"
      },
      &#123;
          id: 2,
          title: "reprehenderit est deserunt velit ipsam",
          thumbnailUrl: "https://picsum.photos/id/149/150/150/?blur=2"
      },
      &#123;
          id: 3,
          title: "officia porro iure quia iusto qui ipsa ut modi",
          thumbnailUrl: "https://picsum.photos/id/199/150/150/?blur=2"
      },
      &#123;
          id: 4,
          title: "culpa odio esse rerum omnis laboriosam voluptate repudiandae",
          thumbnailUrl: "https://picsum.photos/id/249/150/150/?blur=2"
      }
  ];

  var photoListTemplate = ''; 

  for (var photo of photos) &#123;
      photoListTemplate = photoListTemplate + `
      &#60;div id="$&#123;photo.id}" class="card p-1" 
          style="border: 1px solid grey; border-radius: 5px; padding: 5px; $&#123;photo.id === 3 ? 'background-color: pink' : ''}">
          &#60;div>&#60;small>$&#123;photo.title}&#60;/small>&#60;/div>
          &#60;br>
          &#60;img src="$&#123;photo.thumbnailUrl}">
      &#60;/div>
      &#60;br>
      `
  }

  document.getElementById('photos-list-container').innerHTML = photoListTemplate;
            </pre>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #workshopproject data-anchor="workshopproject">Workshop project</h3>
  <ul>
    <li> CRUD
      <ul>
        <li> Create</li>
        <li> Read</li>
        <li> Update</li>
        <li> Delete</li>
      </ul>
    </li>
    <br>
    <li> Read
      <pre>
  var state = &#123;
  products: [
      &#123;name: 'Termék 1', price: 2500, isInStock: true&#125;,
      &#123;name: 'Termék 2', price: 3500, isInStock: true&#125;,
      &#123;name: 'Termék 3', price: 4500, isInStock: true&#125;,
  ]
  &#125;
      </pre>
      <ul>
        <li>Ez az alkalmazásunk alap belső állapota</li>
        <li>Ha a usernek meg akarjuk jeleníteni a termékeket, akkor a Read műveletet kell megvalósítani</li>
        <li>Létre kell hozni a renderelő függvényt, ami a termékeket kilistázza
          <ul>
            <pre>
  function renderProducts() &#123;
    const productListComponent = document.getElementById('product-list-component');

    let productsHTML = '';
    for (var prod of state.products) &#123;
        productsHTML += `
        &#60;div class="card m-2 p-2 $&#123;!prod.isInStock ? 'bg-danger' : ''}">
            &#60;i class="fas fa-check">&#60;/i>
            &#60;p>Terméknév: $&#123;prod.name}&#60;/p>
            &#60;p>Ár: $&#123;prod.price}&#60;/p>
        &#60;/div>
        `;
    }

    productListComponent.innerHTML = productsHTML;
  }

  window.onload = renderProducts;            
            </pre>
            <li> A + = hozzáad a változó aktuális tartalmához</li>
            <li> A window.onload
              <ul>
                <li> Esemény</li>
                <li> A renderProducts függvény akkor fog lefutni, amikor az oldal betöltődött, és minden elem
                  rendelkezésre áll
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li> Create
      <ul>
        <li> A felhasználónak képesnek kell lennie új adatokat bevinni a rendszerbe</li>
        <pre>
  document.getElementById('create-product').onsubmit = function(event) &#123;
      event.preventDefault();
      state.products.push(&#123;
        name: event.target.elements.name.value,
        price: Number(event.target.elements.price.value),
        isInStock: event.target.elements.isInStock.checked,
      &#125;);
  }

  renderProducts();
  &#125;
          </pre>
        <li> Form submit eseményhez bekötöttünk egy függvényt</li>
        <li> A price a kiszelektálás után string volt, ezért átkonvertáltuk számmá</li>
        <li> A state change után újra kell renderelnünk a listát</li>
      </ul>
    </li>
    <br>
    <li> Delete
      <ul>
        <li> Ehhez megmódosítjuk a product tömbünk minden elemét, mégpedig úgy, hogy ellátjuk őket ID - val
        </li>
        <pre>
  var state = &#123;
  products: [
      &#123;id: createRandomID(), name: 'Termék 1', price: 2500, isInStock: true&#125;,
      &#123;id: createRandomID(), name: 'Termék 2', price: 3500, isInStock: false&#125;,
      &#123;id: createRandomID(), name: 'Termék 3', price: 4500, isInStock: true&#125;,
  ]
  &#125;
          </pre>
        <li>Hozzáadtunk egy button-t minden card-hoz, amiket elláttunk data-productid attribútummal
          <ul>
            <li>
              <pre>
  let productsHTML = '';
  for (var prod of state.products) &#123;
      productsHTML += `
          &#60;div class="card m-2 p-2 $&#123;!prod.isInStock ? 'bg-danger' : ''}">
              &#60;i class="fas fa-check">&#60;/i>
              &#60;p>ID: $&#123;prod.id}&#60;/p>
              &#60;p>Terméknév: $&#123;prod.name}&#60;/p>
              &#60;p>Ár: $&#123;prod.price}&#60;/p>
              &#60;button class="btn btn-danger float-right delete-product" data-productid="$&#123;prod.id}" onclick="deleteProduct('$&#123;prod.id}')">Törlés&#60;/button>
          &#60;/div>
      `;
  }                
              </pre>
              <ul>
                <li>A gombnak továbbá adtunk egy delete-product class-t</li>
                <pre>
  function createRandomID() &#123;
    return Math.random().toString(36).substring(2, 9);
  }

  const deleteButtons = document.querySelectorAll('.delete-product');

  for (let button of deleteButtons) &#123;
    button.onclick = function () &#123;
      const id = this.dataset.productid;

      for (let i = 0; i &#60; state.products.length; i++) &#123; // index megkeresése, és törlés splice-szal
        if (state.products[i].id === id) &#123;
          state.products.splice(i, 1);
          break; // kilépünk a ciklusból
        }
      }

      renderProducts(); // újrarenderelés
    };
  }
                </pre>
                <li>Tömbből úgy tudunk törölni, ha megkeressük azt a tömbelem indexét, aminek az az
                  ID-ja,
                  amit a gombra nyomáskor kaptunk (data-productid)
                </li>
                <li>Végigmegyünk a delete-product class-okon, és minden elem onclick-jéhez adunk egy
                  függvényt
                </li>
                <li>A dataset-ben az adott elem 'data-'-val kezdődő attribútumai vannak felsorolva
                </li>
                <li> Kikerestük az megfelelő ID-t</li>
                <li> Használhatunk egy statement-et az iteráción belül
                  <ul>
                    <li>break;</li>
                    <li>Kilépteti a ciklust a működésből</li>
                  </ul>
                </li>
                <li>Végül a splice függvény használatával unset-eljük a tömbelemet a tömbből</li>
                <li>.splice(hányadik elem, a hányadik elemtől hány elem)
                </li>
              </ul>
            </li>
            <li>Külön egy onclick függvényt is hozzáadhatunk, így a deleteProduct függvénybe megérkezik az azonosító
              <ul>
                <pre>
  function deleteProduct(id) &#123;
      state.products.splice(state.products.findIndex(f = > f.id === id), 1);
      renderProducts();
  &#125;
                </pre>
                <li>A findIndex függvénnyel megkereshetjük a kattintott gombnak megfelelő termék
                  indexét
                  a tömbben, majd a splice függvénnyel kitörölhetjük a tömbből
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Update
      <ul>
        <li>Biztosítani kell egy eszközt a User Interface-en, amivel a user tud frissíteni</li>
        <li>Szükség van egy szerkesztés gombra, amire ki kell renderelni egy form-ot, ahol frissíthető a
          state
        </li>
        <pre>
  productsHTML = ''
      for (var prod of state.products) &#123;
          productsHTML += `
          &#60;div class="card m-2 p-2 $&#123;!prod.isInStock ? 'bg-danger' : ''&#125;">
              &#60;i class="fas fa-check">&#60;/i&#62;
              &#60;p&#62;ID: $&#123;prod.id&#125;&#60;/p&#62;
              &#60;p&#62;Terméknév: $&#123;prod.name&#125;&#60;/p&#62;
              &#60;p&#62;Ár: $&#123;prod.price&#125;&#60;/p&#62;
              &#60;button class="btn btn-success mb-1 float-right edit-product" data-productid="$&#123;prod.id&#125;" onclick="editProduct('$&#123;prod.id&#125;')">Szerkesztés&#60;/button&#62;
              &#60;button class="btn btn-danger float-right delete-product" data-productid="$&#123;prod.id&#125;" onclick="deleteProduct('$&#123;prod.id&#125;')">Törlés&#60;/button&#62;
          &#60;/div>
      `
      &#125;

  for (var editBtn of document.querySelectorAll('.edit-product')) &#123;
      editBtn.onclick = function () &#123;
          state.editId = event.target.dataset.productid;
      &#125;
  &#125;
                    </pre>
        <li>Azzal, hogy a gombok onclick kulcsának függvényt határozunk meg JavaScript-ben, az inline írt
          onclick-et felülírjuk
      </ul>
    </li>
    <li>A state-hez hozzáillesztettünk egy editId kulcsot
      <ul>
        <pre>
  var state = &#123;
      products: [
          &#123;id: createRandomID(), name: 'Termék 1', price: 2500, isInStock: true&#125;,
          &#123;id: createRandomID(), name: 'Termék 2', price: 3500, isInStock: false&#125;,
          &#123;id: createRandomID(), name: 'Termék 3', price: 4500, isInStock: true&#125;,
      ],
      editId: ''
  &#125;
        </pre>
        <li>A célunk, hogy egy formot az edit-product id-jú komponensbe beillesszünk, és ezt feldobjuk
          a UI-ban
          <pre>
  function renderEditProduct() &#123;
    if (!state.editId) &#123;
        document.getElementById('edit-product').innerHTML = '';
        return;
    }
    
    var foundProduct;

    for (var prod of state.products) &#123;
        if (prod.id === state.editId) &#123;
            foundProduct = prod;
            break;
        }
    }

    console.log('state.editId: ', state.editId);
    console.log('foundProduct: ', foundProduct);

    var editHTMLForm = `
        &#60;h3>Termék szerkesztése&#60;/h3>
        &#60;form id="update-product" class="p-5">
            &#60;label class="w-100">
                Név:
                &#60;input class="form-control" type="text" name="name" value="$&#123;foundProduct.name}">
            &#60;/label>
            &#60;label class="w-100">
                Ár:
                &#60;input class="form-control" type="number" name="price" value="$&#123;foundProduct.price}">
            &#60;/label>
            &#60;label class="w-100">
                Van készleten?
                &#60;input class="form-control" type="checkbox" name="isInStock" $&#123;foundProduct.isInStock ? 'checked' : ''}>
            &#60;/label>
            &#60;button class="btn btn-primary" type="submit">Módosítás&#60;/button>
        &#60;/form>
    `;

    document.getElementById('edit-product').innerHTML = editHTMLForm;

    document.getElementById('update-product').onsubmit = function (event) &#123;
        event.preventDefault();

        console.log(event.target.elements);

        var name = event.target.elements.name.value;
        var price = event.target.elements.price.value;
        var isInStock = event.target.elements.isInStock.checked;

        var foundIndex;
        for (var i = 0; i &#60; state.products.length; i++) &#123;
            if (state.products[i].id === state.editId) &#123;
                foundIndex = i;
                break;
            }
        }

        state.products[foundIndex] = &#123;
            id: state.editId,
            name,
            price,
            isInStock
        };

        state.editId = '';

        renderProducts();
        renderEditProduct();
    };
  }        
        </pre>
        </li>
      </ul>
    </li>
    <li>A renderEditProduct() függvényt meghívjuk a state változás után, ami kikeresi azt a tömbelemet,
      aminek az adatait változtatni szeretnénk
    </li>
    <li>A form megjelenítéséhez kimásolhatjuk a projektünk form részét</li>
    <li>A checked attribútum valamiért nem működik, pedig a megfelelő helyen true az érték, még sem pipálódott be a
      checkbox
    </li>
    <li>Az utolsó feladat, hogy a Módosítás gomb megnyomásakor át meg kell módosítanunk az adatokat a
      state-ben
      <ul>
        <li>Mivel a függvényben, ahol kicseréljük a tömbelem name, price, isInStock értékét, ugyanolyan
          nevű változókat használtunk, mint ami a tömbelemekben is szerepel, így nem kell kulcs-érték
          párokat megadni
        </li>
        <li>Ha egész blokknyi kódokat kell átmásolgatni egyik helyről a másikra, akkor vegyük észre,
          hogy ki tudjuk szervezni függvénybe, és minden helyen, ahol szükséges, meghívjuk
        </li>
        <li>A módosítás befejeztével kiürítjük az editId kulcsot a state-ben, és meghívjuk ugyanazt a
          függvényt, mint amiben éppen állunk, hiszen az elején szerepel egy olyan kód, ami azért
          felel, hogy ha üres az editId változónk, akkor ne rajzolódjon ki a termék szerkesztő
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #callstack data-anchor="callstack">Call Stack</h3>
  <ul>
    <li>A JavaScript Engine felfogható úgy is, mint egy program a programban
      <ul>
        <li>A böngészőbe van beágyazva, és abban működik</li>
      </ul>
    </li>
    <li>A JavaScript nyelv szinkron végrehajtódású nyelv
      <ul>
        <li>Két programkód egyszerre sosem hajtódik végre (egy szálon futnak a dolgok)</li>
        <li>A kód fentről lefelé, sorról sorra hajtódik végre</li>
        <li>A script mindig a main (fő) kontextusban kezd el futni (a böngésző szűkebb kontextusa)</li>
        <li>Ha a main-ben function hívás történik, a JS átadja a kontrollt annak a függvénynek, ami meg lett
          hívva
          <ul>
            <li>Ilyenkor a Call Stack-hez hozzáadódik ez a függvény</li>
            <li>Amennyiben a meghívott függvényben újabb függvényt hívunk meg, újabb függvény adódik
              hozzá a Call Stack-hez
            </li>
            <li>Ha pedig az újabb függvény lefut, visszaadja a kontrollt a korábbi függvénynek, majd ha
              az a függvény is lefutott, akkor visszaadja a kontrollt a main-nek
            </li>
            <li>A main-ben pedig történhet további kód futás, akár függvényhívás is</li>
            <li>Ha a teljes script lefutott, akkor a Call Stack-ből kikerül a main is, és a rendszerbe
              beáll egy alap állapot, ami nem zárja ki, hogy a későbbiekben a Call Stack-be újabb
              elemek kerüljenek
            </li>
          </ul>
        </li>
        <li>Fontos látni, hogy miután a végrehajtás szinkron, így a Call Stack-et nem blokkolhatja egy
          hosszan tartó művelet
          <ul>
            <li>Ha ez mégis megtörténik, addig, amíg a művelet le nem fut, további sor kódok nem
              hajtódhatnak végre
            </li>
            <li>A hosszan tartó művelet az összes interaktivitást megszünteti az oldalon (befagy az
              oldal)
            </li>
            <li>A szinkron végrehajtódást meg kell hagyni gyorsan végrehajtódó műveleteknek</li>
            <li>Ezzel együtt képesnek kell lenni a böngésző tágabb kontextusának kiadni feladatokat,
              amiket végre tud hajtani
              <ul>
                <li>A script folytathatja a gyors tevékenységét, és elég csak arról értesülni, hogy
                  a hosszabb folyamat befejezte a működését
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A böngésző tágabb kontextusába kihelyezhető párhuzamosan futó feladat
          <ul>
            <li>Legegyszerűbb példa a setTimeout() függvény
              <ul>
                <li>Függvényt vár a bemenetére első paraméternek</li>
                <li>Aszinkron művelet
                  <ul>
                    <li>Az aszinkron műveletekre általánosságban is elmondható, hogy a
                      bemenetükre függvényt várnak
                    </li>
                    <li>Ha bizonyos esemény bekövetkezik a jövőben, akkor mi az a
                      funkcionalitás, amit futtatni kell
                    </li>
                    <li>A jövőbeli esemény a setTimeout-nál az idő (második paraméter)
                    </li>
                    <li>A jövőbeli esemény lehet egy click event is, egy form submit, vagy egy
                      input mező keypress eseménye
                    </li>
                    <li>A fő szálon ezek futtatására nincs szükség, csak amikor mondjuk
                      bekövetkezett az esemény
                    </li>
                    <li>Ezek is belekerülnek a stack-be, de azon nyomban ki is kerülnek belőle,
                      kihelyeződik a main-ből a művelet, és a stack folytatja az adott
                      tevékenységét
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Ide tartoznak a szerver oldali kérések is (pl.: AJAX)
              <ul>
                <li>Szintén nem szinkron időben akarjuk megvárni a választ</li>
                <li>Rábízzuk a böngészőre, ha majd kész a hívás, akkor szólj, és a funkcionalitást
                  (függvényt, amit megadtunk) rakd be a stack-be
                </li>
                <li>Amíg a Call Stack-ben lévő szinkron feladatok nem futnak le, addig a külön sorban várakozó aszinkron
                  feladatok sem kerülhetnek sorra, még akkor sem, ha azok idő közben "elkészültek"
                </li>
                <li>A Web API-k csak annyit csinálnak, hogy amint elvégeztek valami feladatot, az
                  adott elemet (amit visszaadnak) behelyezik egy úgynevezett Callback Queue-ba
                  <ul>
                    <li>A queue ismérve, hogy az első elem, ami bekerült, az távozik először
                    </li>
                    <li>A Web API-k az egyik oldalon pakolják be az elemeket, a másik oldalon
                      pedig kerülnek ki az elemek a Callback Queue-ból
                    </li>
                    <li>Ennek körforgásáról az Event Loop gondoskodik
                      <ul>
                        <li>Az Event Loop ránéz a Call Stack-re, és amennyiben a szinkron
                          működés már lefutott, akkor amit a queue-ban talál, berakja a
                          stack-be
                        </li>
                        <li>Az így behelyezett művelet szintén le fog futni, és újra kiürül
                          a stack
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>setTimeout(function, 0) használatakor, main futásakor a művelet/funkcionalitás
                  ugyanúgy kikerül (a Web API-k közé), majd, ha a setTimeout-ban lévő elem
                  végrehajtódott, bekerül a Callback Queue-ba, és az Event Loop csak abban az
                  esetben fogja berakni a funkcionalitást a stack-be, amennyiben a main műveletek
                  lefutottak
                  <ul>
                    <li>A különbség csak annyi 0 ms-mal, hogy a Web API-k közé gyorsabban bekerül
                      az adott elem, hiszen a "hosszú ideig" tartó művelet 0 ms alatt
                      bekövetkezik
                    </li>
                  </ul>
                </li>
                <img src="assets/imgs/js_event_loop.png" width="100%">
                <br>
                <table style="border-collapse: collapse; width: 100%;">
                  <thead>
                    <tr>
                      <th>Elem</th>
                      <th>Feladat</th>
                      <th>Lényeg</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>Heap</td>
                      <td>A dinamikus memória, ide kerülnek az objektumok</td>
                      <td>"Adattár"</td>
                    </tr>
                    <tr>
                      <td>Call Stack</td>
                      <td>Szinkron függvényhívások verme, a motor mindig a stack tetején lévő keretet futtatja</td>
                      <td>Amíg nem üres, semmi más nem "juthat szóhoz"</td>
                    </tr>
                    <tr>
                      <td>Web- / Node-API-k</td>
                      <td>Böngésző vagy Node C++ rétege futtatja az időigényes/aszinkron műveleteket (például
                        setTimeout, fetch, DOM-esemény)</td>
                      <td>Ezek nem a stack-be kerülnek</td>
                    </tr>
                    <tr>
                      <td>Task&nbsp;queue<br>(macro&nbsp;queue)</td>
                      <td>Készen álló „nagy” feladatok: setTimeout, DOM-esemény, I/O-callback</td>
                      <td>FIFO-elv</td>
                    </tr>
                    <tr>
                      <td>Microtask&nbsp;queue</td>
                      <td>Apró, prioritásos feladatok: Promise.then, queueMicrotask</td>
                      <td>Minden makró feladat után teljesen kiürül</td>
                    </tr>
                    <tr>
                      <td>Event&nbsp;loop</td>
                      <td>Folyamatosan figyel: ha a verem üres, először a microtask queue-t üríti, majd egy feladatot a
                        task queue-ból a verembe tesz</td>
                      <td>Ütemezés, priorizálás</td>
                    </tr>
                    <tr>
                      <td>Main&nbsp;thread</td>
                      <td>Maga a JavaScript motor + az Event Loop + Call Stack; a kód itt fut (single-thread)</td>
                      <td>Párhuzamosság helyett konkurencia</td>
                    </tr>
                  </tbody>
                </table>
                <br>
                <li>A folyamat
                  <ol>
                    <li>A szinkron kód betöltődik
                      <ul>
                        <li>A függvények egymás után hívása bekerül a Call Stack-be</li>
                      </ul>
                    </li>
                    <li>Egy aszinkron hívás (például fetch, setTimeout) elindul
                      <ul>
                        <li>Az engine átadja a Web-API-nak, majd kiveszi a stack-ből
                        </li>
                        <li>A stack "folytatódik"</li>
                      </ul>
                    </li>
                    <li>Amikor az API elkészült, a callback bejegyződik a megfelelő queue-ba (macro vagy micro)</li>
                    <li>Az Event Loop figyel
                      <ul>
                        <li>Ha a Call Stack üres, előbb a microtask queue-t üríti (Promises), aztán a Task Queue
                          (macrotask) első elemét átemeli a stack-be</li>
                      </ul>
                    </li>
                    <li>A kivett callback szinkron kódként fut, újra tölti a veremet</li>
                    <li>A kör újraindul</li>
                  </ol>
                </li>
                <pre>
  <b>// példa</b>

  console.log('A');
  Promise.resolve().then(() => console.log('B'));
  console.log('C');
                </pre>
                <table style="border-collapse: collapse; width: 100%;">
                  <thead>
                    <tr>
                      <th>Lépés</th>
                      <th>Call Stack</th>
                      <th>Queue</th>
                      <th>Konzol kimenet</th>
                    </tr>
                  </thead>

                  <tbody>
                    <tr>
                      <td>1</td>
                      <td>console.log('A') lefut, keret lekerül</td>
                      <td>-</td>
                      <td><strong>A</strong></td>
                    </tr>

                    <tr>
                      <td>2</td>
                      <td>Promise.resolve() szinkron része → a .then callback microtask-ba kerül</td>
                      <td>Microtask:<br>[ () → console.log('B') ]</td>
                      <td>-</td>
                    </tr>

                    <tr>
                      <td>3</td>
                      <td>console.log('C') lefut, keret lekerül</td>
                      <td>-</td>
                      <td><strong>C</strong></td>
                    </tr>

                    <tr>
                      <td>4</td>
                      <td>Stack üres → Event Loop először a microtask queue-t üríti</td>
                      <td>-</td>
                      <td>-</td>
                    </tr>

                    <tr>
                      <td>5</td>
                      <td>Microtask callback fut → console.log('B')</td>
                      <td>-</td>
                      <td><strong>B</strong></td>
                    </tr>
                  </tbody>
                </table>
                <li>Az eredmény A, C, B</li>
                <li>A Promise mindig megelőzi a setTimeout(..., 0)-t, mert a microtask-sor prioritást élvez
                  <ul>
                    <li>A Promise chain-ek mindig microtask-ként futnak, ezért gyorsabban sorra kerülnek, mint például
                      egy setTimeout(fn, 0)</li>
                  </ul>
                </li>
                <br>
                <li>Amíg a call stack nem üres, semmilyen aszinkron callback nem futhat</li>
                <li>Ha a stack kiürül, az Event Loop először minden microtaskot lefuttat, majd egyet a Task Queue-ból
                  <ul>
                    <li>A macro-taskok egyesével érkeznek, hogy ne blokkolják tartósan a felhasználói felületet, és
                      minden aszinkron forrás rendszeresen sorra kerülhessen</li>
                  </ul>
                </li>
                <li>A Web- / Node-API csak “parkoltatja” az időzített/fetch/hardware munkát, és amikor kész, a
                  callbacket sorba rakja</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>


<div>
  <h3 #ajax1 data-anchor="ajax1">AJAX I</h3>
  <ul>
    <li>Az AJAX kérések aszinkron műveletek, nem blokkolják a Call Stack-et, hanem a böngésző stack futásával
      párhuzamosan végeznek műveletet, és a szerver válasza után futtatnak további elemeket, amikor a szinkron
      működés véget ér
    </li>
    <li>Egy szerver oldali kérés akár több 100 ms-ig is tarthat, és addig nem blokkolhatjuk a kód szinkron
      futását
    </li>
    <br>
    <div>
      <button id="fetch-posts" class="btn btn-secondary">Fetch posts with AJAX call</button>
      <div id="post-list-container" class="mt-3" style="max-height: 200px; overflow: auto; border-radius: 5px;"></div>
    </div>

    <pre>
  &#60;button id="fetch-posts" class="btn btn-secondary">Fetch posts with AJAX call&#60;/button>
  &#60;div id="post-list-container" class="mt-3" style="max-height: 200px; overflow: auto; border-radius: 5px;">&#60;/div>
    </pre>

    <li>http://jsonplaceholder.typicode.com/posts
      <ul>
        <li>Nem HTML tartalmat tölt be az oldal, hanem JavaScript-es struktúrához hasonló szerkezet (JSON)</li>
        <pre>
  [
      &#123;
          "userId": 1,
          "id": 1,
          "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",
          "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"
      &#125;,
      ...
  ]
        </pre>
        <li>Nyers adat, önmagában nem alkalmas a felhasználó felé megjelenítésre</li>
        <li>Voltaképp JSON string
          <ul>
            <li>Olyan adatformátum, amit a JavaScript ihletett</li>
            <li>Formai megkötése, hogy a kulcsokat kötelező (kettős) idézőjelbe tenni</li>
            <li>A neten tipikusan ebben a formátumban áramlik az adat</li>
            <li>Régebben az XML formátum volt elterjedve</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Feladatunk, hogy a gomb megnyomásakor kimenjen az AJAX (aszinkron) kérés
      <ul>
        <pre>
  document.getElementById('fetch-posts').onclick = function () &#123;
    var xhr = new XMLHttpRequest();

    xhr.onreadystatechange = function () &#123;
        if (xhr.readyState === 4 && xhr.status === 200) &#123;
            const response = JSON.parse(xhr.responseText);
            console.log(response);

            var posts = '';

            for (var res of response) &#123;
                posts += `
                    &#60;div class="card" style="padding: 10px; margin: 10px; border: 1px solid gray; border-radius: 5px">
                        &#60;div>ID: $&#123;res.id}&#60;/div>
                        &#60;div>UserID: $&#123;res.userId}&#60;/div>
                        &#60;div>Title: $&#123;res.title}&#60;/div>
                        &#60;div>Body: $&#123;res.body}&#60;/div>
                    &#60;/div>
                `;
            }

            var postListContainer = document.getElementById('post-list-container');

            postListContainer.style.border = '1px solid black';
            postListContainer.innerHTML = posts;
        }
    };

    xhr.open('GET', 'http://jsonplaceholder.typicode.com/posts');
    xhr.send();
  };        
        </pre>
        <li>Létre kell hozni egy XMLHttpRequest object-et
          <ul>
            <li>A 'new XMLHttpRequest' objektum kliens által indított, szerver felé irányuló kérést reprezentál</li>
            <li>Ennek kulcsait / funkcionalitásait lehet felhasználni a kérés küldésére</li>
            <li>Az objektum 'onreadystatechange' eseményére kell reagálni
              <ul>
                <li>Mindig lefut akkor, amikor a kérés életciklusában valami változás történik</li>
                <li>Összesen 4 ciklusa van egy ilyen kérésnek (XMLHttpRequest.readyState)
                  <ul>
                    <li>0. - Ha a kérés nem inicializált</li>
                    <li>1. - Ha a kapcsolat létrejött a szerverrel</li>
                    <li>2. - Ha a kérés fogadva van</li>
                    <li>3. - Ha a kérés feldolgozása folyamatban van</li>
                    <li>4. - Ha a kérés kész, a válasz is kész</li>
                  </ul>
                </li>
                <li>Minket most az érdekel, ha kész a válasz</li>
                <li>Az onreadystatechange-hez bekötött callback függvény minden állapotváltozásnál lefut</li>
                <li>A XMLHttpRequest.readyState változik stádiumonként</li>
                <li>Kiegészíthető azzal, hogy az objektumban a status legyen egyenlő 200-zal (tehát
                  a response status sikeres)
                </li>
                <li>Az xhr.responseText értéke szintén változik az állapotváltozások során</li>
              </ul>
            </li>
            <li>xhr.open() függvényben adható meg, hogy hova akarjuk kiküldeni a kérésünket
              <ul>
                <li>Első paraméternek metódust vár, második paraméternek url-t</li>
              </ul>
            </li>
            <li>Az xhr.send() függvény meghívásával kiküldhető a kérés
              <ul>
                <li>Elindítja a hálózati kérést a böngésző</li>
                <li>A korábban beállított xhr.onreadystatechange = () = &#123; } csak egy függvényreferencia, a böngésző
                  később, minden állapotváltozáskor (readyState 0 → 4) meghívja</li>
                <li>Jelen esetben a callback csak akkor fut tovább, ha readyState === 4 és status === 200</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A válaszban, amit a console-log-gal kiírtunk, látható, hogy egy JSON string-et kaptunk vissza,
          tehát a JavaScript részéről ez csak egy string
          <ul>
            <li>Át kell alakítanunk JavaScript-es adatstruktúrává</li>
            <li>JSON.parse() függvény
              <ul>
                <li>JSON string-et parse-ol, és visszatér JavaScript-es adatstruktúrával</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A függvényben végig iterálunk az immáron JavaScript-es objektumunkon, és tetszés szerinti HTML-t
          készíthetünk belőle
        </li>
        <li>Ez egy olyan kérés volt, amihez nem kellett az oldalt befrissíteni, tehát az oldal újra
          letöltése nélkül jutunk hozzá az adathoz
          <ul>
            <li>A modern webapplikációknak ez egy alapvető működésbeli sajátosságuk</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #ajax2 data-anchor="ajax2">AJAX II</h3>
  <ul>
    <li>A korábbiakban megírt AJAX kérést fogjuk kiszervezni egy külön függvénybe, amit felparaméterezünk, hogy
      bárhova tudjunk kéréseket küldeni
    </li>
    <br>
    <div>
      <button id="fetch-anything" class="btn btn-secondary">Fetch posts with AJAX call</button>
      <div id="anything-container" class="mt-3" style="max-height: 200px; overflow: auto; border-radius: 5px;"></div>
    </div>
    <pre>
  &#60;button id="fetch-anything" class="btn btn-secondary">Fetch posts with AJAX call&#60;/button>
  &#60;div id="anything-container" class="mt-3" style="max-height: 200px; overflow: auto; border-radius: 5px;">&#60;/div>
    </pre>
    <pre>
  function sendRequest(url, method, body, callback) &#123;
    document.getElementById('fetch-posts').onclick = function () &#123;
        var xhr = new XMLHttpRequest();

        xhr.onreadystatechange = function () &#123;
            if (xhr.readyState === 4 && xhr.status === 200) &#123;
                callback(JSON.parse(xhr.responseText));
            }
        };

        xhr.open(method, url);
        xhr.send(body);
    };
  }      
      </pre>
    <li>A függvényünk 4. paramétere a callback
      <ul>
        <li>Callback: function típusú, azaz mit csináljon a függvény, ha készen van</li>
        <li>A sendRequest function meg fogja hívni a callback function-ünket, amikor eljön az ideje
        </li>
        <li>Ennek ideje jelen példában akkor jön el, amikor a readyState-ünk 4-es, és a status-unk
          200-as
        </li>
      </ul>
    </li>
    <li>A HTML összeállítását kívülről kell szolgáltatnunk, hogy a funkcionalitás általános maradhasson</li>
    <li>
      <pre>
  document.getElementById('fetch-anything').onclick = function () &#123;
    var url = 'https://jsonplaceholder.typicode.com/posts';   // http-vel CORS error
    var method = 'GET';
    var body = null;

    var callback = function (posts) &#123;
        var content = '';

        for (var post of posts) &#123;
            content += `
                &#60;div class="card" style="padding: 10px; margin: 10px; border: 1px solid gray; border-radius: 5px">
                    &#60;div>ID: $&#123;post.id}&#60;/div>
                    &#60;div>UserID: $&#123;post.userId}&#60;/div>
                    &#60;div>Title: $&#123;post.title}&#60;/div>
                    &#60;div>Body: $&#123;post.body}&#60;/div>
                &#60;/div>
            `;
        }

        var anythingListContainer = document.getElementById('anything-container');
        anythingListContainer.style.border = '1px solid black';
        anythingListContainer.innerHTML = content;
    };

    sendRequest(url, method, body, callback);
  };

  function sendRequest(url, method, body, callback) &#123;
    var xhr = new XMLHttpRequest();

    xhr.onreadystatechange = function () &#123;
        if (xhr.readyState === 4 && xhr.status === 200) &#123;
            callback(JSON.parse(xhr.responseText));
        }
    };

    xhr.open(method, url);  // 'GET', 'http://jsonplaceholder.typicode.com/posts'
    xhr.send(body);         // a body null, 'POST' esetén lenne rá szükség
  }          
      </pre>
      <ul>
        <li>A function-ben hajtódik végre a HTML összeállítása</li>
        <li>A callback function értéke a sendRequest függvény meghívásakor a posts-ban lesz elérhető (amit a
          function paraméterénél látunk)
        </li>
        <li>Jelen példánkban request body-t nem küldünk (nem is kell), csak azt adtuk meg a
          setRequestHeader-ben (beégetve), hogy a content-type az JSON
        </li>
        <li>Jelen példánkban nincs működésbeli különbség a többször felhasználhatóságot tekintve</li>
      </ul>
    </li>
    <br>
    <li>Bejelentkezés flow
      <br>
      <br>
      <div>
        <button id="login" class="btn btn-secondary">Bejelentkezés</button>
        <br>
        <br>
        Token: <span id="login-token-id"></span>
      </div>
      <br>

      <ul>
        <li>reqres.in oldal API-ját fogjuk felhasználni
          <ul>
            <li>/api/login => email és password megadása szükséges, cserébe token-nel válaszol a szerver
            </li>
            <li>A koncepció az, hogy védett erőforrásokhoz akarunk hozzáférni, ezt fogjuk tudni megtenni
              a token-nel
            </li>
            <li>A token meglétekor egy újabb kérést kell majd kiküldenünk, és meg kell szólítanunk a
              list users erőforrást
            </li>
            <li>A token-t hozzácsapva a header-ökhöz, érhető el általában a védett tartalom (jelen
              példában nem lesz hozzá szükségünk)
            </li>
          </ul>
        </li>
        <li>
          <pre>
  document.getElementById('login').onclick = function () &#123;
    var url = 'https://reqres.in/api/login';
    var body = JSON.stringify(&#123;
        email: 'eve.holt@reqres.in',
        password: 'cityslicka'
    });
    sendRequest(url, 'POST', body, function (token) &#123;
        console.log(token);
        document.getElementById('login-token-id').innerHTML = token.token;
    });
  };  
  
  function sendRequest(url, method, body, callback) &#123;
    var xhr = new XMLHttpRequest;

    xhr.onreadystatechange = function () &#123;
        if (xhr.readyState === 4 && xhr.status === 200) &#123;
            callback(JSON.parse(xhr.responseText));
        }
    }

    xhr.open(method, url);

    xhr.setRequestHeader('content-type', 'application/json');

    xhr.setRequestHeader('x-api-key', 'reqres-free-v1');

    xhr.send(body);
  }
          </pre>
          <ul>
            <li>A body egy JSON-né alakított adat (JavaScript objektumból)</li>
            <li>A loginhoz szükséges adatokat ezúttal beégettük</li>
            <li>A kérésből érkezett válasz (token) a callback function-ben jelenik meg</li>
            <li>Először szükséges meghívni az open() függvényt, és csak utána lehet a header információt
              bekötni
            </li>
            <li>Nagyon fontos, hogy a sendRequest függvény nem tér vissza értékkel, így változóba sem
              tárolható el, hogy máshol használjuk, csak egy callback function-t hív meg egy esemény
              kapcsán
            </li>
            <li>Tehát a token-t csak a callback függvényben használhatjuk, csak abban a scope-ban
              létezik
            </li>
          </ul>
        </li>
        <li>A további lekérdezésekhez abban a scope-ban kell meghívnunk (újra) a sendRequest függvényt, ahol
          a token-t megkaptuk
        </li>
        <pre>
  document.getElementById('login').onclick = function () &#123;
    var url = 'https://reqres.in/api/login';
    var body = JSON.stringify(&#123;
        email: 'eve.holt@reqres.in',
        password: 'cityslicka'
    });

    sendRequest(url, 'POST', body, function (token) &#123;  // arrow függvénnyel érthetőbb sendRequest( url, 'POST', body, (token) => &#123; *logika* } )
        console.log(token);
        document.getElementById('login-token-id').innerHTML = token.token;

        sendRequest('https://reqres.in/api/users', 'GET', null, function (users) &#123;
            console.log(users);
        });
    });
  };          

  function sendRequest(url, method, body, callback) &#123;
    var xhr = new XMLHttpRequest;

    xhr.onreadystatechange = function () &#123;
        if (xhr.readyState === 4 && xhr.status === 200) &#123;
            callback(JSON.parse(xhr.responseText));
        }
    }

    xhr.open(method, url);

    xhr.setRequestHeader('content-type', 'application/json');

    xhr.setRequestHeader('x-api-key', 'reqres-free-v1');

    xhr.send(body);
  }
        </pre>
        <li>Két network kérés ment ki, sorrendben</li>
        <li>A token megléte után újra meghívtuk a sendRequest függvényt</li>
        <li>A user-ekkel semmi mást nem csináltunk, csak kilogoltuk console-ba</li>
        <br>
        <img src="assets/imgs/js_ajax_login_users.png" width="100%">
        <br>
        <br>
        <li>A kódra jellemző a beágyazottság, mert az egymástól függő aszinkron kérésekre igaz, hogy
          mindig csak a bedobott callback function scope-jában tudunk dolgozni a végeredménnyel
        </li>
        <li>Ha újabb kérést kellene kiküldenünk, aminek előfeltétele a users erőforrás, az további
          beágyazottságot eredményezne
        </li>
        <li>Ez vezet át a következő témakörbe, a Promise-okhoz
          <ul>
            <li>Egy újabb nyelvi eszköz, aminek keretében megtanuljuk, hogyan lehet kiküszöbölni
              a beágyazottságot, és szebb formába önteni a kódot
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Feladat
      <ul>
        <li>Egy form (2 input mező: felhasználónév és jelszó) submit eseményére loginolni</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #promise data-anchor="promise">Promise</h3>
  <ul>
    <li>Az aszinkron kéréseink miatt a kódunk egy ilyen mintázatot kezd el követni
      <ul>
        <pre>
  sendRequest(url, 'POST', body, function (token) &#123;
    document.getElementById('login-token-id').innerHTML = token.token;
    console.log(token);

    sendRequest('https://reqres.in/api/users', 'GET', null, function (users) &#123;
        console.log(users);

        sendRequest('https://reqres.in/api/tovabbiEroforras1', 'GET', null, function (eroforras1) &#123;
            console.log(eroforras1);

            sendRequest('https://reqres.in/api/tovabbiEroforras2', 'GET', null, function (eroforras2) &#123;
                console.log(eroforras2);
            });
        });
    });
  });        
        </pre>
        <li>Ez az elrendezés nevet is kapott
          <ul>
            <li>callback hell</li>
            <li>pyramid of doom</li>
          </ul>
        </li>
        <li>Ezzel a beágyazott kóddal rendkívül nehéz dolgozni</li>
        <li>A kérések nem feltétlen sikeresek</li>
        <li>Minden egyes aszinkron művelet kapcsán csak a megadott callback function-ben van lehetőség további
          műveletekre
        </li>
        <li>A kód inkább így néz ki
          <pre>
  sendRequest(url, 'POST', body, function (token) &#123;
    document.getElementById('login-token-id').innerHTML = token.token;

    if (token) &#123;
        sendRequest('https://reqres.in/api/users', 'GET', null, function (users) &#123;
            if (users) &#123;
                sendRequest('https://reqres.in/api/tovabbiEroforras1', 'GET', null, function (eroforras1) &#123;
                    if (eroforras1) &#123;
                        sendRequest('https://reqres.in/api/tovabbiEroforras2', 'GET', null, function (eroforras2) &#123;
                            if (!eroforras2) &#123;
                                alert('Error');
                            }
                        });
                    } else &#123;
                        alert('Error');
                    }
                });
            } else &#123;
                alert('Error');
            }
        });
    } else &#123;
        alert('Error');
    }
  });          
        </pre>
        </li>
        <li>Szükségessé vált egy nyelvi konstrukció, ami elejét veszi a kód ilyen módú beágyazásának
          <ul>
            <li>Elkéri a szükséges részeket, minimális információt</li>
            <li>A háttérben összefűzi a szükséges egységeket</li>
            <li>Ugyanezt a működést eredményezi</li>
            <li>Az absztrakció neve Promise</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A Promise jellemzői
      <ul>
        <li>Egy Promise mindig egy (jövőbeli) értékkel, és annak állapotával együtt jelenik meg
          <ul>
            <li>Állapot (state): pending → fulfilled / rejected</li>
            <li>Érték (value): ha fulfilled, akkor megkapjuk at eredményt
              <ul>
                <li>A rejected hiba okjektumot ad</li>
              </ul>
            </li>
            <li>Alapvetően nem mondja, hogy milyen értéket fog szolgáltatni</li>
            <li>Valami érték aszinkron működés révén szinkron időben a kezünkbe kerül (Promise&#60;*type*&#62;)
              <ul>
                <li>Bármilyen típus megadható</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A sendRequest függvény becsomagolása Promise-os interface-be
      <ul>
        <li>Legyen egy függvényünk, ami vár paramétereket</li>
        <li>A callback function már nincs jelen</li>
        <li>Vissza kell térnünk egy Promise-szal, és adnunk kell neki egy "receptet"</li>
        <li>A recept azt hivatott megmondani, hogy mikor minősül sikeresnek a kérés</li>
        <li>A függvény megkap 2 paramétert
          <ul>
            <li>resolve és reject</li>
            <li>Ezek tulajdonképpen függvények</li>
            <li>Amikor meghívjuk őket a belső scope-ban, akkor futtatjuk a Promise-t sikeres, vagy
              sikertelen állapotba
            </li>
          </ul>
        </li>
        <pre>
  function sendRequest2(url, method, body) &#123;
    return new Promise(function (resolve, reject) &#123;
        var xhr = new XMLHttpRequest();
        
        xhr.onreadystatechange = function () &#123;
            if (xhr.readyState === 4) &#123;
                if (xhr.status >= 200 && xhr.status < 300) &#123;
                    resolve(JSON.parse(xhr.responseText));
                } else &#123;
                    reject(xhr.responseText);
                }
            }
        };

        xhr.open(method, url);
        xhr.setRequestHeader('content-type', 'application/json');
        xhr.send(body);
    });
  }          
        </pre>
        <li>Meg kell néznünk, hogy a status sikeres-e, azaz 2-essel kezdődik-e</li>
        <li>Ha ez teljesül, akkor a sikeres állapotba futást a resolve() függvénnyel hajthatjuk végre
        </li>
        <li>A resolve a futásidőben már elérhető, szerverről érkező választ kapja meg</li>
        <li>Reject esetén is átadjuk a szerverről érkező választ</li>
      </ul>
    </li>
    <li>Hívjuk meg a sendRequest2 függvényt
      <ul>
        <pre>
  sendRequest2(url, 'POST', body)
    .then(function (response) &#123;
        console.log(response);
  &#125;)
        </pre>
        <li>A Promise-t úgy tudjuk használni, hogy ami visszatér Promise objektum, annak van egy 'then' kulcsa,
          amiben egy függvény van
        </li>
        <li>A függvényben adhatjuk meg, hogy az aszinkron művelet révén a kezünkbe került értékkel mi történjen
        </li>
        <li>A sendRequest2 then kulcsában megadott függvényben elérhető lesz a kérésből kapott válasz</li>
        <li>Ha a then()-ből visszatérünk, az mindenképp egy Promise lesz</li>
      </ul>
    </li>
    <br>
    <div>
      <button id="login2" class="btn btn-secondary">Bejelentkezés</button>
      <br>
      <br>
      Token: <span id="login-token-id2"></span>
    </div>
    <pre>
  &#60;button id="login2" class="btn btn-secondary">Bejelentkezés&#60;/button>
  Token: &#60;span id="login-token-id2">&#60;/span>

  document.getElementById('login2').onclick = function () &#123;
    var url = 'https://reqres.in/api/login';
    var body = JSON.stringify(&#123;
        email: 'eve.holt@reqres.in',
        password: 'cityslicka'
    });

    sendRequest2(url, 'POST', body)
        .then(function (response) &#123;
            console.log('Promise response: ', response);
            document.getElementById('login-token-id2').innerHTML = response.token;
        })
        .catch(function (error) &#123;
            console.error('Request failed', error);
        });
  }
    </pre>
    <li>Így néz ki a response: &#123;token: 'QpwL5tke4Pnpja7X4'&#125;</li>
    <pre>
  sendRequest2(url, 'POST', body)
      .then(function (response) &#123;
          console.log(response);
          return 'Visszatérési érték';  // a válasz után visszaadunk egy értéket
      })
      .then(function (elozoThenVisszateresiErteke) &#123;
          console.log(elozoThenVisszateresiErteke);  // kiíratjuk az előző `then` visszatérési értékét
      })
      .catch(function (error) &#123;
          console.error('Request failed', error);  // hibakezelés
      });    
    </pre>
    <li>A második then függvényben az első then visszatérési értékéhez jutunk hozzá
      <ul>
        <li>Ha az első then nem Promise-t adna vissza, akkor már ott tudjuk használni result-ot, nem csak a következő
          then blokkban, mint Promise visszatérés esetében</li>
        <li>A következő then akkor is megkapja az előző then által visszaadott értéket, ha nem Promise-t adtunk vissza
        </li>
      </ul>
    </li>
    <pre>
  sendRequest2(url, 'POST', body)
      .then(function (response) &#123;    // itt első körben csak a token-t kérjük el a szervertől
          console.log('Promise response: ', response);
          document.getElementById('login-token-id2').innerHTML = response.token;
          return sendRequest2('https://reqres.in/api/users', 'GET', null);  // Promise-szal térünk vissza, így ennek visszatérési értékét csak a következő then blokkban kapjuk meg
      })
      .then(function (elozoThenVisszateresiErteke) &#123;
          console.log(elozoThenVisszateresiErteke); // már nincs szükség parse-olásra JSON esetében, mert a sendRequest2 függvény resolve-álásánál megtörténik → JSON.parse(xhr.responseText);
      });
    </pre>
    <li>Gondolhatnánk, hogy ebben az esetben az 'elozoThenVisszateresiErteke' egy
      Promise&#60;Promise&#60;any&#62;&#62;
    </li>
    <li>A gondolat téves, mert a then() function megszabadul egy rétegnyi Promise-tól, tehát biztosítja,
      hogy ami a kezünkbe kerül, mindenképpen egy egyszeresen becsomagolt Promise legyen
    </li>
    <br>
    <li>A then() függvény tehát kétféleképpen tud működni
      <ul>
        <li>Ha egyszerű adattal térünk vissza, ami nem Promise, akkor a then blokk becsomagolja az adatot Promise-ba
          <ul>
            <li>A visszatérő értékre meg lehet hívni egy újabb then() függvényt, ami "leveszi" a Promise-t</li>
          </ul>
          <pre>
  aPromise
    .then(function(response) &#123;
        return 'Simple string';  // ez egy sima érték, amit a then automatikusan Promise-ként kezel
    })
    .then(function(result) &#123;
        console.log(result);  // 'Simple string'
    });
          </pre>
        </li>
        <li>Ha pedig egy Promise-szal térünk vissza, akkor a következő then() megszabadul egy rétegnyi Promise-tól
          <ul>
            <li>Azaz ebben az esetben is Promise&#60;valami>-vel térünk vissza, ami szintén "lekerül" az adatról a
              következő blokkban</li>
            <pre>
  let anotherPromise = new Promise((resolve, reject) => &#123;
    setTimeout(() => resolve('Simple string in a Promise'), 1000);
  });

  aPromise
    .then(function(response) &#123;
        return anotherPromise;  // visszatérünk egy Promise-szal
    })
    .then(function(result) &#123;
        console.log(result);  // "Simple string in a Promise"
    });
            </pre>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Megeshet az is például, hogy egy Promise-ba ágyazott Promise-szal van dolgunk
      <ul>
        <li>Ha többszörösen beágyazott Promise-t adunk vissza (azaz egy Promise egy másik Promise-t tartalmaz), akkor
          a chain folytatásaként az első Promise teljesülése után a következő then() blokkban már csak egy Promise-t
          kapunk</li>
        <pre>
  let promiseOfPromise = new Promise((resolve, reject) => &#123; // Promise&#60;Promise&#60;string>>
    resolve(new Promise((resolve, reject) => &#123;
        resolve('Inner promise resolved');
    }));
  });

  aPromise
    .then(function(response) &#123;   // Promise&#60;Promise&#60;string>> => Promise&#60;string>
        return response;              // visszaadja a Promise&#60;string>-et
    })
    .then(function(result) &#123;     // feloldja a megmaradt Promise-t
        console.log(result);          // "Inner Promise resolved"
    });
          </pre>
      </ul>
    </li>
    <br>
    <li>Promise chain
      <ul>
        <li>A then() blokkokból felépített láncolatot hívjuk így</li>
        <li>Az adott then() blokkban dolgozhatunk az előző aszinkron művelet eredményével</li>
      </ul>
    </li>
    <br>
    <li>Hibakezelés
      <ul>
        <li>Két lehetőségünk van
          <ul>
            <li>Az adott then() blokkban kezeljük, egy újabb függvény megadásával
              <ul>
                <pre>
  sendRequest2(url, 'POST', body)
      .then(function (response) &#123;
          console.log('Promise response: ', response);
      }, function (error) &#123;
          console.log('Error: ', error);
      });
                </pre>
                <li> Akkor fog lefutni, ha a Promise hibára fut(reject)</li>
                <li>Átláthatatlanná teszi a kódot</li>
                <li> Nem használatos</li>
              </ul>
            </li>
            <li> Catch blokk
              <ul>
                <pre>
  sendRequest2(url, 'POST', body)
      .then(function(response) &#123;
          console.log('Promise response: ', response);
      &#125;)
      .catch(function(error) &#123;
          console.log(error);
      &#125;);
                </pre>
                <li>Az összes hibaág lekezelhető egy bizonyos pontig vele</li>
                <li>A then() függvényhez nagyon hasonlatos</li>
                <li>Függvény, amit meg lehet hívni</li>
                <li>Bemeneti paraméterként függvényt fogad</li>
                <li>A függvény fogja paraméterként megkapni a hiba értékét, amit a Promise a reject során megkap
                </li>
                <li>A catch() blokkot úgy helyezgetjük, ahogy akarjuk a chainben, és ahova tettük, addig
                  a pontig kezeli le a hibákat, legalábbis olyan módon, ahogy azt a bemeneti
                  függvényben megadjuk, tehát több catch is lehet egy chainben
                </li>
                <li>A best practice, hogy a chain végén van egy darab catch()</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Lehetőségünk van explicite hibát feldobni
          <ul>
            <pre>
  sendRequest2(url, 'POST', body)
      .then(function (response) &#123;
          console.log(response);
          return Promise.reject('Hiba');
      })
      .catch(function (error) &#123;
          console.log(error); // 'Hiba'
      });          
            </pre>
            <li>Vissza kell térnünk egy olyan Promise objektummal, ami reject-elve van</li>
            <li>A reject() függvénynek bármilyen értéket odaadhatunk, a catch() elkapja</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #fetch data-anchor="fetch">Fetch</h3>
  <ul>
    <div>
      <div>
        <div class="row" style="display: grid; grid-template-columns: 1fr 1fr; margin-bottom: 20px">
          <div id="login-component">
          </div>
          <div>
            <div id="user-list-container">
            </div>
          </div>
        </div>
      </div>
    </div>
    <pre>
  &#60;div class="row">
    &#60;div id="login-component">&#60;/div>
    &#60;div id="user-list-container">&#60;/div>
  &#60;/div>

  var state = &#123;
      users: [],
      isLoggedIn: false,
      isLoginPending: false,
      errorMsg: ''
  };

  window.onload = renderForm;

  function renderForm() &#123;
      console.log('state.isLoggedIn: ', state.isLoggedIn);
      if (state.isLoggedIn) &#123;
          document.getElementById("login-component").innerHTML = "";
      }

      document.getElementById("login-component").innerHTML = `
        &#60;div class="card p-3">    
          &#60;b id="log-in-title">Bejelentkezés&#60;/b>   
          &#60;form id="log-in">
              &#60;div>
                  &#60;label class="w-100">Email:
                      &#60;input type="text" name="email" class="form-control" $&#123;state.isLoginPending ? "disabled" : ""}/>
                  &#60;/label>
              &#60;/div>
              &#60;div>
                  &#60;label class="w-100">Jelszó:
                      &#60;input type="password" name="password" class="form-control" $&#123;state.isLoginPending ? "disabled" : ""}/>
                  &#60;/label>      
              &#60;/div>
              &#60;div>
                  &#60;button id="fetchSubmit" class="btn btn-secondary" type="submit" $&#123;(state.isLoginPending || state.isLoggedIn) ? "disabled" : ""}>
                          Bejelentkezés
                  &#60;/button>
                  &#60;button id="fetch-logout" class="btn btn-danger"type="button" $&#123;(state.isLoginPending || !state.isLoggedIn) ? "disabled" : ""}>
                      Kijelentkezés
                  &#60;/button>
              &#60;/div>
            &#60;div id="fetchErrorMessage">
              $&#123;state.isLoginPending ? "Bejelentkezés folyamatban..." : state.errorMsg}
            &#60;/div>
          &#60;/form>
        &#60;/div>
      `;

      if (document.getElementById('fetch-logout')) &#123;
          document.getElementById('fetch-logout').addEventListener('click', function (event) &#123;
              state.isLoggedIn = false;
              state.users = [];
              document.getElementById('user-list-container').innerHTML = '';
              renderForm();
          });
      }

      var fetchForm = document.getElementById('log-in');

      fetchForm.querySelectorAll('input')[0].value = 'eve.holt@reqres.in';
      fetchForm.querySelectorAll('input')[1].value = 'ok';

      fetchForm.onsubmit = function (event) &#123; } // a logika lentebb

  function renderUsers() &#123;
      var userListContainer = document.getElementById('user-list-container');

      var newList = '';

      newList = '&#60;ul class="list-group">'
      for (var s of state.users) &#123;
          newList += `&#60;li class="list-group-item">$&#123;s.first_name} $&#123;s.last_name}&#60;/li>`;
      }
      newList += `
          &#60;/ul>
      `;

      userListContainer.innerHTML = newList;

      state.isLoginPending = false;
      renderForm();

      console.log('state: ', state);
  }

  function renderErrors(errorMsg) &#123;
      // var errorContainer = document.getElementById('fetchErrorMessage');
      // errorContainer.innerHTML = errorMsg;
      state.errorMsg = errorMsg;
      state.isLoginPending = false;
      renderForm();
  }
    </pre>
    <li>Célunk, hogy login után lekérjük a user listát
      <ul>
        <li>A kérés elküldéséhez a beépített fetch függvényt fogjuk használni
          <ul>
            <li>A fetch első paramétere az URL</li>
            <li>A második paramétere pedig egy konfigurációs objektum</li>
            <li>A típus annotációját tekintve a fetch függvény visszatérése &#60;Promise&#60;Response&#62;&#62;
              <ul>
                <li>Egy később elérhető Response objektum</li>
              </ul>
            </li>
            <li>A szervertől érkező válasz több paramétert is tartalmaz(hat)</li>
            <li>A login-hoz a helyes credetial
              <ul>
                <li>eve.holt@reqres.in / *bármi*</li>
              </ul>
            </li>
            <li>Az első then() válasza a következőt adja vissza
              <ul>
                <pre>
  console.log(response);

  ↓↓↓↓↓

  &#123;
      body: ReadableStream
      bodyUsed: false
      headers: Headers &#123;&#125;
      ok: false
      redirected: false
      status: 400
      statusText: ""
      type: "cors"
      url:"https://reqres.in/api/login"
  &#125;
                 </pre>
              </ul>
            </li>
            <li>A body egy úgynevezett ReadableStream, mert potenciálisan hatalmas adat is lehet
              <ul>
                <li>Adatfolyamként van reprezentálva, amit ki lehet olvasni</li>
              </ul>
            </li>
            <li>Ha tudjuk, hogy JSON adatunk van, akkor a kiolvasás nagyon egyszerű</li>
            <li>A response.json() típusát tekintve Promise&#60;any&#62;
              <ul>
                <li>Tudjuk, hogy a Promise így működik, ha a then() blokkba bedobott function-ben
                  visszatérünk egy újabb Promise-szal ( return response.json() ), akkor a következő
                  then() blokkban tudjuk használni az abból az előző Promise-ból resolve-álódó értéket
                </li>
              </ul>
            </li>
            <li>Hibás email vagy jelszó esetén egy &#123;error: string&#125; objektumot kapunk
              <ul>
                <li>400-as státusz kódot kapunk, a fetch() függvény úgy működik, hogy nem futtatja a
                  rendszert Promise szintjén hibára, ezért lehet szükség egy catch() blokkra
                </li>
                <li>Az 'ok' kulcsot kell használnunk, hogy belefuttassuk a rendszert a catch() blokkba,
                  és a Promise-t így tudjuk rejected állapotba átállítani, amit egy Promise.reject()
                  függvénnyel tudunk megtenni
                </li>
                <li>A reject függvénybe bedobhatunk hibakezelésre alkalmas információt
                  <ul>
                    <li>Promise.reject('login error')</li>
                    <li>Ez a string fog felbukkanni a catch() blokk függvényének paramétereként</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>A második then() blokkban a kezünkbe kerül a user token, és lehetőségünk nyílik a második
              API hívás kiküldésére
            </li>
            <li>Visszatérhetünk fetch() függvény által visszaküldött Promise-szal
              <ul>
                <li>A fetch() függvény esetében a 'GET' method a default, 'GET' esetében body nincs, és
                  header információt sem akarunk küldeni, így nincs szükség megadni
                  semmi mást, csak a userek url-jét
                </li>
                <li>A válasz a következő then() blokkban lesz elérhető</li>
                <li>A kapott választ ki kell parse-olnunk</li>
                <li>A rá következő then() blokkban tudjuk ténylegesen használni</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Következő lépésben a form mellett található userelek listáját töltjük fel a kérésünknek
          megfelelően
          <ul>
            <li>Ennek megvalósításához deklarálunk egy state-et a rendszerünkbe
              <ul>
                <li>var state = []</li>
              </ul>
            </li>
            <li>A user lista lejövetelét tekinthetjük state change-nek, ekkor akarjuk megváltoztatni a
              kirenderelt userek listáját
              <ul>
                <li>state = userPage.data</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Adatlekérés</li>
        <pre>
  ...

  fetchForm.onsubmit = function (event) &#123;    // a form elküldésekor lefut a callback függvény
        event.preventDefault();   // megakadályozzuk az alapértelmezett HTML működést

        renderErrors('');   // lényegében eltávolítjuk a korábbi hibákat

        var email = event.target.elements.email.value;    // bekérjük a form email mező értékét
        var password = event.target.elements.password.value;    // bekérjük a password mező értékét

        var body = JSON.stringify(&#123; email, password });    // a credential-t JSON formátumba csomagoljuk

        state.isLoginPending = true;    // a bejelentkezési állapot elkezdődött
        renderForm();   // form frissítése

        fetch('https://reqres.in/api/login', &#123;   // API hívás
            method: 'POST', body, headers: &#123;
                'Content-type': 'application/json',   // JSON-t küldünk
                'x-api-key': 'reqres-free-v1'
            }
        })
        .then(function (response) &#123;
            if (!response.ok) &#123;    // ha a válasz nem sikeres, hibát dobunk
                return Promise.reject(&#123; error: 'Login failed' });    
            }
            // console.log('response.json() ', response.json().then(resp => console.log(resp))); // &#123;token: 'QpwL5tke4Pnpja7X4'}

            return response.json();   // sikeres válasz esetén a választ JSON-ra konvertáljuk
        })
        .then(function (response) &#123;
            state.isLoggedIn = true;
            state.isLoginPending = false;
            renderForm();
            return fetch('https://reqres.in/api/users', &#123; headers: &#123; 'x-api-key': 'reqres-free-v1' } });    // felhasználók lekérdezése
        })
        .then(function (response) &#123;
            if (!response.ok) &#123;
                return Promise.reject(&#123; error: 'Get user list failed' });
            }
            return response.json();   // az előző then blokkbeli fetch válasza Response objektum, ezéert szükséges a .json()
        })
        .then(function (userPage) &#123;
            state.users = userPage.data;    // lekért felhasználók state objektumba mentése
            renderUsers();    // felhasználók renderelése
        })
        .catch(function (error) &#123;
            state.isLoginPending = false;
            renderErrors(error.error);
        });
  }
  
  ...          
        </pre>
        <li>Mivel egyébként nem használjuk a user lista lekérésére a credential-t, nagyon leegyszerűsítve az alábbi
          módon hozzájuk férhetünk</li>
        <pre>
  fetch('https://reqres.in/api/users')    // + , &#123; headers: &#123; 'x-api-key': 'reqres-free-v1' } }
    .then(resp => resp.json())
    .then(users => console.log(users));
        </pre>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #asyncfunction data-anchor="asyncfunction">Async function</h3>
  <ul>
    <li>Eddig két módszert tanultunk, amivel elérjük azt, hogy a stack blokkolása nélkül a hosszú ideig tartó
      műveleteink sikeresen befejeződjenek
      <ul>
        <li>Callback function
          <ul>
            <li>Legrégebbi, a JavaScript készülésétől kezdve elérhető megoldás</li>
          </ul>
        </li>
        <li>Promise láncolat
          <ul>
            <li>A kódunk Promise chain formát ölt, és ezáltal megszűnt a kódban a beágyazottság</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Az async egy szintaktikai könnyítés</li>
    <li>A motorháztető alatt ugyanúgy Promise-okat használ</li>
    <li>Ha egy függvényt async kulcsszóval deklarálunk, akkor a body-n belül használni lehet az await kulcsszót
      <ul>
        <pre>
  async function loginAndFetchUsers() &#123;
      // await
  &#125;
         </pre>
        <li>A fejlesztő számára azt a látszatot kelti az await, mintha szinkron időben leblokkolnánk a kód
          futását
        </li>
        <li>Szinkron időben ugye nem blokkolhatjuk a futást, hiszen a JavaScript engine egyszerre csak egy dolgot tud
          végrehajtani
        </li>
      </ul>
    </li>
    <br>
    <li style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
      <div class="card p-1">
        <b id="log-in-title" style="display: block;padding-bottom: 20px">Belépés</b>
        <form id="log-in-2">
          <div>
            <label class="w-100">Email:
              <input type="text" name="email" class="form-control" />
            </label>
          </div>
          <div>
            <label class="w-100">Jelszó:
              <input type="password" name="password" class="form-control" />
            </label>
          </div>
          <div>
            <button id="fetchSubmit" type="submit" class="btn btn-secondary" style="margin-top: 20px">
              Bejelentkezés
            </button>
          </div>

        </form>
      </div>
      <div class="card p-1">
        <b id="log-in-title" style="display: block;padding-bottom: 20px">Felhasználók</b>
        <div id="user-list"></div>
      </div>
    </li>
    <br>
    <pre>
  var email = '';
  var pass = '';

  login2.onsubmit = function (event) &#123;
      event.preventDefault();

      email = event.target.elements.email.value;
      password = event.target.elements.password.value;

      loginAndFetchUsers();
  }

  async function loginAndFetchUsers() &#123;
    var loginResponse = await fetch('https://reqres.in/api/login', &#123;
        method: 'POST',
        body,
        headers: &#123;
            'Content-type': 'application/json',
            'x-api-key': 'reqres-free-v1'
        }
    });
  }      
    </pre>
    <li>A fetch function egy Promise of Response-szal tér vissza</li>
    <li>Az await kulcsszó megvárja, amíg a Promise resolve-álódik
      <ul>
        <li>Promise&#60;T&#62; típusból csinál T típust</li>
        <li>Tehát végrehajtja az aszinkron műveletet</li>
        <li>A loginResponse változóban szinkron formában tudjuk kezelni</li>
      </ul>
    </li>
    <li>A callback function nem engedi meg, hogy bekössük változóba a visszatérési értéket</li>
    <br>
    <li>A loginResponse változónk megléte után szinkron időben tudjuk a választ kezelni</li>
    <pre>
  async function loginAndFetchUsers() &#123;
    // await

    var body = JSON.stringify(&#123; email, password });

    var loginResponse = await fetch('https://reqres.in/api/login', &#123;
        method: 'POST',
        body,
        headers: &#123;
            'Content-type': 'application/json',
            'x-api-key': 'reqres-free-v1'
        }
    });

    console.log('async - await loginResponse: ', loginResponse);

    if (!loginResponse.ok) &#123;
        alert('Bejelentkezés sikertelen (ERROR)');
        return;
    } else &#123;
        alert('Sikeres bejelentkezés (OK)');
    }

    var tokenObj = await loginResponse.json();

    console.log('token: ', tokenObj.token);

    var usersResponse = await fetch('https://reqres.in/api/users', &#123; headers: &#123; 'x-api-key': 'reqres-free-v1' } });

    if (!usersResponse.ok) &#123;
        alert('Nincsenek userek (ERROR)');
        return;
    } else &#123;
        alert('Userek letöltés indul (OK)');
    }

    var usersPage = await usersResponse.json();

    var listOfUsers = document.getElementById('user-list');

    usersPage.data.map(m => &#123;
        console.log(m);
        listOfUsers.innerHTML += `&#60;div>$&#123;m.first_name} $&#123;m.last_name}&#60;/div>`;
    });
  }    
    </pre>
    <img src="assets/imgs/js_async.png" width="100%">
    <br>
  </ul>
</div>

<div>
  <h3 #movieproject data-anchor="movieproject">Movie project</h3>
  <br>
  <ul>
    <li>A keresésre használhatunk
      <ol>
        <li>callback function-t</li>
        <li>Promise-t</li>
        <li>async function-t</li>
      </ol>
      <ul>
        <br>
        <li>Az eredmény minden esetben a 3 megvalósítás alatt jelenik meg</li>
        <br>
      </ul>
      <ol>
        <li>Callback megvalósítás
          <ul>
            <form id="callback-search" class="input-group mt-3 mb-3 search-movie-form">
              <input type="text" aria-label="Field 1" class="form-control" type="search" name="title"
                placeholder="Title" value="vinny">
              <input type="text" aria-label="Field 2" class="form-control" type="number" maxlength="4" name="year"
                placeholder="Year" value="1992">
              <button id="callback-submit" class="btn btn-secondary movie-search-button" type="submit">
                Search
              </button>
            </form>
            <pre>
  var callbackSubmitButton = document.getElementById('callback-search');
  var searchObj = &#123;};
  
  callbackSubmitButton.onsubmit = function (event) &#123;
      event.preventDefault();
  
      searchObj = &#123;
          title: encodeURI(event.target.elements.title.value),
          year: event.target.elements.year.value
      };
  
      fetchData(searchObj.title, searchObj.year, function (error, data) &#123;
          if (error) &#123;
              console.error('Error: ', error);
              document.getElementById('movie-list').textContent = 'Error fetching data';
          } else &#123;
              console.error('Data: ', data); // nincs hiba, csak piros háttérrel írjuk ki a data-t a Console-ba
              console.log(data);
              if (!data.Response) &#123;
                  document.getElementById('movie-list').textContent = JSON.stringify(data.Error, null, 2);
              } else &#123;
                  renderMovies(data.Search);
              }
          }
      });
  };
  
  function fetchData(title, year, callback) &#123;
      const url = `http://www.omdbapi.com/?s=$&#123;title}&y=$&#123;year}&apikey=9606ae0f`;
  
      // fetch(`http://www.omdbapi.com/?s=$&#123;searchObj.title}&y=$&#123;searchObj.year}&apikey=9606ae0f`);
  
      var xhr = new XMLHttpRequest();
      xhr.open("GET", url, true);   // true = aszinkron kérés / false = szinkron kérés
      xhr.onreadystatechange = function () &#123;
          if (xhr.readyState === 4) &#123;    // a kérés befejeződött
              if (xhr.status === 200) &#123;    // a válasz státusza OK
                  var data = JSON.parse(xhr.responseText);
                  callback(null, data);   // function (error, data) &#123; }
              } else &#123;
                  callback(new Error("Error fetching data"));
              }
          }
      };
      xhr.send();
    }
             </pre>
            <li>A fetchData 3. bemeneti paramétere callback function</li>
            <br>
            <img src="assets/imgs/js_movie_callback.png" width="100%">
            <br>
            <br>
          </ul>
        </li>
        <li>Promise megvalósítás
          <ul>
            <form id="promise-search" class="input-group mt-3 mb-3 search-movie-form">
              <input type="search" aria-label="Field 1" class="form-control" name="title" placeholder="Title"
                value="beverly" />
              <input type="text" aria-label="Field 2" type="number" maxlength="4" class="form-control" name="year"
                placeholder="Year" value="2024" />
              <button id="promise-submit" class="btn btn-secondary movie-search-button" type="submit">Search</button>
            </form>
            <pre>
  var promiseSubmitButton = document.getElementById('promise-search');
  var searchObj = &#123;};
  
  promiseSubmitButton.onsubmit = function (event) &#123;
      event.preventDefault();
  
      searchObj = &#123;
          title: encodeURI(event.target.elements.title.value),
          year: event.target.elements.year.value
      };
  
      getData(searchObj.title, searchObj.year)
          .then((data) => &#123;
              renderMovies(data.Search);
          })
          .catch((error) => &#123;
              console.log(error);
          });
  };
  
  function getData(title, year) &#123;
      return new Promise((resolve, reject) => &#123;
          fetch(`http://www.omdbapi.com/?s=$&#123;title}&y=$&#123;year}&apikey=9606ae0f`)
              .then(response => &#123;
                  if (!response.ok) &#123;
                      throw new Error('Network response was not ok');
                  }
                  return response.json();
              })
              .then(data => &#123;
                  resolve(data);
              })
              .catch(error => &#123;
                  reject(error);
              });
      });
    }              
            </pre>
          </ul>
        </li>
        <li> Async megvalósítás
          <ul>
            <div class="main-header">
              <div class="inner">
                <form id="async-movie" class="input-group mt-3 mb-3 search-movie-form">
                  <input type="search" aria-label="Field 1" class="form-control" name="title" placeholder="Title"
                    value="back to the future" />
                  <input type="number" aria-label="Field 2" maxlength="4" class="form-control" name="year"
                    placeholder="Year" value="1989" />
                  <button id="async-submit" class="btn btn-secondary movie-search-button" type="submit">Search</button>
                </form>
              </div>
            </div>
            <pre>
  movieSubmitButton.onsubmit = async (event) => &#123;
    event.preventDefault();

    searchObj = &#123;
        title: encodeURI(event.target.elements.title.value),
        year: event.target.elements.year.value
    };

    if (!searchObj.title || !searchObj.year) &#123;
        alert('Hiányzik a cím, vagy az év!');
        return;
    }

    const response = await fetch(`http://www.omdbapi.com/?s=$&#123;searchObj.title}&y=$&#123;searchObj.year}&apikey=9606ae0f`);
    const movies = await response.json();

    if (movies.Response === 'False') &#123;
        alert(movies.Error);
        return;
    }

    renderMovies(movies.Search);
  };            
            </pre>
          </ul>
        </li>
      </ol>
    </li>
    <div id="movie-list" style="display: flex; gap: 30px; overflow-x: auto; padding-bottom: 15px;"></div>
    <li>A renderMovies függvény
      <ul>
        <pre>
  &#60;div id="movie-list" style="display: flex; gap: 30px; overflow-x: auto; padding-bottom: 15px;">&#60;/div>

  function getMovies() &#123;
        return fetch(`http://www.omdbapi.com/?s=$&#123;searchObj.title&#125;&y=$&#123;searchObj.year&#125;&apikey=9606ae0f`);
  &#125;

  function renderMovies(movies) &#123;
    var list = document.getElementById('movie-list');
    list.innerHTML = '';

    movies.map(m => &#123;
        var hasPoster = (m.Poster !== 'N/A');
        list.innerHTML += `
            &#60;div style="display: grid; width: min-content;">
                &#60;span>
                    $&#123;hasPoster ? `&#60;img src="$&#123;m.Poster}" height="240px" width="162px">` : 
                        `&#60;div style="height:240px; width: 162px; background: gray">&#60;/div>`}
                &#60;/span>
                &#60;span>
                    &#60;a href="https://imdb.com/title/$&#123;m.imdbID}" style="text-decoration: none; font-weight: bold" target="_blank">
                        $&#123;m.Title}
                    &#60;/a>
                    ($&#123;m.Year})
                    &#60;div data-imdbid="$&#123;m.imdbID}" class="movie-info-button" style="text-align: center; cursor: pointer; margin-top: 10px; border-radius: 5px; border: 1px solid grey;">
                        INFO
                    &#60;/div>
                &#60;/span>
            &#60;/div>
        `;
    });

    const clearPostersButton = document.getElementById('clear-posters');

    if (!clearPostersButton) &#123;
        list.insertAdjacentHTML('afterend', `
            &#60;div id="clear-posters" style="text-align: center; padding: 20px;">
                &#60;button style="background: red; border-color: red; box-shadow: none; color: white;">
                    CLEAR
                &#60;/button>
            &#60;/div>
        `);
    }

    document.getElementById('clear-posters').addEventListener('click', () => &#123;
        list.innerHTML = '';
        const clearPostersButton = document.getElementById('clear-posters');
        clearPostersButton.remove();
    });

    const allMovieButtons = document.querySelectorAll('.movie-info-button');
    allMovieButtons.forEach(f => &#123;
        f.onclick = async (event) => &#123;
            var url = `http://www.omdbapi.com/?i=$&#123;event.target.dataset.imdbid}&apiKey=9606ae0f`;

            const movieInfo = await fetch(url);

            if (!movieInfo.ok) &#123;
                alert('Hiba történt!');
                return;
            }

            const movieInfoData = await movieInfo.json();
            console.log(movieInfoData);

            const modalElem = document.createElement('div', &#123; is: "imdb-movie-info-box" });
            modalElem.setAttribute('id', 'imdb-movie-info-box');
            modalElem.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 50%; height: 50%; background: #f5c519; border-radius: 5px; border: 3px solid black; padding: 10px; z-index: 2;';
            document.body.appendChild(modalElem);

            modalElem.innerHTML = `
                &#60;div style="display: grid; grid-gap: 20px;">
                    &#60;div style="display: grid; grid-template-columns: 1fr auto; justify-content: space-between; font-size: 20px; font-weight: bold">
                        &#60;div>IMDB&#60;/div>
                        &#60;div id="close-imdb-movie-info-box" style="cursor: pointer">&#9447;&#60;/div>
                    &#60;/div>
                    &#60;div>$&#123;movieInfoData.Title}&#60;/div>
                    &#60;div style="display: grid; grid-gap: 5px">
                        &#60;span style="display: grid; grid-template-columns: 25px 1fr">
                            &#60;span>&#9202;&#60;/span>
                            &#60;span>$&#123;movieInfoData.Runtime}&#60;/span>
                        &#60;/span>
                        &#60;span style="display: grid; grid-template-columns: 25px 1fr">
                            &#60;span>&#127909;&#60;/span>
                            &#60;span>$&#123;movieInfoData.Genre}&#60;/span>
                        &#60;/span>
                        &#60;span style="display: grid; grid-template-columns: 25px 1fr">
                            &#60;span>&#128197;&#60;/span>
                            &#60;span>$&#123;movieInfoData.Year}&#60;/span>
                        &#60;/span>
                        &#60;span style="display: grid; grid-template-columns: 25px 1fr">
                            &#60;span>&#9733;&#60;/span>
                            &#60;span>$&#123;movieInfoData.imdbRating}&#60;/span>
                        &#60;/span>
                    &#60;/div>
                    &#60;div style="display: grid; grid-gap: 5px">$&#123;movieInfoData.Plot}&#60;/div>
                &#60;/div>
            `;

            const modalOverlayElem = document.createElement('div', &#123; is: "imdb-movie-info-box-overlay" });
            modalOverlayElem.setAttribute('id', 'imdb-movie-info-box-overlay');
            modalOverlayElem.style.cssText = 'position: fixed; top: 0; left: 0; bottom: 0; right:0; background: #000000; opacity: .7; z-index: 1';
            document.body.appendChild(modalOverlayElem);

            document.getElementById('close-imdb-movie-info-box').onclick = (event) => &#123;
                modalElem.remove();
                modalOverlayElem.remove();
            };

            document.getElementById('imdb-movie-info-box-overlay').onclick = (event) => &#123;
                modalElem.remove();
                modalOverlayElem.remove();
            };
        }
    });
  }
          </pre>
      </ul>
  </ul>
</div>

<div>
  <h3 #paradigms data-anchor="paradigms">Paradigms</h3>
  <ul>
    <li>A programozás során felmerölő problémák, szemléletek</li>
    <li>Mindegyik merőben eltérő megközelítést alkalmaz, a maga eszközeivel, előnyeivel, hátrányaival</li>
    <li>3 típusát különböztetjük meg
      <ul>
        <li>Procedurális
          <ul>
            <li>Ez van a legközelebb (a hardverhez) ahhoz, ami valójában történik
              <ul>
                <li>A számítógépnek utasításokat adunk</li>
              </ul>
            </li>
            <li>Legvékonyabb absztrakciós réteg</li>
            <pre>
  var product = &#123;
      name: 'Fűnyíró',
      price: 45000,
      isInStock: true,
  &#125;
            </pre>
            <ul>
              <li>Két operációt fogunk megvalósítani
                <ul>
                  <li>Leértékelés, és üzenet előállítás
                    <ul>
                      <li>Közvetlenül a memóriában módosítást hajtunk végre</li>
                      <pre>
  product.price *= 0.9;
                          </pre>
                      <pre>
  var message = `A termék neve: $&#123;product.name&#125;, ára: $&#123;product.price&#125;
                          és $&#123;product.isInStock ? 'elérhető' : 'nem elérhető'&#125;`
                         </pre>
                      <li>A kód sorrendiségének nagyon nagy szerepe van</li>
                      <li>Nyelvek, amik ilyenek
                        <ul>
                          <li>C</li>
                          <li>Php</li>
                          <li>JavaScript</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </ul>
        </li>
        <br>
        <li>Funkcionális
          <ul>
            <li>A programunkat pure function-ökből építjük fel, tehát side-effekt nélküli függvényekből,
              fekete dobozok, amik valamilyen bemenő értékből generálnak valami kimenő értéket
            </li>
            <li>A rendszer állapotán nem hajt végre változtatást</li>
            <li>Ilyen nyelvek például
              <ul>
                <li>Lisk</li>
                <li>Haskell</li>
                <li>Clojure</li>
                <li>F#</li>
                <li>(JavaScript)</li>
              </ul>
            </li>
            <li>Akár változók használata nélkül, és side-effektek nélkül lehet az egész kódot megírni,
              úgynevezett moládok segítségével
            </li>
            <li>JavaScript-ben pipeline-okat építünk, amik tulajdonképpen pure function-ökből összerakott csővezetékek,
              mint például a Promise chain, vagy az Array method-ok (például map, filter, reduce), ahol higher order
              függvények segítségével egy csővezetéket hozunk létre, amiben az adat átalakul </li>
            <pre>
  function withDiscount(product, discount) &#123;
    return &#123;
      name: product.name,
      price: product.price * discount,
      isInStock: product.isInStock,
    };
  }              
            </pre>
            <li>String-et képez a bemenő termék objektumból</li>
            <li>Az így összeállt "legókockákat" akár össze is építhetjük
              <ul>
                <pre>
  function toMessage(product) &#123;
      return `A termék neve: $&#123;product.name}, ára: $&#123;product.price} és $&#123;product.isInStock ? 'elérhető' : 'nem elérhető'}`
  }

  console.log(toMessage(withDiscount(product, 0.9)));
                </pre>
                <li>A futási időnek nincs akkora szerepe</li>
                <li>Ugyanaz állt elő, mint procedurális szemlélettel</li>
                <li>A sorrendiséget nem lehet felcserélni</li>
                <li>Nem a memóriában változnak az értékek</li>
                <li>A koncepció, hogy kisebb darabokból összeépítesz egy nagyobb egységet</li>
                <li>Az egyes "darabok" / "részegységek" között a kapcsolatot a function-ök típus
                  annotációi teremtik meg</li>
                <li>Nem módosíthatunk értéket, csak a régiből hozhatunk létre újat</li>
              </ul>
            </li>
          </ul>
        </li>
        <br>
        <li>OOP / Objektum orientált
          <ul>
            <li>Jellemző nyelvek
              <ul>
                <li>Java</li>
                <li>C#</li>
                <li>Php</li>
                <li>JavaScript</li>
              </ul>
            </li>
            <li>Az adatokat, és a műveleteket "összezárja" egy kontextusba, tehát az adatot ruházza fel az
              operációkkat
            </li>
            <li>Ez azt jelenti, hogy a product objektumunk nem csak a primitív adatokat tartalmazza, hanem
              egyúttal az ezeken az adatokon dolgozó műveleteket is
            </li>
            <li>Ilyen módon olyan egységeket lehet létrehozni, amik fel vannak ruházva adattal, tehát belső
              állapottal rendelkeznek, és saját maguk ki tudnak számolni ezekből az adatokból értékeket,
              és tudják szolgáltatni
            </li>
            <li>Konvenció szerint nagybetűvel írjuk a változót
              <ul>
                <pre>
  var Product = &#123;
      name: 'Fűnyíró',
      price: 45000,
      isInStock: true,
      applyDiscount: function (discount) &#123; // function (discount) &#123;&#125;
      &#125;
  &#125;
                </pre>
                <li>A megközelítés lényege, hogy ő saját magán belül ki tudja számolni a leértékelést
                </li>
                <li>Az applyDiscount egy olyan függvény, ami vár egy számot, és nem küld vissza semmit
                  <ul>
                    <li>number -> void</li>
                  </ul>
                </li>
                <li>Belső állapotváltozást hoz létre magán belül, és a külvilág felé nem közvetít
                  semmit
                </li>
                <li>A getMessage (lásd lentebb) pedig egy olyan függvény, ami nem vár paramétert, és string-et ad vissza
                  <ul>
                    <li>() -> string</li>
                  </ul>
                </li>
                <li>A két függvény operáció, ami össze van zárva az adattal</li>
                <li>Az adatmezőket az objektum 'property'-jeinek, vagy más névvel 'field'-jeinek, a
                  függvényeket, amik pedig rá vannak csatlakoztatva az adatokra, 'method'-oknak
                  nevezik
                </li>
                <li>A method-ok a 'this' kulcsszóval tudnak dolgozni az adaton
                  <ul>
                    <li>A this kulcsszó mindig az egész objektumra mutat</li>
                    <li>A this kulcsszóval a többi method-hoz is hozzá lehet férni</li>
                  </ul>
                </li>
                <pre>
  applyDiscount: function (discount) &#123; // function (discount) &#123;&#125;
      this.price = this.price * discount;
  &#125;
                </pre>
                <li>Az objektum megváltozik, de mi nem kapunk belőle értéket</li>
                <pre>
  var Product = &#123;
      name: 'Fűnyíró',
      price: 45000,
      isInStock: true,
      applyDiscount: function (discount) &#123; // function (discount) &#123;}
          this.price = this.price * discount;
      },
      getMessage: function () &#123;
          return `A termék neve: $&#123;this.name}, ára: $&#123;this.price} és $&#123;this.isInStock ? 'elérhető' : 'nem elérhető'}`
      }
  }
                </pre>
                <li>Ha használni szeretnénk az objektum methodjait, meg kell őket hívni</li>
                <pre>
  Product.applyDiscount(0.8)
  console.log('getMessage: ', Product.getMessage());

  ↓↓↓↓↓

  "A termék neve: Fűnyíró, ára: 36000 és elérhető"
                </pre>
                <li>A kedvezmény alkalmazása után a termék ára 20%-kal csökkent (*0.8), így az új ár 9800 lesz</li>
                <li>Arrow function-ök ( () => &#123; } ) esetén a this nem a globális vagy objektum kontextusra
                  mutat, hanem a létrehozásukkor érvényes környezetre
                </li>
                <pre>
  <b>// működő</b>

  const product = &#123;
    price: 1000,
    applyDiscount: function(discount) &#123;
      this.price = this.price * discount;
    }
  };
  
  product.applyDiscount(0.9);
  console.log(product.price); // 900

  <b>// nem működő</b>

  const product = &#123;
    price: 1000,
    applyDiscount: (discount) => &#123;
      this.price = this.price * discount; // a this nem a product objektumra mutat
    }
  };
  
  product.applyDiscount(0.9);
  console.log(product.price); // 1000 marad
                </pre>
                <li>Ezért az objektum metódusainál általában hagyományos function definíciót használunk, hogy
                  biztosítsuk a helyes this kontextust</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A JavaScript többparadigmás nyelv, mindhármat támogatja</li>
  </ul>
</div>

<div>
  <h3 #objectdesign data-anchor="objectdesign">Object design</h3>
  <ul>
    <li>Két módon valósítható meg
      <ul>
        <li>1) Constructor function létrehozása
          <ul>
            <li>A JavaScript létrejötte óta elérhető</li>
            <li>Egyszerű mezei függvény, amit koncepció szerint nagybetűvel szokás elnevezni</li>
            <li>A függvény mindig lefut, amikor tervrajz alapján példányosítani akarunk egy új objecktumot,
              tehát hozzájutni egy adatokkal felpopulált egységhez
            </li>
            <li>A konstruktor bemenetként várja azokat az adatokat, amelyek az adott objektumra jellemzőek</li>
            <ul>
              <pre>
  function Termek(name, price, isInStock) &#123;
      this.name = name;
      this.price = price;
      this.isInStock = isInStock;
  &#125;
              </pre>
              <li>A függvényből nem kell this-el return-ölni, a JavaScript automatikusan megcsinálja</li>
              <pre>
   console.log(new Termek('kolbasz', 1000, true));
              </pre>
              <li>Egyszerűvé válik mindenenfajta entitás létrehozása</li>
              <li>A cél, hogy ne csak a property-k egyezzenek meg, hanem az entitások kapcsán definiált
                funkcionalitás/method-ok is
                <ul>
                  <li>A method-okat futás időben lehet rácsatlakoztatni</li>
                  <pre>
  Termek.prototype.applyDiscount = function (discount) &#123;
      this.price = this.price * discount;
  &#125;

  Termek.prototype.getMessage = function () &#123;
      return `A termék neve: $&#123;this.name&#125;, ára: $&#123;this.price&#125; és $&#123;
      this.isInStock ? 'elérhető' : 'nem elérhető'&#125;`;
  &#125;
                   </pre>
                  <li>Ha ugyanabba a kontextusba helyezzük el, mint a Termek() függvényt, akkor a
                    methodnak hozzáférése van a property-khez, tud velük dolozni
                  </li>
                  <pre>
  var termekek = [
      new Termek('kolbasz', 1000, true),
      new Termek('kenyér', 800, true),
      new Termek('hagyma', 300, true),
  ]
                    </pre>
                  <li>Biztosak lehetünk benne, hogy a method-ok minden elemre elérhetők</li>
                  <pre>
  for (var product of termekek) &#123;
      console.log(product.getMessage());
  &#125;
                    </pre>
                  <li>Így minden termék nevét, árát, és elérhetőségét kiírtuk console log-ba
                  </li>
                  <pre>
  new Termek('kolbasz', 1000, true)
                  </pre>
                  <li>Létrehoztunk egy új instance-t, avagy új példányt (instantiation =
                    példányosítás)
                  </li>
                </ul>
              </li>
            </ul>
          </ul>
        </li>
        <br>
        <li>2) Class declaration
          <ul>
            <li>Az ES6 létrejötte óta elérhető</li>
            <li>Szintaktikai könnyítés, de a motorháztető alatt ugyanazt a módszert használja, mint a
              Constructor function
            </li>
            <pre>
  class Termek_ &#123;
      quantity = 1;   // default value

      constructor(name, price, isInStock) &#123;
          this.name = name;
          this.price = price;
          this.isInStock = isInStock;
      &#125;

      applyDiscount(discount) &#123;
          this.price = this.price * discount;
      &#125;

      getMessage() &#123;
          return `A termék neve: $&#123;this.name&#125;, ára: $&#123;this.price&#125; és $&#123;
          this.isInStock ? 'elérhető' : 'nem elérhető'&#125;`;
      &#125;
  &#125;
            </pre>
            <li>Egy kontextusban leírható, amit Constructor function esetében leírtunk</li>
            <li>Nem kell szétválasztani constructor-ra, és egyéb function-ökre</li>
            <li>Baráti az objektum orientált szemléletű fejlesztők számára</li>
            <li>A construtor dedikált megnevezésű függvény</li>
            <li>Ugyanúgy lehet példányosítani</li>
            <pre>
  const paprika = new Termek_('paprika', 600, false);
  console.log(paprika);
            </pre>
            <li>A constructor előtt property-ket is felsorolhatunk
              <ul>
                <li>Futási időben később használható</li>
                <pre>
  paprika.quantity = 3;
                </pre>
                <li>A quantity 1 default érték</li>
              </ul>
            </li>
            <li>A method-ok a constructor alatti függvények
              <ul>
                <li>Nincs szükség a function, és prototype kulcsszóra</li>
                <pre>
  paprika.applyDiscount(0.8);
  console.log('Paprika aktuálisan: ', paprika.getMessage());
                </pre>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A tervrajzok komplexebb egységeket is reprezentálhatnak
      <ul>
        <li>Az Angular, a React, és a Vue előszeretettel használnak class deklarációkat arra, hogy a programnak
          a moduláris felépítését elérjék
        </li>
        <li>Ezekben a rendszerekben tipikusan class deklarációkkal lehet leírni azt, hogy a User Interface-ek
          egyes komponensei hogyan működjenek, hogyan nézzenek ki
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #arrowfunction data-anchor="arrowfunction">Arrow function</h3>
  <br>
  <ul>
    <li>Alternatív függvény deklarálási lehetőség</li>
    <li>Könnyedebb szintaxissal lehet leírni ugyanazt, mint amit a normál függvény deklarációval leírunk</li>
    <li>Csak anonym függvény lehet</li>
    <li>Futási időben lehet létrehozni könnyed függvénykifejezéseket, amelyek változókhoz köthetők, vagy átadhatók
      más függvényeknek
    </li>
    <li>Akkor a leghasználatosabb, amikor egyszerű, könnyed műveletekről (pure műveletekről) van szó
      <ul>
        <pre>
  var addOne = function (szam) &#123;
      return szam + 1;
  &#125;
        </pre>
        <li>Arrow function használatával ez a következőképpen néz ki:</li>
        <pre>
  var addTwo = szam => szam + 2;

  var headers = &#123; 'x-api-key': 'reqres-free-v1' };
        </pre>
        <li>A function és a return szótól is megszabadultunk, de ugyanazt a funkcionalitást értük el</li>
        <li>Promise chain-ben nagyon hasznos
          <ul>
            <pre>
  fetch('https://reqres.in/api/users', &#123; headers })
      .then(function (response) &#123;
          return response.json();
      &#125;).then(function (content) &#123;
      console.log(content)
  &#125;);
            </pre>
            <li>Átláthatóbbá, rövidebbé lehet tenni arrow function használatával</li>
            <pre>
  fetch('https://reqres.in/api/users', &#123; headers })
      .then(response => response.json())
      .then(content => &#123;
          console.log(content)
      &#125;);
            </pre>
            <li>További .then() blokkok ugyanígy leírhatók</li>
            <pre>
  fetch('https://reqres.in/api/users', &#123; headers })
      .then(response => response.json())
      .then(page => page.data[0])
      .then(user => `$&#123;user.first_name&#125; $&#123;user.last_name&#125;`)
      .then(content => &#123;
          console.log(content);
      &#125;);
            </pre>
          </ul>
        </li>
        <li>Az arrow function-nek is lehet body-ja
          <ul>
            <pre>
    ...
    .then((content) => &#123;
        console.log(content);
    &#125;);
    ...
              </pre>
            <li>Body nélküli</li>
            <pre>
    ...
    .then(page => page.data[0])
    ...
            </pre>
            <li>A body-val nem tér vissza automatikusan az értékkel, ehhez szükséges a return kulcsszó</li>
            <pre>
    ...
    .then((content) => &#123;
        console.log(content)
        return content;
    &#125;);
    ...
            </pre>
            <li>Használatos, ha valamilyen kalkulációhoz egy részeredményt létre akarunk hozni, deklarálni
              változóként csak a függvény scope-ján belül
              <ul>
                <pre>
  // ...
  .then(user => &#123;
      const name = `$&#123;user.first_name&#125; $&#123;user.last_name&#125;`;
      return name;
  &#125;)
  // ...
                </pre>
                <li>Arrow function esetében, amennyiben egyetlen egy paramétere van a függvényünknek,
                  úgy nem
                  kötelező kitenni a zárójelet
                </li>
              </ul>
            </li>
            <li>Mi történik akkor, ha arrow function használatakor object-tel szeretnénk return-ölni?
              <ul>
                <li>A &#123;&#125; alkalmas az objektum leírására, viszont jelen esetben megnyitjuk vele a
                  function body-t
                </li>
                <pre>
  fetch("https://reqres.in/api/users", &#123; headers })
      .then(response => response.json())
      .then(page => page.data[0])
      .then(user => &#123;
          const name = `$&#123;user.first_name&#125; $&#123;user.last_name&#125;`;
          return name;
      &#125;)
      .then(name => (&#123;userName: name&#125;))
      .then((content) => &#123;
          console.log(content);
      &#125;);
                </pre>
                <li>Fontos, hogy a name-mel megyünk tovább</li>
              </ul>
            </li>
            <li>Array műveleteknél is hasznát vesszük
              <ul>
                <pre>
  var vegeredmeny = [1, 3, 4, 6, 45, 56]
      .filter(szam => szam % 2 === 0)
      .map(szam => szam / 2)
      .reduce((acc, cr) => acc + cr);
                </pre>
                <li>A filter function-be bedobott függvény is lehet arrow függvény</li>
                <li>A filterrel kiszedjük a tömbből a páros számokat</li>
                <li>A map-pel az összes így kapott páros számot elosztjuk kettővel</li>
                <li>Végül, ha az összegét akarnánk kiszámolni, használhatjuk a reduce function-t
                  <ul>
                    <li>Mindig, amikor érkezik egy szám (acc), azt hozzáadjuk az addig összeadott
                      számokhoz
                    </li>
                    <li>Aggregált értéket hozunk létre
                      <ul>
                        <li>Különböző részekből összegyűjtött</li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #trycatch data-anchor="trycatch">Try/Catch</h3>
  <br>
  <ul>
    <li>Hibakezelés, amivel szinkron futási időben keletkező hibákat lehet lekezelni</li>
    <li>Ahol a hiba történik - legyen ez a Call Stack-en bárhol - ott az egész kód futás megáll, és a Call Stack-en
      a keletkezett hibát elkezdi visszafelé passzolgatni, a hiba elkezd visszafelé propagálódni
    </li>
    <li>Amennyiben a hiba a Call Stack egyik elemében sincs lekezelve, végül visszakerülünk a main-be (legfelsőbb
      futási szintre), és fatális hibára futunk ()
      <ul>
        <li>Uncaught error, azaz senki sem kapta el</li>
      </ul>
    </li>
    <li>Megkapjuk a Stack Trace-t, vagyis, hogy a Call Stack-en hol keletkezett ez a hiba</li>
    <pre>
  try &#123;

  &#125; catch (error) &#123;

  &#125;
    </pre>
    <li>Ezzel a szintaktikával kell körülvenni azt a kódrészletet, amit le akarunk kezelni</li>
    <li>Így a hiba nem propagálódik fel a main-be, hanem a hibát a megfelelő scope-ban megfogjuk</li>
    <li>A catch blockban lévő kód fut le</li>
    <li>A hiba lekezelése után a kód futása folytatódik sorról sorra, ezért nagyon nem mindegy, hova teszünk try/catch
      hibakezelést</li>
    <br>
    <li>Mi történik, ha a hiba aszinkron működéskor keletkezik?
      <ul>
        <li>Mivel a try/catch szinkron hibakezelésre alkalmas, és az aszinkron művelet (például setTimeout())
          sokkal később keletkezik, így nem lehet lekezelni, kifutunk a mainbe
        </li>
        <li>A hiba csakis kizárólag az aszinkron művelet scope-jában kezelhető le</li>
        <pre>
  setTimeout(function() &#123;
      try &#123;
        hiba // hibára fut
      &#125;
      catch (error) &#123;
        console.log(error);
      &#125;
  &#125;, 0);
        </pre>
      </ul>
    </li>
    <li>Mi magunk is generálhatunk hibát
      <ul>
        <pre>
  throw 'Fatális hiba';
        </pre>
        <li>Ilyenkor a catch ág error-jába bekerül a "bedobott" szöveg</li>
        <li>Error object-et is előállíthatunk
          <ul>
            <pre>
  throw new Error('Totális hiba');
            </pre>
            <li>Error objektum példányosítása történik, ami egy message-t vár bemeneti paraméternek</li>
            <li>Az ilyen módú hibára futtatást minden esetben valamilyen feltételhez kell kötni</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A try/catch a program flow-ját nagyon megbonyolíthatja, ha túlzásba visszük, hiszen a kód lineáris futása
      helyett össze-vissza ugráló futást kapunk
    </li>
  </ul>
</div>

<div>
  <h3 #movieticketbooking data-anchor="movieticketbooking">Movie ticket booking</h3>
  <br>
  <div class="theater"
    style="display: grid; gap: 5px; width: 600px; max-width: 100%; height: 700px; background-color: #1e2b37; border-radius: 5px; padding: 10px">
    <div style="text-align: center">
      <select id="movie-select" class="form-select">
        <option value="" disabled selected>Válassz egy filmet</option>
      </select>
    </div>
    <div style="width: 75%;perspective: 1000px;justify-self: center;">
      <div
        style="background-color: aliceblue;height: 70px;width: 100%;margin: 15px 0;transform: rotateX(-45deg);box-shadow: 0 3px 10px rgba(255, 255, 255, 0.75);">
      </div>
    </div>
    <div id="auditorium" class="auditorium" style="min-height: 200px;">
    </div>
    <div>
      <div class="legend">
        <div>Szabad <span></span></div>
        <div>Foglalt <span></span></div>
        <div>Kiválasztva <span></span></div>
      </div>
    </div>
    <div id="user-info" style="text-align: center; color: white">
      Kiválasztottál <span id="seat-number">0</span> széket, aminek a teljes ára <span id="seat-price">0</span>
      forint
    </div>
    <div style="text-align: center;">
      <form id="send-reservation" method="post">
        <input id="person-count" class="form-control mb-3" placeholder="Név">
        <button type="submit" class="btn btn-secondary">Foglalás</button>
      </form>
    </div>
  </div>
  <br>
  <ul>
    <li>Az ES2015-ös verziója óta az objektum megőrzi a sorrendiséget, kivéve, hogy ha valamilyen numerikus kulcs
      fordul elő
    </li>
    <li>Map() class
      <ul>
        <li>Különleges gyűjtemény</li>
        <li>Rendezett objektum</li>
        <li>Példányosításával reprezentálható olyan kulcs-érték párok sorozata, ahol a kulcsok mindig megőrzik
          hozzáadási sorrendjét, pontosan úgy, ahogy beszúrtuk</li>
        <li>Nem számít, hogy a kulcs szám, szöveg vagy akár objektum</li>
      </ul>
    </li>
    <pre>
  const test = new Map();
  test.set("A", 123); // A Map-nek a set() egy method-ja
        </pre>
    <li>Így numerikus érték esetén is megmarad a sorrend</li>
    <pre>
  test.set("A", 123);
  test.set("999", 456); // Mindig a második helyen fog elhelyezkedni
  test.set("B", 789);
    </pre>
    <li>A Map kulcsai sorrendben lesznek, ahogy set()-tel hozzáadjuk őket</li>
    <li>Ha egy kulcsot újra set()-elünk, nem változik a helye, csak az értéke</li>
    <br>
    <table style="border-collapse: collapse; width: 100%;">
      <thead>
        <tr>
          <th></th>
          <th>Objektum (&#123;})</th>
          <th>Map (new Map())</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Kulcs típusa</td>
          <td>String vagy Symbol</td>
          <td>Bármilyen típus (akár objektum is)</td>
        </tr>
        <tr>
          <td>Sorrend</td>
          <td>Számkulcsok növekvően, majd szövegkulcsok beszúrási sorrendben, végül szimbólumok</td>
          <td>Beszúrási sorrend 100%-ban garantált</td>
        </tr>
        <tr>
          <td>Iterálás módja</td>
          <td>for...in, Object.keys(), Object.entries()</td>
          <td>for...of, map.entries(), map.keys()</td>
        </tr>
        <tr>
          <td>Használat célja</td>
          <td>Általános adatstruktúra (kulcs-érték tárolás)</td>
          <td>Kulcs-érték párok sorrenddel, komplex kulcsokkal</td>
        </tr>
        <tr>
          <td>Garancia sorrendre</td>
          <td>Részben, szabvány szerint, de nem abszolút</td>
          <td>Teljesen garantált</td>
        </tr>
      </tbody>
    </table>
  </ul>
</div>

<div>
  <h3 #boxes2 data-anchor="boxes2">Boxes II</h3>
  <app-color-chooser (newColorSelected)="newColorHasBeenSelected($event)"></app-color-chooser>

  <div style="position: relative; width: 100%; height: 500px;">
    <div #box class="box" [ngClass]="isBoxGrabbed ? 'grabbed' : 'not-grabbed'"
      [ngClass]="isBoxGrabbed ? 'grabbed' : 'not-grabbed'" [ngStyle]="{
         'position': 'absolute',
         'left.px': xPosition,
         'top.px': yPosition,
         'border': '1px solid black'
       }" (mousedown)="toggleGrab($event)" (mouseup)="toggleGrab($event)" (mousemove)="isGrabbed($event)">
      <h3 style="text-align: center">grab-it</h3>
    </div>

    <div>{{ isBoxGrabbed }}</div>
    <div>{{ xPosition }}</div>
    <div>{{ yPosition }}</div>

    <app-box [xPosition]="100" [yPosition]="300" [color]="color"></app-box>
    <app-box [xPosition]="150" [yPosition]="400" [color]="color"></app-box>
    <app-box [xPosition]="200" [yPosition]="450" [color]="color"></app-box>
  </div>

</div>