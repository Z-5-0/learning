<h1>Angular</h1>

<div class="anchor-navi-container">
  <div *ngFor="let mainButton of anchorButtons" class="btn-group">
    <button type="button" class="btn btn-primary btn-sm anchor" (click)="scrollToAnchor(mainButton?.anchor)">
      {{ mainButton.title }}
    </button>
    <button *ngIf="mainButton?.subtitles?.length" type="button"
      class="btn btn-primary dropdown-toggle dropdown-toggle-split btn-sm anchor" data-bs-toggle="dropdown"
      aria-expanded="false">
    </button>
    <ul *ngIf="mainButton.subtitles?.length" class="dropdown-menu dropdown-menu-dark">
      <li>
        <button *ngFor="let subButton of mainButton?.subtitles" class="dropdown-item"
          (click)="scrollToAnchor(subButton?.anchor)">
          {{ subButton?.title }}
        </button>
      </li>
    </ul>
  </div>
</div>

<div>
  <h3 #unittest data-anchor="unittest">Unit test</h3>
  <ul>
    <li>Az alkalmazás legkisebb, önállóan tesztelhető egységeinek (pl. komponensek, szolgáltatások, direktívák)
      tesztelését jelenti</li>
    <li>Az Angular különösen támogatja az egységtesztelést a beépített keretrendszerével, mint például a Karma (teszt
      futtató), és a Jasmine (tesztelési keretrendszer)</li>
    <li>Célja
      <ol>
        <li>Kódminőség garantálása</li>
        <li>Idő- és pénzmegtakarítás</li>
      </ol>
    </li>
    <li>A fókusz az egyes egységekre kerül
      <ul>
        <li>Egység alatt értjük például a komponenseket, szolgáltatásokat, pipe-okat vagy direktívákat</li>
        <li>Az egységet a függőségeitől izolálva teszteljük, így a tesztelt kód kizárólag a saját felelősségi körét
          érinti</li>
      </ul>
    </li>
    <li>Kódmódosítások után gyors visszajelzést kapunk arról, hogy nem sértettük-e a meglévő funkciókat</li>
    <li>Az egységtesztek futtatása automatikusan történhet, például CI/CD folyamatban</li>
    <br>
    <li>A unit test-en kívül más tesztek is végrehajthatók
      <ul>
        <li>E2E (End-to-End) tesztelés
          <ul>
            <li>A teljes alkalmazás működésének tesztelése felhasználói szemszögből</li>
            <li>A tesztelés során az alkalmazás fut, és az automatizált tesztek valós felhasználói interakciókat
              szimulálnak, például kattintásokat, űrlapok kitöltését vagy adatbetöltést</li>
            <li>Eszközök
              <ol>
                <li>Protractor</li>
                <li>Cypress</li>
                <li>Playwright</li>
              </ol>
            </li>
          </ul>
        </li>
        <li>Integrációs teszt
          <ul>
            <li>Különböző rendszerek, vagy modulok közötti interakciók tesztelését végzi</li>
            <li>Eszközök
              <ol>
                <li>Jasmine</li>
                <li>Jest</li>
              </ol>
            </li>
          </ul>
        </li>
        <li>Kontakt tesztelés
          <ul>
            <li>A contract tesztelés célja annak biztosítása, hogy az API-k és szolgáltatások pontosan úgy működjenek,
              ahogyan azt a szerződésük előírja</li>
            <li>Eszközök
              <ul>
                <li>Pact</li>
                <li>Spring Cloud Contract</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Smoke tesztelés
          <ul>
            <li>Gyors ellenőrzés, hogy az alapvető, legfontosabb dolgok működnek-e</li>
            <li>Minden új verzió előtt érdemes elvégezni</li>
            <li>Eszközök
              <ol>
                <li>Kézi, manuális tesztelés</li>
                <li>Selenium</li>
                <li>Cypress</li>
              </ol>
            </li>
          </ul>
        </li>
        <li>Teljesítmény tesztelés
          <ul>
            <li>Az alkalmazás sebességének és stabilitásának ellenőrzése a cél</li>
            <li>Eszközök
              <ol>
                <li>JMeter</li>
                <li>Lighthouse</li>
                <li>Artillery</li>
              </ol>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #jasminekarma data-anchor="jasminekarma">Jasmine / Karma</h5>
  <ul>
    <li>Jasmine (tesztelési keretrendszer /framework)
      <ul>
        <li>Népszerű JavaScript tesztelési keretrendszer</li>
        <li>Eszköz, amely a tesztek megírását és az elvárások (assertion) megfogalmazását teszi lehetővé</li>
        <li>Különösen egységtesztelésre használják</li>
        <li>Független a DOM-tól, tehát nem igényel böngészőt a futtatáshoz</li>
        <li>Angular alapértelmezett tesztelési keretrendszere</li>
        <li>A Karma-t használja default test runner-nek</li>
        <li>Alapvető fogalmak
          <ul>
            <li>Spec: Egy teszteset (egy konkrét teszt)
              <ul>
                <pre>
                  describe('Math operations', () => &#123;
                    // Tesztek
                  });
                </pre>
              </ul>
            </li>
            <li>Suite: Egy tesztekből álló csoport, amelyet a describe kulcsszóval definiálunk
              <ul>
                <pre>
                  it('should add two numbers', () => &#123;
                    const result = 1 + 2;
                    expect(result).toBe(3); // Elvárjuk, hogy az eredmény 3 legyen
                  });
                </pre>
              </ul>
            </li>
            <li>Matcher: Az expect állítással kombinált függvény, amely ellenőrzést végez (pl. toBe, toEqual)
              <ul>
                <pre>
                  expect(5).toBe(5);       // Ellenőrzi, hogy az érték megegyezik
                  expect([1, 2]).toEqual([1, 2]); // Ellenőrzi, hogy az objektumok egyenlők
                  expect('hello').toContain('he'); // Ellenőrzi, hogy tartalmazza
                  expect(10).toBeGreaterThan(5);  // Ellenőrzi, hogy nagyobb-e
                </pre>
              </ul>
            </li>
            <li>Spy: Olyan eszköz, amely lehetővé teszi, hogy függvényhívásokat figyeljünk és helyettesítsünk
              <ul>
                <pre>
                  const obj = &#123;
                    getData: () => 'real data',
                  };
                  
                  spyOn(obj, 'getData').and.returnValue('mock data');
                  
                  expect(obj.getData()).toBe('mock data'); // A spy módosította a viselkedést
                  expect(obj.getData).toHaveBeenCalled(); // Ellenőrzi, hogy a függvényt hívták-e                  
                </pre>
              </ul>
            </li>
          </ul>
        </li>
        <li>Támogatja az aszinkron tesztelést
          <ul>
            <pre>
              it('should fetch data asynchronously', async () => &#123;
                const fetchData = () => Promise.resolve('data');
                const data = await fetchData();
                expect(data).toBe('data');
              });
            </pre>
          </ul>
        </li>
      </ul>
    </li>
    <li>Karma (tesztfuttató eszköz / test runner)
      <ul>
        <li>Eszköz, amely felelős a tesztek futtatásáért</li>
        <li>A következőket biztosítja
          <ol>
            <li>Automatizált környezet: Automatikusan elindítja a böngészőket és végrehajtja a teszteket</li>
            <li>Több böngésző támogatása: Teszteket futtathatsz különböző böngészőkben, például Chrome, Firefox, Edge
            </li>
            <li>Tesztelési jelentés: Információt ad a sikertelen tesztekről, valamint statisztikákat a tesztek
              lefutásáról</li>
            <li>Folyamatos integráció: Könnyen integrálható CI/CD eszközökkel, például Jenkins, GitHub Actions vagy
              CircleCI</li>
          </ol>
        </li>
      </ul>
    </li>
    <li>A Jasmine és a karma kéz a kézben járnak
      <ul>
        <li>A Jasmine a tesztek megírására szolgál</li>
        <li>A Karma a tesztek futtatását és jelentéskészítést végzi</li>
      </ul>
    </li>
    <li>A unit testek megírása a spec.ts fájlban történik
      <ul>
        <pre>
          <b>// app.component.spec.ts</b>
          describe('AppComponent', () => &#123;
            beforeEach(async () => &#123;
              await TestBed.configureTestingModule(&#123;
                imports: [RouterTestingModule],
                declarations: [AppComponent],
              }).compileComponents();
            });
          
            it('should create the app', () => &#123;
              const fixture = TestBed.createComponent(AppComponent);
              const app = fixture.componentInstance;
              expect(app).toBeTruthy();
            });
          
            it(`should have as title 'alapok'`, () => &#123;
              const fixture = TestBed.createComponent(AppComponent);
              const app = fixture.componentInstance;
              expect(app.title).toEqual('alapok');
            });
          
            it('should render title', () => &#123;
              const fixture = TestBed.createComponent(AppComponent);
              fixture.detectChanges();
              const compiled = fixture.nativeElement as HTMLElement;
              expect(compiled.querySelector('.content span')?.textContent).toContain('alapok app is running!');
            });
          });
        </pre>
        <li>describe
          <ul>
            <li>Egy Jasmine által biztosított funkció, amely egy tesztcsoportot definiál</li>
            <li>Ebben a blokkban minden, az AppComponent-tel kapcsolatos teszt összegyűlik</li>
            <li>Logikailag összekapcsolja az ugyanahhoz a komponenshez (vagy funkcióhoz) tartozó teszteket</li>
            <li>Két paraméterrel rendelkezik
              <ol>
                <li>'AppComponent': Ez a tesztcsoport neve, az AppComponent tesztelésére utal</li>
                <li>Egy callback függvény, amely tartalmazza a tesztelési logikát</li>
              </ol>
            </li>
          </ul>
        </li>
        <li>beforeEach
          <ul>
            <li>Beállító függvény, amely minden teszteset futtatása előtt végrehajtódik</li>
            <li>A fenti példában Angular TestBed van konfigurálva</li>
          </ul>
        </li>
        <li>TestBed.configureTestingModule()
          <ul>
            <li>Inicializál egy tesztelési környezetet, ahol az AppComponent tesztelhető</li>
            <li>Paraméterként egy objektumot kap
              <ul>
                <li>imports: Az alkalmazáshoz szükséges modulok importálása</li>
                <li>declarations: Azokat a komponenseket deklaráljuk, amelyeket tesztelni szeretnénk</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>RouterTestingModule
          <ul>
            <li>A RouterTestingModule az Angular tesztelési modulja, amelyet a RouterModule tesztelésére terveztek</li>
            <li>Segítségével az alkalmazás navigációját és útvonalait (routing) tudjuk szimulálni, anélkül, hogy valódi
              HTTP-kérések vagy böngészőinterakciók történnének</li>
            <li>A routing funkciók tesztelése nem zavarja az alkalmazás többi részét</li>
            <li>Az alapértelmezett szimulációnál nem szükséges explicit útvonalak megadása, de megadhatunk útvonalakat
              (Routes), hogy teszteljük, megfelelően navigál-e az alkalmazás.</li>
            <pre>
                ...
                beforeEach(async () => &#123;
                  await TestBed.configureTestingModule(&#123;
                    imports: [
                      RouterTestingModule.withRoutes([
                        &#123; path: '', component: HomeComponent },
                        &#123; path: 'about', component: AboutComponent }
                      ])
                    ],
                    declarations: [AppComponent],
                  }).compileComponents();
                });
                ...
              </pre>
            <li>A withRoutes metódus lehetővé teszi, hogy megadjuk az alkalmazás teszteléshez szükséges útvonalait</li>
          </ul>
        </li>
        <li>compileComponents()
          <ul>
            <li>Fordítja és létrehozza a komponenseket, így azok tesztelhetővé válnak</li>
          </ul>
        </li>
        <li>it
          <ul>
            <li>A teszteset definíciója</li>
            <li>Ez határozza meg, hogy mit tesztelünk, azaz hogy mit várunk el a kódtól egy adott feltétel vagy
              szcenárió alapján</li>
            <li>it (1)
              <ul>
                <li>Ellenőrzi, hogy az AppComponent példánya sikeresen létrejön</li>
                <br>
                <li>A TestBed.createComponent(AppComponent) létrehozza az AppComponent tesztpéldányát</li>
                <li>Az app = fixture.componentInstance hozzáfér az AppComponent-hez a teszteléshez</li>
                <li>Az expect(app).toBeTruthy() határozza meg, hogy a komponensnek léteznie kell, különben a teszt
                  elbukik</li>
              </ul>
            </li>
            <li>it (2)
              <ul>
                <li>Ellenőrzi, hogy az AppComponent title property értéke 'alapok'-e</li>
                <br>
                <li>A TestBed.createComponent(AppComponent) létrehozza az AppComponent tesztpéldányát</li>
                <li>Az app = fixture.componentInstance hozzáfér az AppComponent-hez a teszteléshez</li>
                <li>Ellenőrzi a title tulajdonság értékét a expect(app.title).toEqual('alapok') segítségével</li>
              </ul>
            </li>
            <li>it (3)
              <ul>
                <li>Ellenőrzi, hogy az AppComponent HTML-jében megjelenik-e a cím</li>
                <br>
                <li>A TestBed.createComponent(AppComponent) létrehozza az AppComponent tesztpéldányát</li>
                <li>A fixture.detectChanges() lefuttatja az Angular változásdetektálását</li>
                <li>A querySelector kikeresi a .content span elemet</li>
                <li>Az expect(...).toContain(...) ellenőrzi, hogy az elem szövege tartalmazza az elvárt szöveget
                  ('alapok app is running!')</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A tesztet az 'ng test' CLI paranccsal tudjuk lefuttatni
      <ul>
        <li>A Karma elindít egy szervert, és lefuttatja a Jasmine tesztet</li>
        <li>Hot reload mode-ban fut
          <ul>
            <li>Amennyiben változtatunk a spec.ts fájlon, újra lefut a teszt</li>
            <li>Az ng test --no-watch paranccsal nem fog frissülni</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Komponens készítésekor a spec fájl automatikusan létrejön
      <ul>
        <li>Az ng g c *név* --skip-tests megakadályozza a fájl létrehozását</li>
        <li>Ha nem kívánjuk tesztelni a komponenst, le is törölhetjük a fájlt</li>
      </ul>
    </li>
    <li>A megértést érdemes a service-nél kezdeni
      <ul>
        <pre>
          <b>// calc.service.ts</b>
    
          <b>// calc.service.spec.ts</b>
          describe('CalcService', () => &#123; // első paraméter a leírás, ami lehet például a service neve, a második pedig egy anonim függvény, vagy más néven callback függvény
            let calcService: CalcService; // létrehozunk egy példányt a szervizből

            beforeEach(() => &#123;
              TestBed.configureTestingModule(&#123;
                providers: [CalcService] // Ellenőrzi hogy a CalcService megfelelően legyen regisztrálva
              });
              calcService = TestBed.inject(CalcService);
            });

            it('should multiply two numbers', () => &#123; // a teszteset (it) első paraméter a leírás

            });

            it('should multiply', () => &#123;
              const result = calcService.multiply(3, 5);
              expect(result).toBe(15);
            });
          })
        </pre>
        <li>Ha csak unit tesztjét szeretnénk lefuttatni, használhatjuk az fdescribe függvényt
          <ul>
            <li>Focused describe</li>
            <li>Az fdescribe a describe funkciók kiemelésére szolgál, azaz ha egy fdescribe-ot használunk, akkor az
              adott tesztcsoport (describe blokk) lesz az egyedüli, amit futtat a tesztelési környezet, miközben a többi
              describe blokkot figyelmen kívül hagyja</li>
            <li>Ha pedig csak egy kifejezett specifikációt / tesztet futtatnánk le, az it helyett a fit függvényt
              használjuk</li>
          </ul>
        </li>
        <li>Amennyiben ki szeretnénk zármi egy describe függvényt a testből, describe helyett xdescribe-ot használjunk
          <ul>
            <li>Exclude describe</li>
            <li>Ha pedig csak egy kifejezett specifikációt / tesztet zárnánk ki, az it helyett az xit függvényt
              használjuk</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #spy data-anchor="spy">Spy</h5>
  <ul>
    <li>Az Angular tesztelési környezetben a Jasmine tesztelési keretrendszer egy fontos eszköze</li>
    <li>Szintaxisa
      <ul>
        <pre>
          spyOn(object, 'methodName');
        </pre>
        <li>Csak figyelést/ellenőrzést tesz lehetővé ebben a formában</li>
        <li>Ezzel az eredeti függvény (methodName) nem fog lefutni</li>
        <li>A függvénynek maximum a meghívásainak száma, bemeneti paraméterei, és egyáltalán a meghívásának ténye
          figyelhető meg</li>
        <pre>
            spyOn(sharedService, 'sharedFunction').and.returnValue('mocked value');
        </pre>
        <li>Mockolt visszatérési érték</li>
        <li>A függvény egy előre meghatározott értékkel tér vissza, amit a teszt során határozunk meg</li>
      </ul>
    </li>
    <li>Fő használati célok
      <ol>
        <li>Nem akarjuk, hogy az eredeti metódus ténylegesen végrehajtódjon (pl. HTTP requests)</li>
        <li>Ellenőrizni szeretnénk, hogy a metódus meghívódott-e, és ha igen, hányszor, milyen paraméterekkel</li>
      </ol>
    </li>
    <li>Egy objektum metódusát "kémkedés" alá lehet vonni, azaz meg lehet figyelni, hogy meghívták-e, hányszor hívták
      meg, milyen paraméterekkel hívták meg, vagy akár kontrollálni lehet a metódus viselkedését</li>
    <li>Egy adott teszt eset (egy it blokk) részeként is használható, de a tesztkörnyezet előkészítése (beforeEach)
      során is alkalmazhatjuk, ha minden tesztben szükségünk van rá</li>
    <pre>
        <b>// shared.service.ts</b>
        sharedFunction(a?: number, b?: number) &#123; }

        <b>// calc.service.ts</b>
        multiply(a: number, b: number): number &#123;
          let shared = this.sharedService.sharedFunction(a, b); // ha spyOn-t használunk, és nem mock-olunk, akkor a shared értéke undefined lesz
          return a * b;
        }

        <b>// calc.service.spec.ts</b>
        fdescribe('CalcService', () => &#123;
          let calcService: CalcService;
          let sharedService: SharedService;
        
          beforeEach(() => &#123;
            TestBed.configureTestingModule(&#123;
              providers: [CalcService, SharedService] // Ellenőrzi hogy a CalcService megfelelően legyen regisztrálva
            });
            calcService = TestBed.inject(CalcService);
            sharedService = TestBed.inject(SharedService);
          });
        
          it('should be created', () => &#123;
            expect(calcService).toBeTruthy();
          });
        
          it('should multiply', () => &#123;
            const result = calcService.multiply(3, 5);
            expect(result).toBe(15);
          });
        
          it('should call sharedFunction', () => &#123;
            spyOn(sharedService, 'sharedFunction');
            const result = calcService.multiply(3, 5); // a sharedService.sharedFunction()-t is meg lehetne hívni, de a calcService multiply függvénye meghívja
            // expect(sharedService.sharedFunction).toHaveBeenCalled();
            // expect(sharedService.sharedFunction).toHaveBeenCalledTimes(1);
            expect(sharedService.sharedFunction).toHaveBeenCalledWith(3, 5); // más értékekkel: "Expected spy sharedFunction to have been called with: [ 2, 3 ] but actual calls were: [ 3, 5 ]."
          });

          it('should mock return value', () => &#123;
            spyOn(sharedService, 'sharedFunction').and.returnValue('mocked value'); // Mockoljuk a sharedFunction viselkedését, visszatérési értékét; ha nem térne vissza a sharedFunction, nem lenne értelme ennek a sornak
            const result = calcService.multiply(3, 5); // meghívódik a multiply függvényben a SharedService-ben lévő sharedFunction
            expect(sharedService.sharedFunction()).toBe('mocked value'); // ellenőrizzük, hogy a sharedFunction visszatérési értéke 'mocked value'-e
          });
        });
    </pre>
    <li>Ellenőrizhetjük
      <ul>
        <li>...hogy megtörtént-e a függvényhívás</li>
        <pre>
          expect(sharedService.sharedFunction).toHaveBeenCalled();
        </pre>
        <li>...hogy hányszor hívódott meg a függvény</li>
        <pre>
          expect(sharedService.sharedFunction).toHaveBeenCalledTimes(1); // azt várjuk, hogy csak egyszer (1)
        </pre>
        <li>...hogy milyen paraméterekkel hívták meg</li>
        <pre>
          expect(sharedService.sharedFunction).toHaveBeenCalledWith(3, 5); // más értékekkel: "Expected spy sharedFunction to have been called with: [ 2, 3 ] but actual calls were: [ 3, 5 ]."
        </pre>
      </ul>
    </li>
    <li>Mock
      <ul>
        <li>Felülírhatjuk a metódus eredeti működését is
          <ul>
            <li>Izoláltan lehet tesztelni
              <ul>
                <li>A fenti példában nem kell azzal foglalkoznunk, hogy sharedFunction-ben milyen logika szerepel, csak
                  azzal, hogy a multiply hányszor, milyen paraméterekkel, és egyáltalán meghívja-e</li>
              </ul>
            </li>
            <li>A mockolt visszatérési értékkel egyszerűsödik a tesztelés</li>
          </ul>
        </li>
        <li>Ha a multiply belső működése az eredeti sharedFunction viselkedésére támaszkodna, a mocked érték hibás
          eredményt okoz(hat)na</li>
        <li>A függvények teljes implementációját is megváltoztathatjuk
          <ul>
            <li>A callFake függvény segíségével</li>
            <pre>
              spyOn(sharedService, 'sharedFunction').and.callFake((a, b) => &#123;
                return a + b; // custom implementáció
              });
              expect(sharedService.sharedFunction(3, 5)).toBe(8);
            </pre>
          </ul>
        </li>
        <li>A spyOn után mindig 'and' következik, ha módosítani akarjuk a függvény viselkedését</li>
      </ul>
    </li>
    <li>jasmine.createSpyObj
      <ul>
        <pre>
          const sharedService = jasmine.createSpyObj('SharedService', ['sharedFunction']);
        </pre>
        <li>Új példányt hoz létre az objektumból
          <ul>
            <li>spyOn esetében egy meglévő példányt használtunk</li>
          </ul>
        </li>
        <li>Nem ellenőrzésre, hanem teljes mértélű mock-olásra való</li>
        <li>Beállítható visszatérési érték</li>
        <pre>
          let mockService = jasmine.createSpyObj('Service', ['method']);
          mockService.method.and.returnValue('mocked');
        </pre>
      </ul>
    </li>
    <li>throwError
      <ul>
        <li>Hasznos lehet, ha a teszt során azt szeretnénk szimulálni, hogy a függvény hibát dob</li>
        <li>Leellenőrizhetjük, hogy kaptunk-e hibát, és milyen szövegezéssel</li>
        <pre>
          <b>// calc.service.ts</b>
          export class CalcService &#123;
            sharedService: SharedService = inject(SharedService);
          
            constructor() &#123; }
            ...
            multiplyError(a: number, b: number): number &#123;
              if (a &#60; 0 || b &#60; 0) &#123;
                throw new Error('Negative numbers are not allowed');
              }
              return a * b;
            }
          }

          <b>// calc.service.spec.ts</b>
          fdescribe('CalcService', () => &#123;
            ...
            it('should throw error', () => &#123;
              expect(() => calcService.multiplyError(-1, 5)).toThrowError('Negative numbers are not allowed');
            });
          });
        </pre>
      </ul>
    </li>
    <br>
    <table style="border-collapse: collapse; width: 100%;">
      <thead>
        <tr>
          <th style="padding: 8px; text-align: left;">Mockolás Típusa</th>
          <th style="padding: 8px; text-align: left;">Leírás</th>
          <th style="padding: 8px; text-align: left;">Példa</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="padding: 8px;">Csak figyelés (`spyOn`)</td>
          <td style="padding: 8px;">Letiltja az eredeti függvényt, de lehetővé teszi a hívások figyelését</td>
          <td style="padding: 8px;">
            <code>spyOn(sharedService, 'sharedFunction');</code><br>
            <code>expect(sharedService.sharedFunction).toHaveBeenCalled();</code>
          </td>
        </tr>
        <tr>
          <td style="padding: 8px;">Mockolt visszatérési érték</td>
          <td style="padding: 8px;">A függvény egy előre meghatározott értékkel tér vissza</td>
          <td style="padding: 8px;">
            <code>spyOn(sharedService, 'sharedFunction').and.returnValue('mocked value');</code><br>
            <code>expect(sharedService.sharedFunction()).toBe('mocked value');</code>
          </td>
        </tr>
        <tr>
          <td style="padding: 8px;">Mockolt viselkedés (hiba dobása)</td>
          <td style="padding: 8px;">A függvény dobjon egy hibát, hogy tesztelhesd a hibakezelést</td>
          <td style="padding: 8px;">
            <code>spyOn(sharedService, 'sharedFunction').and.throwError('Mocked error');</code><br>
            <code>expect(() => calcService.multiply(3, 5)).toThrowError('Mocked error');</code>
          </td>
        </tr>
        <tr>
          <td style="padding: 8px;">Teljes mock implementáció</td>
          <td style="padding: 8px;">A függvényt egyedi logikával helyettesíti</td>
          <td style="padding: 8px;">
            <code>spyOn(sharedService, 'sharedFunction').and.callFake((a, b) => a + b);</code><br>
            <code>expect(sharedService.sharedFunction(3, 5)).toBe(8);</code>
          </td>
        </tr>
      </tbody>
    </table>
  </ul>
  <br>
  <h5 #testbed data-anchor="testbed">TestBed</h5>
  <ul>
    <li>A beforeEach blokkban van
      <ul>
        <li>Minden egyes teszt (it) előtt lefut</li>
        <li>Kiváló hely arra, hogy ne az egyes it specifikációban / tesztesetben példányosítsuk a szervizeket</li>
        <li>Minden it specifikáció blokkban le fog futni az itt lévő kód</li>
      </ul>
    </li>
    <li>Az it blokkokban alapvetően példányosítani kellene a szervizeket
      <ul>
        <li>Rengeteg duplikált kódot eredményezne</li>
        <pre>
          it('should multiply', () => &#123;
            const shared = new SharedService();
            const calc = new CalcService(shared); // az argomentum azt feltételezi, hogy a CalcService konstuktorában ShardService DI történt  
            ...
          });
          it('should add', () => &#123;
            const shared = new SharedService();
            const calc = new CalcService(shared); // az argomentum azt feltételezi, hogy a CalcService konstuktorában ShardService DI történt  
            ...
          });
        </pre>
        <li>A kódismétlés elkerülése érdekében érdemes az olyan közös részeket, mint a SharedService és CalcService
          példányosítása, és a beforeEach blokkon belül elhelyezni</li>
        <li>A különböző tesztek a közös beállításokat újrahasználhatják</li>
        <pre>
          describe('CalcService', () => &#123;
            let calcService: CalcService;
            let sharedService: SharedService;
          
            beforeEach(() => &#123;
              sharedService = new SharedService();
              calcService = new CalcService(sharedService);// az argomentum azt feltételezi, hogy a CalcService konstuktorában ShardService DI történt
            });
          });
        </pre>
        <li>Ha új példányát hoznánk létre az osztálynak, és a CalcService konstruktorán keresztük injektáltuk volna a
          SharedService-t, akkor lenne szükség rá, hogy az új osztály argomentumában megadjuk a SharedService-t
          <ul>
            <li>Egyébként nem</li>
            <pre>
              new CalcService();
            </pre>
          </ul>
        </li>
        <li>Ezzel a kóddal tettünk egy lépést előre, nem duplikáljuk a kódott, de manuálisan készítjük el a példányokat
          minden specifikáció (it) előtt
          <ul>
            <li>Itt jött el az idő, hogy az Angular Testbed utility-ját használjuk</li>
          </ul>
        </li>
        <pre>
          beforeEach(() => &#123;
            TestBed.configureTestingModule(&#123;
              providers: [CalcService, SharedService] // elérhetővé tesszük a SharedService-t a környezetben
            });
            calcService = TestBed.inject(CalcService);
            sharedService = TestBed.inject(SharedService);
          });
        </pre>
        <li>TestBed.configureTestingModule()
          <ul>
            <li>Objektumot fogad</li>
            <li>Ugyanazokat a kulcsokat (beállítási lehetőségeket) fogadja, mint egy NgModule
              <ul>
                <li>imports, declarations, providers...</li>
              </ul>
            </li>
            <li>Itt konfiguráljuk a tesztelési környezetet</li>
            <li>A providers tömbben regisztráljuk a szolgáltatásokat, amelyeket a tesztelni kívánt osztályok igényelnek
            </li>
          </ul>
        </li>
        <li>TestBed.inject()
          <ul>
            <li>Az inject() metódus segítségével hívjuk meg a SharedService és a CalcService példányokat a teszt során
            </li>
            <li>Nem manuálisan használtuk a service-eket, hanem Dependency Injection-t használtunk</li>
          </ul>
        </li>
        <li>A TestBed tehát egy teszt környezetet hoz létre az Angular alkalmazás szintjén, amely a szokásos modul
          beállításokkal hasonlít a normál Angular alkalmazásokhoz</li>
        <li>A tesztelés során a TestBed a függőségek megfelelő injektálásáért és inicializálásáért felelős, éppen úgy,
          mint az alkalmazásban az NgModule</li>
        <li>A providers tömböt a configureTestingModule objektumban csak az alábbi esetekben szükséges használni
          <ul>
            <li>Ha a SharedService egyedi viselkedést igényel a tesztben, például egy mock implementációt szeretnénk
              használni
              <ul>
                <pre>
                  TestBed.configureTestingModule(&#123;
                    providers: [
                      &#123; provide: SharedService, useClass: MockSharedService } // egyedi implementáció
                    ]
                  });

                  export class MockSharedService &#123;
                    sharedFunction(a: number, b: number): string &#123;
                      return '42'; // teszthez készített, egyedi logika
                    }
                  }
                </pre>
                <li>Ezzel azt mondjuk meg, hogy bár a SharedService class alapján kérjük a szolgáltatást, valójában egy
                  másik service egy példányát fogunk használni a tesztnél</li>
              </ul>
            </li>
            <li>A szolgáltatás nem része az alkalmazásod globális DI környezetének</li>
            <li>A szolgáltatás nincs @Injectable dekorátorral regisztrálva</li>
            <li>Ha minden teszthez külön példányokat szeretnénk használni a szolgáltatásokból</li>
          </ul>
        </li>
        <pre>
          fdescribe('CalcService', () => &#123;
            ...
            const mockSharedService = &#123;
              sharedFunction: (a: number, b: number) => '42' // mock-olt logika
            };
            beforeEach(() => &#123;
              TestBed.configureTestingModule(&#123;
                // providers: [] // Ellenőrzi hogy a CalcService megfelelően legyen regisztrálva
                providers: [
                  &#123; provider: SharedService, useValue: mockSharedService }
                ]
                /* providers: [ // ez is ugyanaz a megoldás
                  &#123;
                    provide: SharedService, useValue: &#123;
                      sharedFunction: (a: number, b: number) => '42'
                    }
                  }
                ] */
              });
            });
          });
        </pre>
        <li>useValue esetében egy konkrét objektumot vagy értéket adunk meg, amelyet az Angular DI rendszer közvetlenül
          használ az adott szolgáltatás helyettesítésére
          <ul>
            <li>A useClass osztály vár, a useValue értéket</li>
          </ul>
        </li>
        <pre>
          fdescribe('CalcService', () => &#123;
            let calcService: CalcService;
            let sharedService: SharedService;
          
            const mockSharedService = &#123;
              sharedFunction: (a: number, b: number) => '42'
            };
          
            beforeEach(() => &#123;
              TestBed.configureTestingModule(&#123;
                providers: [
                  &#123; provide: SharedService, useValue: mockSharedService }
                ]
              });
              calcService = TestBed.inject(CalcService);
              sharedService = TestBed.inject(SharedService);
            });
          });

          ...

          it('should mock return value', () => &#123;
            spyOn(sharedService, 'sharedFunction').and.returnValue('mocked value'); // Mockoljuk a sharedFunction viselkedését
            const result = calcService.multiply(3, 5); // meghívódik a multiply függvényben a SharedService-ben lévő sharedFunction
            expect(sharedService.sharedFunction()).toBe('mocked value'); // ellenőrizzük, hogy a sharedFunction visszatérési értéke 'mocked value'-e
          });

          it('should still return original value - 42', () => &#123;
            expect(sharedService.sharedFunction()).toBe('42'); // OK, mert a spyOn csak egy előző it-ben volt érvényes
          });
        </pre>
        <li>A fenti példa magyarázata
          <ul>
            <li>beforeEach
              <ul>
                <li>A SharedService helyett a mockSharedService objektumot regisztráljuk</li>
                <li>Amikor az Angular DI (TestBed.inject) a SharedService-t kéri, az a mockSharedService példányt adja
                  vissza</li>
                <li>A mockSharedService definíciójában a sharedFunction metódus mindig 42-t ad vissza</li>
              </ul>
            </li>
            <li>spyOn
              <ul>
                <li>A sharedService-ben (ami most a mockSharedService-re mutat) a sharedFunction metódus eredeti
                  implementációját (ami '42'-t ad vissza) felülírjuk a spyOn segítségével</li>
                <li>Az utasítás után a sharedFunction metódus már mindig a 'mocked value' értéket adja vissza,
                  függetlenül az eredeti implementációtól.</li>
                <li>Az it specifikációban elhelyezett spyOn csak az adott specifikációra terjed ki, hiszen a beforeEach
                  minden it előtt lefut</li>
              </ul>
            </li>
            <li>Az utolsó it is hiba nélkül lefut, mert ebben a specifikációban egy mock példányunk van, ami fixen egy
              stringet ad vissza, ami 42</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #testinghttpservice data-anchor="testinghttpservice">Testing HTTP service</h5>
  <ul>
    <li>A tesztelés során általában nem kívánunk valóban HTTP kérést intézni
      <ul>
        <pre>
          <b>// data.service.ts</b>
          @Injectable(&#123;
            providedIn: 'root'
          })
          export class DataService &#123;
            http: HttpClient = inject(HttpClient);
          
            constructor() &#123; }
          
            getAllUsers() &#123;
              return this.http.get('https://jsonplaceholder.typicode.com/users');
            }
          }
      
          <b>// data.service.spec.ts</b>
          fdescribe('DataService', () => &#123;
            let service: DataService;
            let httpClient: HttpClient;
          
            beforeEach(() => &#123;
              TestBed.configureTestingModule(&#123;
                imports: [HttpClientModule]
              });
              service = TestBed.inject(DataService);
              httpClient = TestBed.inject(HttpClient);
            });
          
            it('should be created', () => &#123;
              expect(service).toBeTruthy();
            });
          
            it('should get all users', (done) => &#123;
              service.getAllUsers().subscribe(users => &#123;
                expect(users).toBeTruthy();  // ellenőrizzük, hogy az adatokat megkapjuk
                done();  // az aszinkron teszt befejezéséhez szükséges
              });
            });
          });
        </pre>
        <li>Ebben a példakódban megtörténik a test lefuttatásakor a get request
          <ul>
            <li>A done() callback használata biztosítja, hogy a teszt csak akkor fejeződik be, amikor a hálózati válasz
              megérkezett</li>
            <li>Érdemes lehet teszteket izolálni a valódi HTTP-hívásoktól</li>
          </ul>
        </li>
        <pre>
          <b>// data.service.ts</b>
          export class DataService &#123;
            http: HttpClient = inject(HttpClient);
          
            constructor() &#123; }
          
            getAllUsers() &#123;
              return this.http.get('https://jsonplaceholder.typicode.com/users');
            }
          
            getUserByID(id: number) &#123;
              return this.http.get(`https://jsonplaceholder.typicode.com/users/$&#123;id}`);
            }

            updateUser(id: number, user: any) &#123;
              return this.http.put(`https://jsonplaceholder.typicode.com/users/$&#123;id}`, user);
            }
          }

          <b>// data.service.spec.ts</b>
          fdescribe('DataService', () => &#123;
            let service: DataService;
            let httpTestingController: HttpTestingController;
          
            beforeEach(() => &#123;
              TestBed.configureTestingModule(&#123;
                imports: [HttpClientTestingModule]
              });
              service = TestBed.inject(DataService);
              httpTestingController = TestBed.inject(HttpTestingController);
            });
          
            afterEach(() => &#123;
              httpTestingController.verify(); // ellenőrizzük, hogy minden HTTP kérés kezelve lett
            });
          
            it('should be created', () => &#123;
              expect(service).toBeTruthy(); // ellenőrzi, hogy létrejött-e a DataService-ből példány
            });
          
            it('should get all users', (done) => &#123;
              const mockUsers = [
                &#123; id: 1, name: 'John Doe' },
                &#123; id: 2, name: 'Jane Doe' },
                &#123; id: 3, name: 'Harry Potter' }
              ];
          
              service.getAllUsers().subscribe((users: any) => &#123;
                const thirdUser = users.find((user: any) => user.id === 3);
          
                expect(users).toBeTruthy();  // ellenőrizzük, hogy az adatokat valóban megkapjuk
                expect(users.length).toBe(3);  // ellenőrizzük, hogy 3 felhasználót kaptunk-e
                expect(thirdUser.name).toBe('Harry Potter'); // ellenőrizzük, hogy a 3-mas ID-val rendelkező user neve Harry Potter-e
          
                done(); // az aszinkron teszt befejezéséhez szükséges
              });
          
              const mockRequest = httpTestingController.expectOne('https://jsonplaceholder.typicode.com/users'); // szimuláljuk a HTTP GET kérést és annak válaszát
              expect(mockRequest.request.method).toBe('GET'); // ellenőrizzük a HTTP request metódust
              mockRequest.flush(mockUsers); // szimulált adatok visszaküldése a service számára
            });
          
            it('should get one user by ID', (done) => &#123;
              const mockUser = &#123; id: 3, name: 'Harry Potter' };
          
              service.getUserByID(3).subscribe((user: any) => &#123;
                expect(user).toBeTruthy();
                expect(user.name).toEqual('Harry Potter');
                done();
              });
          
              const mockRequest = httpTestingController.expectOne('https://jsonplaceholder.typicode.com/users/3');
              expect(mockRequest.request.method).toBe('GET');
              mockRequest.flush(mockUser);
            });

            it('should update one user by ID', (done) => &#123;
              const mockUser = &#123; id: 3, name: 'Tom Denem' };
              const mockUserChange = &#123; name: 'Tom Denem' };
          
              service.updateUser(3, mockUserChange).subscribe((user: any) => &#123;
                console.log(user);
                expect(user.id).toBe(3);
                done();
              });
          
              const mockRequest = httpTestingController.expectOne('https://jsonplaceholder.typicode.com/users/3');
              expect(mockRequest.request.method).toBe('PUT');
              expect(mockRequest.request.body).toBe(mockUserChange);
              mockRequest.flush(mockUser);
            });
          });
        </pre>
        <li>A kód átírásával nem történik valódi HTTP request
          <ul>
            <li>TestBed.inject
              <ul>
                <li>Létrehozza a DataService és a HttpTestingController példányát</li>
              </ul>
            </li>
            <li>HttpClientTestingModule
              <ul>
                <li>Helyettesíti a valódi HTTP kommunikációt egy tesztelési környezetben, így nem történik valódi
                  HTTP kapcsolat</li>
              </ul>
            </li>
            <li>HttpTestingController
              <ul>
                <li>Class, ami lehetővé teszi, hogy szimuláljunk és manipuláljunk HTTP kéréseket a tesztkörnyezetben
                </li>
              </ul>
            </li>
            <li>afterEach
              <ul>
                <li>Minden specifikáció lefutása után végrehajtódik a venne lévő logika</li>
                <li>A httpTestingController.verify() függvénnyel ellenőrizzük, hogy minden HTTP kérés le lett-e kezelve
                </li>
              </ul>
            </li>
            <li>'should get all users'
              <ul>
                <li>Aszinkron teszt, amely ellenőrzi, hogy a getAllUsers metódus helyesen viselkedik-e</li>
                <li>A mockUsers a felhasználók lekérésének a szimulált response-a</li>
                <li>A httpTestingController.expectOne('https://jsonplaceholder.typicode.com/users') megfog egy HTTP
                  kérést
                  <ul>
                    <li>Több kérés küldése esetén hibát kapunk</li>
                    <li>Lehetővé teszi, hogy a teszt szimulált válaszokat küldjön erre a kérésre</li>
                  </ul>
                </li>
                <li>A flush metódus a mockRequest által elfogott kérésre szimulált választ küld vissza</li>
              </ul>
            </li>
            <li>done()
              <ul>
                <li>Mivel a teszt aszinkron, a Jasmine-nak meg kell várnia a done hívását, hogy tudja, a teszt
                  befejeződött</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Ha a mockRequest.request.body és a mockUserChange két külön objektum, az toBe hibát dob, mert azok nem
          azonos memóriacímen találhatók, még akkor sem, ha a tartalmuk ugyanaz
          <ul>
            <li>Ezért hibás az egyik, míg a másik nem</li>
            <pre>
              const mockUserChange = &#123; name: 'Tom Denem' };

              expect(mockRequest.request.body).toBe(&#123; name: 'Tom Denem' }); // failure
              expect(mockRequest.request.body).toBe(mockUserChange); // success
            </pre>
            <li>A toBe metódus referencia-azonosságot ellenőriz (ugyanaz az objektum-e), és mivel a két objektum
              különböző memóriacímen van, hibát dob</li>
            <li>Ha két különböző objektum tartalma megegyezik, csak a toEqual fogja őket egyenlőnek tekinteni, mivel az
              mély összehasonlítást végez</li>
          </ul>
        </li>
        <li>A működés röviden
          <ul>
            <li>A getAllUsers metódusban a HttpClient egy GET kérést küld az adott URL-re</li>
            <li>A HttpTestingController elfogja a kérést, és nem engedi ki a tényleges hálózatra</li>
            <li>A flush által megadott adatokat "válaszként" küldi vissza a HttpClient-nek</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #componenttesting data-anchor="componenttesting">Component</h5>
  <ul>
    <li>Az Angular alapértelmezetten csak egy spec-et hoz létre, mégpedig azt, hogy a komponens sikeresen létrejött</li>
    <pre>
      <b>// hometest.component.spec.ts</b>
      fdescribe('HometestComponent', () => &#123;
        let component: HometestComponent;
        let fixture: ComponentFixture&#60;HometestComponent>;
      
        beforeEach(() => &#123;
          TestBed.configureTestingModule(&#123;
            declarations: [HometestComponent]
          });
          fixture = TestBed.createComponent(HometestComponent);
          component = fixture.componentInstance;
          fixture.detectChanges();
        });
      
        it('should create', () => &#123; // ez az egy teszt az alapértelmezés
          expect(component).toBeTruthy();
        });
      });
    </pre>
    <pre>
          let fixture: ComponentFixture&#60;HometestComponent>;
    </pre>
    <li>A ComponentFixture az Angular tesztelési keretrendszerében használt segédobjektum
      <ul>
        <li>Lehetőséget nyújt a komponenspéldány (componentInstance) elérésére</li>
        <li>Lehetőséget a DOM manipulálására és ellenőrzésére</li>
        <li>Lehetőséget az Angular életciklus eseményeinek vezérlésére (pl. detectChanges segítségével)</li>
      </ul>
    </li>
    <pre>
          fixture = TestBed.createComponent(HometestComponent);
    </pre>
    <li>Létrehozza a HometestComponent tesztpéldányát, és ezt a példányt a fixture változó kezeli</li>
    <li>A fixture tartalmazza az egész tesztkomponenst, a sablonnal (HTML) és a TypeScript osztállyal együtt</li>
    <pre>
      component = fixture.componentInstance;
    </pre>
    <li>A componentInstance-szel van hozzáfárásünk a teszkomponenshez</li>
    <li>Tartalmazza a komponens referenciáját</li>
    <li>A component-en keresztül meghívhatóak a a komponens metódusai, ellenőrizhetőek és módosíthatók a változói</li>
    <pre>
      fixture.detectChanges();
    </pre>
    <li>Angular teljes adatkötési folyamatát lefuttatja, beleértve az összes lifecycle hookot</li>
    <li>A tesztkörnyezetben a komponens sablonja renderelődik a DOM-ban, azonban nem jelenik meg a böngészőben, csak a
      tesztkörnyezetben érhető el a fixture.nativeElement vagy fixture.debugElement segítségével</li>
    <br>
    <li>Elterjedt, best practice megközelítés a tesztelés során async függvényt adni a beforeEach-nek
      <ul>
        <li>Az első beforeEach callback függvényét aszinkronná tesszük, és megvárjuk, amíg a a compileComponents()
          befejeződik, és csak az után lépünk tovább a tesztben
          <ul>
            <li>A compileComponents() Promise-szal tér vissza</li>
            <pre>
              (method) TestBed.compileComponents(): Promise&#60;any>
            </pre>
          </ul>
        </li>
        <li>A másodk beforeEach szinkron</li>
        <li>Natív JavaScript async/await-et használunk</li>
        <li>Átláthatóbb, jobban kezelhető kódot kapunk, ha szétbontjuk a beforeEach függvényt, de nem kötelező</li>
        <pre>
          beforeEach(async () => &#123;
            await TestBed.configureTestingModule(&#123;
              declarations: [HometestComponent]
            })
              .compileComponents();
          });
        
          beforeEach(() => &#123;
            fixture = TestBed.createComponent(HometestComponent);
            component = fixture.componentInstance;
            fixture.detectChanges();
          });

          // így is teljesen rendben van
          beforeEach(async () => &#123;
            await TestBed.configureTestingModule(&#123;
              declarations: [HometestComponent]
            })
              .compileComponents();

            fixture = TestBed.createComponent(HometestComponent);
            component = fixture.componentInstance;
            fixture.detectChanges();
          });
        </pre>
      </ul>
    </li>
    <li>Egy másik megoldás lehet a waitForAsync használata
      <ul>
        <li>Angular által biztosított helper, amely lehetővé teszi az aszinkron műveletek kezelését a tesztekben,
          anélkül hogy explicit done() callback-et kellene használni</li>
        <li>Csak akkor működik, ha waitForAsync függvénybe csomagoljuk a kódot, ellenkező esetben then-t használva hibát
          kapunk a teszt során</li>
        <li>Használata a modern Angular appokban nem szerencsés</li>
        <pre>
            beforeEach(waitForAsync(
              () => &#123;
                TestBed.configureTestingModule(&#123;
                  declarations: [HometestComponent]
                }).compileComponents().then(
                  () => &#123;
                    fixture = TestBed.createComponent(HometestComponent);
                    component = fixture.componentInstance;
                    fixture.detectChanges();
                  }
                );
              }));
        </pre>
      </ul>
    </li>
    <li>debugElement
      <ul>
        <li>Angular-specifikus objektum</li>
        <li>A DOM manipulációk, és a komponensek mélyebb vizsgálatára ad lehetőséget</li>
        <li>A natív DOM, és Angular metainformációik is elérhetők</li>
        <li>query() és queryAll() metódusokkal kereshetünk meg elemeket</li>
        <pre>
          const button = fixture.debugElement.query(By.css('button'));
        </pre>
        <li>triggerEventHandler()-rel lehetővé teszi események (pl. kattintás) szimulálását</li>
        <pre>
          const element = fixture.debugElement.query(By.css('div'));
          expect(element.attributes['id']).toBe('myId');
        </pre>
        <li>Ellenőrizhetőek az elem attribútumai, osztályai vagy direktívái</li>
        <pre>
          fdescribe('HometestComponent', () => &#123;
            ...
            let debugElement: DebugElement;

            ...

            beforeEach(() => &#123;
              ...
              debugElement = fixture.debugElement;
            });

            it('should have a paragraph in the template', () => &#123;
              let paragraphs = debugElement.queryAll(By.css('p')); // array-jal tér vissza
              expect(paragraphs.length).toBeGreaterThan(0);
            });

            it('should have fixed text first paragraph', () => &#123;
              let paragraphs = debugElement.queryAll(By.css('p'));
              expect(paragraphs[0].nativeElement.textContent).toBe('This is a test home component'); // megnézzük, hogy az elem szövege a várt-e
            });

            it('should have first button disabled attribute', () => &#123;
              let buttonElements = debugElement.queryAll(By.css('.btn'));
              expect(buttonElements[0].nativeElement.disabled).toBeTrue(); // megnézzük, hogy van-e disabled attribútuma a gombnak
            });

            it('should have fixed source first image', () => &#123;
              let imageElements = debugElement.queryAll(By.css('img'));
              expect(imageElements[0].nativeElement.src).toBe('https://placehold.co/300x200'); // megnézzük, hogy megfelelő-e a source-a az első képnek
            });

            it('should have fixed string interpolation of title', () => &#123;
              component.title = 'Hi';
              fixture.detectChanges();
              let titleElements = debugElement.queryAll(By.css('.title'));
              expect(titleElements[0].nativeElement.textContent).toBe('Hi');
            });
          })
        </pre>
        <li>A debugElement segítségével megkeressük a számunkra releváns elemet, vagy elemeket
          <ul>
            <li>QueryAll esetében az eredmény egy tömb lesz</li>
            <li>Dinamikus elemek esetében (pl. string interpoláció) a komponenst a fixture.componentInstance-en
              keresztül elérjük, és közvetlen módosíthatjuk a változóit (pl. component.title)
              <ul>
                <li>Viszont az érték csak a change detection mechanizmus manuális lefuttatása után változik meg</li>
                <li>Lehet, hogy adatbázisból érkezik a dinamikus adat, így fixáljuk, hogy mit szeretnénk látni</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A component logolva az alábbi
      <ul>
        <pre>
          component: HometestComponent &#123;
            title: 'Hi',
            __ngContext__: 0
          }
        </pre>
        <li>title: A komponens title nevű tulajdonsága, amelynek értéke 'Hi'</li>
        <li>__ngContext__: Az Angular belső kontextusreferenciája, amely a komponenshez tartozó környezetet azonosítja
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #dominteraction data-anchor="dominteraction">DOM interaction</h5>
  <ul>
    <pre>
      <b>// hometest.component.html</b>
      &#60;p>This is a test home component&#60;/p>

      &#60;button class="btn btn-danger" disabled>Submit&#60;/button>

      &#60;img src="https://placehold.co/300x200">

      &#60;h3 class="title">&#123; &#123; title }}&#60;/h3>

      &#60;button class="btn btn-primary subscribe" (click)="subscribe()" [disabled]="isSubscribed">&#123; &#123; subscribeText }}&#60;/button>

      &#60;button *ngIf="!isSubscribed" class="conditional-sub" (click)="subscribe()">Subscribe&#60;/button>
      &#60;button *ngIf="isSubscribed" class="conditional-sub" disabled>Subscribed&#60;/button>

      &#60;router-outlet>&#60;/router-outlet>

      <b>// hometest.component.ts</b>
      export class HometestComponent &#123;
        title: string = 'This is the title of home page';

        subscribeText: string = 'Subscribe';
        isSubscribed: boolean = false;

        subscribe() &#123;
          this.isSubscribed = true;
          this.subscribeText = 'Subscribed';
        }
      }
    </pre>
    <li>Ahhoz, hogy a router-outlet miatt ne legyen hibánk, a spec fájl TestBed.configureTestingModule függvényének
      objektum argomentumának import kulcsa alatt a tömbben deklarálni szükséges a RouterTestingModule-t</li>
    <li>A funkcionalitás teszteléséhez hozzá kell férnünk a DOM elemekhez
      <pre>
        fdescribe('HometestComponent', () => &#123;
          let component: HometestComponent;
          let fixture: ComponentFixture&#60;HometestComponent>;
          let debugElement: DebugElement;

          beforeEach(async () => &#123;
            await TestBed.configureTestingModule(&#123;
              declarations: [HometestComponent],
              imports: [RouterTestingModule]
            })
              .compileComponents();
          });
        
          beforeEach(() => &#123;
            fixture = TestBed.createComponent(HometestComponent);
            component = fixture.componentInstance;
            debugElement = fixture.debugElement;
            fixture.detectChanges();
          });

          it('should have button with the text Subscribe', () => &#123;
            let buttonElements = debugElement.queryAll(By.css('.subscribe'));
            component.isSubscribed = false;
            component.subscribeText = 'Subscribe'; // a determinálhatóság érdekében gyakran explicit módon állítjuk be a property-ket, hogy garantáltan a tesztkörnyezet kívánt állapotát teszteljük
            fixture.detectChanges();
            expect(buttonElements[0].nativeElement.textContent).toBe('Subscribe');
            expect(buttonElements[0].nativeElement.disabled).toBeFalse();
            // expect(component.isSubscribed).toBeFalse();
          });
        
          it('should have button with the text Subscribed and a disabled attribute (WRONG)', () =>  &#123; // DOM interakciót nem tesztelünk, így nem ez a megfelelő mód
            let buttonElements = debugElement.queryAll(By.css('.subscribe'));
            component.isSubscribed = true;
            component.subscribeText = 'Subscribed';
            fixture.detectChanges();
            expect(buttonElements[0].nativeElement.textContent).toBe('Subscribed');
            expect(buttonElements[0].nativeElement.disabled).toBeTrue();
          });
        
          it('should have button with the text Subscribed and a disabled attribute (RIGHT)', () => &#123; // DOM interakció teszt
            let buttonElements = debugElement.queryAll(By.css('.subscribe'));
            component.subscribeText = 'Subscribe';
            component.isSubscribed = false;
            buttonElements[0].nativeElement.click(); // az eventeknek a change detection előtt kell szerepelniük
            fixture.detectChanges();
            expect(buttonElements[0].nativeElement.textContent).toBe('Subscribed');
            expect(buttonElements[0].nativeElement.disabled).toBeTrue;
          });

          it('should have a conditional button when not subscribed', () => &#123;
            component.isSubscribed = false; // Kezdeti állapot
            fixture.detectChanges(); // DOM frissítése
        
            let buttonElements = debugElement.queryAll(By.css('.conditional-sub')); // *ngIf="!isSubscribed"
            expect(buttonElements.length).toBe(1); // csak egy gomb jelenhet meg
            expect(buttonElements[0].nativeElement.textContent).toBe('Subscribe'); // a gomb szövegének itt még Subcribe-nak kell lennie
            expect(buttonElements[0].nativeElement.disabled).toBeFalse(); // ellenőrizzük, hogy a gomb nem tiltott
        
            buttonElements[0].triggerEventHandler('click', null); // meghívja a (click)="subscribe()" metódust -> isSubscribed = true
            // buttonElements[0].nativeElement.click(); // ez is működik
            fixture.detectChanges(); // újrarenderelés / lefutnak a lifecycle hookok
        
            buttonElements = debugElement.queryAll(By.css('.conditional-sub')); // *ngIf="isSubscribed" / nem frissül automatikusan, az újrarenderelés után újra le kell kérdezni
            expect(buttonElements.length).toBe(1); // csak egy gomb jelenhet meg
            expect(buttonElements[0].nativeElement.textContent).toBe('Subscribed'); // a gomb szövege immáron Subcribe
            expect(buttonElements[0].nativeElement.disabled).toBeTrue(); // a gomb legyen disabled
          });
        
          it('should have a conditional button when subscribed', () => &#123;
            component.isSubscribed = true; // Kezdeti állapot
            fixture.detectChanges(); // DOM frissítése
        
            let buttonElements = debugElement.queryAll(By.css('.conditional-sub')); // a length 1, hiszen true az érték, így csak a *ngIf="isSubscribed" fog megjelenni
            expect(buttonElements.length).toBe(1); // csak egy gomb jelenhet meg
            expect(buttonElements[0].nativeElement.textContent).toBe('Subscribed');
            expect(buttonElements[0].nativeElement.disabled).toBeTrue(); // a gomb legyen disabled
          });
        });
      </pre>
    </li>
    <li>Az Angular tesztelési keretrendszerében a DOM események (pl. kattintás) szimulálásához a triggerEventHandler
      metódust kell használni
      <ul>
        <li>A nativeElement.click() is abszolút jók működik</li>
      </ul>
    </li>
    <li>Minden állapotváltozás után szükséges lefuttatni a detectChanges() metódust, hogy a DOM frissüljön az új állapot
      alapján</li>
    <li>Az esemény hatására a DOM újrarenderelődik, ezért újra le kell kérdezni a buttonElements változót az aktuális
      állapot alapján</li>
    <li>Ha bővül a tesztek száma, érdemes helper függvényeket használni</li>
  </ul>
  <br>
  <h5 #asynchronoustest data-anchor="asynchronoustest">Asynchronous test</h5>
  <ul>
    <pre>
      <b>// hometest.component.html</b>
      ...
      &#60;button *ngIf="!isApiSubscribed" class="conditional-sub-api" (click)="apiSubcribe()">Subscribe&#60;/button>
      &#60;button *ngIf="isApiSubscribed" class="conditional-sub-api" disabled>Subscribed&#60;/button>

      <b>// hometest.component.ts</b>
      export class HometestComponent &#123;
        ...
        apiSubscribeText: string = 'Subscribe';
        isApiSubscribed: boolean = false;
      
        apiSubcribe() &#123;
          setTimeout(()=>&#123;
            this.isApiSubscribed = true;
            this.apiSubscribeText = 'Subscribe';
          }, 3000);
        }
      }
    </pre>
    <li>Adatbázisból jövő adat esetében némi idő is eltelhet, amíg az értékek felveszik végső formájukat</li>
    <li>A default timeout ideje a Jasmine-nak 5 másodperc
      <ul>
        <li>Amennyiben ennyi idő alatt nem érkezik meg a kívánt adat, a teszt failed állapotba kerül</li>
      </ul>
    </li>
    <li>Az aszinkron adatok kezelésére a Jasmine biztosít számunkra egy függvényt
      <ul>
        <li>done: DoneFn</li>
        <li>DoneFn típusú</li>
        <li>Az async adatok megérkezéséről értesítenünk kell a Jasmine-t
          <ul>
            <li>Ehhez a done() függvényt hívjuk meg</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A legtöbb esetben nincs tudomásunk arról, hogy mennyi idő, amíg megkapjuk a választ
      <ul>
        <li>Annak ellenére, hogy ez a megközelítés működik, nem feltétlenül kényelmes, főleg bonyolultabb
          komponensekben, ahol több aszinkron műveletet hajtunk végre</li>
      </ul>
    </li>
    <pre>
      <b>// hometest.componnt.spec.ts</b>
      ...
      it('should have a conditional button when not subscribed (simulating API / 3s delay)', (done: DoneFn) => &#123;
        component.isApiSubscribed = false; // Kezdeti állapot
        fixture.detectChanges(); // DOM frissítése
    
        let buttonElements = debugElement.queryAll(By.css('.conditional-sub-api')); // *ngIf="!isApiSubscribed"
        expect(buttonElements.length).toBe(1); // csak egy gomb jelenhet meg
        expect(buttonElements[0].nativeElement.textContent).toBe('Subscribe'); // a gomb szövegének itt még Subcribe-nak kell lennie
        expect(buttonElements[0].nativeElement.disabled).toBeFalse(); // ellenőrizzük, hogy a gomb nem tiltott
    
        buttonElements[0].triggerEventHandler('click', null); // meghívja a (click)="apiSubscribe()" metódust -> isApiSubscribed = true
        // buttonElements[0].nativeElement.click(); // ez is működik
    
        setTimeout(() => &#123;
          fixture.detectChanges(); // újrarenderelés / lefutnak a lifecycle hookok
          buttonElements = debugElement.queryAll(By.css('.conditional-sub-api')); // *ngIf="isApiSubscribed" / nem frissül automatikusan, az újrarenderelés után újra le kell kérdezni
          expect(buttonElements.length).toBe(1); // csak egy gomb jelenhet meg
          expect(buttonElements[0].nativeElement.textContent).toBe('Subscribed'); // a gomb szövege immáron Subcribe
          expect(buttonElements[0].nativeElement.disabled).toBeTrue(); // a gomb legyen disabled
          done();
        }, 3000);
      });
      ...
    </pre>
    <li>Egy másik megközelítés lehet a fakeAsync függvény használata
      <ul>
        <li>A fakeAsync lehetővé teszi, hogy manuálisan szimuláljuk az idő múlását a tick segítségével</li>
        <li>A tick(3000) azt jelenti, hogy előreugrunk 3000 milliszekundumot, szimulálva a setTimeout befejeződését</li>
        <li>Minden jelentős esemény után frissíteni kell a DOM-ot, hogy az Angular lifecycle hookjai lefussanak</li>
      </ul>
    </li>
    <li>Sajnos még mindig hardcoded az idő múlása, pedig a valóságban nem tudjuk előre, mikor érkezik meg a válasz</li>
    <pre>
      <b>// hometest.component.spec.ts</b>
      ...
      it('should have a conditional button when not subscribed (simulating API / 3s delay)', fakeAsync(() => &#123;
        component.isApiSubscribed = false; // Kezdeti állapot
        fixture.detectChanges(); // DOM frissítése
    
        let buttonElements = debugElement.queryAll(By.css('.conditional-sub-api')); // *ngIf="!isApiSubscribed"
        expect(buttonElements.length).toBe(1); // csak egy gomb jelenhet meg
        expect(buttonElements[0].nativeElement.textContent).toBe('Subscribe'); // a gomb szövegének itt még Subcribe-nak kell lennie
        expect(buttonElements[0].nativeElement.disabled).toBeFalse(); // ellenőrizzük, hogy a gomb nem tiltott
    
        buttonElements[0].triggerEventHandler('click', null); // meghívja a (click)="apiSubscribe()" metódust -> isApiSubscribed = true
        // buttonElements[0].nativeElement.click(); // ez is működik
        tick(3000); // előre léptetjük az időt
        fixture.detectChanges(); // újrarenderelés / lefutnak a lifecycle hookok
    
        buttonElements = debugElement.queryAll(By.css('.conditional-sub-api')); // *ngIf="isApiSubscribed" / nem frissül automatikusan, az újrarenderelés után újra le kell kérdezni
        expect(buttonElements.length).toBe(1); // csak egy gomb jelenhet meg
        expect(buttonElements[0].nativeElement.textContent).toBe('Subscribed'); // a gomb szövege immáron Subcribe
        expect(buttonElements[0].nativeElement.disabled).toBeTrue(); // a gomb legyen disabled
      }));
      ...
    </pre>
    <li>Ezen a ponton jön képbe a flush() függvény
      <ul>
        <li>Az Angular tesztkörnyezetében az összes időzített aszinkron eseményt (pl. setTimeout, setInterval) azonnal
          végrehajtja, függetlenül attól, hogy milyen késleltetés van beállítva
          <ul>
            <li>Különbözik a tick()-től, amely csak a megadott időt lépteti előre</li>
          </ul>
        </li>
      </ul>
    </li>
    <pre>
      <b>// hometest.component.spec.ts</b>
      ...
      it('should have a conditional button when not subscribed (simulating API / 3s delay)', fakeAsync(() => &#123;
        component.isApiSubscribed = false; // Kezdeti állapot
        fixture.detectChanges(); // DOM frissítése
    
        let buttonElements = debugElement.queryAll(By.css('.conditional-sub-api')); // *ngIf="!isApiSubscribed"
        expect(buttonElements.length).toBe(1); // csak egy gomb jelenhet meg
        expect(buttonElements[0].nativeElement.textContent).toBe('Subscribe'); // a gomb szövegének itt még Subcribe-nak kell lennie
        expect(buttonElements[0].nativeElement.disabled).toBeFalse(); // ellenőrizzük, hogy a gomb nem tiltott
    
        buttonElements[0].triggerEventHandler('click', null); // meghívja a (click)="apiSubscribe()" metódust -> isApiSubscribed = true
        // buttonElements[0].nativeElement.click(); // ez is működik
        flush();
    
        fixture.detectChanges(); // az összes async művelet végrehajtása után újrarenderelés
    
        buttonElements = debugElement.queryAll(By.css('.conditional-sub-api')); // *ngIf="isApiSubscribed" / nem frissül automatikusan, az újrarenderelés után újra le kell kérdezni
        expect(buttonElements.length).toBe(1); // csak egy gomb jelenhet meg
        expect(buttonElements[0].nativeElement.textContent).toBe('Subscribed'); // a gomb szövege immáron Subcribe
        expect(buttonElements[0].nativeElement.disabled).toBeTrue(); // a gomb legyen disabled
      }));
      ...
    </pre>
  </ul>
  <br>
  <h5 #promiseandobservable data-anchor="promiseandobservable">Promise and Observable</h5>
  <ul>
    <li>A Promise mindig a setTimeout előtt jajtódik végre
      <ul>
        <li>A microtask a setTimeout pedig makrotask</li>
        <li>A makrotaskok után futnak le a queue-ban a mikrotaskok</li>
      </ul>
    </li>
    <pre>
      ...
      it('should test a promise', fakeAsync(() => &#123;
        let counter = 0;
    
        setTimeout(() => &#123;
          counter = counter + 3
        }, 2000)
    
        Promise.resolve().then(() => &#123;
          counter++;
        });
    
        flush();
    
        expect(counter).toBe(4);
      }));
    
      it('should test another promise', async () => &#123; // ez a megoldás is helyes
        let counter = 0;
    
        await Promise.resolve().then(() => &#123;
          counter++;
        });
    
        expect(counter).toBe(1);
      });
    
      it('should test a promise using done callback', (done) => &#123; // szintén success
        let counter = 0;
        Promise.resolve().then(() => &#123;
          counter++;
          expect(counter).toBe(1); // a counter értéke helyesen frissült
          done(); // jelezzük a Jasmine-nak, hogy az aszinkron teszt befejeződött
        });
      });
      ...
    </pre>
    <li>Observable esetén az of egy szinkron RxJS operátor, amely azonnal kibocsátja a megadott értéket, majd befejezi
      az Observable-t
    </li>
    <li>Az of által létrehozott Observable szinkron módon működik, a .subscribe() metódus azonnal lefut, és a next
      callback végrehajtódik (szinkron)</li>
    <li>A next callback a isSubscribed változó értékét true-ra állítja</li>
    <li>Az expect már a frissített értéket ellenőrzi, hiszen minden szinkron módon történik</li>
    <li>Egy Promise mindig aszinkron, így a then callback a következő eseményciklusban fut le, az of által létrehozott
      Observable ezzel szemben szinkron alapértelmezés szerint, így a callback már a teszt futása közben végrehajtódik
    </li>
  </ul>
  <pre>
    ...
    it('should test an observable', () => &#123;
      let isSubscribed = false;
  
      let myObservable = of(isSubscribed); // szinkron observable
      myObservable.subscribe(&#123;
        next: () => isSubscribed = true
      });
  
      expect(isSubscribed).toBeTrue;
    });
    ...
  </pre>
  <li>Aszinkron Observable-t is tudunk kezelni
    <ul>
      <li>A fakeAsync wrapper szükséges ahhoz, hogy az Angular tesztkörnyezetében kontrollálhassuk az aszinkron
        folyamatokat</li>
      <li>Az of egy szinkron Observable-t hoz létre, amely azonnal kibocsátja a isSubscribed változó aktuális értékét
      </li>
      <li>A delay operátor aszinkronná teszi az Observable-t azáltal, hogy a kibocsátást 1 másodperces késleltetéssel
        végzi el, ami azt jelenti, hogy a next callback csak 1 másodperccel később fut le</li>
      <li>Az Observable subscribe-ja még azelőtt lefut, hogy az of által kibocsátott érték ténylegesen megérkezne, mert
        a delay(1000) 1 másodperccel késlelteti a next eseményt</li>
      <li>Az Angular tesztkörnyezetében az időzítéseket (pl. setTimeout, delay, stb.) szimulálhatod a fakeAsync és a
        tick segítségével</li>
      <li>A tick végrehajtása után a subscribe callback fut le, és isSubscribed = true lesz</li>
    </ul>
  </li>
  <pre>
    it('should test an async observable', fakeAsync(() => &#123;
      let isSubscribed = false;
  
      let myObservable = of(isSubscribed).pipe(delay(1000)); // ez így már aszinkron Observable
      myObservable.subscribe(&#123;
        next: () => isSubscribed = true
      });
  
      tick(1000); // a delay miatt szükséges egy egy másodperces előre ugrás
  
      expect(isSubscribed).toBeTrue();
    }));
  </pre>
  <br>
  <h5 #testingpipes data-anchor="testingpipes">Pipes</h5>
  <ul>
    <li></li>
    <pre>
      <b>// hometest.compomnent.html</b>
      ...
      &#60;div *ngFor="let mark of marks">&#123; &#123; mark | grade }}&#60;/div>

      <b>// hometest.compomnent.ts</b>
      ...
      marks: number[] = [83, 26, 53, 84, 34];
      ...

      <b>// grade.pipe.ts</b>
      export class GradePipe implements PipeTransform &#123;
        transform(value: any, ...args: any[]) &#123;
            let grade = '';
    
            if (value >= 90) &#123;
                grade = 'A';
            } else if (value < 90 && value >= 80) &#123;
                grade = 'B';
            } else if (value < 80 && value >= 70) &#123;
                grade = 'C';
            } else if (value < 70 && value >= 60) &#123;
                grade = 'D';
            } else if (value < 60 && value >= 35) &#123;
                grade = 'E';
            } else if (value < 35) &#123;
                grade = 'F';
            }
    
            return grade;
        }
      }

      <b>// hometest.component.spec.ts</b>
      fdescribe('HometestComponent', () => &#123;
        let component: HometestComponent;
        let fixture: ComponentFixture&#60;HometestComponent>;
        let debugElement: DebugElement;

        beforeEach(async () => &#123;
          await TestBed.configureTestingModule(&#123;
            declarations: [HometestComponent, GradePipe],
            imports: [RouterTestingModule]
          })
            .compileComponents();
        });
      
        beforeEach(() => &#123;
          fixture = TestBed.createComponent(HometestComponent);
          component = fixture.componentInstance;
          debugElement = fixture.debugElement;
          fixture.detectChanges();
        });

        it('should create', () => &#123;
          expect(component).toBeTruthy();
        });
        ...
      });

      <b>// grade.pipe.spec.ts</b>
      fdescribe('GradePipe', () => &#123;// ez jön létre alapértelemzetten
        it('create an instance', () => &#123;
            const pipe = new GradePipe();
            expect(pipe).toBeTruthy();
        });
      })
    </pre>
    <li>A GradePipe-ot használjuk annak érdekében, hogy a mark-okat grade-dé alakítsuk
      <ul>
        <li>Deklarálni kell a komponens spec.ts fájljában annak érdekében, hogy ne legyen failed a teszt</li>
        <li>Azért szükséges, mert az Angular tesztelés során minden komponenst és függőséget, beleértve a pipe-okat is,
          explicit módon regisztrálni kell a TestBed konfigurációban</li>
      </ul>
    </li>
    <pre>
      fdescribe('GradePipe', () => &#123;
        it('create an instance', () => &#123;
            const pipe = new GradePipe();
            expect(pipe).toBeTruthy();
        });
    
        it('should assign A when the mark is at least 90', () => &#123;
            const pipe = new GradePipe();
            let grade = pipe.transform(93);
            expect(grade).toBe('A');
        });
    
        it('should assign A when the mark is between 80 and 90', () => &#123;
            const pipe = new GradePipe();
            let grade = pipe.transform(85);
            expect(grade).toBe('B');
        });
    })
    </pre>
  </ul>
  <br>
  <h5 #testingdirectives data-anchor="testingdirectives">Directives</h5>
  <ul>
    <li></li>
    <pre>
      <b>// hometest.component.html</b>
      &#60;div *ngFor="let mark of marks" [mark]="mark" appGrade>&#123; &#123; mark | grade }}&#60;/div>

      <b>// hometest.component.ts</b>
      ...
      marks: number[] = [83, 26, 53, 84, 34];
      ...

      <b>// grade.directive.ts</b>
      @Directive(&#123;
        selector: '[grade]'
      })
      
      export class GradeDirective &#123;
          @Input() mark: number = 0;
      
          @HostListener('mouseenter') onMouseEnter() &#123;
              if (this.mark >= 90) &#123;
                  this.el.nativeElement.style.color = 'green';
              } else if (this.mark < 90 && this.mark >= 35) &#123;
                  this.el.nativeElement.style.color = 'yellow';
              } else if (this.mark < 35) &#123;
                  this.el.nativeElement.style.color = 'red';
              }
          }
      
          @HostListener('mouseleave') onMouseLeave() &#123;
              this.el.nativeElement.style.color = 'black';
          }
      
          constructor(private el: ElementRef) &#123; }
      }

      <b>// grade.directive.spec.ts</b>
      /* describe('GradeDirective', () => &#123; // alapból ennyi jön létre, de a dependencia miatt ki kell egészítenünk, hogy ne kapjunk hibát
        it('should be created', () => &#123;
            const directive = new GradeDirective();
            expect(GradeDirective).toBeTruthy();
        }) */

      describe('GradeDirective', () => &#123; // alapból ennyi jön létre, de a dependencia miatt ki kell egészítenünk, hogy ne kapjunk hibát
      it('should be created', () => &#123;
          let mockElRef = &#123;
            nativeElement: document.createElement('div')
          };
          const directive = new GradeDirective(mockElRef);
          expect(GradeDirective).toBeTruthy();
      })
    });
    </pre>
    <li>Elhelyeztük az iterált div-en az appGrade direktívát, és a direktíva input property-je megkapja az éppen
      aktuális értéket</li>
    <li>HostListener segítségével, amíg rajta állunk az aktuális div-en, megváltoztatjuk a szövegezés színét a mark
      értékétől függően
      <ol>
        <li>Zöld: A mark legalább 90</li>
        <li>Sárga: A mark értéke legalább 35, és legfeljebb 89</li>
        <li>Piros: A mark kevesebb, mint 35</li>
      </ol>
    </li>
    <li>A GradeDirective-et természetesen ez esetben is deklarálnunk szükséges a hometest.component.spec.html fájlban
    </li>
    <pre>
      beforeEach(async () => &#123;
        await TestBed.configureTestingModule(&#123;
          declarations: [HometestComponent, GradePipe, GradeDirective],
          imports: [RouterTestingModule]
        })
          .compileComponents();
      });
    </pre>
    <li>Minden komponenst, direktívát, és pipe-ot explicit módon deklarálni kell a tesztmodulban, mert ezek nem részei
      automatikusan a teszt környezetnek
      <ul>
        <li>Ez alól a direktívák sem kivételek</li>
        <li>Ha nem deklaráljuk a direktívát a TestBed.configureTestingModule-ben, az Angular nem fogja felismerni, hogy
          a GradeDirective kezel egy bizonyos attribútumot (mark).</li>
      </ul>
    </li>
    <li>A direktíva spec fájljában egy mock objektumot hozunk létre
      <ul>
        <li>egy nativeElement nevű tulajdonságot adunk az objektumhoz, amely egy új &#60;div> HTML elemet tartalmaz, és
          ez szimulálja a DOM elemet, amelyre a direktívát alkalmazni szeretnénk</li>
        <li>Létrejön egy GradeDirective példány, amely a mockElRef-re alkalmazza a direktívát</li>
      </ul>
    </li>
    <pre>
      <b>// grade.directive.spec.ts</b>
      ...
      it('should change color on mouse over', () => &#123;
        let divs = debugElement.queryAll(By.css('div'));
        divs[0].triggerEventHandler('mouseenter', null);
        divs[1].triggerEventHandler('mouseenter', null);
        divs[2].triggerEventHandler('mouseenter', null);
        divs[3].triggerEventHandler('mouseenter', null);
        divs[4].triggerEventHandler('mouseenter', null);
        fixture.detectChanges();
        expect(divs[0].nativeElement.style.color).toBe('yellow'); // 83
        expect(divs[1].nativeElement.style.color).toBe('red'); // 26
        expect(divs[2].nativeElement.style.color).toBe('yellow'); // 53
        expect(divs[3].nativeElement.style.color).toBe('yellow'); //84
        expect(divs[4].nativeElement.style.color).toBe('red'); // 34
    });
    ...
    </pre>
  </ul>
  <br>
  <h5 #testingrouting data-anchor="testingrouting">Routing</h5>
  <ul>
    <li>Különösen akkor hasznos, ha dinamikus útvonalakat használ az app, vagy ha guard-okkal és resolver-ekkel
      dolgozunk</li>
    <pre>
      <b>// hometest.component.html</b>
      &#60;a [routerLink]="[/infotest]">Info&#60;/a>
      &#60;router-outlet>&#60;/router-outlet>

      <b>// infotest.component.html</b>
      &#60;a [routerLink]="[/hometest]">Go back&#60;/a>

      <b>// tests-routing.module.ts</b> // itt most egy fájl a module, és a routing, az egyszerűség kedvéért
        export const routes: Routes = [ // nagyon fontos exportálni a route-okat, a spec fájlban szükségünk lesz rá
            &#123; path: '', redirectTo: '/hometest', pathMatch: 'full' },
            &#123; path: 'hometest', component: HometestComponent },
            &#123; path: 'infotest', component: InfotestComponent }
        ];

        @NgModule(&#123;
            declarations: [
                HometestComponent,
                InfotestComponent,
                GradePipe,
                GradeDirective
            ],
            imports: [
                RouterModule.forChild(routes)
            ]
        })

        export class TestsModule &#123; }
    </pre>
    <li>A komponenseket, pipe-ot, direktívát elérhetővé kell tenni a teszt során</li>
    <li>A RouterTestingModule.withRoutes(routes) importálása biztosítja, hogy az Angular router működjön a tesztben, és
      a routes konfigurációban megadott útvonalak elérhetők legyenek</li>
    <li>A router.initialNavigation() elindítja az inicializálást a teszt során, hogy biztosítsuk, hogy a router
      készen áll a navigációra</li>
    <li>Az await router.navigate(['']) kód a router-t arra utasítja, hogy navigáljon az üres útvonalra (''), ami
      átirányítást tartalmaz a /hometest útvonalra, Tehát a navigálás után az alkalmazásnak át kell irányítania a
      felhasználót a /hometest-re</li>
    <li>Amikor a whenStable() Promise teljesül, akkor biztosak lehetünk benne, hogy az alkalmazás stabil állapotban van,
      és az UI változások vagy navigációk végbementek</li>
    <li>A default path-re való navigálás tesztje így lefut hiba nélkül</li>
    <li></li>
    <pre>
      <b>// testing-routing.module.spec.ts</b>
      fdescribe('TestsRouting', () => &#123;
        let router: Router;
        let location: Location;
        let fixture: ComponentFixture&#60;HometestComponent>;
        let fixtureInfo: ComponentFixture&#60;InfotestComponent>;
        let debugElement: DebugElement;
    
        beforeEach(async () => &#123;
            await TestBed.configureTestingModule(&#123;
                declarations: [HometestComponent, InfotestComponent, GradePipe, GradeDirective],
                imports: [RouterTestingModule.withRoutes(routes)]
            })
                .compileComponents();
        });
    
        beforeEach(() => &#123;
            router = TestBed.inject(Router);
            location = TestBed.inject(Location);
            fixture = TestBed.createComponent(HometestComponent);
            fixtureInfo = TestBed.createComponent(InfotestComponent);
            debugElement = fixture.debugElement;
            router.initialNavigation();
        });
    
        it('should navigate to default path - home', async () => &#123;
            fixture.detectChanges();
            await router.navigate(['']); // kézzel navigálunk az üres útvonalra, ami redirect-el a /hometest-re
            await fixture.whenStable(); // Promise
            expect(location.path()).toBe('/hometest');
        });
    
        it('should navigate to info by clicking /info routerLink"', async () => &#123;
            fixture.detectChanges();
            let links = debugElement.queryAll(By.css('a'));
            // links[0].triggerEventHandler('click', null); // hibára fut - Cannot read properties of null (reading 'button')
            links[0].nativeElement.click();
            await fixture.whenStable(); // then blokk is használható, de nem szükséges, mert folytatódik a futás, miután megvártuk a Promise-t
            expect(location.path()).toBe('/infotest');
        });
    
        it('should navigate back to home by clicking /home routerLink"', waitForAsync(() => &#123; // régebbi szintaktika
            fixtureInfo.detectChanges();
            let buttons = debugElement.queryAll(By.css('button'));
            buttons[0].triggerEventHandler('click', null); // gombon már működik a triggerEventHandler
            fixtureInfo.whenStable().then(() => &#123; // így biztosítható, hogy a Promise
                expect(location.path()).toBe('/hometest'); // a promise itt már sikeresen befejeződött
            });
        }));
    })
    </pre>
  </ul>
  <br>
  <h5 #codecoverage data-anchor="codecoverage">Code coverage</h5>
  <ul>
    <li>Kódlefedettség</li>
    <li>Test coverage-nek is hívják</li>
    <li>A tesztelés egyik fontos mérőszáma, amely megmutatja, hogy a kódunk hány százalékát teszteljük a tesztjeinkkel
    </li>
    <li>Típusai
      <ol>
        <li>Line Coverage (Sorlefedettség)
          <ul>
            <li>Leggyakoribb kódlefedettség típus</li>
            <li>Megmutatja, hogy a kód hány sorát futtattuk a tesztelés során</li>
            <li>Ha egy sor elérhető, akkor azt "lefedettnek" tekintjük</li>
          </ul>
        </li>
        <li>Branch Coverage (Elágazáslefedettség)
          <ul>
            <li>Méri, hogy a kódban lévő elágazásokat (pl. if, else, switch, stb.) lefedtük-e a tesztjeinkben</li>
          </ul>
        </li>
        <li>Function Coverage (Függvénylefedettség)
          <ul>
            <li>Azt mutatja, hogy a kódban lévő függvények hány százalékát hívtuk meg a tesztelés során</li>
          </ul>
        </li>
        <li>Condition Coverage (Feltétellefedettség)
          <ul>
            <li>A kód minden egyes feltételének lehetséges kimeneteit (pl. if feltételek) teszteli</li>
            <li>Mélyebb szintű tesztelési forma</li>
          </ul>
        </li>
        <li>Path Coverage (Útvonal-lefedettség)
          <ul>
            <li>Az útvonal-lefedettség a kódban lévő összes lehetséges útvonal lefedettségét jelenti</li>
          </ul>
        </li>
      </ol>
    </li>
    <li>A 100%-os kódlefedettség nem jelenti azt, hogy a kód hibamentes, mivel a tesztek nem feltétlenül vizsgálják meg
      a kód minden lehetséges hibáját vagy hibás viselkedését</li>
    <li>Riport generálható
      <ul>
        <li>ng test --code-coverage
          <ul>
            <li>--no watch: A megnyitott böngészőt bezárja</li>
          </ul>
        </li>
        <li>A CLI-ben láthatjuk a mérőszámokat</li>
        <pre>
          =============================== Coverage summary ===============================
          Statements   : 8.9% ( 154/1729 )
          Branches     : 0% ( 0/185 )
          Functions    : 0% ( 0/698 )
          Lines        : 6.54% ( 105/1605 )
          ================================================================================
        </pre>
        <li>A projektünk root-jában egy coverage mappa keletkezik, néhány fájllal
          <ul>
            <li>A benne lévő index.html-t megnyitva részletes nézetet kapunk</li>
            <li>A listában a fájlok kattinthatók, további információt kaphatunk arról, hogy mit nem fedtünk le</li>
          </ul>
        </li>
        <li>Általában 70-80% feletti lefedettség a cél, és e felett lehet a deploy-t engedélyezni</li>
        <li>Például, ha egy fentebbi példában, amikor a feliratok színeit mark/grade alapján megváltoztattuk, amennyiben
          a mouseleave event-et is felvittük volna, mint spec, és a teszt lefedné azt is, hogy feketére visszaváltoznak
          a szövegek színei, máris javítottunk volna a lefedettségen</li>
        <li>Minél komplexebb egy alkalmazás, annál nehezebb magasabb számú százalékot elérni</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #jasminejest data-anchor="jasminejest">Jasmine / Jest</h5>
  <ul>
    <li>A Jest is egy tesztfuttató eszköz
      <ul>
        <li>Mint a Karma, ami jelenleg már deprecated</li>
        <li>Egyszerre nem szokás mindkettőt alkalmazni</li>
        <li>Telepíteni szükséges</li>
        <pre>
          npm install jest jest-preset-angular @type/jest --save-dev

          OR

          npm install jest jest-preset-angular @type/jest -D // a -D a --save-dev rövidített formájas
        </pre>
        <li>A létrehozott jest.config.ts fájlban végezhetünk konfigurációt</li>
      </ul>
    </li>
    <br>
    <table style="width: 100%; table-layout: fixed">
      <thead>
        <tr>
          <th>Funkció</th>
          <th>Karma</th>
          <th>Jest</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Típusa</td>
          <td>Böngésző-alapú tesztfuttató</td>
          <td>Node.js-alapú tesztfuttató</td>
        </tr>
        <tr>
          <td>Sebesség</td>
          <td>Lassabb, mivel valódi böngészőket használ</td>
          <td>Gyorsabb, mivel a Node.js környezetben fut</td>
        </tr>
        <tr>
          <td>Böngésző támogatás</td>
          <td>Valódi böngészőkben fut (pl. Chrome, Firefox)</td>
          <td>Szimulált DOM környezet (pl. jsdom)</td>
        </tr>
        <tr>
          <td>Konfiguráció</td>
          <td>Több konfigurációt igényel</td>
          <td>Egyszerűbb beállítások</td>
        </tr>
        <tr>
          <td>Használat az Angular-ban</td>
          <td>Alapértelmezett az Angular CLI-ben</td>
          <td>Harmadik féltől származó integráció szükséges</td>
        </tr>
        <tr>
          <td>Fő célja</td>
          <td>Platformfüggetlen tesztek valódi böngészőkben</td>
          <td>Gyors, egyszerű egységtesztelés</td>
        </tr>
      </tbody>
    </table>
    <br>
    <li></li>
  </ul>
  <br>
  <h5 #next data-anchor="next">Next</h5>
  <ul>
    <li></li>
  </ul>
</div>

<div>
  <h3 #angular data-anchor="angular">Angular</h3>
  <ul>
    <li>Az egyik legnépszerűbb Javascript framework kliens oldali applikációk készítéséhez mobilra és dektopra</li>
    <li>HTML-t, CSS-t (SCSS/SAAS), Javascriptet és Typescriptet használ</li>
    <li>Nem programnyelv, hanem framework, ami programnyelveket használ</li>
    <li>Tehát mondhatjuk, hogy egy Javascript framework, ami lehetővé teszi Single Page Application-ök készítését</li>
    <li>Framework:
      <ul>
        <li>Egy platform a fejlesztéshez</li>
        <li>Lehetnek előre definiált osztályai, függvényei, amiket egyébként nekünk kellene manuálisan megírni</li>
        <li>Api-kkal is szolgál, különféle műveletek megvalósítására</li>
      </ul>
    </li>
    <li>(A Javascript kliens oldali programnyelv!)</li>
    <li>SPA:
      <ul>
        <li>Klasszikus esetben, amikor a kliens a szerver felé kérést intéz, például egy weboldal aloldalának url-jét,
          akkor a szerver visszaküldi az aloldal html-jét; Ez a html renderelésre kerül kliens oldalon
        </li>
        <li>Az SPA-nak egyetlen HTML oldala van, és amikor navigálunk, csak a tartalom változik benne</li>
        <li>Amikor navigálunk, nem intézünk a szerver felé kérést, csupán a Javascript megváltoztatja a kontentet az
          oldalon a kért 'resource' alapján
        </li>
        <li>Előnyei:
          <ul>
            <li>A content betöltése sokkal gyorsabb</li>
            <li>Nincs folyamatos szerver felé kommunikáció</li>
            <li>Reaktívabb oldal hozható így létre</li>
            <li>Olyan kódstuktúrát építhetünk fel, amit könnyű nyomon követni, és karbantartani</li>
            <li>Újrahasznosítható (akár más projektben) kódokat hozhatunk létre</li>
            <li>Tesztelhető a kód</li>
          </ul>
        </li>
        <li>Miért használjunk Angulart?
          <ul>
            <li>A vanilla Javascript / jQuery kódok elég kezelhetetlenné váltak</li>
            <li>A vanilla Javascript / jQuery kódokat nehéz tesztelni</li>
            <li>Beépített funkcionalitásokkal rendelkezik, amiket nulláról kellene megírnunk</li>
            <li></li>
          </ul>
        </li>
      </ul>
    </li>
    <li>2010 októberében adták ki az első verziót, az Angular JS, ami nagyon más volt a mai verziókhoz képes;
      túlbonyolított
    </li>
    <li>Használatához Node.JS-t és Angular CLI telepítésére van szükség
      <ul>
        <li>Angular projekt buildeléshez tool</li>
      </ul>
    </li>
    <li>Telepítés
      <ul>
        <pre>
          npm install -g @angular/cli
        </pre>
        <li>Globális telepítés, jelen esetben a legfrissebb verzió kerül installálásra</li>
        <pre>
          npx @angular/cli new my-angular-app
        </pre>
        <li>Ugyanaz, csak nem telepíti tartósan a CLI-t</li>
        <pre>
        npx @angular/cli@12 new my-angular-app
        </pre>
        <li>Egy általunk választott CLI verziót telepítünk</li>
        <pre>
          ng new my-angular-app --routing --style=scss
        </pre>
        <li>Az interaktív kérdéseket kihagyhatjuk switch-ekkel</li>
        <pre>
          npx -p @angular-cli@17 ng new angular-testing
        </pre>
        <li>Ideiglenesen letölti az Angular CLI 17-es verzióját és létrehoz egy új Angular projektet angular-testing
          néven a letöltött CLI verzióval
          <ul>
            <li>A -p opció az npx parancsnál azt jelenti, hogy egy adott csomagot (például @angular/cli) szeretnénk
              ideiglenesen telepíteni és futtatni, anélkül, hogy azt globálisan vagy helyileg telepítenénks</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #howitworks data-anchor="howitworks">How it works?</h3>
  <ul>
    <li>Böngészőben működő Javascript alkalmazások működése
      <ul>
        <li>UI / User Interface
          <ul>
            <li>Az a felület, amivel a felhasználó találkozik, interakcióba lép</li>
            <li>Amikor a felhasználó valamilyen elemmel interakcióba lép, az alkalmazás állapotát fogja
              manipulálni
            </li>
          </ul>
        </li>
        <li>State
          <ul>
            <li>State / Alkalmazás állapot
              <ul>
                <li>Adatstruktúra, amit az alkalmazás futása során folyamatosan a memóriában tartunk</li>
                <li>A legminimálisabb módon leírja a UI-on megjelenő elemeket
                  <ul>
                    <li>Tehát minden információt tartalmaz, ami ahhoz szükséges, hogy az interface
                      kirajzolódhasson
                    </li>
                  </ul>
                </li>
                <li>A UI-on dinamikusan változó dolgok azok a State-nek a leképeződései</li>
                <li>Bármilyen adatstruktúra lehet</li>
                <li>Nem statikus adatstruktúra, hanem futási időben a memóriában folyamatosan felülíródik, ahogy
                  különféle események végbemennek a UI-on
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Eseménykezelők
          <ul>
            <li>Az az egység, amit megírtunk annak érdekében, hogy leírjuk, hogy a felhasználói interakció hatására
              miképp menjen végbe az értékváltozás az alkalmazás állapotában
            </li>
          </ul>
        </li>
        <li>Controller
          <ul>
            <li>A State és az eseménykezelők egysége</li>
            <li>Definiált állapot, amit eseménykezelő függvények bizonyos események hatására megváltoztatnak</li>
          </ul>
        </li>
        <li>Template / Sablon
          <ul>
            <li>Az adatstruktúrából konkrét elemeket készít</li>
            <li>HTML elemekből áll, amik a UI statikus részét képzik</li>
            <li>A statikus elemeket időközönként megszakítják a State-ből kiolvasott dinamikus értékek
              <ul>
                <li>String interpolációnak nevezik (amikor beleírjuk a State-ből a sablon dinamikus részébe)
                </li>
              </ul>
            </li>
            <li>A sablonban lehetnek egyszerű kontroll struktúrák
              <ul>
                <li>if-else</li>
                <li>for</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Render / Renderelés
          <ul>
            <li>A folyamat, amely során alapul vesszük a State-et, dinamikus adatokat, - és akár -
              kontroll struktúrákat használunk fel, és összeollózunk egy sablont
            </li>
          </ul>
        </li>
        <li>Component / Komponens
          <ul>
            <li>A Controller és a sablon logika összefoglaló neve</li>
            <li>React esetében a komponenst egyetlen egy fájlban kell definiálni</li>
            <li>Angular esetében két külön fájlban definiált</li>
          </ul>
        </li>
        <br>
        <li>A folyamat:
          <ul>
            <li>Ha végfelhasználóként letöltöd az oldalt, és elindul a Javascriptes alkalmazás, az első, hogy az
              alkalmazásnak van egy kiinduló állapota, ehhez jön hozzá a meghatározott statikus sablon, és ezek
              alapján megtörténik az első renderelés, megjelenik a User Interface-en a tartalom
            </li>
            <li>Ezután a felhasználó valamilyen action-t hajt végre, ami állapotmódosítást eredményez az általunk
              megírt eseménykezelők szerint
            </li>
            <li>Az állapotmódosítást renderelés követi a frissített adatokkal, aminek következtében a UI-on frissül
              a tartalom
            </li>
          </ul>
        </li>
        <img src="assets/imgs/process.png" style="width: 100%;">
        <li>A folyamat bővebben:
          <ol>
            <li>index.html betöltése
              <ul>
                <li>A bőngésző betölti az index.html</li>
                <li>Az oldalon szerepelnek stílusfájlok, és JS fájlok</li>
              </ul>
            </li>
            <li>JavaScript fájlok letöltése és futtatása
              <ul>
                <li>A hivatlkozott JS fájlokat letölti a böngésző, és futtatja</li>
              </ul>
            </li>
            <li>Angular indítása (Bootstrap)
              <ul>
                <li>Az Angular alkalmazás belépési pontja az main.ts fájl (az angular.json fájlban van meghatározva -->
                  'main'), amely bootstrappel elindítja az Angular alkalmazást
                </li>
                <li>Ez a fájl inicializálja az Angular keretrendszert, és meghívja az alapértelmezett root modul-t
                  (AppModule)
                </li>
              </ul>
            </li>
            <li>Root modul betöltése (AppModule)
              <ul>
                <li>Az Angular betölti a root modul-t, ami az alkalmazás legfelsőbb modulja</li>
                <li>Az app.module.ts-ben van meghatározva az AppComponent betöltése
                  <pre>
                    ...
                    bootstrap: [AppComponent]
                    ...
                  </pre>
                </li>
              </ul>
            </li>
            <li>Komponensek inicializálása
              <ul>
                <li>Miután az AppModule betöltődött, az Angular elindítja az AppComponent-et, amely az alkalmazás
                  elsődleges
                  komponense
                </li>
                <li>Az Angular létrehozza a komponens template-jét</li>
              </ul>
            </li>
            <li>DOM renderelés
              <ul>
                <li>Az Angular change detection rendszere gondoskodik a megfelelő HTML elemek megjelenítéséről</li>
                <li>A DOM struktúra frissül az adatok alapján, és az Angular kirendereli az alkalmazást a böngészőben
                </li>
              </ul>
            </li>
            <li>Routing, interakció, adatkezelés
              <ul>
                <li>Route váltáskor, felhasználói interakciókat követően, vagy szerverről való adatbetöltés után az
                  Angular
                  (tehát változásokkor a Change Detection) újrarendereli a DOM-ot
                </li>
              </ul>
            </li>
          </ol>
        </li>
      </ul>
    </li>
    <li>Hogyan könnyíthetik meg a különféle kliens oldali könyvtárak és keretrendszerek (framework) a User Interface-ek
      készítését?
      <ul>
        <li>React / Angular / Vue</li>
        <li>React és Angular esetén a renderelés teljesen automatikus (amint valamilyen State változás
          történik), amíg vanilla Javascript esetén a renderelő mechanizmust a fejlesztőnek kell manuálisan
          működésbe léptetni a State változás után
        </li>
        <li>A felhasználói felület külön részegységekre bontható a segítségükkel
          <ul>
            <li>Egy interaktív részleg helyett létre lehet hozni többet</li>
            <li>Mindegyikért a saját, dedikált kontrollere és template-je, azaz komponense lesz felelőt</li>
            <li>Az összes komponensnek meg van a saját állapota, template-je, és action-jei
              <ul>
                <li>Ilyen módon két komponens egymástól teljesen függetlenül tud működni</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A React és Angular alkalmazásoknak egyetlen belépési pontja van
          <ul>
            <li>Létezik az egész alkalmazást összefogó, és az egész User Interface-ért felelős
              app.component
            </li>
            <li>Teljesen ugyanúgy működik, mint az összes többi</li>
            <li>A különbség, hogy szülő elem a többi komponenshez képest</li>
            <li>A sablon logikájában van hivatkozás a gyerek komponensekre</li>
            <li>Tehát egy-egy komponens a többitől elkülönülve le tudja írni saját maga működését, és ezt a
              szülő
              elem akárhányszor felhasználhatja
            </li>
            <li>A különböző komponensek közötti adatáramlás is könnyen manadzselhető</li>
            <li>Természetesen a gyerekeknek is lehetnek gyerekeik, így egy fa struktúra épül fel</li>
            <li>Egy komponens a szülő elemétől mindig kaphat kívülről adatot, és azt tovább tudja passzolni
              a saját gyerekének, gyerekeinek
            </li>
            <li>A gyermek elemek is tudnak a szülőnek adatot küldeni</li>
            <li>A komponensek más irányba is tud(hat)nak kommunikálni, például AJAX kérést küldhetnek,
              adatot tölthet fel, vagy szerezhet
            </li>
            <li>A komponensek a localstorage-dzsal is kapcsolatot teremthetnek (írás, olvasás)</li>
            <li>Az alkalmazások engedik, hogy létrehozzunk kliens oldali útvonal választót
              <ul>
                <li>Ez csak az SPA (Single Page App) kapcsán releváns
                  <ul>
                    <li>Olyan rendszer, amiben a felhasználó, ha rákattint egy linkre, akkor nem
                      történik tényleges oldalletöltés az oldalon, hanem mindezt virtuálisan
                      idézzük elő
                    </li>
                  </ul>
                </li>
                <li>Az útvonalválasztóban van eldöntve, hogy melyik komponens legyen aktív</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #files data-anchor="files">Files/Folders</h3>
  <ul>
    <li>node_modules
      <ul>
        <li>Az összes third-party library-t tartalmazza</li>
        <li>npm csomagok formájában töltjük le őket</li>
        <li>Nem deploy-oljuk production-be, és repo-ba (verziókezelőbe) sem töltjük fel</li>
        <li>npm i / npm installal telepíthető újra, ha esetleg letöröltük</li>
        <li>.gitignore tartalmazza</li>
        <li>Build során a third party könyvtárakkal az alábbiak történnek:</li>
        <ol>
          <li>Tree-shaking:
            <ul>
              <li>Az Angular csak azokat a részeket veszi figyelembe a könyvtárakból, amelyek
                ténylegesen szükségesek a projektheu, a felesleges kódokat elhagyja
              </li>
              <li>Így csökken a build mérete is</li>
            </ul>
          </li>
          <li>Minifying:
            <ul>
              <li>A kód tömörítésre kerül, a whitespace-ek, felesleges karakterek eltűnnek</li>
            </ul>
          </li>
          <li>Bundle:
            <ul>
              <li>A könyvtárak kódja beépül az alkalmazás különálló JavaScript fájljaiba (bundle-ökbe)</li>
              <li>Ezek a fájlok kerülnek betöltésre a felhasználói oldalon, amikor az alkalmazás elindul</li>
              <li>Az Angular a Webpack-et használni "csomagolónak" (bundle-nek)
                <ul>
                  <li>A megfelelő működés érdekében az Angular automatikusan konfigurálja a Webpack-et</li>
                  <li>Felkutatja az applikációnkban található JS fájlokat, és létrehoz belőlük egy, vagy több
                    bundle-t
                  </li>
                  <li>Amikor az index.html fájl betöltődik, a bundle-ök inicializálása már végbement (betöltődött a
                    böngészőbe)
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ol>
      </ul>
    </li>
    <li>package.json
      <ul>
        <li>Minden node projekt tartalmazza</li>
        <li>Standard konfigurációs file</li>
        <li>Projekttel kapcsolatos beállításokat tartalmaz
          <ul>
            <li>Projekt neve</li>
            <li>Verziója</li>
            <li>Szkriptek
              <ul>
                <li>ng / ng start / ng build / ng watch / ng test</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>dependencies
          <ul>
            <li>A dependenciák és dev dependenciák third party függőségeket tartalmaznak</li>
            <li>A projekt közvetlenül függ ezektől</li>
            <li>A dependenciákat különféle helyekre beimportáljuk
              <pre>
                                import &#123;Component} from '@angular/core';
            </pre>
            </li>
          </ul>
        </li>
        <li>devDependencies
          <ul>
            <li>Addig függ tőlük a projekt, amíg fejlesztjük</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>editorconfig
      <ul>
        <li>Team environment beállítására való</li>
        <li>Minden fejlesztő más kódolási standardot követ; ezt véli egységesíteni</li>
        <li>Fájltípusonként, és globálisan is megadhatók szabályok</li>
        <li>Praktikusan csak a Team Leader szerkesztheti</li>
        <li></li>
      </ul>
    </li>
    <li>gitignore
      <ul>
        <li>Kizárásokat lehet meghatározni (fájlok, mappák), amik nem kerülnek fel a Git repository-ba</li>
        <li></li>
      </ul>
    </li>
    <li>angular.json
      <ul>
        <li>Angularral kapcsolatos konfigurációs beállításokat tartalmaz</li>
        <li>Használandó stílusok, szkriptek lokációját határozhatjuk meg</li>
        <li>Beállíthatjuk, melyik fájl fusson le, amikor az Angular elkezd futni (index), csakúgy, mint az applikáció
          belépési pontját (main)
        </li>
        <li></li>
      </ul>
    </li>
    <li>package.lock.json
      <ul>
        <li>Az npm csomagkezelő hozza létre automatikusan</li>
        <li>Rögzíti az összes telepített csomag pontos verzióját</li>
        <li>Biztosítja, hogy ha más is dolgozik a projekten, ugyanazokat a csomagokat fogja használni</li>
        <li>Megelőzi a nem kívánt frissítések okozta problémákat</li>
      </ul>
    </li>
    <li>tsconfig.json
      <ul>
        <li>Typescript compiler beállításokat tartalmaz</li>
        <li>Ezek alapján a beállítások alapján történik a compile Javascript nyelvre (amit a böngésző ért)</li>
      </ul>
    </li>
    <li>src
      <ul>
        <li>Az applikációnk teljes forráskódja ebbe a mappába kerül</li>
        <li>app
          <ul>
            <li>Alapértelmezetten a projektünk egy alkalmazást tartalmaz, az "app"-ot</li>
            <li>Szintén alapértelmezetten az app komponenst, és az app modult tartalmazza</li>
            <li>Minden applikáció, amit készítünk, van legalább egy komponense, és egy module fájlja</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>assets
      <ul>
        <li>Képek, ikonok, szöveges fájlok helye</li>
        <li>"Publikusan" elérhető fájlok</li>
        <li>Példa: <a href="/assets/imgs/process.png" [target]="'_blank'">Process PNG</a></li>
        <li>Az app, vagy más mappába helyezett fájlok nem elérhetőek</li>
      </ul>
    </li>
    <li>favicon.ico
      <ul>
        <li>Az alapértelmezett favicon</li>
      </ul>
    </li>
    <li>index.html
      <ul>
        <li>A fő HTML fájl, ami a böngészőben renderelődik az Angular futásakor</li>
        <li>Nem tartalmaz referenciát stylesheethez, vagy JS fájlhoz, mert a build folyamat közben az Angular
          beinjektálja őket
        </li>
      </ul>
    </li>
    <li>main.ts
      <ul>
        <li>Az Angular app kiindulási pontja</li>
        <li>Az AppModule "bootstrap"-elésre kerül; betöltődik</li>
        <li>"Bootstapping"-nek nevezzük az Angular applikáció inicializálását / betöltését</li>
        <li>A beimportált PlatformBrowserDynamic a desktop app betöltéséért felelős modul</li>
        <li>Mobilon való betöltéshez használhatunk Ionic-ot, vagy PlatformBrowserDynamic helyett
          PlatformNativeScriptDynamic
          <ul>
            <li>Arra szolgál, hogy Angular alapú alkalmazásokat futtathass natív mobilalkalmazásként Androidon és
              iOS-en
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>styles.css / styles.scss
      <ul>
        <li>Minden globális CSS szabály ide kerül</li>
        <li>Minden komponensre kiterjedő szabályokat írhatunk bele</li>
        <li>A komponensekben lévő component.css fájlba írt szabályok kizárólag arra a komponenesre hatnak</li>
      </ul>
    </li>
  </ul>
</div>


<div>
  <h3 #components data-anchor="components">Components</h3>
  <ul>
    <li>Az Angular egy komponens alapú, kliens oldali Javascript framework</li>
    <li>A komponens tulajdonképpen egy (kis) darab felhasználói felület</li>
    <li>Egy komponensre tekinthetünk úgy is, mint egy Typescript class-ra</li>
    <li>Ezen részegységek összevegyítése adja a komplex User Interface-t</li>
    <li>Minden Angular applikáció legalább egy komponenssel rendelkezik (root/app)
      <ul>
        <li>Konvenció, de átnevezhető</li>
        <li>Az app komponensnek lehetnek gyerekei, így az Angular applikációk tulajdonképpen fa struktúrájúak</li>
      </ul>
    </li>
    <li></li>
    <li>Alapértelmezetten az index.html-ben találjuk az app-root tag-et, ami az app komponenst rendereli</li>
    <li>Az app.module.ts nem része az app komponensnek</li>
    <li>Komponens létrehozásakor 4 fájl generálódik
      <ul>
        <li>.html</li>
        <li>.css / .scss</li>
        <li>spec.ts</li>
        <li>.ts</li>
      </ul>
    </li>
    <li>.ts fájl:
      <ul>
        <li>Komponens class található benne</li>
        <li>
          <pre>
              @Component(&#123;
                selector: 'app-root',
                templateUrl: './app.component.html'
                styleUrls: ['./app.component.scss'],
              })
            </pre>
          <ul>
            <li>@Component
              <ul>
                <li>Komponenes dekorátor
                  <ul>
                    <li>Objektumot adunk át neki</li>
                    <li>A komponens class selector értéke használható HTML elemként</li>
                    <li>A HTML-ben a selector tag helyére renderelődik a selector template content-je</li>
                    <li>A templateUrl kulcs alatt mondjuk meg, hogy hol található a template
                      <ul>
                        <li>Írhatunk HTML-t közvetlenül a kontrollerbe is, ehhez a template kulcsot szükséges
                          használnunk templateUrl helyett
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A komponens létrehozásának 3 lépése:
      <ol>
        <li>Typescript class készítése, és exportálása</li>
        <li>A class dekorálása @Component dekorátorral</li>
        <li>A class deklarálása module file-ban</li>
      </ol>
      <pre>
          @Component(&#123;
          selector: 'app-root',
          template: ``
          })

          export class AppComponent &#123;
            ...
          }

          //

          @NgModule(&#123;
            declarations: [
              AppComponent
            ]
          })
      </pre>
    </li>
    <li>Template
      <ul>
        <li>Amennyiben a komponens dekorátorban templateUrl-t adunk meg, értéknek a komponens HTML template-jének a
          lokációját szükséges megadnunk
        </li>
        <li>Ha csak néhány sor HTML kerül a template-be, nem érdemes külön file-t létrehozni</li>
        <li>Kontrollerben létrehozott template esetében compile közben nem kapunk hibát, ha mondjuk nem zártunk be egy
          tag-et (hatrány)
        </li>
      </ul>
    </li>
    <li>Stílusok
      <ul>
        <li>A dekorátorban a styles tömb használatakor stringként felsorolva adhatjuk meg a szabályokat
          <pre>
            @Component(&#123;
              selector: 'app-root',
              styles: ['a&#123;text-decoration:none}',h1&#123;font-size:30px}]
            })
          </pre>
          <ul>
            <li>Compile közben szintén nem kapunk hibát, csak futási időben észlelhetjük, hogy valamit elírtunk
              (hátrány)
            </li>
          </ul>
        </li>
        <li>A dekorátorban a styleUrls esetén a component.css/component.scss fájl URL-jét adjuk meg, szintén tömb
          formájában
          <pre>
            @Component(&#123;
              selector: 'app-root',
              styleUrls: ['./app.component.scss']
            })
          </pre>
        </li>
        <li>A szülőnek adott CSS szabályt a gyerekek nem öröklik meg</li>
      </ul>
    </li>
    <li>Komponens létrehozása parancssorból:
      <ul>
        <li>ng generate component *componentName* / ng g c *componentName*</li>
        <li>Létrehozza mind a 4 komponenshez tartozó fájlt, és regisztálja a komponenst a modulban</li>
      </ul>
    </li>
    <li>Komponens szelektorok használati módjai:
      <ul>
        <li>HTML tag
          <ul>
            <li>Tipikusan HTML tag-ként használjuk a szelektort</li>
            <li>A szelektor használható html tag-ként
              <pre>
                @Component(&#123;
                  selector: 'app-angular',
                  ...
                })

                &#60;app-angular>&#60;/app-angular>
              </pre>
            </li>
          </ul>
        </li>
        <li>HTML attribútum
          <ul>
            <li>Ha a szelektort szögletes zárójelbe rakjuk, elérjük, hogy attribútumként tudjuk használni
              <pre>
                @Component(&#123;
                  selector: '[app-angular]',
                  ...
                })

                &#60;div app-angular>&#60;div>
              </pre>
            </li>
            <li>Innentől HTML elementként már nem használható a szelektor</li>
            <li>A DOM-ban nem az &#60;app-angular> tag fog megjelenni, hanem az a tag, amire ráraktuk az attribútumot
            </li>
            <li>Direktívák esetében használatos ez a megadási mód</li>
          </ul>
        </li>
        <li>CSS osztály
          <ul>
            <li>CSS classként is használható a szelektor
              <pre>
                @Component(&#123;
                  selector: '.app-angular',
                  ...
                })

                &#60;div class="app-angular">&#60;/div>
              </pre>
            </li>
            <li>Az elem gyerekeként renderelődik az app-angular template tartalma</li>
          </ul>
        </li>
        <li>ID:
          <ul>
            <li>ID megadásával szintén működik
              <pre>
                @Component(&#123;
                  selector: '#app-angular',
                  ...
                })

                &#60;div id="app-angular">&#60;/div>
              </pre>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #modules data-anchor="modules">Modules</h3>
  <ul>
    <li>@NgModule
      <ul>
        <li>Modul dekorátor</li>
        <li>A modulok szervezik és struktúrálják az alkalmazás különböző részeit</li>
        <li>Meghatározza, hogy mely komponensek, szolgáltatások és más Angular funkciók tartoznak az adott modulhoz
        </li>
      </ul>
      <ol>
        <li>Declarations: Definiálják, hogy mely komponensek, direktívák és pipe-ok tartoznak az adott modulhoz</li>
        <li>Imports: Meghatározzák, hogy az adott modul milyen egyéb modulokat (pl. BrowserModule, FormsModule)
          használ
        </li>
        <li>Providers: Meghatározzák, hogy mely szolgáltatások (pl. HTTP_INTERCEPTORS, AuthService) érhetők el az adott
          modulban
        </li>
        <li>Bootstrap: Megmondja, melyik komponens legyen az alkalmazás belépési pontja (Tipikusan az AppComponent)
        </li>
      </ol>
    </li>
    <br>
    <li>Új modul létrehozásának folyamata komponenssel egyetemben, amit az app komponensbe be lehet hívni
      <ul>
        <li>ng g m navi --routing</li>
        <li>ng g c navi</li>
        <pre>
          <b>// app.module.ts</b>
          @NgModule(&#123;
            declarations: [
              ...
            ],
            imports: [
              ...
              NaviModule
            ],
            providers: [],
            bootstrap: [AppComponent]
          })
          export class AppModule &#123; }

          <b>// app.component.html</b>
          &#60;app-navi>&#60;/app-navi>

          <b>// navi.module.ts</b>
          @NgModule(&#123;
            declarations: [
              NaviComponent
            ],
            imports: [
              CommonModule,
              NaviRoutingModule
            ],
            exports: [
              NaviComponent
            ]
          })
          export class NaviModule &#123; }

          <b>// navi-routing.module.ts</b>
          const routes: Routes = [
          &#123;path: '', component: NaviComponent}, // erre akkor van szükség, ha útvonalra akarunk navigálni
          ];

          @NgModule(&#123;
            imports: [RouterModule.forChild(routes)],
            exports: [RouterModule]
          })
          export class NaviRoutingModule &#123; }
        </pre>
      </ul>
    </li>
    <li>A modul Angular blokkokat csomagol össze
      <ul>
        <li>Komponenseket, szervizeket, pipe-okat, direktívákat, satöbbi</li>
        <li>Az Angular megnézi, hogy az adott module-ban milyen feature-öket használunk</li>
        <li>Ahhoz, hogy egy class module legyen, az NgModule dekorátorral kell ellátni</li>
        <li>Minden Angular projektnek legalább 1 modulból szükséges állnia
          <ul>
            <li>Kivéve standalone komponensek használata esetében, amit a legújabb Angular verziókban vezettek be</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Amikor az applikáció elkezd futni, a main.ts meghívódik
      <ul>
        <li>Ebben a file-ban bootstrap-eljük az AppModule-t</li>
        <li>Megnézi az AppModule-t, hogy miket deklaráltunk, importáltunk</li>
        <li>Így tájékozódik, és ha mondjuk az egyik komponens szelektorral találkozik, tudja renderelni</li>
        <li>Amennyiben olyan szelektort használunk, amelyik nincs deklarálva, hibát fogunk kapni
          <ul>
            <li>Igaz ez persze a pipe-okra, direktívákra, szervizekre, és modulokra is</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Onnantól kezdve, hogy egy class-t ellátunk az @NgModule dekorátorral, az Angular modulként kezeli
      <ul>
        <li>Természetesen a fő modulunkban importálnunk kell</li>
        <li>Használhatunk több module-t is a projektünkön belül</li>
      </ul>
    </li>
    <li>Minden module standalone, nincs köztük kommunikáció
      <ul>
        <li>Ha egy adott komponenst egy adott modulban deklaráltunk, akkor az ott használható, másikban nem</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #featuremodule data-anchor="featuremodule">Feature module</h5>
  <ul>
    <li>A fő modul-t (app) feloszthatjuk kisebb (feature) modulokra</li>
    <li>Az alkalmazás egy adott funkcionalitását vagy területét kezeli és modularizálja</li>
    <li>A feature modulban használhatók
      <ol>
        <li>Koomponensek</li>
        <li>Szolgáltatások</li>
        <li>Direktívák</li>
        <li>Pipe-ok</li>
      </ol>
    </li>
    <li>A module konfigurálása
      <ol>
        <li>declarations: Az adott modulhoz tartozó komponensek</li>
        <li>imports: Azok a modulok, amelyeket a feature module használ</li>
        <li>exports: Azok az elemek, amelyeket más moduloknak elérhetővé szeretnél tenni</li>
      </ol>
    </li>
    <li>Minden module standalone, egymástól függetlenül működnek</li>
    <li>Létrehozás komponensből
      <ul>
        <li>Új fájl készítése
          <ul>
            <li>*név*.module.ts (névkonvenció)</li>
          </ul>
        </li>
        <li>Class létrehozása
          <ul>
            <li>ModulingModule</li>
          </ul>
        </li>
        <li>A module osztály NgModule dekorátorral való ellátása
          <ul>
            <li>Metadata objektumot lehet átadni, amiben deklarációt, importot, exportot, providereket, stb. adhatunk
              meg</li>
            <li>Az itt található - egyelőre - egyetlen komponenst deklaráljuk is</li>
          </ul>
        </li>
        <pre>
          <b>// moduling.module.ts</b>
          @NgModule(&#123;
            declarations: [ModulingComponent],
            exports: [ModulingComponent],
            imports: [
                CommonModule
            ]
          })
          
          export class ModulingModule &#123;
          
          }
        </pre>
      </ul>
    </li>
    <li>Ezen a ponton az Angular sem a module-ról, sem a benne található komponensről nem tud
      <ul>
        <li>Egyrészt a moduling modult importálnunk kell az app module-ba</li>
        <li>Másrészt a modulunkban lévő komponenst exportáljuk</li>
        <li>Innentől kezdve, amikor az Angulár scan-eli az app modult, megtalálja a moduling modult, ahogyan a benne
          található komponenst, komponenseket is
          <ul>
            <li>De csakis kizárólag az exportált komponensekkel foglalkozik</li>
          </ul>
        </li>
        <li>Minden modul önállóan kezeli az importjait</li>
      </ul>
    </li>
    <li>Amennyiben az AppModule-ban deklarálva volt már a komponensünk, onnan el kell távolítani</li>
    <li>Nagyon fontos megjegyezni, hogy sem komponenst, sem direktívát, sem pipe-ot nem lehet egy projektben többször
      deklarálni
      <ul>
        <li>Ha több modulban szeretnénk használni, akkor azt a modulban exportálni kell, amelyben deklaráltuk, és azt a
          modult importálni máshol</li>
        <li>Ha lazy-loaded modulban deklarálunk egy komponenst, direktívát vagy pipe-ot, és azt megpróbálnád más
          modulban használni, az nem fog működni, amíg a lazy-loaded modul be nem töltődik</li>
        <li>Az új standalone komponenseknél nincs szükség deklarációra egy modulban
          <ul>
            <li>Ezeket közvetlenül használhatjuk más modulokban vagy komponensekben, ha importáljuk őket</li>
          </ul>
        </li>
        <li>A service egyébként kivételt képez a fenti állítás alól, őket lehet több helyen deklarálni</li>
      </ul>
    </li>
    <li>A BrowserModule nem importálható többször
      <ul>
        <li>Az alkalmazás inicializálását kezeli, amelyet csak egyszer szabad elvégezni a gyökérmodulban</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #sharedmodule data-anchor="sharedmodule">Shared module</h5>
  <ul>
    <li>Komponenseket, direktívákat, és pipe-okat tartalmazó modul, amik közös használatúak az alkalmazásban</li>
    <li>Más module-ban csak a shared module-t kell beimportálni, és máris használható a megosztott eszköztár</li>
    <pre>
      <b>// shared.module.ts (example)</b>
      @NgModule(&#123;
        declarations: [
          AppLoaderComponent // Komponens deklarálása
        ],
        exports: [
          CommonModule,
          FormsModule,
          ReactiveFormsModule,
          RouterModule,
          AppLoaderComponent // Exportáljuk, hogy más modulok is használhassák
        ],
        imports: [
          CommonModule, // Hozzáadjuk a CommonModule-t, hogy ngIf, ngFor stb. működjön
          FormsModule,
          ReactiveFormsModule,
          RouterModule
        ]
      })
      export class SharedModule &#123;}

      <b>// app.module.ts (example)</b>
      @NgModule(&#123;
        declarations: [
          AppComponent // az AppComponent deklarációja
        ],
        imports: [
          BrowserModule,
          SharedModule // SharedModule hozzáadása
        ],
        bootstrap: [AppComponent]
      })
      export class AppModule &#123;}

      <b>// feature.module.ts (example)</b>
      @NgModule(&#123;
        declarations: [
          FeatureComponent // Feature specifikus komponensek
        ],
        imports: [
          CommonModule,
          SharedModule // AppLoaderComponent használható ebben a modulban
        ]
      })
      export class FeatureModule &#123;}
    </pre>
    <li>Érdemes az alkalmazásunkban egy shared module-t létrehozni
      <ul>
        <li>A fenti példát követve így az AppLoaderComponent könnyen megosztható más modulokkal</li>
        <li>Más modulokat is érdemes lehet így kezelni
          <ul>
            <li>CommonModule: Bár az AppModule automatikusan tartalmazza, minden olyan modulban, amely nem a root modul,
              szintén szükséges importálni</li>
            <li>A FormsModule és ReactiveFormsModule olyan formák kezelésére szolgálnak, amelyek az alkalmazás több
              részében is előfordulhatnak</li>
            <li>Ha a shared modulban olyan komponensek vannak, amelyeket router-rel navigálunk, akkor érdemes
              importálni a RouterModule-t/li>
          </ul>
        </li>
        <li>Pipe-ok, direktívák importálása, és exportálása is javasolt, amiket alkalmazásszerte szeretnénk használni
        </li>
        <li>Amennyiben a shared module-t használtuk olyan feature module-ban, amit importáltunk az app module-ban, akkor
          abban a feature module-ban elég az import mellett exportálni a shared module-t, így az app module-ban nincs
          szükség a shared module importálására</li>
        <pre>
          <b>// shared.module.ts (example)</b>
          @NgModule(&#123;
            declarations: [
              AppLoaderComponent
            ],
            exports: [
              AppLoaderComponent
            ],
            imports: []
          })
          export class SharedModule &#123;}

          <b>// feature.module.ts (example)</b>
          @NgModule(&#123;
            declarations: [
              FeatureComponent
            ],
            imports: [
              SharedModule
            ],
            exports: [
              SharedModule // exportáljuk a shared module-t
            ]
          })
          export class FeatureModule &#123;}
    
          <b>// app.module.ts (example)</b>
          @NgModule(&#123;
            declarations: [
              AppComponent
            ],
            imports: [
              FeatureModule
              // SharedModule // nem szükséges már importálni
            ],
            bootstrap: [AppComponent]
          })
          export class AppModule &#123;}
        </pre>
        <li>Működés
          <ul>
            <li>A SharedModule deklarálja és exportálja azokat a komponenseket, amelyeket más modulokban is használni
              szeretnénk</li>
            <li>A FeatureModule importálja a SharedModule-t, így hozzáfér a benne deklarált és exportált komponensekhez
            </li>
            <li>A SharedModule-t exportálja a FeatureModule-ból, hogy más modulok is használhassák azt, akik importálják
              a FeatureModule-t</li>
            <li>Az AppModule importálja a FeatureModule-t, és így hozzáfér a FeatureModule által exportált elemekhez,
              beleértve a SharedModule által exportáltakat is</li>
            <li>Az AppModule-ban már nem szükséges külön importálni a SharedModule-t, mivel a FeatureModule már
              importálja és exportálja azt</li>
            <li>( A RouterModule adja a Router, Route, RouterLink, RouterOutlet direktívákat és egyéb routing
              funkciókat,
              amelyek lehetővé teszik az alkalmazás útvonalainak kezelését )</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #creatingchildroutes data-anchor="creatingchildroutes">Creating child routes</h5>
  <ul>
    <li>A modulunk child route-okat kap</li>
    <pre>
      <b>// app-routing.module.ts</b>
      const routes: Routes = [
        ...
        &#123;
          path: 'angular',
          component: AngularComponent,
          loadChildren: () => import('./angular/navi/navi.module').then(m => m.NaviModule), // Lazy load
        },
        ...
      ];

      <b>// navi-routing.module.ts</b>
      const routes: Routes = [
        ...
        &#123;
          path: 'moduling', outlet: 'module', children: [
            &#123; path: 'list', component: ListModuleComponent },
            &#123; path: 'overview', component: OverviewComponent },
          ]
        },
        ...
      ];

      <b>// navi.component.ts</b>
      &#60;ng-container *ngIf="tempSwitcher == 'module'">
        &#60;br>
        &#60;app-home-module>&#60;/app-home-module> // betöltődik a module mappában lévő home.component
        &#60;br>
      &#60;/ng-container>

      <b>// app-home.component.html</b>
        &#60;button [routerLink]="['/', 'angular']" class="btn btn-dark">Home&#60;/button>
        &#60;button [routerLink]="['/', 'angular', &#123; outlets: &#123; module: ['moduling', 'list'] } }]">List&#60;/button>
        &#60;button [routerLink]="['/', 'angular', &#123; outlets: &#123; module: ['moduling', 'overview'] } }]">Overview&#60;/button>

        &#60;router-outlet name="module">&#60;/router-outlet>

      <b>//</b>
    </pre>
    <li>Ez a kiindulási alap a téma demonstrálásához
      <ul>
        <li>Valójában nem történt modul létrehozás</li>
      </ul>
    </li>
    <li>Amennyiben több modulunk van, megadhatjuk a CLI-ben komponens létrehozásakor, hoogy melyik modulunkhoz
      szeretnénk hozzáadni az új komponenest</li>
    <pre>
      ng g c overview --module *modulnév*
    </pre>
    <li>Itt inkább a child route-ok hozzáadása, és a több szegmensből álló outlet-ek használata a hasznos</li>
    <br>
    <app-navi [tempSwitcher]="'module'"></app-navi>
    <br>
    <li>A 'list' és az 'overview' a 'moduling' route-hoz tartozik, ezért szeretnénk készíteni egy különálló route-ot a
      moduling module-nak
      <ul>
        <li>Legalábbis a következő témakörben</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #routesforfeaturemodule data-anchor="routesforfeaturemodule">Routes for feature module</h5>
  <ul>
    <li>Adott egy modul, ami tartalmazza az oda tartozó komponenseket, direktívákat, és egyéb importálásokat
      <ul>
        <li>Ennek a modulnak van route-ja</li>
        <pre>
          &#123;
            path: 'moduling', outlet: 'module', children: [ // moduling feature, amihez gyerek route-ok kapcsolódnak
              &#123; path: 'list', component: ListModuleComponent },
              &#123; path: 'overview', component: OverviewComponent },
            ]
          },
        </pre>
        <li>Ezeket a route-okat bevihetjük a moduling module routing-jába
          <ul>
            <li>Így a route-okat is elkülöníte, a module-on belül tudjuk kezelni</li>
            <li>Ehhez létrehozzuk a moduling-routing.module.ts fájlt, és a class-t beimportálni a module-ba</li>
            <pre>
              const routes: Routes = [
                &#123; path: '', component:  },
              }

              @NgModule(&#123;
                imports: [RouterModule.forChild(routes)], // a forRoot metódus a teljes applikációra vonatkozik, ezért szerepel itt forChild
                exports: [RouterModule]
              })
              export class ModulingRoutingModule &#123; }
            </pre>
            <li>A routes variable, nem property</li>
            <li>A komponenseket nem elég a router-ben deklarálni, a modulban is szükséges</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #creatingacoremodule data-anchor="creatingacoremodule">Creating a core module</h5>
  <ul>
    <li>Az Angular alkalmazás egyik fontos koncepciója</li>
    <li>Az alkalmazás központi funkcionalitásának kezelésére használnak</li>
    <li>A fő alkalmazás logikai részeit, alapvető szolgáltatásait, és azokat az elemeket jelöli, amelyeket az alkalmazás
      minden komponensében, szolgáltatásában, vagy moduljában igénybe kell venni</li>
    <li>Gyakran globális szolgáltatások, amelyeket nem akarunk többször importálni más modulokban
      <ol>
        <li>Szolgáltatások (Services)
          <ul>
            <li>AuthService - Felhasználói hitelesítést kezel</li>
            <li>LoggerService - Az alkalmazás naplózásáért felelős szolgáltatás</li>
            <li>ApiService - Az alkalmazás backendjével való kommunikáció</li>
            <li>NotificationService - A felhasználóknak szóló értesítéseket kezeli</li>
          </ul>
        </li>
        <li>Modulok
          <ul>
            <li>HTTP Modul - Az alkalmazás HTTP kommunikációját biztosítja</li>
            <li>Auth Modul - Az autentikációval kapcsolatos logika és komponensek</li>
          </ul>
        </li>
        <li>Központi komponens
          <ul>
            <li>LoaderComponent - Egy globális betöltő komponens, amely minden oldal alján megjelenhet</li>
          </ul>
        </li>
        <li>Utility funkciók
          <ul>
            <li>DateFormatter - Dátumok formázása</li>
            <li>MathUtility - Matematikai segédfunkciók</li>
          </ul>
        </li>
      </ol>
    </li>
    <li>A Core Module-ban deklarált szolgáltatásokat és egyéb erőforrásokat csak egyszer kell importálni az alkalmazásba
      <ul>
        <li>Általában az AppModule-ba</li>
        <li>Az alkalmazás minden egyes részében elérhetőek lesznek, nem szükséges őket külön-külön importálni</li>
      </ul>
    </li>
    <li>Minden modul ugyanazzal a módszerrel készíthető el
      <ul>
        <li>Class-t hozunk létre, és @NgModule-lal dekoráljuk</li>
      </ul>
    </li>
    <li>A Core és a Shared module közötti különbség
      <ul>
        <li>Core Module: Az alkalmazás alapvető szolgáltatásait, globális konfigurációkat és egyszeri példányú elemeket
          tartalmazza, és az alkalmazásban csak egyszer importáljuk, jellemzően az AppModule-ban</li>
        <li>
          Shared Module: Az alkalmazásban bárhol újrahasznosítható komponenseket, direktívákat, pipe-okat és egyéb
          vizuális elemeket tartalmazza, amelyeket bármely más feature modulban felhasználhatunk</li>
      </ul>
    </li>
    <li>Amennyiben az app.module.ts fájlban a providers tömbben elhelyezünk egy service-t, azt a példányt a teljes
      alkalmazásunkban használni tudjuk
      <ul>
        <li>Alternatív megoldás a providedIn: 'root' megadása a service dekorátor mate objektumában
          <ul>
            <li>Ez a legjobb megközelítés</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Amennyiben a providedIn-t nem használjuk, és core modulunk sincs, ugyanakkor sok a szervizünk, úgy jó sok minden
      fog szerepelni az app.module.ts fájlunkban</li>
    <li>Az egyik ok, amiért nagyonon hasznos a core modul, mert az app modul rendezettebb tud maradni</li>
    <li>A SharedModule-unkban jelenleg 2 db HttpInterceptor-t proovide-olunk (későbbi téma)
      <ul>
        <li></li>
        <pre>
          <b>// shared.mopdule.ts</b>
          @NgModule(&#123;
            declarations: [
              ...
            ],
            imports: [
              ...
            ],
            exports: [
              ...
            ],
            providers: [
              ...
              &#123; provide: HTTP_INTERCEPTORS, useClass: AuthInterceptorService, multi: true },
              &#123; provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptorService, multi: true }
            ]
          })
        </pre>
      </ul>
    </li>
    <li>Az app mappába, az app.module.ts fájl mellé készítsünk egy core.module.ts fájlt
      <ul>
        <li>Vigyük át az app modul providers tömbjét a core module-ba</li>
      </ul>
    </li>
    <pre>
      <b>// core.module.ts</b>
      registerLocaleData(localeHu);

      @NgModule(&#123;
          providers: [
              &#123;
                  provide: LOCALE_ID,
                  deps: [SettingsService],
                  useFactory: (settingsService: SettingsService) => settingsService.getLocale()
              }
          ]
      })

      export class CoreModule &#123;

      }

      <b>// app.module.ts</b>
      @NgModule(&#123;
        declarations: [
          ...
        ],
        imports: [
          ...
          CoreModule,
        ],
        providers: [ ],
        bootstrap: [AppComponent]
      })
    </pre>
    <li>Ne felejtsük el, hogy a szervizeket nem szükséges exportálni
      <ul>
        <li>Másképp működnek, mint a komponensek, vagy a direktívák</li>
      </ul>
    </li>
    <li>A core module alkalmazása opcionális</li>
  </ul>
  <br>
  <h5 #creatinganauthfeaturemodule data-anchor="creatinganauthfeaturemodule">Creating an auth feature module</h5>
  <ul>
    <li>Feature module</li>
    <li>A login komponensből készíthetünk egy auth module-t</li>
    <pre>
      <b>// auth.module.ts</b>
      @NgModule(&#123;
        declarations: [
          LoginComponent
        ],
        imports: [
          CommonModule,
          SharedModule,
          AuthRoutingModule
        ]
      })

      export class AuthModule &#123; }
    </pre>
    <li>Minden ugyanúgy működőképes marad, csak az authentikáció feature kap egy külön module-t</li>
  </ul>
  <br>
  <h5 #eagerloadingvslazyloading data-anchor="eagerloadingvslazyloading">Eager loading vs lazy loading</h5>
  <ul>
    <li>Az eddigiekben megnéztük, mi az a feature module, shared module, core module
      <ul>
        <li>Könnyebben átláthatóbbá, karbantarthatóbbá teszik a kódunkat</li>
      </ul>
    </li>
    <li>Alapvetően ezek használata még nem javítja az appunk teljesítményét
      <ul>
        <li>Amikor elindítjuk az alkalmazásunkat, betöltődik az összes modul, és a modulokban deklarált komponensek,
          direktívák, pipe-ok</li>
      </ul>
    </li>
    <li>Az Angular 2 statégiát nyújt a modulok betölésére
      <ol>
        <li>Eager loading
          <ul>
            <li>Minden, az AppModule imports tömbjében listázott modul az alkalmazás elindításával betöltődik</li>
            <li>Ez az alapértelmezett viselkedés</li>
            <li>A module-okban lévő összes komponensre, direktívára, pipe-ra, service-re vonatkozik</li>
            <li>Minden egyszerre töltődik be, amikor elindul az app</li>
          </ul>
        </li>
        <li>Lazy loading
          <ul>
            <li>Aszinkron modul betöltést tesz lehetővé</li>
            <li>Akkor történik meg, amikor az adott url-re navigálunk</li>
            <li>Az eager loading-os modulok betöltődnek, de a lazy load-osok nem az alkalmazás indulásakor</li>
            <li>Optimalizálja az alkalmazás indulását</li>
          </ul>
        </li>
      </ol>
      <br>
      <table style="width: 100%; table-layout: fixed">
        <thead>
          <tr>
            <th>Tulajdonság</th>
            <th>Eager Loading</th>
            <th>Lazy Loading</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Betöltés ideje</td>
            <td>Az alkalmazás indulásakor</td>
            <td>Amikor a felhasználó először elér egy adott útvonalat</td>
          </tr>
          <tr>
            <td>Teljesítmény</td>
            <td>Lassabb indulás, de az összes funkció azonnal elérhető</td>
            <td>Gyorsabb indulás, de az első használatkor lassabb lehet</td>
          </tr>
          <tr>
            <td>Konfiguráció</td>
            <td>Egyszerű</td>
            <td>Összetettebb</td>
          </tr>
          <tr>
            <td>Használat</td>
            <td>Kis projektekhez vagy alapértelmezett funkciókhoz</td>
            <td>Nagy projektekhez vagy ritkán használt funkciókhoz</td>
          </tr>
        </tbody>
      </table>
    </li>
  </ul>
  <br>
  <h5 #implementinglazyloading data-anchor="implementinglazyloading">Implementing lazy loading</h5>
  <ul>
    <li>Alapvetően minden modulunk eager loading stratégia szerint töltődik be</li>
    <li>Jó teszt lehet megnézni a DevTools network tab-jén, hogy mekkora bundle-ök töltődnek be lazy load-tól mentesen,
      és lazy load-ot használva</li>
    <li>A modulok lazy load betöltésének implementálásához a route-okba szükséges egy kicsit belenyúlnunk</li>
    <li>Az újabb verziókban az alábbi módon történik a lazy loading
      <ul>
        <pre>
          <b>// app-routing.module.ts</b>
          const routes: Routes = [
            ...
            &#123;
              path: 'angular',
              component: AngularComponent,
              loadChildren: () => import('./angular/navi/navi.module').then(m => m.NaviModule), // Lazy load
            },
            ...
          ]
        </pre>
        <li>A () => import('./angular/navi/navi.module') függvény visszaadja az összes modul class-t, ami a fájlban
          szerepel</li>
        <li>Promise-t ad vissza, ezért használjuk a then metódust rajta</li>
        <li>A then()-nek is egy callback függvényt adunk, ami visszaad egy objektumot, a modulokat, és innen térünk
          vissza az általunk használandó module class nevével</li>
      </ul>
    </li>
    <li>Pontosan meg kell határoznunk, melyik module class-t töltjük be
      <ul>
        <li>Egy fájlon belül több osztályunk is lehet(ne)</li>
      </ul>
    </li>
    <li>A korábbi Angular verziókban a loadChildren kulcs string értéket várt
      <ul>
        <li>Az újabb verziókban az érték típusa LoadChildrenCallback</li>
        <pre>
            const routes: Routes = [
              ...
              &#123;
                path: 'angular',
                component: AngularComponent,
                loadChildren: './angular/navi/navi.module#NaviModule'
              },
              ...
            ]
          </pre>
      </ul>
    </li>
    <li>Amikor a route-unk 'angular' lesz, az app betölti a NaviModule-t</li>
    <li>Viszont amennyiben mondjuk a NaviModule-t beimportáljuk az AppModule-ba, szabotáljuk a lazy loading-ot
      <ul>
        <li>Ha egy modult lazy loading-gal töltünk be, azt nem szabad máshol importálni</li>
        <pre>
          // import &#123; NaviModule } from './angular/navi/navi.module';
        </pre>
        <li>A lazy loading modulok esetében csak a routingban szükséges megadni a modult</li>
        <li>Az alkalmazás felépítése miatt az app.module.ts-ben importálva van a NaviModule</li>
      </ul>
    </li>
    <li>A lazy loading implementálása után indísuk újra az appunkat, hogy lássuk az eredményt</li>
    <li>A main.js-től lehet várni - komplexitástól függően - méretbeli változást (csökkenést)</li>
    <li>A network tab-en is nyomon követhető a route-ra érkezéskor fájlbetöltés
      <ul>
        <li>Javascript file</li>
        <li>A neve a konfigurációtól függ, illetve production buildben is más nevet kap, mint csak dev szervert futtatva
        </li>
        <pre>
            src_app_login_auth-module.ts.js
        </pre>
      </ul>
    </li>
    <li>Lazy loaded module elkészítésének lépései
      <ol>
        <li>Komponens létrehozása (ng g c)</li>
        <li>Modul létrehozása (ng g m --routing)
          <ul>
            <li>Hozzuk létre a module, és a routing file-t</li>
            <pre>
              <b>// AngularPlusModule</b>
              @NgModule(&#123;
                declarations: [AngularplusComponent],
                imports: [
                    CommonModule,
                    AngularPlusRoutingModule
                ],
              })
              
              export class AngularPlusModule &#123; }

              <b>// AngularPlusRoutingModule</b>
              const routes: Route[] = [
                  &#123; path: '', component: AngularplusComponent }
              ]

              @NgModule(&#123;
                  imports: [RouterModule.forChild(routes)],
                  exports: [RouterModule]
              })

              export class AngularPlusRoutingModule &#123; }
            </pre>
          </ul>
        </li>
        <li>Route megadása
          <ul>
            <li>Készítsük el a lazy loaded route-ot</li>
            <pre>
              <b>// app-routing.module.ts</b>
              const routes: Routes = [
                ...
                &#123; path: 'angularplus', loadChildren: () => import('./angularplus/angularplus.module').then(mod => mod.AngularPlusModule) },
                ...
              ];
            </pre>
          </ul>
        </li>
      </ol>
    </li>
    <li>Nagyon-nagyon fontos, hogy miután a routing-ban megadtuk a modulunk nevét, ne adjuk hozzá a modult külön az
      @NgModule import tömbjéhez, mert ezzel a lépéssel kigáncsoljuk a lazy loading-t, azaz nem fog működni</li>
  </ul>
  <br>
  <h5 #preloadinglazymodules data-anchor="preloadinglazymodules">Pre-loading lazy loaded modules</h5>
  <ul>
    <li>Van egy kis probléma a lazy loading megközelítéssel
      <ul>
        <li>A felhasználónak a lazy load module betöltődésekor meg kell várnia, amíg letöltődik az adatcsomag</li>
        <li>Optimális esetben kis idő, de még így is tapasztal(hat) a felhasználó egy kis késést</li>
        <li>Ennek elkerülése érdekében megmondhatjuk az Angularnak, hogy töltse elő a lazy load modulokat, ahelyett,
          hogy csak az adott útvonalra tévedéskor történne meg a betöltés</li>
        <li>A gyakorlatban ez annyit jelent, hogy amikor az alkalmazás betöltődött, az Angular utána a színfalak mögött
          betölti a lazy load modulokat</li>
        <li>A fő modulunkban tudjuk bekonfigurálni
          <ul>
            <li>A forRoot metódusnak átadhatunk egy második argomentumot</li>
            <li>Objektum</li>
            <li>Az egész alkalmazásra hatással van az itteni konfig</li>
          </ul>
        </li>
        <pre>
          <b>// app-routing.module.ts</b>

          @NgModule(&#123;
            imports: [RouterModule.forRoot(routes, &#123;
              ...
              preloadingStrategy: PreloadAllModules // default értéke a NoPreloading
            })],
            exports: [RouterModule]
          })
          export class AppRoutingModule &#123;
          }
        </pre>
        <li>Ne felejtsük el, hogy nem egy bundle-ön belül lesz az összes kódunk
          <ul>
            <li>Minden feature module egy külön bundle-ben fog letöltődni</li>
            <li>Az initial load után, amint lehet, letöltődnek</li>
          </ul>
        </li>
        <li>A felhasználónak nem lesz majd szükséges várnia, amíg letöltődik a module fájl, amikor az adott útvonalra
          navigál</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #providingserviceinlazyloadedmodules data-anchor="providingserviceinlazyloadedmodules">
    Providing service in lazy loaded modules</h5>
  <ul>
    <li>Service-t különféle helyekről provide-olhatunk az applikációnkban
      <ol>
        <li>providedIn: root
          <ul>
            <li>Ugyanaz a példány elérhető a teljes alkalmazásban</li>
          </ul>
        </li>
        <li>AppModule
          <ul>
            <li>Ugyanaz a példány elérhető a teljes alkalmazásban</li>
          </ul>
        </li>
        <li>Component
          <ul>
            <li>Ugyanaz a példány elérhető a komponens fában (a komponensben és az összes gyerekeiben)</li>
          </ul>
        </li>
        <li>Eager loaded module
          <ul>
            <li>Ugyanaz a példány elérhető a teljes alkalmazásban</li>
          </ul>
        </li>
        <li>Lazy loaded module
          <ul>
            <li>Ugyanaz a példány elérhető a modulban</li>
          </ul>
        </li>
      </ol>
    </li>
  </ul>
</div>

<div>
  <h3 #templateoperations data-anchor="templateoperations">Template operations</h3>
  <ul>
    <li>Első körben behúztunk egy minify-olt CSS-t
      <ul>
        <li>&#60;link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css"&#62;</li>
        <li>Favágó megoldás, vannak jobb módszerek stílusok alkalmazására Angularban</li>
      </ul>
    </li>
    <br>
    <li>
      <h5 #stringinterpolationops data-anchor="stringinterpolationops">String interpoláció (sablon művelet)</h5>
      <ul>
        <li>Dupla kapcsos zárójelek közé dinamikus tartalom kerülhet</li>
        <li>&#123; &#123; &#125; &#125;</li>
        <li>Természetesen mindenhol szorosan egymás mellett vannak a megegyező irányú zárójelek</li>
      </ul>
    </li>
    <li>
      <h5 #ngforops data-anchor="ngforops">*ngFor strukturális direktíva (sablon művelet)</h5>
      <ul>
        <li>
          <pre>
                        &#60;div *ngFor="let elem of elems; let last = last; let i = index"&#62;
                            &#60;span&#62;&#123; &#123; elem &#125; &#125;&#60;/span&#62;
                        &#60;span class="trash" (click)="removeElem(i)"&#62;&#60;/span&#62;
                        &#60;hr *ngIf="!last"&#62;
                        &#60;/div&#62;
                    </pre>
          <ul>
            <li>A 'last' a ciklus utolsó elemre vonatkozik</li>
            <li>Ebben az esetben br tag az utolsó elem után nem jelenik meg</li>
          </ul>
        </li>
        <li>Tömb elemein lehet végigiterálni</li>
        <li>Mindegyik elem kapcsán ki lehet generálni valamilyen HTML tartalmat</li>
        <li>Bármilyen elemre rá lehet aggatni</li>
        <li>*ngFor="let elem of elems"</li>
        <li>Az iterációba bemenet lehet bármelyik állapotváltozó</li>
        <li>Iteráción belül egy elemre az 'elem' változóval lehet hivatkozni a fenti példában</li>
        <li>A let kulcsszó után bármilyen név adható a változónak</li>
        <li>form-ból tömbhöz elemet hozzáadni az alábbi módon lehetséges
          <ul>
            <li>
              <pre>
                                &#60;form (submit)="newElem($event)"&#62;
                                    &#60;input name="title" value="" placeholder="New elem"&#62;
                                    &#60;button type="submit"&#62;Send&#60;/button&#62;
                                &#60;/form&#62;

                                newElem(event: any) &#123;
                              event.preventDefault();
                              const newElem = event.target.elements.title.value;
                              this.elems.push(newElem);
                              event.target.reset();
                                &#125;
                            </pre>
            </li>
            <li>A push() method a memóriában közvetlenül módosítja a tömb értékét</li>
            <li>Az event.target.reset() method a form összes input mezőjének az értékét kinullázza</li>
          </ul>
        </li>
        <li>Az iterációban hozzájuthatunk az adott elem indexéhez
          <ul>
            <li>*ngFor="let elem of elems; let i = index"</li>
            <li>Az 'i' karakterrel hivatkozunk az aktuális elem indexére</li>
            <li>
              <pre>
                                removeElem(index: number) &#123;
                              this.elems.splice(index, 0);
                                &#125;
                            </pre>
              <ul>
                <li>A splice() methoddal az állapotot közvetkenül manipulálhatjuk</li>
                <li>Indexet vár, és a törlendő elemek számát</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>
      <h5 #ngifops data-anchor="ngifops">*ngIf strukturális direktíva (sablon művelet)</h5>
      <ul>
        <li>Bizonyos boolean érték függvényében megjelenít / elrejt</li>
        <li>
          <pre>
                        &#60;form *ngIf="elems.length < 5" (submit)="newElem($event)"&#62;
                            &#60;input #formInput name="title" value="" ngModel placeholder="New elem"&#62;
                            &#60;button type="submit" [disabled]="formInput.value === ''">Send&#60;/button&#62;
                      &#123; &#123; formInput.value &#125; &#125;
                      &#60;/form&#62;
                    </pre>
          <ul>
            <li>Ahhoz, hogy az Angular érzékelje azt, hogy megváltozott az input értéke (formInput.value),
              szükség van az ngModelre
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>
      <h5 #ngtemplateops data-anchor="ngtemplateops">&#60;ng-template&#62;</h5>
      <ul>
        <li>Egy HTML snippet-et (kódrészletet) hordoz magában, ami úgy viselkedik, mint egy template, és kirenderelhető
          a DOM-ba
        </li>
        <li>Angular elem</li>
        <li>El kell látni valami egyedi azonosítóval</li>
        <li>Bármilyen HTML tartalom beleírható</li>
        <li>Strukturális direktívákkal szokták együtt használni
          <ul>
            <li>Leggyakoribb egy if statement else ágának megjelenítése</li>
            <pre>
              &#60;>div *ngIf="elemek.length < 5; else elemsLengthReachedMax">&#60;/div>

              &#60;ng-template #elemsLengthReachedMax&#62;
                  &#60;h5&#62;Max length of elems reached!&#60;/h5&#62;
              &#60;/ng-template&#62;
            </pre>
          </ul>
        </li>
        <li>ngTemplateOutlet
          <ul>
            <li>Struktúrális direktíva</li>
            <li>Template-et renderel, manipulál a weboldalon</li>
            <li>Miután elkészítettük a template-ünket, template referencia változót szükséges adnunk neki</li>
            <li>ngTemplateOutlet nélkül nem jelenik meg semmi a template-ből</li>
            <br>
            <app-ng-hyphen [ngType]="'template'"></app-ng-hyphen>
            <br>
            <pre>
              &#60;app-ng-hyphen [ngType]="'template'">&#60;/app-ng-hyphen>

              &#60;ng-template #ngtemplateexample>
                &#60;h6>Ez egy template.&#60;/h6>
                &#60;p>Template paragráfus.&#60;/p>
              &#60;/ng-template>

              &#60;div *ngTemplateOutlet="ngtemplateexample">&#60;/div>
            </pre>
            <app-ng-hyphen #ngtemplate [ngType]="'template2'"></app-ng-hyphen>
            <br>
            <button type="button" class="btn" [ngClass]="ngtemplate.isAvailable ? 'btn-success' : 'btn-danger'"
              (click)="ngtemplate.isAvailable = !ngtemplate.isAvailable">
              Toggle ng-template isAvailable variable
            </button>
            <div>isAvailable: {{ ngtemplate.isAvailable }}</div>
            <br>
            <pre>
              &#60;app-ng-hyphen #ngtemplate [ngType]="'template2'">&#60;/app-ng-hyphen>

              &#60;button type="button" class="btn"
                      [ngClass]="ngtemplate.isAvailable ? 'btn-success' : 'btn-danger'"
                      (click)="ngtemplate.isAvailable = !ngtemplate.isAvailable">
                Toggle ng-template isAvailable variable
              &#60;/button>
              &#60;div>isAvailable: &#123; &#123; ngtemplate.isAvailable }}&#60;/div>

              &#60;h6>Template 2&#60;/h6>
              &#60;div *ngIf="isAvailable; else ngtemplateelseexample">
                Available
              &#60;/div>

              &#60;ng-template #ngtemplateelseexample>
                Not available
              &#60;/ng-template>
            </pre>
            <li>A template referencia változón keresztül manipulálható a komponens belső property-je</li>
            <li>Amennyiben az isAvailable változó hamis, úgy egy template fog megjelenni</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>
      <h5 #ngcontainerops data-anchor="ngcontainerops">&#60;ng-container&#62;</h5>
      <ul>
        <li>Speciális Angular elem</li>
        <li>Struktúrális direktívákat adhatunk neki, anélkül, hogy új elem jelenne meg a DOM-ban</li>

        <li>
          <pre>
              &#60;ng-container *ngFor="let elem of elemek; let i = index"&#62;
                &#60;span&#62; &#123; &#123;i + 1&#125; &#125;. &#123; &#123; elem &#125; &#125;&#60;/span&#62;
                &#60;button (click)="elemTorlese(i)">Törlés&#60;/button&#62;
                &#60;hr&#62;
              &#60;/ng-container&#62;
          </pre>
        </li>
        <li>A konténer, amire az *ngFor strukturális direktíva került, nem fog megjelenni a DOM-ban</li>
        <li>Ha csak nem követünk el valamilyen hibát, a működést semmilyen módon sem befolyásoljuk</li>
        <li>Akkor is nagyon használatos, amikor egyetlen sablondarabkára szeretnénk egyszerre *ngIf és *ngFor
          strukturális direktívát ráaggatni
        </li>
        <li>Ez esetben nem alkalmazhatjuk az ngIf else ágában a referencia változót</li>
        <pre>
          // Ilyen nincs
          &#60;div *ngIf="variable; else toggle>Text&#60;/div>

          &#60;ng-container #toggle>Other text&#60;/ng-container>
        </pre>
        <app-ng-hyphen #ngtemplate [ngType]="'container'"></app-ng-hyphen>
        <br>
        <li>Abban különbözik a fenti példa az ng-template-nél látottól, hogy az elem, amire a ngTemplateOutlet került,
          nem
          egy div, hanem ng-container, azaz, ahol kirenderelődik a template-ünk tartalma, ott nem lesz a template
          beágyazva egy div-ba
        </li>
        <pre>
          &#60;ng-template #ngtemplateexample>
            &#60;h6>Ez egy template.&#60;/h6>
            &#60;p>Template paragráfus.&#60;/p>
          &#60;/ng-template>

          &#60;ng-container *ngTemplateOutlet="ngtemplateexample">&#60;/ng-container>
        </pre>
        <li>Egy elemre egyszerre csak egy direktíva alkalmazható
          <ul>
            <li>
              <pre>
                  &#60;ng-container *ngIf="elemek.length < 5; else maxElemszamElerve;" *ngFor="let elem of elemek; let i = index"&#62;
              </pre>
              <ul>
                <li>Ez nem működik</li>
              </ul>
            </li>
            <li>Beágyazott ng-container-t szokás alkalmazni</li>
          </ul>
        </li>
        <li>A click event nem működik rajta</li>
      </ul>
    </li>
    <li>
      <h5 #ngcontentops data-anchor="ngcontentops">&#60;ng-content&#62;</h5>
      <ul>
        <li>A komponens szelektorokba írhatunk tartalmat, amik a megfelelő helyen meg tudnak jelenni a komponens
          template-jében
        </li>
        <li>Ha csak úgy beleírunk valamit a szelektorba, nem történik semmi, a beemelt komponens tartalma fog
          megjelenni
        </li>
        <app-ng-hyphen #ngtemplate [ngType]="'content'">
          Selector content
        </app-ng-hyphen>
        <pre>
          &#60;app-ng-hyphen #ngtemplate [ngType]="'content'">
            Selector content
          &#60;/app-ng-hyphen>

          &#60;div *ngIf="ngType === 'content'" class="rounded-border">
            Child content
          &#60;/div>
        </pre>
        <li>Rendkívül hasznos tud lenni az ng-content, amennyiben ugyanúgy kinéző elemekből többet szükséges kiraknunk
          az oldalra
        </li>
        <br>
        <div class="rounded-border">
          <app-ng-hyphen [ngType]="'content2'">Hello</app-ng-hyphen>
          <app-ng-hyphen [ngType]="'content2'">Szia</app-ng-hyphen>
          <app-ng-hyphen [ngType]="'content2'">Szevasz</app-ng-hyphen>
        </div>
        <pre>
          &#60;app-ng-hyphen [ngType]="'content2'">Hello&#60;/app-ng-hyphen>
          &#60;app-ng-hyphen [ngType]="'content2'">Szia&#60;/app-ng-hyphen>
          &#60;app-ng-hyphen [ngType]="'content2'">Szevasz&#60;/app-ng-hyphen>

          // app-ng-hyphen
          &#60;div *ngIf="ngType === 'content2'">
            &#60;div class="rounded-border">
              &#60;div>Text before ng-content&#60;/div>
              &#60;ul>
                &#60;li>
                  &#60;span style="color: #9d2626">
                    &#60;ng-content>&#60;/ng-content>
                  &#60;/span>
                  &#60;small> (ng-content)&#60;/small>
                &#60;/li>
              &#60;/ul>
              &#60;div>Text after ng-content&#60;/div>
            &#60;/div>
          &#60;/div>
        </pre>
        <li>Bármi, amit beírunk a komponens class szelektorba, megjelenik az ng-content helyén</li>
        <li>Content projection-nek hívják
          <ul>
            <li>Mód, amellyel HTML tartalom adható át a szülőtől a gyerek komponensnek</li>
          </ul>
        </li>
        <li>Amennyiben több ng-content-et helyezünk el a kódunkban, a legutolsó helyére fog kirenderelődni a tartalom,
          amit a szelektorba írtunk
        </li>
        <li>Arra is van lehetőség, hogy több helyre beszúrjunk a komponens szelektorból HTML-t
          <ul>
            <li>Az ng-content-en a [select] attribútumot szükséges használni</li>
            <li>CSS osztályok használhatók kiválasztásra</li>
          </ul>
        </li>
        <div class="rounded-border">
          <app-ng-hyphen [ngType]="'content3'">
            <span class="text">Hello</span>
            <button type="button" class="btn btn-secondary">Useless button</button>
          </app-ng-hyphen>
          <app-ng-hyphen [ngType]="'content3'">
            <span class="text">Szia</span>
            <button type="button" class="btn btn-secondary">Useless button</button>
          </app-ng-hyphen>
          <app-ng-hyphen [ngType]="'content3'">
            <span class="text">Szevasz</span>
            <button type="button" class="btn btn-secondary">Useless button</button>
          </app-ng-hyphen>
        </div>
        <pre>
          &#60;app-ng-hyphen [ngType]="'content2'">
            &#60;span class="text">Hello&#60;/span>
            &#60;button type="button" class="btn btn-secondary">Useless button&#60;/button>
          &#60;/app-ng-hyphen>
          &#60;app-ng-hyphen [ngType]="'content2'">
            &#60;span class="text">Szia&#60;/span>
            &#60;button type="button" class="btn btn-secondary">Useless button&#60;/button>
          &#60;/app-ng-hyphen>
          &#60;app-ng-hyphen [ngType]="'content2'">
            &#60;span class="text">Szevasz&#60;/span>
            &#60;button type="button" class="btn btn-secondary">Useless button&#60;/button>
          &#60;/app-ng-hyphen>

          // app-ng-hyphen
          &#60;div *ngIf="ngType === 'content3'">
            &#60;div class="rounded-border">
              &#60;div>Text before ng-content&#60;/div>
              &#60;ul>
                &#60;li>
                  &#60;span style="color: #9d2626">
                    &#60;ng-content select=".text">&#60;/ng-content>
                  &#60;/span>
                  &#60;small> (ng-content select=".text")&#60;/small>
                &#60;/li>
              &#60;/ul>
              &#60;div>Text after ng-content&#60;/div>
              &#60;ng-content select=".btn-secondary">&#60;/ng-content>
              &#60;small> (ng-content select=".btn-secondary")&#60;/small>
            &#60;/div>
          &#60;/div>
        </pre>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #databinding data-anchor="databinding">Data binding</h3>
  <ul>
    <li>A komponens class és a template kommunikációját jelenti (oda-vissza)</li>
    <li>Legegyszerűbb példa:
      <pre>
        export class AngularComponent &#123;
          example: string = 'Ez csak egy példa';
        })

        {{ example }} // &#123; &#123; example }}
      </pre>
      <ul>
        <li>
          A kontrollerből beleíródik a duplakapcsos zárójelek közé a változó értéke
        </li>
      </ul>
      <pre>
        export class AngularComponent &#123;
          display: boolean = false;
        })

        &#60;div [hidden]="display">&#60;/div>
      </pre>
      <ul>
        <li>A szögletes zárójel a befelé irányuló kommunikációt jelzi, azaz, a div tag hidden attribútuma megkapja a
          class display változójának mindenkori aktuális értékét
        </li>
      </ul>
    </li>
    <li>Template-ből is küldhetünk adatot a classnak
      <pre>
        &#60;button type="button" class="btn btn-danger" (click)="onDataBindFromHTMLToClass()">
          Data binding to class from template  (&#123; &#123;testToastIsVisible ? 'ON' : 'OFF' }})
        &#60;/button>

        &#60;div class="toast-container position-fixed top-0 end-0 p-3">
        &#60;div class="toast" [ngClass]="&#123;'show': testToastIsVisible}" role="alert">
          &#60;div class="toast-header">
            &#60;strong class="me-auto">Bootstrap toast&#60;/strong>
            &#60;small class="text-body-secondary">now&#60;/small>
            &#60;button type="button" class="btn-close" (click)="testToastIsVisible = false">&#60;/button>
          &#60;/div>
          &#60;div class="toast-body">
            This is a Bootstrap toast message
          &#60;/div>
        &#60;/div>
      &#60;/div>

        onDataBindFromHTMLToClass() &#123;
          this.testToastIsVisible = !this.testToastIsVisible;
        }
      </pre>
      <br>
      <button type="button" class="btn btn-danger" (click)="onDataBindFromHTMLToClass()">
        Data binding to class from template ({{ testToastIsVisible ? 'ON' : 'OFF' }})
      </button>
      <div class="toast-container position-fixed top-0 end-0 p-3">
        <div class="toast" [ngClass]="{'show': testToastIsVisible}" role="alert">
          <div class="toast-header">
            <strong class="me-auto">Bootstrap toast</strong>
            <small class="text-body-secondary">now</small>
            <button type="button" class="btn-close" (click)="testToastIsVisible = false"></button>
          </div>
          <div class="toast-body">
            This is a Bootstrap toast message
          </div>
        </div>
      </div>
      <ul>
        <li>Amennyiben megnyomjuk a gombot, a komponens osztály tudomást szerez róla</li>
        <li>A kerek zárójel a templateből a kontroller felé irányuló információt jelzi</li>
        <li>A method-oknak paramétereket is átadhatunk</li>
      </ul>
    </li>
    <li>A fentiekből adódóan két fajtáját különböztetjük meg:
      <ol>
        <li>One way data binding
          <ul>
            <li>Adatot adunk át templateből a kontrollernek, vagy a kontrollerből a templatenek</li>
            <li>Ebből adódik, hogy két fajtáját különböztetjük meg:
              <ol>
                <li>Kontrollerből template-be történő adatátadás:
                  <ul>
                    <li>Két módon történhet:
                      <ul>
                        <li>String interpoláció
                          <ul>
                            <li>Adat megjelenítésére szolgál a template-ben</li>
                            <li>A string interpoláció az alábbi 3 HTML attribútummal nem működik:
                              <ol>
                                <li>disabled</li>
                                <li>hidden</li>
                                <li>checked</li>
                              </ol>
                            </li>
                            <pre>
                              &#60;div>
                                ...

                                &#123; &#123; data }}

                                &#123; &#123; '1.' + data }} // Összefűzés (+)
                                &#123; &#123; data * 50 }} // Bármilyen Typescript kifejezést írhatunk a dupla kapcsoszárójelek közé
                                &#123; &#123; calculateDiscountPrice() }}
                                &#123; &#123; calculateDiscountPrice().toFixed(0) }} // Typescript method-okat is használhatunk
                                &#123; &#123; inStock > 0 ? 'In stock' : 'Out of stock'  }} // Ternary operator
                                ...
                              &#60;/div>

                              calculateDiscountPrice() &#123;
                                return this.originalPrice * (100 - discountPercent) / 100;
                              }
                            </pre>
                          </ul>
                        </li>
                        <li>Property binding
                          <ul>
                            <li>DOM elemnek adhatunk property-t</li>
                            <pre>
                              &#60;div>
                                ...
                                [property]="data"

                                &#60;img [src]="imgSrc"> // Property binding syntax
                                &#60;button [disabled]="inStock ? true : false" >&#60;/button>
                                &#60;input bind-value="John Doe" bind-disabled="inStock ? true : false"> // A 'bind-' használatávan is működik
                                ...
                              &#60;/div>
                            </pre>
                          </ul>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>Template-ből kontrollerbe történő adatátadás:
                  <div>
                    <input [value]="personName">
                    <div>name: {{ personName }}</div>
                  </div>
                  <ul>
                    <li>A property binding miatt átírva az input értékét, a string interpoláció "értéke" nem
                      változik
                    </li>
                  </ul>
                  <pre>
                    &#60;div>
                        ...
                        // Event binding
                        (data)="expression"

                        name: string = "Ryan Smith";

                        &#60;input [value]="name">
                        &#60;div>name: &#123; &#123;name}}&#60;/div>
                        ...
                    &#60;/div>
                  </pre>
                  <ul>
                    <li>Amennyiben szeretnénk változást, event bindingot szükséges használnunk</li>
                    <input [value]="personName" (input)="onNameChange($event)">
                    <li>Input event-re lefut egy method</li>
                    <li>Minden karakterleütésnél egy input event object keletkezik
                      <ul>
                        <li>A $event változóval hozzáférhetünk</li>
                        <li>A kontrollerben ezt az event paramétert adjuk át</li>
                      </ul>
                    </li>
                    <pre>
                      &#60;input [value]="personName" (input)="onNameChange($event)">

                      onNameChange(e: any) &#123;
                        this.personName = e.target.value;
                      }
                    </pre>
                    <li>Az event target kulcsa alatt található value az az érték, amit aktuálisan az input mező
                      tartalmaz
                    </li>
                  </ul>
                </li>
              </ol>
            </li>
          </ul>
        </li>
        <li>Two-way data binding
          <ul>
            <li>Az adat mindkét irányba (template <--> kontroller) folyhat</li>
            <li>Ha a kettő közül bármelyikben változtatunk, annak hatása van a másikra is</li>
            <li>Ennek elérésére az [ngModel]-t használjuk</li>
            <li>Property és Event binding kombinációja</li>
            <li>A szülő modulba be kell importálni a FormsModule-t</li>
            <br>
            <pre>
              &#60;app-search> &#60;/app-search>
            </pre>
            <app-search [shownInput]="'learning'"></app-search>
            <br>
          </ul>
        </li>
      </ol>
    </li>
    <br>
    <li>Attribútumot is lehet bind-olni, a következő módon:</li>
    <pre>
      &#60;input [attr.aria-hidden]>
    </pre>
    <br>
    <div>
      <button (click)="decreaseCartCounter()">-</button>
      <span>{{ cartCounter }}</span>
      <button (click)="increaseCartCounter()">+</button>
    </div>
    <pre>
      &#60;div>
        &#60;button (click)="decreaseCartCounter()">-&#60;/button>
        &#60;span>&#123; &#123; cartCounter }}&#60;/span>
        &#60;button (click)="increaseCartCounter()">+&#60;/button>
      &#60;/div>

      decreaseCartCounter() &#123;
        this.cartCounter > 0 ? this.cartCounter-- : null;
      }

      increaseCartCounter() &#123;
        this.cartCounter++;
      }
    </pre>
    <div>
      <button (click)="cartCounter = (cartCounter - 1)">-</button>
      <span>{{ cartCounter }}</span>
      <button (click)="cartCounter = (cartCounter + 1)">+</button>
    </div>
    <pre>
      &#60;div>
        &#60;button (click)="cartCounter = (cartCounter - 1)">-&#60;/button> // Click event binding
        &#60;span>&#123; &#123; cartCounter }}&#60;/span>
        &#60;button (click)="cartCounter = (cartCounter + 1)">+&#60;/button> // Click event binding
      &#60;/div>
    </pre>
  </ul>
</div>

<div>
  <h3 #directives data-anchor="directives">Directives</h3>
  <ul>
    <li>A DOM manipulálására használjuk; hogyan működjön, vagy nézzen ki a DOM elem</li>
    <li>3 csoportba szedhetjük őket:
      <ol>
        <li>Komponens direktíva
          <ul>
            <li>Nem más, mint a komponens</li>
            <li>A komponens tehát egy direktíva is, de egy template-tel rendelkező direktíva</li>
            <li>A többi direktíva típusnak nincs template-je</li>
          </ul>
        </li>
        <li>Attribútum direktíva
          <ul>
            <li>A kinézetét, vagy a működését tudjuk befolyásolni, megváltoztatni a DOM elemeknek</li>
            <li>Nincs template-je</li>
            <li>Akár feltételesen is lehet használni</li>
            <li>Direktíva létrehozása a következő parancssal történik: ng g d *directiveName*</li>
            <pre>
              import &#123; Directive, ElementRef, OnInit, Renderer2 } from '@angular/core';

              @Directive(&#123;
                selector: '[changeToGreen]'
              })

              export class ChangeToGreenDirective implements OnInit &#123;
                @Input() set changeToGreen(condition: boolean) &#123;
                  condition ? this.setColor('#1aff00') : this.setColor('#bfff00');
                }

                constructor(private elementRef: ElementRef, private renderer: Renderer2) &#123;
                }

                ngOnInit() &#123;
                  this.setColor('#bfff00');
                }

                setColor(color: string) &#123;
                  this.renderer.setStyle(
                    this.elementRef.nativeElement,
                    "color",
                    color
                  );
                }
              }
            </pre>
            <li [changeToGreen]="changeToDarkerGreen">Úgy használhatjuk, mint egy attribútum</li>
            <button type="button" class="btn btn-secondary" [changeToGreen]="changeToDarkerGreen"
              (click)="changeToDarkerGreen = !changeToDarkerGreen">
              {{ changeToDarkerGreen ? 'Lighten green text' : 'Darken green text' }}
            </button>
            <pre>
              &#60;li changeToGreen>Úgy használhatjuk, mint egy attribútum&#60;/li>

              &#60;button type="button" class="btn btn-secondary"
                      [changeToGreen]="changeToDarkerGreen"
                      (click)="changeToDarkerGreen = !changeToDarkerGreen">
                      &#123; &#123; changeToDarkerGreen ? 'Lighten green text' : 'Darken green text' }}
              &#60;/button>
            </pre>
            <li>Beépített attribútum direktívák is léteznek, mint az [ngClass], és az [ngStyle]</li>
          </ul>
        </li>
        <li>Struktúrális direktíva
          <ul>
            <li>A DOM elrendezését tudja változtatni, elem hozzáadásával, vagy elvételével</li>
            <li>Ugyancsak nincs template-je</li>
            <li>Beépített Angular direktívák például:
              <ul>
                <li>ngFor</li>
                <li>ngIf</li>
                <li>ngSwitch</li>
              </ul>
            </li>
            <li>* szükséges eléjük, ezzel mondjuk meg az Angularnak, hogy struktúrális direktívát használunk épp</li>
          </ul>
        </li>
      </ol>
    </li>
    <li>A direktíva is egy Typescript class, amit @Directive dekorátorral ruházunk fel</li>
    <br>
    <h5 #ngfor data-anchor="ngfor">ngFor</h5>
    <ul>
      <li>Struktúrális direktíva</li>
      <li>Végigiterál egy listán, és template szerint HTML elemeket készít</li>
      <li>Iteráljunk végig egy egyszerű tömbön (number[]):
        <div *ngFor="let number of [2, 5, 9]">
          <span> - Current item of the array: {{ number }}</span>
        </div>
        <pre>
          &#60;div *ngFor="let number of [2, 5, 9]">
            &#60;span> - Current item of the array: &#123; &#123; number }}&#60;/span>
          &#60;/div>
        </pre>
      </li>
      <li>Iteráljunk végig egy egyszerű változón, ami egy string tömb (string[]):
        <div *ngFor="let word of sampleStringArray">
          <span> - Current item of the array: {{ word }}</span>
        </div>
        <pre>
          &#60;div *ngFor="let word of sampleStringArray">
            &#60;span> - Current item of the array: &#123; &#123; word }}&#60;/span>
          &#60;/div>

          sampleStringArray: string[] = ['pin', 'shelf', 'club'];
        </pre>
      </li>
      <li>Komplexebb tömb:
        <div *ngFor="let vehicle of sampleCompexArray"
          style="display: grid; grid-template-columns: auto 1fr; gap: 10px">
          <img [src]="vehicle.img" width="200px" height="120px">
          <div>
            <div><b>ID: </b>{{ vehicle.id }}</div>
            <div><b>Label: </b>{{ vehicle.label }}</div>
            <div><b>Type: </b>{{ vehicle.type }}</div>
            <div><b>Weight: </b>{{ vehicle.details.weight }} kg</div>
            <div><b>Available colors ({{ vehicle.details.colors.length }}): </b>
              <span *ngFor="let color of vehicle.details.colors; let last = last">
                {{ color }}<span *ngIf="!last">, </span>
              </span>
            </div>
          </div>
          <br>
        </div>
        <pre>
          &#60;div *ngFor="let vehicle of sampleCompexArray"
                 style="display: grid; grid-template-columns: auto 1fr; gap: 10px">
            &#60;img [src]="vehicle.img" width="200px" height="120px">
            &#60;div>
              &#60;div>&#60;b>ID: &#60;/b>&#123; &#123; vehicle.id }}&#60;/div>
              &#60;div>&#60;b>Label: &#60;/b>&#123; &#123; vehicle.label }}&#60;/div>
              &#60;div>&#60;b>Type: &#60;/b>&#123; &#123; vehicle.type }}&#60;/div>
              &#60;div>&#60;b>Weight: &#60;/b>&#123; &#123; vehicle.details.weight }} kg&#60;/div>
              &#60;div>&#60;b>Available colors: (&#123; &#123; vehicle.details.colors.length) }} &#60;/b>
                &#60;span *ngFor="let color of vehicle.details.colors; let last = last">
                  &#123; &#123; color }}&#60;span *ngIf="!last">, &#60;/span>
                &#60;/span>
              &#60;/div>
            &#60;/div>
            &#60;br>
           &#60;/div>

          sampleCompexArray: any[] = [
          &#123;
            id: 12, label: 'Hajabusa', type: 'motor', details: &#123;
            colors: ['white', 'grey'],
            weight: 430
            },
            img: 'https://centralization-images.s3.ap-south-1.amazonaws.com/small_suzuki_hayabusa_standard_4_4c3fbe0319.png'
          },
          &#123;
            id: 56, label: 'Punto 199', type: 'car', details: &#123;
            colors: ['blue', 'orange'],
            weight: 1100
            },
            img: 'https://e7.pngegg.com/pngimages/162/547/png-clipart-third-generation-fiat-punto-fiat-500-fiat-idea-fiat-punto-compact-car-building-thumbnail.png'
          },

            id: 89, label: 'Astra GTC', type: 'car', details: &#123;
            colors: ['white', 'black'],
            weight: 1600
            },
            img: 'https://w7.pngwing.com/pngs/95/269/png-transparent-vauxhall-motors-vauxhall-astra-opel-astra-opel-gtc-red-vauxhall-astra-vxr-car-compact-car-sedan-transport-thumbnail.png'
          },
        ];
        </pre>
      </li>
    </ul>
    <h5 #ngif data-anchor="ngif">ngIf</h5>
    <ul>
      <li>Struktúrális direktíva</li>
      <li>Feltétel mentén távolít el, vagy ad hozzá DOM elemet</li>
      <li>
        <button type="button" class="btn btn-secondary" (click)="testElemIsVisible = !testElemIsVisible">
          {{ 'Elem is visible: ' + testElemIsVisible }}
        </button>
        <span *ngIf="testElemIsVisible">A gomb ezt a span-t tünteti el</span>
      </li>
      <pre>
        &#60;button type="button"
                class="btn btn-secondary"
                (click)="testElemIsVisible = !testElemIsVisible">
          &#123; &#123; 'Elem is visible: ' + testElemIsVisible }}
        &#60;/button>
        &#60;span *ngIf="testElemIsVisible">A gomb ezt a span-t tünteti el&#60;/span>

        testElemIsVisible: boolean = false;
      </pre>
    </ul>
    <h5 #ngstyle data-anchor="ngstyle">ngStyle</h5>
    <ul>
      <li>Attribútum direktíva</li>
      <li>Dinamikusan, (Typescript) feltételekkel állíthatjuk az elemek inline-style-ját</li>
      <li>
        <button type="button" class="btn btn-dark" (click)="testElemIsVisible = !testElemIsVisible">
          <span [ngStyle]="testElemIsVisible ? {color: 'green'} : {color: 'red'}">
            {{ 'Elem is visible: ' + testElemIsVisible }}
          </span>
        </button>
        <pre>
          &#60;button type="button"
                  class="btn btn-dark"
                  (click)="testElemIsVisible = !testElemIsVisible">
            &#60;span [ngStyle]="testElemIsVisible ? &#123;'color': 'green'} : &#123;'color': 'red'}"> // Több stílusjegy megadásánál előnyösebb
              &#123; &#123; 'Elem is visible: ' + testElemIsVisible }}
            &#60;/span>
          &#60;/button>
        </pre>
        <button type="button" class="btn btn-dark" (click)="testElemIsVisible = !testElemIsVisible">
          <span [ngStyle]="{color: testElemIsVisible ? 'green' : 'red'}">
            {{ 'Elem is visible: ' + testElemIsVisible }}
          </span>
        </button>
        <pre>
          &#60;button type="button"
                  class="btn btn-dark"
                  (click)="testElemIsVisible = !testElemIsVisible">
            &#60;span [ngStyle]="&#123;'color': testElemIsVisible ? 'green' : 'red'}">
              &#123; &#123; 'Elem is visible: ' + testElemIsVisible }}
            &#60;/span>
          &#60;/button>
        </pre>
      </li>
      <li>A property-kről elhagyható az aposztróf</li>
      <pre>
        [ngStyle]="testElemIsVisible ? &#123;color: 'green'} : &#123;color: 'red'}"
        [ngStyle]="&#123;color: testElemIsVisible ? 'green' : 'red'}"

        //

        [ngStyle]="&#123;fontWeight: '30px'} = [ngStyle]="&#123;'font-weight': '30px'}
      </pre>
    </ul>
    <h5 #ngclass data-anchor="ngclass">ngClass</h5>
    <ul>
      <li>Attribútum direktíva</li>
      <li>Dinamikusan, (Typescript) feltételekkel állíthatjuk az elemek osztályait</li>
      <li>
        <button type="button" class="btn btn-dark" (click)="testElemHasClass = !testElemHasClass">
          <span [ngStyle]="testElemHasClass ? {color: 'green'} : {color: 'red'}">
            {{ 'Button has ' + (testElemHasClass ? 'btn-success' : 'btn-danger') + ' class' }}
          </span>
        </button>
        <button type="button" class="btn disabled" [ngClass]="testElemHasClass ? 'btn-success' : 'btn-danger'">
          {{ 'btn class: ' + testElemHasClass }}
        </button>
      </li>
      <pre>
        &#60;button type="button"
                class="btn btn-dark"
                (click)="testElemHasClass = !testElemHasClass">
          &#60;span [ngStyle]="testElemHasClass ? &#123;color: 'green'} : &#123;color: 'red'}">
            &#123; &#123; 'Button has ' + (testElemHasClass ? 'btn-success' : 'btn-danger') + ' class' }}
          &#60;/span>
        &#60;/button>
        &#60;button type="button"
                class="btn"
                [ngClass]="testElemHasClass ? 'btn-success' : 'btn-danger'">
          &#123; &#123; 'btn class: ' + testElemHasClass }}
        &#60;/button>

        //

        [class.my_class] = "step === 'step1'"
        [ngClass]="&#123;'my_class': step === 'step1'}"
        [ngClass]="&#123;'my_class': step === 'step1', 'my_class2' : step === 'step2' }"
        [ngClass]="&#123;1 : 'my_class1', 2 : 'my_class2', 3 : 'my_class4'}[step]"
        [ngClass]="step == 'step1' ? 'my_class1' : 'my_class2'"
      </pre>
      <li>Amennyiben ngClass-ba fixen is be szeretnénk tenni osztályt:
        <pre>
          &#60;button [ngClass]="&#123;'btn': true, 'btn-dark': testElemHasClass, 'disabled': !testElemHasClass}">
            Button
          &#60;/button>
        </pre>
      </li>
      <li>Az a kifejezés, ami nem boolean értékkű, úgynevezett "type cast"-oláson megy keresztük, azaz boolean értékűvé
        alakul; Így a false értékek:
        <ol>
          <li>false</li>
          <li>'' (üres string)</li>
          <li>0</li>
          <li>null</li>
          <li>undefined</li>
        </ol>
      </li>
    </ul>
  </ul>
</div>

<div>
  <h3 #propertybinding data-anchor="propertybinding">Property binding</h3>
  <ul>
    <li>Két komponens közti kommunikációt hivatott megvalósítani, amennyiben a két komponens között van valamilyen
      kapcsolat (például szülő-gyermek)
    </li>
    <li>Property binding syntax: [property]="..."</li>
    <br>
    <h5 #inputbinding data-anchor="inputbinding">@Input</h5>
    <li>Custom property binding</li>
    <li>Az @Input dekorátort használjuk ahhoz, hogy a szülő komponensből adatot adjunk át a gyerek komponensnek</li>
    <li>A gyerek komponensben létre kell hozni egy property-t, amit ellátunk a fenti dekorátorral
      <ul>
        <pre>
          @Input() inputData = undefined;

          // Meghatározható, milyen kulcsokat várunk, de ebben az esetben kezdeti értéket is szükséges megadni, ellenkező esetben:
          // Property inputData has no initializer
          @Input() inputData: &#123;
            id: number,
            label: string,
            type: string,
            details: &#123;
                colors: string[],
                weight: number
              },
            img: string
            } = &#123;
            id: 0,
            label: '',
            type: '',
            details: &#123;
              colors: [],
              weight: 0
            },
            img: 'string'
          };
        </pre>
        <li>A komponens szelektoron ezek után a attribútumként használhatjuk az @Input dekorátorral ellátot property-t
        </li>
        <br>
        <ol>
          <li *ngFor="let item of sampleCompexArray">
            <app-child [inputData]="item" [shownData]="'labels'"></app-child>
          </li>
        </ol>
        <pre>
          // Szülő (template)
          &#60;ol>
            &#60;li *ngFor="let item of sampleCompexArray">
              &#60;app-child [inputData]="item" [shownData]="'labels'">&#60;/app-child> // Szelektor input attribútum
            &#60;/li>
          &#60;/ol>

          // Gyerek (template)
          &#60;div>&#123; &#123; inputData.label }}&#60;/div>
        </pre>
        <li>Bárhol használjuk ezt a szelektort, az @Input dekorátorral felruházott property-ket is használhatjuk
          rajta
        </li>
        <br>
        <app-child [shownData]="'radios'" [typeCount]="sampleCompexArrayTypeLengths"></app-child>
        <pre>
          <b>// Parent</b>
          &#60;app-child [shownData]="'radios'" [typeCount]="sampleCompexArrayTypeLengths">&#60;/app-child>

          sampleCompexArrayTypeLengths: &#123; all: number, motor: number, car: number } = &#123;all: 0, motor: 0, car: 0};

          this.sampleCompexArrayTypeLengths.all = this.sampleCompexArray.length;
          this.sampleCompexArrayTypeLengths.motor = this.sampleCompexArray.filter(f => f.type === 'motor').length;
          this.sampleCompexArrayTypeLengths.car = this.sampleCompexArray.filter(f => f.type === 'car').length;

          <b>// Child</b>
          @Input() shownData: 'labels' | 'radios' = 'labels';

          @Input() typeCount: &#123; all: number, motor: number, car: number } = &#123;all: 0, motor: 0, car: 0};

          &#60;ng-container *ngIf="shownData === 'radios'">
            &#60;div class="form-check">
              &#60;input class="form-check-input" type="radio" name="flexRadioDefault" id="flexRadioDefault1" [value]="'all'" checked>
              &#60;label class="form-check-label" for="flexRadioDefault1">
                All &#123; &#123; '(' + typeCount.all + ')' }}
              &#60;/label>
            &#60;/div>
            &#60;div class="form-check">
              &#60;input class="form-check-input" type="radio" name="flexRadioDefault" id="flexRadioDefault2" [value]="'motor'">
              &#60;label class="form-check-label" for="flexRadioDefault2">
                Motor &#123; &#123; '(' + typeCount.motor + ')' }}
              &#60;/label>
            &#60;/div>
            &#60;div class="form-check">
              &#60;input class="form-check-input" type="radio" name="flexRadioDefault" id="flexRadioDefault3" [value]="'car'">
              &#60;label class="form-check-label" for="flexRadioDefault3">
                Car &#123; &#123; '(' + typeCount.car + ')' }}
              &#60;/label>
            &#60;/div>
          &#60;/ng-container>
        </pre>
      </ul>
    </li>
    <h5 #outputbinding data-anchor="outputbinding">@Output</h5>
    <li>Custom property binding</li>
    <li>A gyerek kommunikációja a szülő felé</li>
    <br>
    <app-child [shownData]="'radios2'" [typeCount]="sampleCompexArrayTypeLengths"
      (selectedRadioChange)="selectedRadioButtonOutput = $event"></app-child>
    <br>
    Selected: {{ selectedRadioButtonOutput }} (no opacity)
    <br>
    <div *ngFor="let vehicle of sampleCompexArray">
      <div
        [ngStyle]="{ 'opacity': (selectedRadioButtonOutput === 'all' || selectedRadioButtonOutput === vehicle.type) ? 1 : .3}"
        style="display: grid; grid-template-columns: auto 1fr; gap: 10px">
        <img [src]="vehicle.img" width="200px" height="120px">
        <div>
          <div><b>ID: </b>{{ vehicle.id }}</div>
          <div><b>Label: </b>{{ vehicle.label }}</div>
          <div><b>Type: </b>{{ vehicle.type }}</div>
          <div><b>Weight: </b>{{ vehicle.details.weight }} kg</div>
          <div><b>Available colors ({{ vehicle.details.colors.length }}): </b>
            <span *ngFor="let color of vehicle.details.colors; let last = last">
              {{ color }}<span *ngIf="!last">, </span>
            </span>
          </div>
        </div>
        <br>
      </div>
    </div>
    <br>
    <li>A gombok alatt a Child komponensben kiválasztott radio gomb által küldött érték jelenik meg, de
      <ul>
        <li>A gyerek komponensben a 'motor' érték van kiválasztva alapból</li>
        <li>Csak változásra módosul a kiírt érték, mert a parentben az 'all' az alapértelmezett</li>
      </ul>
    </li>
    <li>A fenti példát kiegészítettük two-way data binding-gal
      <ul>
        <li>[(ngModel)] - Struktúrális direktíva</li>
        <li>Az (ngModelChange) használata helyett maradhatunk az [(ngModel)]-nél, és egy (change) metódus segítségével
          is továbbíthatjuk az adatokat "kifelé"
        </li>
        <li>Amennyiben szétszedjük a two-way binding ki- és bemenetét, és a lentiek szerint bocsátunk ki a kimenetnél
          adatokat, azaz nem ugyanabba a változóba rakjuk vissza az értéket, úgy megszüntetjük a two-way data bindingot!
        </li>
      </ul>
    </li>
    <pre>
      // Gyerek
      &#60;ng-container *ngIf="shownData === 'radios2'">
        &#60;div>
          &#60;input id="all" type="radio" [value]="'all'"
            [ngModel]="selectedRadio" (ngModelChange)="selectedRadioChange.emit($event)">
          &#60;label for="all">All &#123; &#123; '(' + typeCount.all + ')' }}&#60;/label>
        &#60;/div>
        &#60;div>
          &#60;input id="motor" type="radio" [value]="'motor'"
            [ngModel]="selectedRadio" (ngModelChange)="selectedRadioChange.emit($event)">
          &#60;label for="motor">Motor &#123; &#123; '(' + typeCount.motor + ')' }}&#60;/label>
        &#60;/div>
        &#60;div>
          &#60;input id="car" type="radio" [value]="'car'"
            [ngModel]="selectedRadio" (ngModelChange)="selectedRadioChange.emit($event)">
          &#60;label for="car">Car &#123; &#123; '(' + typeCount.car + ')' }}&#60;/label>
        &#60;/div>
      &#60;/ng-container>

      // [(ngModel)]="selectedRadio" (change)="onSelectedRadioChange()" // Funkcionalitás tekintetében ugyanaz
      // onSelectedRadioChange() &#123;
            this.selectedRadioChange.emit(selectedRadio);
          }

      // Szülő
      &#60;app-child [shownData]="'radios2'" [typeCount]="sampleCompexArrayTypeLengths"
                 (selectedRadioChange)="selectedRadioButtonOutput = $event">&#60;/app-child>

      (selectedRadioChange)="onRadioChange($event);
      onRadioChange(e) &#123;
            this.selectedRadioButtonOutput = e;
          }
    </pre>
    <li>Azt is megtehetjük, hogy a gyerek által kibocsátott esemény adatát egy metódusban dolgozzuk fel</li>
    <pre>
      (selectedRadioChange)="onRadioChange($event);
      onRadioChange(e) &#123;
            this.selectedRadioButtonOutput = e;
          }
    </pre>
    <li>A célunk az, hogy a gyerek komponensben lévő 'selectedRadio' property változásairól értesüljön a szülő
      komponens
      <ul>
        <li>A gyerek komponensben Eventemitterre van szükségünk
          <ul>
            <li>Az Eventemitternek meg kell határozni a típusát, esetünkben string típusú</li>
            <li>A konstruktorját hívjuk meg az Eventemitter osztálynak</li>
            <li>Létrehozunk egy property-t, aminek Eventemitter osztályt adunk értéknek, így ez a változó automatikusan
              event típusú lesz, de explicite módon is meghatározhatjuk a property típusút
            </li>
            <pre>
              selectedRadio: 'all' | 'motor' | 'car' = 'all';
              @Output() selectedRadioChange = new EventEmitter&#60;string>();
              // @Output() selectedRadioChange: EventEmitter&#60;string> = new EventEmitter&#60;string>(); // Explicit típusmegadás
              // @Output() selectedRadioChange: EventEmitter<'all' | 'motor' | 'car'> = new EventEmitter<'all' | 'motor' | 'car'>(); // Még explicitebb megadás
            </pre>
            <li>Változás esetén gondoskodnunk kell róla, hogy kibocsássuk az eseményt
              <ul>
                <li>Ehhez az Eventemitter emit() metódusát használjuk</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Egynél több struktúrális direktíva nem alkalmazható egy elemen</li>
    <pre>
      &#60;div *ngFor="let vehicle of sampleCompexArray">
        &#60;div
          [ngStyle]="&#123; 'opacity': (selectedRadioButtonOutput === 'all' || selectedRadioButtonOutput === vehicle.type) ? 1 : .3}"
          style="display: grid; grid-template-columns: auto 1fr; gap: 10px">
          &#60;img [src]="vehicle.img" width="200px" height="120px">
          &#60;div>
            &#60;div>&#60;b>ID: &#60;/b>&#123; &#123; vehicle.id }}&#60;/div>
            &#60;div>&#60;b>Label: &#60;/b>&#123; &#123; vehicle.label }}&#60;/div>
            &#60;div>&#60;b>Type: &#60;/b>&#123; &#123; vehicle.type }}&#60;/div>
            &#60;div>&#60;b>Weight: &#60;/b>&#123; &#123; vehicle.details.weight }} kg&#60;/div>
            &#60;div>&#60;b>Available colors (&#123; &#123; vehicle.details.colors.length }}): &#60;/b>
              &#60;span *ngFor="let color of vehicle.details.colors; let last = last">
                  &#123; &#123; color }}&#60;span *ngIf="!last">, &#60;/span>
              &#60;/span>
            &#60;/div>
          &#60;/div>
          &#60;br>
        &#60;/div>
      &#60;/div>
    </pre>
  </ul>
</div>

<div>
  <h3 #componentcommunication data-anchor="componentcommunication">Component communication</h3>
  <ul>
    <li>Az Angular egyik legfontosabb témaköre
      <ul>
        <li>Komponensek létrehozása, és a köztük lévő kapcsolatok kialakítása</li>
      </ul>
    </li>
    <li>Komponens létrehozásához navigáljunk be a projekt mappájába
      <ul>
        <li>ng g c &#60;komponensnév&#62;</li>
        <li>Az 'ng' az angular CLI program</li>
        <li>A 'g' a generate</li>
        <li>A 'c' a component</li>
        <li>A terminál kiírja, hogy hova, és milyen fájlokat hozott létre, és milyen fájlban végzett
          módosításokat
        </li>
        <li>Akár manuálisan is létrehozhatók a fájlok</li>
        <li>A spec.ts fájl tesztelési célt szolgál</li>
      </ul>
    </li>
    <li>A component.ts fájlból szerezhetünk információt
      <ul>
        <li>@Component(&#123;&#125;)
          <ul>
            <li>Dekorátor</li>
            <li>Itt van leírva a komponensnek minden tulajdonsága</li>
            <li>selector: milyen tagnévvel tudjuk működésbe léptetni</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>
      <ul>
        <li>Az egyes gyerek komponensekbe a szülőtől tudnak input adatok érkezni</li>
        <li>Ehhez a gyerek komponenst el kell látni egy input dekorátorral
          <ul>
            <li>@Input()</li>
            <li>Dekorátor alatt egy typescriptes nyelvi eszközt értünk, ami kerülhet class-ra, property-re,
              és methodra is
              <ul>
                <li>Class --> @Component()</li>
                <li>property --> @ViewChild('box') box!: ElementRef&#60;HTMLDivElement&#62;</li>
                <li>method -->
                  <pre>
                                         @HostListener('window:resize', ['$event'])
                                              onWindowResize(event: Event) &#123;
                      console.log('Window resized', event);
                                          &#125;
                                      </pre>
                </li>
              </ul>
            </li>
            <li>Ez a property nem csak egy sima State változó, hanem kívülről érkezhet, amikor az adott
              komponens a szülő elemben működésbe lép
            </li>
            <li>&#60;app-box&#62; [xPosition]="200" [xPosition]="400" [color]="'red'"&#60;/app-box&#62;
              <ul>
                <li>A color értéke string, ha nem lenne idézőjelbe rakva, akkor a a komponensben lévő
                  state változóra hivatkozunk (ha létezik ilyen néven property)
                </li>
                <li>Ha futásidőben megváltozik valamelyik input paraméter, akkor az angular
                  újrarendereli a megfelelő elemet
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A gyerek is küldhet felfelé adatokat
          <ul>
            <li>@Output()</li>
            <li>Eseményelnevezést szokás neki adni</li>
            <li>Pl.: newColorSelected</li>
            <li>@Output() newColorSelected: EventEmitter&#60;string&#62; = new EventEmitter&#60;string&#62;
            </li>
            <li>EventEmitter típust szokás bekötni hozzá
              <ul>
                <li>Magyarul eseménykibocsátó</li>
                <li>Működése nagyon egyszerű
                  <ul>
                    <li>A property révén bármikor hibatkozhatunk erre az értékre</li>
                    <li>this.newColorSelected.emit();</li>
                    <li>Az emit() method alkalmazásakor a komposens ekkor fogja magából kibocsátani
                      az értéket
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A kifele menő adatforgalom esetén zárójel a szintaktika () és általában adatként valamilyen eseményt
          kapunk, befele menő adat esetén pedig szögletes zárójelet használunk [] és értékként a konkrét
          adatot adjuk meg
        </li>
        <li>
          <pre>
                          &#60;form (submit)="formSubmit($event)">
                            &#60;select name="color"&#62;
                              &#60;option selected&#62;&#60;/option&#62;
                              &#60;option value="blue"&#62;blue&#60;/option&#62;
                              &#60;option value="red"&#62;red&#60;/option
                              &#60;option value="green"&#62;green&#60;/option&#62;
                              &#60;/select&#62;
                            &#60;button type="submit"&#62;SEND&#60;/button&#62;
                          &#60;/form>
  
                          formSubmit(e: any) &#123;
                        e.preventDefault();
                        console.log(e.target.elements.color.value);
                          &#125;
                      </pre>
          <ul>
            <li>Egy közönséges formban lévő selectből ilyen módon nyerhető ki a választott érték</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <ul>
    <li>Testvér, vagy egymástól teljesen független komponensek között is teremthetünk kommunikációt</li>
    <li>A két komponens, amit használni fogunk, az app-search (abban is kizárólag egy two-way binding-gal ellátott input
      mezőt), és az app-vehicles (amibe átkerült a járművel példatömbje)
    </li>
    <pre>
      &#60;app-search [shownInput]="'inputOnly'">&#60;/app-search>
      &#60;br>
      &#60;app-vehicles>&#60;/app-vehicles>
    </pre>
    <li>A komponensek között semmilyen kapcsolat sincs (pontosabban testvérek)</li>
    <li>A köztük lévő kommunikációra használhatjuk a custom event és a custom property binding kombinációját
      <ul>
        <li>Az egyik gyerek custom event binding ( @Output --> (data)="" ) segítségével adatot közölhet a szülővel</li>
        <li>A szülő a kapott adatot custom property binding-gal ( [data]="" --> @Input ) továbbíthatja a másik
          gyereknek
        </li>
      </ul>
    </li>
    <pre>
      // A template-ből nem jut el az adat a kontrollerbe:
      [ngModel]="searchText2" (ngModelChange)="searchText2Change.emit($event)"

      // Megmarad a two-way binding, és megtörténik az adatkibocsátás is:
      [ngModel]="searchText2" (ngModelChange)="searchText2 = $event; searchText2Change.emit($event)"
    </pre>
    <li>Service-szel ugyancsak megvalósítható a feladat, de most nem ez lesz az irány</li>
    <br>
    <app-search [shownInput]="'inputOnly'" (searchText2Change)="searchData = $event"></app-search>
    <br>
    <app-vehicles [searchText2]="searchData"></app-vehicles>
    <br>
    <pre>
      <b>// Parent</b>
      &#60;app-search [shownInput]="'inputOnly'" (searchText2Change)="searchData = $event">&#60;/app-search>
      &#60;app-vehicles [searchText2]="searchData">&#60;/app-vehicles>

      <b>// app-search</b>
      &#60;div *ngIf="shownInput === 'inputOnly'">
        &#60;input placeholder="search"
               [ngModel]="searchText2"
               (ngModelChange)="searchText2 = $event; searchText2Change.emit($event)">
      &#60;/div>

      searchText2: string = '';
      @Output() searchText2Change: EventEmitter&#60;string> = new EventEmitter&#60;string>();

      <b>// app-vehicles</b>
      &#60;div *ngFor="let vehicle of vehicles">
        &#60;div
          [ngStyle]="&#123; 'opacity': (vehicle.label.includes(searchText2)) ? 1 : .3}"
          style="display: grid; grid-template-columns: auto 1fr; gap: 10px">
            ...
        &#60;/div>
      &#60;/div>

      @Input() searchText2: string = '';

      vehicles: any[] = [...]
    </pre>
    <li>A search-ben lévő input mező változásaira kibocsátjuk a szülő felé a beírt értéket, amit továbbítunk a vehicles
      komponensnek, ami az includes method-dal megnézi, hogy melyik label-ben található meg az az érték, amit
      begépeltünk, és ennek megfelelően a találatok opacity: 1-en maradnak, a többi pedig megkapja a .3 értéket
    </li>
    <li>Amennyiben kis- és nagybetűtől függetlenül szeretnénk "keresni":</li>
    <pre>
      ((vehicle.label).toLowerCase().includes(searchText2.toLowerCase()))
    </pre>
  </ul>
</div>

<div>
  <h3 #templatereference data-anchor="templatereference">Template reference variable</h3>
  <ul>
    <li>Speciális változó Angularban, amelyet a template-ben definiálunk</li>
    <li>Arra használható, hogy hozzáférjünk egy DOM elemhez, egy komponenshez vagy egy direktívához a HTML kódban</li>
    <li>Ezeket a változókat a # karakterrel definiáljuk, és a template-ben hivatkozhatunk rájuk</li>
    <br>
    <h5 #domreference data-anchor="domreference">DOM elem</h5>
    <app-search [shownInput]="'searchWithButton'" (searchText2Change)="searchData = $event"></app-search>
    <br>
    Search text: {{ searchData }}
    <app-vehicles [searchText2]="searchData"></app-vehicles>
    <pre>
      <b>// app-search</b>
      &#60;app-search [shownInput]="'searchWithButton'" (searchText2Change)="searchData = $event">&#60;/app-search>

      &#60;div *ngIf="shownInput === 'searchWithButton'">
        &#60;input #searchInput placeholder="search">
        &#60;button type="button" class="btn btn-light" (click)="onSearchClick(searchInput)">Search&#60;/button>
      &#60;/div>

      onSearchClick(inputElement: HTMLInputElement) &#123;
        this.searchText2Change.emit(inputElement.value)
      }
    </pre>
    <li>Készítettünk az input elementen egy template reference változót (#searchInput)</li>
    <li>A searchInput változó az input (DOM) elem (HTMLInputElement) referenciáját tartalmazza!</li>
    <li>Gombnyomásra meghívunk egy method-ot, aminek odaadjuk az input referencia változóját</li>
    <li>A kontrollerben kibocsátjuk az app-search komponensből az input értékét, amit megkap a szülő komponens</li>
    <li>A HTMLInputElement value property-jére van szükségünk</li>
    <li>Ezzel ugyanúgy megvalósítottuk a keresést, csak template referencia változót használtunk az app-search
      komponensben
    </li>
    <br>
    <h5 #componentreference data-anchor="componentreference">Komponens</h5>
    <li>Létrehoztunk egy vehicle.ts fájlt:
      <ul>
        <li>Az ebben lévő class példányosítható, tartalmazhat metódusokat</li>
        <li>A new kulcsszóval új példány hozható létre belőle</li>
        <pre>
          export class Vehicle &#123;
            id?: number;
            label?: string;
            type?: 'motor' | 'car';
            details?: &#123;
              colors: string[],
              weight: number,
            };
            img?: string
          }

          // A példányosításhoz szükség lenne arra, hogy bemeneti paramétereket lehessen megadni neki:

          constructor(id?: number, label?: string, type?: 'motor' | 'car', details?: &#123; colors: string[], weight: number }, img?: string) &#123;
            this.id = id;
            this.label = label;
            this.type = type;
            this.details = details;
            this.img = img;
          }

          // Példányosítás:

          const myVehicle = new Vehicle(1, 'My Car', 'car', &#123; colors: ['red'], weight: 1500 }, 'image_url.png');
        </pre>
      </ul>
    </li>
    <li>A járművekre kattintva kinyerjük a gyerekből a megfelelő adatokat</li>
    <br>
    <div class="rounded-border">
      <label>Parent component</label>
      <div>{{ vehiclecomponent.selectedVehicle | json }}</div>
    </div>
    <br>
    <div class="rounded-border">
      <label>Child component</label>
      <br>
      <app-vehicles #vehiclecomponent [searchText2]="searchData"></app-vehicles>
    </div>
    <li>A #vehiclecomponent template referencia változó a Vehicles class egy példányának referenciáját tartalmazza</li>
    <li>Ezen változó segítségével hozzáférhetünk a property-jeihez</li>
    <pre>
      &#60;div>
        &#60;label>Parent component&#60;/label>
        &#123; &#123; vehiclecomponent.selectedVehicle | json }}
      &#60;/div>
      &#60;div>
        &#60;label>Child component&#60;/label>
        &#60;app-vehicles #vehiclecomponent [searchText2]="searchData">&#60;/app-vehicles>
      &#60;/div>
    </pre>
  </ul>
</div>

<div>
  <h3 #viewchild data-anchor="viewchild">ViewChild</h3>
  <ul>
    <li>Dekorátor, ami az adott DOM elem referenciáját tartalmazza</li>
    <li>Az első találattal tér vissza</li>
    <li>Jól jöhet, amikor nem akarjuk event-tal összekötni a DOM manipulációját</li>
    <li>Ahogy az app-search komponens betöltött, azonnal hozzáférünk a referenciához</li>
    <br>
    <h5 #viewchilddomref data-anchor="viewchilddomref">DOM elem referencia</h5>
    <pre>
      <b>// app-search</b>

      &#60;input #searchInput placeholder="search">
      &#60;button type="button" class="btn btn-light" (click)="onSearchClickWithViewChild()">Search/button>

      @ViewChild('searchInput') searchInputElement: HTMLInputElement;

      onSearchClickWithViewChild() &#123;
        const inputElementRef = this.searchInputElementRef.nativeElement.value;
        this.searchText2Change.emit(inputElementRef);
      }
    </pre>
    <li>A ViewChild dekorátor két paramétert fogad:</li>
    <ul>
      <li>Az első paraméter a szelektor, ide kerül a template-beli referencia neve (searchInput)</li>
      <li>A szelektor lehet egy string, egy komponens neve, vagy egy direktíva neve</li>
      <li>A második paraméter opcionális
        <ul>
          <li>read:
            <ul>
              <li>Megmondja az Angularnak, hogy milyen típusú adatot olvasunk ki</li>
              <li>Ha például egy DOM elemre van szükség (div, input, ...), akkor az ElementRef típus használható</li>
              <li>A read: ElementRef a kiolvasott típus, a végén lévő ElementRef típus pedig a Typescriptnek szól</li>
              <pre>
                @ViewChild('myDiv', &#123; read: ElementRef }) myDiv: ElementRef;
              </pre>
            </ul>
          </li>
          <li> static:
            <ul>
              <li>False esetén az elem az ngAfterViewInit() előtt érhető el, és változás esetén (ngFor, ngIf) frissül
              </li>
              <li>True esetén az elem már az ngOnInit() előtt elérhető, a change detection előtt, így változásokra
                (ngFor, ngIf) nem frissül
              </li>
              <li>Alapértelmezetten true értéket vesz fel</li>
              <pre>
                @ViewChild('myTemplateVar', &#123; static: true }) myTemplate: ElementRef;
              </pre>
              <li>TemplateRef-et kiolvasva az ngTemplateOutlet direktívával megjeleníthető a template-ben</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
    <br>
    <app-search [shownInput]="'viewchildsearch'" (searchText2Change)="searchData = $event"></app-search>
    Search data using ViewChild: {{ searchData }}
    <pre>
      &#60;app-search [shownInput]="'viewchildsearch'" (searchText2Change)="searchData = $event">&#60;/app-search>
      Search data using ViewChild: &#123; &#123; searchData }}
    </pre>
    <h5 #viewchildcomponentref data-anchor="viewchildcomponentref">Komponens referencia</h5>
    <li>Az adott komponensbe behivatkozott szelektorra tehetünk template reference változót</li>
    <li>Ebben az esetben hozzáférünk a property-jeihez</li>
    <li>Használhatjuk a komponens nevét is (VehicleComponent)</li>
    <li>A 'vehicleComponent' / VehicleComponent a template-ben lévő komponens referenciáját tárolja</li>
    <br>
    <app-vehicles #vehicleComponent></app-vehicles>
    <pre>
      &#60;app-vehicles #vehicleComponent>&#60;/app-vehicles>

      @ViewChild('vehicleComponent') vehicleComponentRef!: ComponentRef&#60;any>;
      // @ViewChild(VehicleComponent) vehicleComponentRef!: VehicleComponent;

      // console.log(this.vehicleComponent)
        &#123; searchText2: "",
        selectedVehicle:Vehicle &#123;}
        vehicles:(6) [&#123;…}, &#123;…}, &#123;…}, &#123;…}, &#123;…}, &#123;…}]
        }
      // AfterViewInit életciklusban már elérhető
    </pre>
    <li>Ez a referencia pedig tovább adható másik komponensnek</li>
  </ul>
</div>

<div>
  <h3 #viewchildren data-anchor="viewchildren">ViewChildren</h3>
  <ul>
    <li>A ViewChild dekorátorral egyetlen egy referenciát kapunk meg</li>
    <li>Amennyiben az összes egyezést szeretnénk lekérni, megkapni, úgy a ViewChildren-re van szükségünk</li>
    <li>DOM elemek template-beli referenciáinak listáját tartalmazza a kontroller rétegben</li>
    <li>QueryList típussal tér vissza</li>
    <li>Minden esetben a change detection lefutása után érhető el (ngOnInit-ben nem)</li>
    <li>A ViewChildren-nél már csak a 'read' property-t adhatjuk meg második paraméternek</li>
    <br>
    <div style="display: inline-grid">
      <input #inputEl type="text" placeholder="First name">
      <input #inputEl type="text" placeholder="Middle name">
      <input #inputEl type="text" placeholder="Last name">
      <button type="button" class="btn btn-primary" (click)="getFullNameFromQueryList()">Show full name</button>
      <div>Full name: {{ fullNameFromQueryList }}</div>
    </div>
    <pre>
      &#60;input #inputEl type="text" placeholder="First name">
      &#60;input #inputEl type="text" placeholder="Middle name">
      &#60;input #inputEl type="text" placeholder="Last name">
      &#60;button type="button" class="btn btn-primary" (click)="getFullNameFromQueryList()">Show full name&#60;/button>

      @ViewChildren('inputEl') inputElRef!: QueryList&#60;ElementRef>
      // @ViewChildren('inputEl') inputElRef!: QueryList&#60;HTMLInputElement> // Ugyanazt az eredményt adja

      getFullNameFromQueryList() &#123;
        console.log(this.inputElRef);
      }

      &#123;
        dirty: false,
        first: "ElementRef &#123;nativeElement: input}",
        last: "ElementRef &#123;nativeElement: input}",
        length: 3,
        _changes: null,
        _changesDetected: true,
        _emitDistinctChangesOnly: true,
        _results: ["ElementRef", "ElementRef", "ElementRef"],
        changes: "(...)"
      }
    </pre>
    <li>A gombnyomásra lefut egy change detection</li>
    <li>A QueryList-en végig tudunk iterálni</li>
    <pre>
      &#60;div>Full name: &#123; &#123;fullNameFromQueryList}}&#60;/div>

      getFullNameFromQueryList() &#123;
        this.inputElRef.forEach(input => &#123;
          this.fullNameFromQueryList += (' ' + input.nativeElement.value);
        })
      }
    </pre>
    <li></li>
  </ul>
</div>

<div>
  <h3 #contentchild data-anchor="contentchild">Content child</h3>
  <ul>
    <li>Dekorátor, amely egy DOM elem, komponens vagy direktíva referenciájához fér hozzá, amit a szülő komponensben
      helyeztek el content projection céljából
    </li>
    <li>Ehhez a referenciához a gyerek komponensből hozzáférünk</li>
    <li>Az alábbi példában a gyerek komponensben szeretnénk elérni a paragráfus referenciáját</li>
    <pre>
      <b>// parent.component.html</b>
      &#60;h2>Parent Component&#60;/h2>
      &#60;app-child>
        &#60;h2>Some Heading&#60;/h2>
        &#60;p #paragraph>This is a paragraph&#60;/p>
        &#60;app-test>&#60;/app-test>
      &#60;/app-child>

      <b>// child.component.html</b>
      &#60;h2>Parent Component&#60;/h2>
      &#60;ng-content>&#60;/ng-content>

      <b>// child.component.ts</b>
      @Component (&#123;
            selector: 'app-child',
            templateUrl: *./child.component.html',
            styleUrls: ['./child.component.css']｝）
      export class ChildComponent &#123;

        @ContentChild("paragraph') paraEl: ElementRef;
     }
    </pre>
    <li>A ContentChild megnézi a projektált tartalmat, és az első szelektor találatnak a referenciáját adja meg</li>
    <br>
    <app-ng-hyphen ngType="contentchild">
      <h5>This is the title</h5>
      <div #sometext>Some text</div>
      <div class="text">More text</div>
      <button type="button" class="btn btn-secondary">Useless button</button>
    </app-ng-hyphen>
    <br>
    <li>Amennyiben egy adott class-t már kiszelektáltunk, az nem fog megjelenni máshol
      <ul>
        <li>Sem a 'More text' (select=".text"), sem az első gomb (select=".btn-secondary") nem renderelődik ki itt</li>
      </ul>
    </li>
    <pre>
      <b>// Parent</b>
      &#60;app-ng-hyphen ngType="contentchild">
        &#60;h5>This is the title&#60;/h5>
        &#60;div #sometext>Some text&#60;/div>
        &#60;div class="text">More text&#60;/div>
        &#60;button type="button" class="btn btn-secondary">Useless button&#60;/button>
      &#60;/app-ng-hyphen>

      <b>// Child</b>
      &#60;div *ngIf="ngType === 'contentchild'">
        &#60;div class="rounded-border">
          &#60;ng-content>&#60;/ng-content>
          &#60;button type="button" class="btn btn-light" (click)="getProjectedContentReference()">Click to get reference
          &#60;/button>
          &#60;br>
          &#60;br>
          &#60;div>someTextElement.nativeElement.innerText: &#60;span style="color: #9d2626">&#123; &#123; someTextInnerText }}&#60;/span>&#60;/div>
        &#60;/div>
      &#60;/div>

      @ContentChild('sometext') someTextElement!: ElementRef;
      someTextInnerText: string = '';

      getProjectedContentReference() &#123;
        this.someTextInnerText = this.someTextElement.nativeElement.innerText;
      }
    </pre>
    <li>Az AfterViewInit életciklusban már elérhető</li>
    <li>ViewChild-dal nem férünk hozzá a szülőben lévő projektált tartalomban a referenciákhoz</li>
    <br>
    <button type="button" class="btn btn-secondary" (click)="getViewChildOfProjectedText()">
      Get 'Some text' from parent
    </button>
    <br><br>
    <div>Get 'Some text' with ViewChild: <span style="color: #9d2626">{{ someTextWithViewChild }}</span></div>
    <br>
    <li>Amennyiben a szülő komponensben szeretnénk elérni az adott elem referenciáját, alkalmazhatunk ViewChild-ot</li>
    <li>Tehát, ha az adott komponensen belül szeretnénk hozzáférni egy referenciához, a ViewChild dekorátort
      használhatjuk, viszont, ha gyerek komponensből férnénk hozzá a szülőben található template reference változóhoz a
      projektált (ng-content) tartalomban, akkor a ContentChild dekorátor alkalmazandó
    </li>
    <pre>
      &#60;button type="button" class="btn btn-secondary" (click)="getViewChildOfProjectedText()">
        Get 'Some text' from parent
      &#60;/button>
      &#60;div>Get 'Some text' with ViewChild: &#60;span style="color: #9d2626">&#123; &#123; someTextWithViewChild }}&#60;/span>&#60;/div>

      @ViewChild('sometext') someTextRef!: ElementRef;
      someTextWithViewChild: string = '';

      getViewChildOfProjectedText() &#123;
        this.someTextWithViewChild = this.someTextRef.nativeElement.innerText;
      }
    </pre>
    <li>Fontos, hogy a gyerek komponensben a szelektorába írt, azaz projected content kapcsán értelmehzető a
      ContentChild, vagy ContentChildren, és ott bármilyen elemre
    </li>
    <li>Komponens is projektálható szülőből gyerek komponensbe</li>
    <br>
    <app-ng-hyphen ngType="contentchild2">
      <div style="margin-top: -8px;margin-left: -10px;">
        <b style="padding: 5px; border-right: 1px solid #4b4b4b; border-bottom: 1px solid #4b4b4b; border-radius: 5px;">
          // szülő komponens</b>
      </div>
      <br>
      <app-child #projectedChildComponent [shownData]="'projectComponent'"></app-child>
    </app-ng-hyphen>
    <br>
    <li>A beillesztett app-child komponensről is kaphatunk referenciát</li>
    <li>Használhatjuk a referencia megszerzéséhez a komponens nevét is</li>
    <pre>
      <b>// A szülő komponens</b>
      &#60;app-ng-hyphen ngType="contentchild2">
        &#60;app-child #projectedChildComponent [shownData]="'projectComponent'">&#60;/app-child>
      &#60;/app-ng-hyphen>

      <b>// app-ng-hyphen</b>
      &#60;div *ngIf="ngType === 'contentchild2'">
        &#60;div>
          &#60;ng-content>&#60;/ng-content>
          &#60;div>
              &#60;button type="button" class="btn btn-light" (click)="getProjectedComponentReference()">
                Click to get reference of component
              &#60;/button>
            &#60;span>Child component projected name: &#60;/span>
            &#60;small>&#123; &#123; childComponentProjectedName }}&#60;/small>
          &#60;/div>
        &#60;/div>
      &#60;/div>

      @ContentChild('projectedChildComponent') projectedChildComponentRef!: ChildComponent; // Nem ElementRef!
      // @ContentChild(ChildComponent) projectedChildComponentRef!: ChildComponent; // Ugyanúgy helyes
      childComponentProjectedName: string = '';

      getProjectedComponentReference() &#123;
        this.childComponentProjectedName = this.projectedChildComponentRef.nameOfProjection;
      }
      <b>// app-child</b>
      &#60;ng-container *ngIf="shownData === 'projectComponent'">
        The name of the secret agent is &#60;span style="color: #9d2626">&#123; &#123; nameOfProjection }}&#60;/span> // app-child komponensben van
      &#60;/ng-container>

      nameOfProjection: string = 'John Smith';
    </pre>
    <li>A szülő komponensbe beillesztettünk egy másik komponenst (app-ng-hyphen), amibe content projection-nel tartalmat
      kívántunk elhelyezni, amely tartalom szintén egy komponens volt (app-child), aminek tartalmát belevetítettük az
      app-ng-hyphen komponensbe, ahol ContentChild segítségével elérjük az app-child komponens property-jeit
    </li>
  </ul>
</div>

<div>
  <h3 #contentchildren data-anchor="contentchildren">Content children</h3>
  <ul>
    <li>Dekorátor, amely több DOM elem, komponens vagy direktíva referenciájához fér hozzá, amit a szülő komponensben
      helyeztek el content projection céljából
    </li>
    <li>Ugyanaz, mint a ContentChild, csak az összes találati elemet visszaadja</li>
    <li>Az összes referenciát tartalmazza</li>
    <li>Amennyiben DOM elemeket szeretnénk kiszelektálni, úgy a QueryList-ünk típusa ElementRef</li>
    <li>Az elemeken végig lehet iterálni</li>
    <app-ng-hyphen ngType="contentchildren" [clearChildrenContentProjection]="clearChildrenContentProjectionEvent">
      <div #contentChildrenProjection class="content1">Projected content 1</div>
      <div #contentChildrenProjection class="content1">Projected content 2</div>
      <div #contentChildrenProjection class="content1">Projected content 3</div>
      <div #contentChildrenProjection class="content1">Projected content 4</div>
      <div #contentChildrenProjection *ngFor="let content of projectedContents; let i = index" class="content1">
        {{ content }}
      </div>
      <button type="button" class="btn btn-success content1" (click)="projectedContents.push('Projected content +')">
        Add new projected content
      </button>
      <button *ngIf="projectedContents.length" type="button" class="btn btn-danger content1"
        (click)="clearChildrenContentProjectionEvent = $event; projectedContents.pop()">
        Remove projected content
      </button>
    </app-ng-hyphen>
    <pre>
      <b>// Parent</b>
      &#60;app-ng-hyphen ngType="contentchildren" [clearChildrenContentProjection]="clearChildrenContentProjectionEvent">
        &#60;div #contentChildrenProjection>Projected content 1&#60;/div>
        &#60;div #contentChildrenProjection>Projected content 2&#60;/div>
        &#60;div #contentChildrenProjection>Projected content 3&#60;/div>
        &#60;div #contentChildrenProjection>Projected content 4&#60;/div>
        &#60;div #contentChildrenProjection *ngFor="let content of projectedContents">
          &#123; &#123; content }}
        &#60;/div>
        &#60;button type="button" class="btn btn-success" (click)="projectedContents.push('Projected content +')">
          Add new projected content
        &#60;/button>
        &#60;button *ngIf="projectedContents.length" type="button" class="btn btn-danger"
                (click)="clearChildrenContentProjectionEvent = $event; projectedContents.pop()">
          Remove projected content
        &#60;/button>
      &#60;/app-ng-hyphen>

      <b>// Child</b>
      &#60;div *ngIf="ngType === 'contentchildren'">
        &#60;div>
          // ng-content starts
          &#60;ng-content>&#60;/ng-content>
          // ng-content ends

          // child content
          Number of projected elements: &#123; &#123; projectedChildrenRef.length }}
          &#60;button type="button" class="btn btn-secondary" (click)="getProjectedMultiContentReference()">
            Get content children
          &#60;/button>
          &#60;pre>
            // ContentChildren tartalma (gombra frissül):
            &#123; &#123; childrenContentProjection | json }}
          &#60;/pre>
        &#60;/div>
      &#60;/div>

      @ContentChildren('contentChildrenProjection') projectedChildrenRef!: QueryList&#60;ElementRef>
      childrenContentProjection: any[] = [];

      @Input()
        set clearChildrenContentProjection(value: any) &#123;
            if (value) &#123;
            this.childrenContentProjection = [];
          }
        }

      getProjectedMultiContentReference() &#123;
          this.childrenContentProjection = [];
          this.projectedChildrenRef.forEach(child => &#123;
          this.childrenContentProjection.push(child);
        })
      }
    </pre>
    <li>Alapból négy darab projektált elem szerepel a szelektor nyitás-, és zárás között</li>
    <li>A gombokkal hozzá tudunk adni, és a hozzáadottakat elvenni, ezáltam nő, és csökken projektált elemek száma</li>
    <li>A tömbből való elvételkor szükség volt a childban egy @Input setter-re, hogy ne fussunk hibára</li>
    <br>
    <app-ng-hyphen #nghyphenforclickevent [ngType]="'contentchildren2'"
      (colorElemsComponentList)="colorElemsComponentList = $event">
      <app-child [shownData]="'projectMultiComponent'" [color]="'red'" class="content2"></app-child>
      <app-child [shownData]="'projectMultiComponent'" [color]="'blue'" class="content2"></app-child>
      <app-child [shownData]="'projectMultiComponent'" [color]="'green'" class="content2"></app-child>
    </app-ng-hyphen>
    <button type="button" class="btn btn-light" (click)="nghyphenforclickevent.getProjectedMultiComponentReference()">
      Click
    </button>
    <div>Projected component input color 1: <span style="color: #9d2626">{{ colorElemsComponentList?.[0].color }}</span>
    </div>
    <div>Projected component input color 2: <span style="color: #1a7cc4">{{ colorElemsComponentList?.[1].color }}</span>
    </div>
    <div>Projected component input color 3: <span style="color: #8de725">{{ colorElemsComponentList?.[2].color }}</span>
    </div>
    <br>
    <li>A szülő komponensbe behívtuk az app-ng-hyphen komponenst, és projekcióra került három app-child komponens</li>
    <li>A childnak input paraméterrel adtunk át színeket</li>
    <li>Template reference variable segítségével meg tudjuk hívni az ng-hyphen komponensben lévő egyik függvényt, ami
      arról gondoskodik, hogy a szülő komponens megkapja a projektált komponensek referenciáját
    </li>
    <li>A referenciák alapján hozzáférhetünk a példányosított class-ok property-jeihez</li>
    <pre>
      <b>// parent component</b>
      &#60;app-ng-hyphen #nghyphenforclickevent
                     [ngType]="'contentchildren2'"
                     (colorElemsComponentList)="colorElemsComponentList = $event">
        &#60;app-child [shownData]="'projectMultiComponent'" [color]="'red'" class="content2">&#60;/app-child>
        &#60;app-child [shownData]="'projectMultiComponent'" [color]="'blue'" class="content2">&#60;/app-child>
        &#60;app-child [shownData]="'projectMultiComponent'" [color]="'green'" class="content2">&#60;/app-child>
      &#60;/app-ng-hyphen>
      &#60;button type="button" class="btn btn-light"
              (click)="nghyphenforclickevent.getProjectedMultiComponentReference()">
        Click
      &#60;/button>
      &#60;div>Projected component input color 1: &#60;span style="color: #9d2626">&#123; &#123; colorElemsComponentList?.[0].color }}&#60;/span>&#60;/div>
      &#60;div>Projected component input color 2: &#60;span style="color: #1a7cc4">&#123; &#123; colorElemsComponentList?.[1].color }}&#60;/span>&#60;/div>
      &#60;div>Projected component input color 3: &#60;span style="color: #8de725">&#123; &#123; colorElemsComponentList?.[2].color }}&#60;/span>&#60;/div>

      <b>// ng-hyphen component</b>
      &#60;div *ngIf="ngType === 'contentchildren2'">
        &#60;div class="rounded-border">
          &#60;div>// ng-content starts&#60;/div>
          &#60;ng-content select=".content2">&#60;/ng-content>
          &#60;div>// ng-content ends&#60;/div>
        &#60;/div>
      &#60;/div>

      @ContentChildren(ChildComponent) projectedChildrenColorRef!: QueryList&#60;ChildComponent>
      childrenComponentProjection: any[] = [];
      @Output() colorElemsComponentList: EventEmitter&#60;ChildComponent[]> = new EventEmitter&#60;ChildComponent[]>();

      <b>app-child component</b>
      &#60;ng-container *ngIf="shownData === 'projectMultiComponent'">
        &#60;div>Color is &#123; &#123; color }} // app-child komponensben van&#60;/div>
      &#60;/ng-container>
    </pre>
    <li>Végül a különbségek összefoglalása
      <ul>
        <li><b>@ViewChild:</b> Adott komponens kontrolleréből hozzáférünk template reference változón keresztül egy
          elem, komponens, vagy direktíva referenciájához
        </li>
        <li><b>@ViewChildren:</b> Adott komponens kontrolleréből hozzáférünk template reference változón keresztül több
          elem, komponens, vagy direktíva referenciájához
        </li>
        <li><b>@ContentChild:</b> Projektált (más komponens ng-contentjében megjelenő) elem, komponens, vagy direktíva
          referenciájához férünk hozzá template reference változón, vagy komponens esetén akár a komponens nevén
          keresztül
        </li>
        <li><b>@ContentChildren:</b> Projektált (más komponens ng-contentjében megjelenő) elemek, komponensek, vagy
          direktívák referenciájához férünk hozzá template reference változón, vagy komponens esetén akár a komponens
          nevén keresztül
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #lifecycle data-anchor="lifecycle">Lifecycle</h3>
  <ul>
    <li>Amikor az Angular alkalmazás elkezd futni, és talál egy komponens szelektort, példányosítja a komponensben
      található class-t, és kirendereli a DOM-ba
    </li>
    <li>Az első szelektor az App komponensben található, az app-root</li>
    <li>A példányosításhoz meghívja a class konstruktorát</li>
    <li>Minden Typescript class-nak van konstruktora</li>
    <li>Tehát, amikor a program elér az app-lifecycle szelektorig, akkor létrehoz egy példányt a classból</li>
    <li>Amennyiben az osztály nem rendelkezik konstruktorral, a Typescript automatikusan létrehoz egy paraméterek
      nélkülit, amit default parameterless constructornak nevezünk
    </li>
    <li>A komponens betöltésekor megkezdődik a renderelés, amihez szükséges ellenőrizni az érkező Inputok értékeit,
      kiértékelni az adatkötéseket (data binding), renderelni a projektált tartalmakat
    </li>
    <li>Amikor ár nincs szükség a komponensre, az Angular eltávolítja a DOM-ból</li>
    <li>A fejti eseményeket nyomon tudjuk követni lifecycyle hook segítségével</li>
    <li>A lifecycle hook-ok az alkalmazás futásideje alatt, különböző időkben (a komponens létrejöttekor, változásakor,
      DOM-ból való eltávolításakor) lefutó methodok összessége
    </li>
    <li>Nézzük meg lefutásuk sorrendjében a különböző "állomásokat":</li>
    <br>
    <li>
      <h5>Constructor</h5>
      <ul>
        <li>A konstruktorban megadhatjuk, milyen logikák valósuljanak meg a komponens indulásakor</li>
        <li>Lefutásakor az @Input paraméterek még nem frissülnek, nem elérhetőek, csak inicializálódnak</li>
        <li>Lefutásakor a gyerek komponensek nem konstruktorai még nem futottak le</li>
        <li>Lefutásakor a projektált tartalom ugyancsak nem elérhető még</li>
        <li>A template view még nem renderelődik</li>
        <li>Nem része a lifecycle-nek, nem is Angular specifikus, hanem Javascript sajátosság</li>
      </ul>
    </li>
    <li>
      <h5 #onchanges data-anchor="onchanges">ngOnChanges</h5>
      <ul>
        <li>Először fut le a lifecycle hookban</li>
        <li>Mechanizmus, amelynek segítségével az Angular szinkronban tartja a template-et a kontrollerrel</li>
        <li>Ha mondjuk van egy string interpolációnk, amint annak a változónak az értéke megváltozik, a template-ben
          (weboldalon) is láthatjuk a változást
        </li>
        <li>Az Angular változás észlelési ciklust futtat, minden esemény kapcsán, ami a DOM-on történik</li>
        <li>Ez change detection cycle fut le például:
          <ol>
            <li>Amikor egy komponens @Input paramétere megváltozik</li>
            <li>Amikor DOM esemény történik, click, vagy change event</li>
            <li>Amikor setTimeOut(), vagy setInterval esemény történik</li>
            <li>Amikor HTTP kérés történik</li>
          </ol>
        </li>
        <li></li>
        <div class="rounded-border">
          <div>
            // Parent
          </div>
          <div>
            <input #onchangesmessage type="text">
          </div>
          <button class="btn btn-secondary" (click)="onchangescycle.onChangesMessage = onchangesmessage.value">Change
            @Input
          </button>
          <br>
          <br>
          <div>
            // Child
          </div>
          <app-lifecycle #onchangescycle [cycleSelector]="'onchanges'"
            [onChangesMessage]="onchangesmessage.value"></app-lifecycle>
        </div>
        <pre>
          // Parent
          &#60;input #lifecyclemessage type="text">
          &#60;button class="btn btn-secondary" (click)="applifecycle.message = lifecyclemessage.value">
            Change @Input
          &#60;/button>
          &#60;app-lifecycle #applifecycle [message]="'This is a simple message'">&#60;/app-lifecycle>

          // Child
          &#60;div>Message: &#123; &#123; message }}&#60;/div>

          @Input() message: string = '';

          ngOnChanges(changes: SimpleChanges) &#123;
            console.log(changes);
          }
        </pre>
        <li>Az app-lifecycle komponens message property-je egészen egyszerűen módosítható template reference változók
          használatával
        </li>
        <li>Az app-lifecycle komponensben a 'This is a simple message' a konstruktorban még nem érkezik meg</li>
        <li>A későbbiekben a szülő komponensbe gépelt szöveggel felülírható a gyerek komponens message változója</li>
        <li>Az ngOnChanges lifecycle hookban érkezik meg a gyerek komponensbe a beégetett, statikus értéke a property
          bindingnak ( [message] )
        </li>
        <li>Használatához implementálni kell az OnChanges interface-t</li>
        <li>Minden alkalommal, amikor az @Input() message property-be új érték érkezik, lefut az ngOnChanges method</li>
        <li>Az ngOnChanges függvénynek van egy bemeneti paramétere, aminek bármilyen nevet adhatunk, és SimpleChanges
          típusú, amely 3 kulccsal rendelkezik
          <ol>
            <li>currentValue: Az Input property aktuális értéke</li>
            <li>previousValue: Az Input property korábbi értéke</li>
            <li>firstChange: Boolean érték, ami az Input property legelső változása esetén true értéket vesz fel</li>
          </ol>
        </li>
        <li>Az ngOnChanges lifecycle hook nem fut le, ha semmilyen @Input paraméterben sem történik változás (illetve
          akkor sem, ha van ugyan változás, de a currentValue és a previousValue megegyezik)
        </li>
        <pre>
          // Működik a gyerek komponensben az értékváltoztatás, de az ngOnChanges method mégsem fut le!
          &#60;button class="btn btn-secondary" (click)="applifecycle.message = lifecyclemessage.value">Change @Input
          &#60;/button>
          &#60;app-lifecycle #applifecycle [message]="'This is a simple message'">&#60;/app-lifecycle>

          // Javításra került, nincs átadott kezdeti érték, de minden változtatásnál lefut az OnChanges
          &#60;button class="btn btn-secondary" (click)="applifecycle.message = lifecyclemessage.value">Change @Input
          &#60;/button>
          &#60;app-lifecycle #applifecycle [message]="lifecyclemessage.value">&#60;/app-lifecycle>
        </pre>
        <li>Az első változás a komponens betöltődésekor megtörténik</li>
        <pre>
          &#123;
          message: @&#123;
            currentValue: "",
            firstChange: true,
            previousValue: undefined
            }
          }
        </pre>
      </ul>
    </li>
    <li>
      <h5 #ngoninit data-anchor="ngoninit">ngOnInit</h5>
      <ul>
        <li>Az után fut le, hogy a komponens összes property-je inicializálódott (kezdeti értéket kapott), valamint
          megtörtént az első change cycle (update-elődtek az Input property-k is)
        </li>
        <li>A komponens életciklusa alatt csak egyszer fut le az ngOnChanges után</li>
        <li>A DOM nem készült még el ebben a hook-ban</li>
        <li>Ebben a ciklusban még nem jönnek létre a gyerek komponensek, és a projektált tartalmak sem elérhetőek,
          valamint a template még nem renderelődik
          <ul>
            <li>
              Mindegyik undefined még: @ViewChild, @ViewChildren, @ContentChild, @ContentChildren
            </li>
          </ul>
        </li>
        <li>Belső állapotok változtatása, és adatlekérések történnek ebben a ciklusban</li>
        <br>
        <input #oninitinput>
        <button class="btn btn-secondary" (click)="addElemToOnInitMessages(oninitinput.value)">Add new message
        </button>
        <app-lifecycle #oninitcycle [cycleSelector]="'oninit'" [onInitMessages]="messageArray"></app-lifecycle>
        <pre>
          // Parent
          &#60;input #oninitinput>
          &#60;button class="btn btn-secondary" (click)="oninitcycle.onInitMessages.push(oninitinput.value)">Add new message
          &#60;/button>
          &#60;app-lifecycle #oninitcycle [cycleSelector]="'oninit'" [onInitMessages]="messageArray">&#60;/app-lifecycle>

          // Child
          &#60;ng-container *ngIf="cycleSelector === 'oninit'">
            &#60;div class="rounded-border">
              &#60;div #oninitmessage *ngFor="let message of onInitMessages">
                &#60; &#60; message }}
              &#60;/div>
              &#60;div>Number of changes: &#60; &#60; simpleChangeCounter2 }}&#60;/div>
            &#60;/div>
          &#60;/ng-container>

          @ViewChild('oninitparagraph') onInitParagraph!: ElementRef;
          @Input() onInitMessages: string[] = [];
          simpleChangeCounter2: number = 0;

          ngOnChanges(changes: SimpleChanges) &#123;
            if (changes['onChangesMessage']) &#123;
              this.simpleChangeCounter++;
              this.simpleChangeFirstChange = changes['onChangesMessage']?.firstChange;
            }
            if (changes['onInitMessages']) &#123;
              this.simpleChangeCounter2++;
            }
          }
        </pre>
        <li>A tömb bővítésével, annak ellenére, hogy Input property, és változik az elemszám, mégsem fut le az
          ngOnChanges hook
          <ul>
            <li>A tömb egy referenciatípus</li>
            <li>Valójában egy hivatkozást tárol a memóriában lévő tényleges adatra (referencia), és nem magát az
              adatot
            </li>
            <li>Amikor a tömböt átadjuk egy másik változónak, vagy függvénynek, csak a tömb referenciáját másoljuk, nem
              magát a tömböt
            </li>
            <li>Bármilyen változtatás, amit a tömb egyik referencia változóján végrehajunk, a tömb összes többi
              referencia változójában is látható lesz
            </li>
            <li>A tömb bővítésével a tömb változik, de a referenciája nem, tehát a 'messageArray' tömb ugyanazt a
              referenciát tárolja, emiatt nem érzékelhető változás
            </li>
          </ul>
        </li>
        <li>Egy kis trükkel megtriggerelhető az ngOnChanges lifecycle hook
          <ul>
            <li>Spread operátor használatával új referenciát adhatunk a tömbünknek</li>
            <li>Valamint, úgynevezett 'deep copy'-t is használhatunk, azaz mély másolást
              <ul>
                <li>Átalakítja a tömböt, vagy objektumot JSON formátumú stringgé, amit aztán vissza alakít tömbbé, vagy
                  objektummá, aminek a referenciája megváltozik a folyamat során
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Az ngDoCheck képes figyelni a tömb elemeinek változását is</li>
        <pre>
          addElemToOnInitMessages(elem: string) &#123;
            this.messageArray = [...this.messageArray, elem]; // Spread operátor

            this.messageArray.push(elem);
            this.messageArray = JSON.parse(JSON.stringify(this.messageArray)); // Deep copy
          }
        </pre>
        <li>A szülőből a 'messageArray' átadása ennél a példánál is eredményez egy firstChange-t</li>
        <br>
        <input #oninitinput2>
        <button class="btn btn-secondary" (click)="addElemToOnInitObject(oninitinput2.value)">
          Add new ingredient to object
        </button>
        <app-lifecycle #oninitcycle2 [cycleSelector]="'oninit2'" [onInitObject]="messageObject"></app-lifecycle>
        <br>
        <li>Objektumnál sem működik trükközés nélkül az ngOnChanges hook, ugyanazon okokból kifolyólag, mint a tömb
          esetében
        </li>
        <pre>
          &#60;button class="btn btn-secondary"
                  (click)="oninitcycle2.onInitObject['message' + (Object.keys(messageObject).length + 1)] = oninitinput2.value"> // Nem okoz ngOnChange-t
            Add new ingredient to object
          &#60;/button>
          &#60;app-lifecycle #oninitcycle2 [cycleSelector]="'oninit2'" [onInitObject]="messageObject">&#60;/app-lifecycle>

          // Fix
          (click)="addElemToOnInitObject(oninitinput2.value)"

          addElemToOnInitObject(elem: string) &#123;
            this.messageObject = &#123;...this.messageObject, ['message' + (Object.keys(this.messageObject).length + 1)]: elem};
            // Spread operátor: variable = &#123;...variable, key: 'value'};
          }
        </pre>
        <li>['message' + (Object.keys(messageObject).length + 1)]
          <ul>
            <li>A fenti kódrészlettel a templateben megszámolhatjuk az objektumban lévő kulcsok számát</li>
            <li>Így a minden esetben 'message' kulcsot kapunk, a +1 hozzáadásával a sorban következő számot</li>
            <li>Viszont a templateben az Object.keys() csak akkor működik, amennyiben elhelyezzük az alábbi sort a
              komponens classban
              <ul>
                <li>protected readonly Object = Object;</li>
              </ul>
            </li>
            <li>Az Object egy Javascript objektum, automatikusan nem érhető el a templateben, deklarálni szükséges</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>
      <h5 #docheck data-anchor="docheck">ngDoCheck</h5>
      <ul>
        <li>Az ngOnChanges, és az ngOnInit után hívódik meg</li>
        <li>Minden change detection ciklus során meghívódik, még akkor is, ha az Input property-kben nincs változás</li>
        <li>Ha például megnyomunk egy gombot a weboldalon, ami nem is csinál semmit, az is lefuttatja az ngDoCheck
          lifecycle hook-ot
        </li>
        <li>Azért fut le minden (bárhová) kattintáskor a DoCheck, mert az app.component.ts fájlban a renderer figyeli a
          kattintásokat a menü bezárása érdekében
        </li>
        <button class="btn btn-secondary" (click)="menuService.setWorkingState(false)">
          Disable click listener for 15 sec
        </button>
        <li>Nincs bemeneti paramétere</li>
        <li>Lehetőséget ad custom change detection létrehozására, az olyan helyzetekre, amikor az Angular valamilyen
          okból kifolyólag nem érzékel változást (és nem hívódik meg az OnChange), vagy esetleg csak szeretnénk minden
          egyes user interakciókor valamit ellenőrizni
        </li>
        <li></li>
        <br>
        <input #oninitinput3>
        <button class="btn btn-secondary" (click)="addElemToDoCheckObject(oninitinput3.value)">
          Add new ingredient to object
        </button>
        <app-lifecycle #appdocheck [cycleSelector]="'docheck'" [onInitObject2]="messageObject2"></app-lifecycle>
        <pre>
          //Parent
          &#60;app-lifecycle #appdocheck [cycleSelector]="'docheck'" [onInitObject2]="messageObject2">&#60;/app-lifecycle>

          // Child
          &#60;ng-container *ngIf="cycleSelector === 'docheck'">
            &#60;div class="rounded-border">
              &#60;pre>
                &#123; &#123; onInitObject2 |json }}
              &#60;/pre>
              &#60;div>Number of changes: &#123; &#123; changeCounter }}&#60;/div>
              &#60;div>Number of doChecks: &#123; &#123; doCheckCounter }}&#60;/div>
            &#60;/div>
          &#60;/ng-container>
        </pre>
      </ul>
    </li>
    <li>
      <h5 #aftercontentinit data-anchor="aftercontentinit">ngAfterContentInit</h5>
      <ul>
        <li>Az ngDoCheck után fut le, amikor már az összes kívülről beszúrt (projektált) gyerek content inicializálva
          lett (az összes ng-content-be megtörtént a beillesztés)
        </li>
        <li>Csak egyszer hívódik meg (ebben hasonlít az OnInit-re, de egyébként az összes Init-re ez a jellemző), akkor
          is, ha nincs projected content a komponensben
        </li>
        <li>Ebben a lifecycle hookban már elérhető a @ContentChild és @ContentChildren</li>
        <br>
        <app-lifecycle [cycleSelector]="'aftercontentinit'">
          <div #aftercontentinitprojection> This is a projected DIV element to child's ng-content</div>
        </app-lifecycle>
        <br>
        <li>A ContentChild az ngOnInit hook-ban undefined, az ngAfterContentInit-ben viszont már elérhető</li>
        <pre>
          // Parent
          &#60;app-lifecycle [cycleSelector]="'aftercontentinit'">
            &#60;div #aftercontentinitprojection>> This is a projected DIV element to child's ng-content &#60;&#60;/div>
          &#60;/app-lifecycle>

          // Child
          &#60;ng-container *ngIf="cycleSelector === 'aftercontentinit'">
            &#60;div class="rounded-border">
              &#60;ng-content>&#60;/ng-content>
              &#60;br>
              &#60;div>Projection during ngOnInit: &#123; &#123; projectionDuringOnInit }}&#60;/div>
              &#60;br>
              &#60;div>Projection during ngAfterContentInit: &#123; &#123; projectionDuringAfterContentInit | json }}&#60;/div>
            &#60;/div>
          &#60;/ng-container>

          @ContentChild('aftercontentinitprojection') afterContentInitProjection!: ElementRef;
          projectionDuringOnInit: any;
          projectionDuringAfterContentInit: any;

          ngOnInit() &#123;
            this.projectionDuringOnInit = this.afterContentInitProjection;
          }

          ngAfterContentInit() &#123;
            this.projectionDuringAfterContentInit = this.afterContentInitProjection;
          }
        </pre>
        <li>A példában azért nem az ngDoCheck szerepel (hiszen ott sem elérhető még a ContentChild/ContentChildren),
          mert más is megtriggereli a a DoCheck-et, így többször lefut, és amíg az első futásra undefined a visszaadott
          értéke a a ContentChildnak, addig a DoCheck második futásánál már elérhető, így a fenti példa nem lenne
          szemléletes
        </li>
        <li>Az ngAfterContentInit, és ngAfterContentChecked komponens hook-ok, direktívák számára nem elérhetők</li>
      </ul>
    </li>
    <li>
      <h5 #aftercontentchecked data-anchor="aftercontentchecked">ngAfterContentChecked</h5>
      <ul>
        <li>Minden change detection ciklusban lefut (az elsőnél is), miután az Angular inicializálta az összes
          projektált tartalmat
        </li>
        <app-lifecycle [cycleSelector]="'aftercontentchecked'">
          <div>
            <input #aftercontentcheckedinput id="aftercontentcheckedinput1" [ngModel]="afterContentCheckedInputValue">
            <label for="aftercontentcheckedinput1">Don't have input event</label>
          </div>
          <br>
          <div>
            <input #aftercontentcheckedinput id="aftercontentcheckedinput2" (focus)="0">
            <label for="aftercontentcheckedinput2">Have input event</label>
          </div>
          <br>
          <p>Entered input value: {{ afterContentCheckedInputValue }}</p>
        </app-lifecycle>
        <li>Minden alkalommal, amikor változik az input értéke, változik az 'afterContentCheckedInputValue' értéke is,
          amit szintén projektálódik a gyerek komponensbe, így a változásoknál le fog futni az ngAfterContentChecked
        </li>
        <li>Szintén a kattintásokra is érzékeny a change detection, továbbra is az app.component.ts-ben lévő click event
          végett, de az látszik, hogy az input mezőbe gépelve nő a change-ek száma
        </li>
        <button class="btn btn-secondary" (click)="menuService.setWorkingState(false)">
          Disable click listener for 15 sec
        </button>
        <li>A gombbal 15 másodpercre kikapcsolható az app.component.ts-ben lévő click event figyelés</li>
        <li>A felső input mezőnél a data binding miatt fut le a change detection kikattintáskor (blur)</li>
        <li>Az alsó input mezőre kerül egy focus event binding, így a mezőbe kattintva is triggerelődik a change
          detection
        </li>
        <pre>
          // Parent
          &#60;app-lifecycle [cycleSelector]="'aftercontentchecked'">
            &#60;div>
              &#60;input #aftercontentcheckedinput id="aftercontentcheckedinput1" [(ngModel)]="afterContentCheckedInputValue">
              &#60;label for="aftercontentcheckedinput1">Don't have input event&#60;/label>
            &#60;/div>
            &#60;br>
            &#60;div>
              &#60;input #aftercontentcheckedinput id="aftercontentcheckedinput2"
                     (focus)="0">
              &#60;label for="aftercontentcheckedinput2">Have input event&#60;/label>
            &#60;/div>
            &#60;br>
            &#60;p>Entered input value: &#60; &#60; afterContentCheckedInputValue }}&#60;/p>
          &#60;/app-lifecycle>

          // Child
          &#60;ng-container *ngIf="cycleSelector === 'aftercontentchecked'">
            &#60;div class="rounded-border">
              &#60;ng-content>&#60;/ng-content>
              &#60;br>
              &#60;div>ngAfterContentChecked run counter: &#123; &#123; afterContentCheckedInputChangeCounter }}&#60;/div>
            &#60;/div>
          &#60;/ng-container>

          ngAfterContentChecked() &#123;
            this.afterContentCheckedInputChangeCounter++;
          }
        </pre>
        <li>Amennyiben például egy gomb változtatná a projektált content-et nem (tehát a UI-ban semmi változás sem
          történik), de a konkrét tartalma nem változna, akkor is lefutna a change detection, és ezzel együtt az
          ngAfterContentChecked is
        </li>
        <li>Az Angular frissíti a ContentChild és ContentChildren tartalmakat, mielőtt lefutna az
          ngAfterContentChecked
        </li>
        <li>Az ngAfterContentInit, és ngAfterContentChecked komponens hook-ok, direktívák számára nem elérhetők</li>
      </ul>
    </li>
    <li>
      <h5 #afterviewinit data-anchor="afterviewinit">ngAfterViewInit</h5>
      <ul>
        <li>Lefut, ha a komponens view template-je, és a komponens összes gyerek view templateje inicializálódott</li>
        <li>Vonatkozik ez a gyerekek gyerekére is, tehát a teljes komponens fára (aminek az aktuális komponens a
          "root"-ja)
        </li>
        <li>Csak az első change detection cycle során fut le, mint az összes Init hook</li>
        <li>A ViewChild és ViewChildren property-k már elérhetőek, ezt megelőzően pedig undefined az értékük</li>
        <li>A szülő komponens ngAfterViewInit-je csak az után fut le, hogy már az összes gyerek template-je elkészült
        </li>
      </ul>
    </li>
    <li>
      <h5 #afterviewichecked data-anchor="afterviewichecked">ngAfterViewChecked</h5>
      <ul>
        <li>Amikor a komponens view-ja inicializálóik, vagy megváltozik, lefut</li>
        <li>A ViewChild és ViewChildren frissített értékeit ebben a hookban érjük el</li>
      </ul>
    </li>
    <li>
      <h5 #ondestroy data-anchor="ondestroy">ngOnDestroy</h5>
      <ul>
        <li>Az Angular akkor aktiválja, mielőtt a komponens DOM-ból való eltávolításrára sor kerülne</li>
        <br>
        <button type="button" class="btn btn-secondary"
          (click)="childComponentIsDestroyed = !childComponentIsDestroyed">
          Component destroyer toggler
        </button>
        <br>
        <br>
        <app-lifecycle *ngIf="childComponentIsDestroyed" #appondestroy [cycleSelector]="'ondestroy'"
          (destroysEvent)="destroysIncreased()">
          <div>This is a projected content to child</div>
        </app-lifecycle>
        <br>
        <div>Child component is destroyed: {{ !childComponentIsDestroyed }}</div>
        <br>
        <div>Number of child component is destroyed: {{ numberOfChildComponentIsDestroyed }}</div>
        <br>
        <li>A child komponens DOM-ból való eltüntetésekor lefut az ngOnDestroy függvény, ahol még végezhetünk
          műveleteket
        </li>
        <li>Jelen esetben egy event binding történik, OnDestroy esetén a gyerektől a szülő kap egy eventet, ami egy szám
          típusú változó értékét növeli meg eggyel
        </li>
        <pre>
          // Parent
          &#60;button type="button" class="btn btn-secondary"
                  (click)="childComponentIsDestroyed = !childComponentIsDestroyed">
            Component destroyer toggler
          &#60;/button>
          &#60;br>
          &#60;br>
          &#60;app-lifecycle *ngIf="childComponentIsDestroyed" #ondestroy
                         [cycleSelector]="'ondestroy'"
                         (destroysEvent)="destroysIncreased()">
            &#60;div>This is a projected content to child&#60;/div>
          &#60;/app-lifecycle>
          &#60;br>
          &#60;div>Child component is destroyed: &#123; &#123; !childComponentIsDestroyed }}&#60;/div>
          &#60;br>
          &#60;div>Number of child component is destroyed: &#123; &#123; numberOfChildComponentIsDestroyed }}&#60;/div>

          destroysIncreased() &#123;
            this.numberOfChildComponentIsDestroyed++;
          }

          // Child
          &#60;ng-container *ngIf="cycleSelector === 'ondestroy'">
              &#60;ng-content>&#60;/ng-content>
          &#60;/ng-container>

          @Output() destroysEvent: EventEmitter&#60;void> = new EventEmitter&#60;void>();

          ngOnDestroy() &#123;
            this.destroysEvent.emit();
          }
        </pre>
        <li>Tisztogatásra kiváló hook, például leiratkozni observable-ökről, event handlereket törölni a memory leak
          (memóriaszivárgás) csökkentése / megelőzése végett
        </li>
        <li>Az utolsó lifecycle hook-ja a komponenseknek, direktíváknak</li>
      </ul>
    </li>
    <li><b>Különbségek</b>
      <ul>
        <li>ngDoCheck:
          <ul>
            <li>Minden change detection cycle-ben lefut</li>
            <li>Ebben a hookban sem az ngAfterContentChecked-ben, sem pedig az ngAfterViewChecked-ben már megtörténő
              változások nem elérhetők
            </li>
          </ul>
        </li>
        <li>ngAfterContentChecked:
          <ul>
            <li>Csak azután hívódik meg minden változáskor, ha a projektált tartalom inicializálódott</li>
            <li>Ha össze akarnánk hasonlítani a korábbi, és az aktuálisan projektált tartalmat, azt itt tudjuk
              megtenni
            </li>
            <li>Minden változásdetektálási ciklus után lefut, ha a komponensben van ng-content, még akkor is, ha nem
              történt változás a projektált tartalomban
            </li>
          </ul>
        </li>
        <li>ngAfterViewChecked:
          <ul>
            <li>Csak onnantól hívódik meg minden change detection esetén, ha már a szülő, és az összes gyerek
              template-je inicializálódott
            </li>
            <li>Ha össze akarnánk hasonlítani a korábbi, és az aktuálisan view-t, azt itt tudjuk
              megtenni
            </li>
            <li>Ideális hely lehet a vizuális elemek és a nézetek összehasonlítására</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li><b>Lifecycle sorrend</b>
      <ol>
        <li>(constructor) // Nem lifecycle hook</li>
        <li>ngOnChanges</li>
        <li>ngOnInit</li>
        <li>ngDoCheck</li>
        <li>ngAfterContentInit</li>
        <li>ngAfterContentChecked</li>
        <li>ngAfterViewInit</li>
        <li>ngAfterViewChecked</li>
        <li>ngOnDestroy</li>
      </ol>
    </li>
    <br>
    <li><b>Lifecycle sorrend gyerek komponens esetén</b>
      <ol>
        <li>Parent: ngOnChanges</li>
        <li>Parent: ngOnInit</li>
        <li>Parent: ngDoCheck</li>
        <li>Parent: ngAfterContentInit</li>
        <li>Parent: ngAfterContentChecked</li>
        <li>Child: ngOnChanges</li>
        <li>Child: ngOnInit</li>
        <li>Child: ngDoCheck</li>
        <li>Child: ngAfterContentInit</li>
        <li>Child: ngAfterContentChecked</li>
        <li>Child: ngAfterViewInit</li>
        <li>Child: ngAfterViewChecked</li>
        <li>Parent: ngAfterViewInit</li>
        <li>Parent: ngAfterViewChecked</li>
      </ol>
    </li>
    <br>
    <li><b>Lifecycle sorrend gyerek komponens esetén, inicializált állapotban, ha a projektált tartalom megváltozik</b>
      <ol>
        <li>Parent: ngDoCheck - A szülő komponens változásdetektálása elindul</li>
        <li>Parent: ngAfterContentChecked - A szülő komponens projektált tartalmának ellenőrzése</li>
        <li>Child: ngDoCheck - A child komponens is átesik egy változásdetektálási cikluson</li>
        <li>Child: ngAfterContentChecked - A child komponens projektált tartalmának ellenőrzése</li>
        <li>Child: ngAfterViewChecked - A child komponens nézetének ellenőrzése</li>
        <li>Parent: ngAfterViewChecked - A szülő komponens nézetének ellenőrzése</li>
      </ol>
    </li>
  </ul>
</div>

<div>
  <h3 #customdirective data-anchor="customdirective">Custom directive</h3>
  <ul>
    <li>Minden angular komponens egy direktíva</li>
    <li>Direktívák számára elérhető lifecycle hook-ok a következők:
      <ol>
        <li>ngOnChanges</li>
        <li>ngOnInit</li>
        <li>ngDoCheck</li>
        <li>ngOnDestroy</li>
      </ol>
    </li>
    <li>Beépített direktívák például:
      <ol>
        <li>ngIf (struktúrális)</li>
        <li>ngFor (struktúrális)</li>
        <li>ngSwitch (struktúrális) [ngSwitch / ngSwitchCase / ngSwitchDefault]</li>
        <li>ngStyle (attribútum)</li>
        <li>ngClass (attribútum)</li>
        <li>ngModel (attribútum)</li>
        <li>ngForm (attribútum)</li>
        <li>ngSubmit (attribútum)</li>
        <li>ng-container (egyéb)</li>
        <li>ng-template (egyéb)</li>
        <li>routerLink (egyéb)</li>
        <li>routerLinkActive (egyéb)</li>
        <li>etc.</li>
      </ol>
    </li>
    <br>
    <h5 #customdirectivecreation data-anchor="customdirectivecreation">Creation</h5>
    <li>Az ng g d / ng g directive / ng generate d / ng generate directive paranccsal hozható létre direktíva</li>
    <pre>
      import &#123; Directive } from '@angular/core';

      @Directive(&#123;
            selector: '[setBackgroundToBrown]'
      })
      export class SetBackgroundToBrownDirective &#123;
            constructor(element: ElementRef) &#123;
              element.nativeElement.style.backgroundColor = '#6e3208';
              // element.nativeElement.style.color = '#c3e8e2';
        }
      }
    </pre>
    <li>A fájlstruktúrában jelen projektben egy shared modulba kerültnek a direktívák, így az ott lévő module.ts fájlban
      szükséges deklarálni őket, illetve annak érdekében, hogy az app-ban is használhatóak legyenek, exportálni is
    </li>
    <li>@Directive dekorátorral szükséges ellátni</li>
    <li>A dekorátor metadata objektumot kap
      <ul>
        <li>selector: '[setBackgroundToBrown]'</li>
      </ul>
    </li>
    <li>A direktívákat, mint attribútumokat tudjuk használni</li>
    <li>A szelektort attribútumként szeretnénk használni, ezért szükséges a zárójel '[setBackgroundToBrown]'</li>
    <li>Amikor egy elemre direktívát helyezünk el, az Angular dependency injection segítségével az elem referenciáját
      átadja a direktíva komponens osztályának
    </li>
    <li>Ezért a konstruktorban létrehozhatunk egy paramétert (element: ElementRef)</li>
    <li>Amikor egy DOM elemen használjuk a direktívát, akkor példányosítás történik, létrejön egy példánya a direktíva
      osztálynak, és ahhoz, hogy létrejöjjön ez a példány, a kontruktora meghívódik
    </li>
    <li>Az element paraméter megkapja a az elem referenciáját, amin elhelyeztük a direktívás</li>
    <pre>
      &#60;div setBackgroundToBrown>This DIV has an attribute: setBackgroundToBrown (directive)&#60;/div>
    </pre>
    <div setBackgroundToBrown>This DIV has an attribute: setBackgroundToBrown</div>
    <br>
    <li>Minden egyes használatkor újabb és újabb direktíva osztály példányok keletkeznek</li>
    <li>Tehát a HTML elemnek, vagy a komponensnek meg van a referenciája, mint konstruktor paraméter</li>
    <li>Az element.nativeElement tárolja a HTML DOM elemet</li>
    <li>Bármilyen HTML elemen lehet használni</li>
    <br>
    <div setBackgroundToBrown [setColorToo]="true">This DIV has an attribute: setBackgroundToBrown (setColorToo)</div>
    <pre>
      // PARENT
      &#60;div setBackgroundToBrown [setColorToo]="true">This DIV has an attribute: setBackgroundToBrown&#60;/div>

      // DIRECTIVE
      export class SetBackgroundToBrownDirective implements OnChanges &#123;
            @Input() setColorToo: boolean = false;

            elementRef!: ElementRef;

            constructor(element: ElementRef) &#123;
          this.elementRef = element;
          element.nativeElement.style.backgroundColor = '#6e3208';
        }

        ngOnChanges(&#123;setColorToo}: SimpleChanges) &#123;
          if (setColorToo.currentValue === true) &#123;
            this.elementRef.nativeElement.style.color = '#c3e8e2';
          }
        }
      }
    </pre>
    <li>A fenti példában kiegészítettük a direktívát egy bemeneti paraméterrel, amit az ngOnChanges lifecycle hook-ban
      érünk el
    </li>
    <li>A konstruktorban átadjuk az adott elem referenciáját, amit a change-nél használunk, ha true érték érkezik a
      setColorToo változóba, akkor a szöveg színe világkék lesz
    </li>
    <li>A bemeneti paramétere az ngOnChanges függvénynek kibontható</li>
    <pre>
      ngOnChanges(changes: SimpleChanges) &#123;}

      VAGY

      ngOnChanges(&#123;setColorToo}: SimpleChanges) &#123;}
    </pre>
    <li>A fenti példában a konstruktorba került a logika, de ez nem a megfelelő hely, mert a class (bizonyára @Input())
      property-jei még nincsenek inicializálva, így az OnInit lifecycle-t szoktuk használni (nem az OnChanges-t)
    </li>
    <pre>
      export class SetBackgroundToBrownDirective implements OnInit &#123;
        @Input() setColorToo: boolean = false;

        // elementRef!: ElementRef;

        constructor(private element: ElementRef) &#123;
          element.nativeElement.style.backgroundColor = '#6e3208';
        }

        ngOnInit() &#123;
          if (this.setColorToo) &#123;
            this.element.nativeElement.style.color = '#c3e8e2';
          }
        }
      }
    </pre>
    <li>constructor(private element: ElementRef): A háttérben a Typescript létrehoz egy private property-t</li>
    <br>
    <h5 #customdirectiverenderer data-anchor="customdirectiverenderer">Renderer2</h5>
    <li>Nem a megfelelő megközelítés közvetlenül módosítani a DOM elemeket</li>
    <li>Az Angular a komponensek, és view-k szinkronban tartását például template-k, adatkötések (data binding), change
      detection segítségével teszi
    </li>
    <li>A DOM direktben módosításával megkerüljük ezeket, amit nem tanácsos megtenni
      <ul>
        <li>A DOM manipuláció csakis kizárólag böngészőkben működik, egyéb platformokon, workor-ökön, szervereken nem
          fog
          működni az applikáció
        </li>
        <li>A böngésző által biztosított DOM API-k (például a innerHTML, document.write(), stb.) nem végeznek
          automatikus adatellenőrzést vagy tisztítást
        </li>
        <li>A rosszindulatú felhasználók képesek lehetnek olyan adatokat (például JavaScript kódot) injektálni,
          amelyeket a böngésző végrehajt, amit Cross-Site Scripting-nek (XSS) nevezünk
          <ul>
            <li>Az XSS támadás során a támadó beágyazhat olyan JavaScript kódot egy alkalmazásba, amely végül a
              felhasználó böngészőjében fut le
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A Renderer2 class egy sokkal biztonságosabb DOM manipuláló
      <ul>
        <li>Nem direkt férünk hozzá az elemekhez</li>
        <li>A DOM elem és a komponens kód közötti absztrakciós réteget használja</li>
        <li>Be szükséges injektálni az adott direktívába a Renderer2 osztály egy példányát</li>
        <li>A konstruktorba egy újabb paramétert deklarálunk, aminek típusa Renderer2</li>
        <pre>
          constructor(private element: ElementRef, renderer: Renderer2) &#123;
            ...
          }
        </pre>
        <li>Ezzel hozzárendelünk egy példányát a Renderer2 osztálynak a renderer paraméterhez</li>
        <li>Ebben a formában csak a konstruktorban elérhető, másképp mondva lokális változója lesz a konstruktornak,
          ezért a dependency injection-nél a 'private' access modifier-t ráaggatjuk, akkor már a class-ra lesz lokálisan
          elérhető a változó
        </li>
        <pre>
          constructor(private element: ElementRef, private renderer: Renderer2) &#123;
            ...
          }
        </pre>
        <li>Létrehozhatunk elemeket, szöveget adhatunk hozzá, appendChild metódussal gyerekek adhatunk hozzá, ugyancsak
          hozzáadhatunk stílus attribútumokat, CSS osztályokat, property-ket
        </li>
        <pre>
          export class SetBackgroundToBrownDirective implements OnInit &#123;
            @Input() setColorToo: boolean = false;

            private renderer!: Renderer2;

            constructor(renderer: Renderer2) &#123;
              renderer.setStyle(element.nativeElement, 'backgroundColor', '#6e3208');
              this.renderer = renderer;
            }

            ngOnInit() &#123;
              if (this.setColorToo)
                  this.renderer.setStyle(this.element.nativeElement, 'color', '#c3e8e2')
              }
            }
          }
        </pre>
        <li>A setStyle metódussal CSS stílusokat tudunk adni az elemnek
          <ul>
            <li>3 paramétert kér (+1)
              <ol>
                <li>Az elem, amin a stílust akarjuk érvényesíteni (.nativeElement)</li>
                <li>A stílus, amit be akarunk állítani</li>
                <li>A stílus értéke</li>
                <li>Opcionálisan a 'flags' paraméter is beállítható
                  <ul>
                    <li>Lehetőséget ad arra, hogy beállítsuk a stílusok frissítési módját</li>
                  </ul>
                </li>
              </ol>
            </li>
          </ul>
        </li>
        <br>
        <div setBackgroundToBrown [setTitle]="true">This DIV has an attribute: setBackgroundToBrown (setFontSize)
        </div>
        <br>
        <pre>
          this.renderer.setAttribute(this.element.nativeElement, 'title', 'Title is set');

          // Result
          &#60;div _ngcontent-egh-c12="" setbackgroundtobrown="" ng-reflect-set-title="true" title="Title is set"
               style="background-color: rgb(110, 50, 8);">
            This DIV has an attribute: setBackgroundToBrown (setFontSize)
          &#60;/div>
        </pre>
        <li>A setAttribute metódussal (a nevéből adódóan) attribútumot tudunk beállítani az elemnek
          <ul>
            <li>Dinamikusan tudunk HTML elemnek attribútumot adni</li>
            <li>Beállítható például 'title', 'alt', 'href', 'src', 'class'</li>
            <li>A title-t beállítva, hogy annak látszatja is legyen, tartsuk a div elemen az egeret</li>
          </ul>
        </li>
        <br>setCustomClass
        <div setBackgroundToBrown [setCustomClass]="true">This DIV has an attribute: setBackgroundToBrown
          (setCustomClass)
        </div>
        <pre>
          &#60;div setBackgroundToBrown [setCustomClass]="true">This DIV has an attribute: setBackgroundToBrown (setCustomClass)&#60;/div>

          // Result
          &#60;div _ngcontent-ufg-c12="" setbackgroundtobrown="" ng-reflect-set-custom-class="true" class="custom-class"
            style="background-color: rgb(110, 50, 8);">
              This DIV has an attribute: setBackgroundToBrown
          &#60;/div>
        </pre>
        <li>A addClass metódussal CSS szabályokat adhatunk az elemnek
          <ul>
            <li>Szorosan kapcsolódik hozzá a removeClass method</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <h5 #propertybindingindirective data-anchor="propertybindingindirective">Property binding in directives</h5>
    <ul>
      <li>A host elemnek természetesen nem csak beégetett módon lehet a renderer segítségével stílust</li>
      <li>Azt szeretnénk elérni, hogy a felhasználó meg tudja adni a property-k értékeit</li>
      <br>
      <div propertybindingold [background]="'#995511'" [color]="'#EEEEEE'">Property binding in directive</div>
      <br>
      <li>A host elemre property binding került (background és color), a dekorátorban pedig ez a két property Input
        dekorátort kapott</li>
      <pre>
        // Parent
        &#60;div propertybinding [background]="'#995511'" [color]="'#EEEEEE'">Property binding in directive&#60;/div>

        // Directive
        export class PropertybindingDirective implements OnInit &#123;
          @Input() background: string = '';
          @Input() color: string = '';
      
          constructor(private element: ElementRef, private renderer: Renderer2) &#123;
          }
      
          ngOnInit(): void &#123;
              this.renderer.setStyle(this.element.nativeElement, 'background', this.background);
              this.renderer.setStyle(this.element.nativeElement, 'color', this.color);
          }
        }
      </pre>
      <li>A direktívák input property-jeivel dinamikusan állíthatjuk/változtathatjuk a host elem stílusát, osztályát,
        stb.</li>
      <li>Az ngClass direktívának direkt módon adunk meg értéket, értékeket, és nem pedig a direktíva property-jeinek,
        mint ahogy a fenti példában láthatjuk
      </li>
      <li>Nézzük meg, miképp tehetjük meg ezt a custom direktívánkkal
        <ul>
          <li>A propertybinding direktívának szeretnénk értéket adni, nem pedig az input property-jeinek</li>
          <li>Amennyiben a szelektornak értéket adunk, az az érték kerüljön bele a direktíva property-jébe</li>
          <li>Ennek megvalósítása érdekében az @Input dekorátornak átadunk egy argomentumot, ami a property alias-a lesz
          </li>
          <li>Az argomentum egyezzen meg a szelektrorral</li>
          <li>Ez után már nem használhatjuk property bindingra a direktívában lévő property-t, az alias-szal tudunk
            tovább dolgozni</li>
          <li>Ezek után a direktíva szelektorokat már nem szükséges használni</li>
          <li>Amennyiben más propert-k értékét is be szeretnénk állítani, vagy az aliasnak (ami most a szelektor neve),
            mint property binding szerepelnie kell az elemen, vagy pedig az elemnek meg kell adni a direktíva
            szelektorát</li>
          <br>
          <div propertybindingold [background]="'#995511'" [color]="'#EEEEEE'">Property binding in directive</div>
          <div [propertybindingold] [color]="'#EEEEEE'">Property binding in directive</div>
          <div [propertybindingold]="'blue'" [color]="'#EEEEEE'">Property binding in directive</div>
          <pre>
            // Parent
            &#60;div propertybindingold [background]="'#995511'" [color]="'#EEEEEE'">Property binding in directive&#60;/div>
            // A szelektorral kapcsolt direktíva (propertybinding) mellett property binding-ot (background és color) is használtunk
            
            &#60;div [propertybindingold] [color]="'#EEEEEE'">Property binding in directive&#60;/div>
            // Ebben az esetben a background2 input alias-t használtuk, és mivel nem kapott a template-ből értéket, ezért a default (red) értéket vette fel

            &#60;div [propertybindingold]="'blue'" [color]="'#EEEEEE'">Property binding in directive&#60;/div>
            // Konkrétan megadtuk a background2 alias-ának a a blue  értéket 

            // Directive
            @Input('propertybindingold') background2: any = 'red';
            // A későbbi példa miatt átnevezésre került 'propertybindingold' névre

            this.renderer.setStyle(this.element.nativeElement, 'background', this.background2 || this.background);
          </pre>
          <li>Honnan tudja az Angular, hogy a title a span DOM elem attribútuma (attribute binding), vagy a direktíva
            property-je (property binding)?</li>
          <br>
          <div [propertybindingold]="'#212121'" [color]="'#b2b1bc'" [title]="'Example title'">Property binding in
            directive
          </div>
          <pre>
            // Parent
            &#60;div [propertybindingold]="'#212121'" [color]="'#b2b1bc'" [title]="'Example title'">Property binding in directive&#60;/div>

            // Direktíva
            @Input() title: string = 'My title';


          </pre>
          <li>A span-nak ugyanúgy van egy title property-je / attribútuma</li>
          <li>Tulajdonképpen az Angular kitalálja, megnézi a direktíva property-jeit, és amennyiben van egyezés, azaz az
            attribútum neve és az input property neve azonos, akkor azonosítja, mint property binding, és tovább adja az
            értéket a direktíva property-jének</li>
          <li>Amennyiben a direktív-nak nincs adott nevű property-je, akkor az Angular megnézi, hogy a DOM elem, amit
            attribute bindinggal láttunk el, rendelkezik-e azzal az adott nevű property-vel</li>
          <br>
          <li>A direktívában az input aliasnak ( @Input('propertybindingold') ) csak egy értéket adtunk át fentebb
            <ul>
              <li>Ugyanakkor megadható több property is</li>
              <li>Két ugyanúgy elnevezett alias-t ugyanakkor nem használhatunk két külön property-re</li>
              <li>Készítsünk egy property-t, aminek a típusa anonymous object (avagy névtelen objektum)</li>
              <div [propertybinding]="{background: 'purple', color: 'white'}">Property binding in directive</div>
              <pre>
                // Parent
                &#60;div [propertybinding]="&#123;background: 'purple', color: 'white'}">Property binding in directive&#60;/div>

                // Child
                export class PropertybindingDirective implements OnInit &#123;
                  @Input('propertybinding') changeAllProp!: &#123;background: string, color: string};
              
                  constructor(private element: ElementRef, private renderer: Renderer2) &#123;
                  }
              
                  ngOnInit(): void &#123;
                      this.renderer.setStyle(this.element.nativeElement, 'background', this.changeAllProp.background);
                      this.renderer.setStyle(this.element.nativeElement, 'color', this.changeAllProp.color);
                  }
                }
              </pre>
              <li>A property binding egy Typescript kifejezést, egy objektumot kapott background és color kulcsokkal
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
    <br>
    <h5 #conditionalattributedirective data-anchor="conditionalattributedirective">Conditional attribute directive</h5>
    <ul>
      <li>Az attribútum direktíva feltételesen megadható DOM elemnek, vagy komponensnek</li>
      <li>Létrehoztunk egy új direktívát</li>
      <li>Bármilyen HTML elemen kívánjuk használni a szelektort, arról az elemről referenciát kapunk
        <ul>
          <li>A referenciát dependency injection segítségével, az ElementRef osztály injektálásával tesszük meg</li>
          <li>A private access modifier végett egy, az osztályra lokális property is létrejön</li>
        </ul>
      </li>
      <li>A Renderer2 osztályra szintén szükségünk lesz</li>
      <li>Hozzunk létre egy input property-t is (boolean), aminek a neve legyen azonos a szelektoréval</li>
      <li>Amikor true fog érkezni, alkalmazunk valamilyen logikát a host elemre</li>
      <br>
      <div style="display: flex; gap: 10px;">
        <span style="display: inline-block; width: 50px; height: 50px; background-color: #4b4b4b;"></span>
        <span style="display: inline-block; width: 50px; height: 50px; background-color: #4b4b4b;"
          [disableElement]="boxIsDisabled"></span>
        <span style="display: inline-block; width: 50px; height: 50px; background-color: #4b4b4b;"></span>
        <button type="button" class="btn btn-secondary" (click)="boxIsDisabled = !boxIsDisabled">Toggle disable
          box</button>
      </div>
      <br>
      <li>A direktívában az input property-n setter metódust használunk
        <ul>
          <li>Amikor 'set' kulcsszót használunk egy property előtt, akkor a property-t használhatjuk method-ként</li>
          <li>Az érkező értéket argomentumként tovább t udjuk adni a metódusnak</li>
        </ul>
      </li>
      <pre>
        // Parent
        &#60;div style="display: flex; gap: 10px;">
          &#60;span style="display: inline-block; width: 50px; height: 50px; background-color: #4b4b4b;">&#60;/span>
          &#60;span style="display: inline-block; width: 50px; height: 50px; background-color: #4b4b4b;"
            [disableElement]="boxIsDisabled">&#60;/span>
          &#60;span style="display: inline-block; width: 50px; height: 50px; background-color: #4b4b4b;">&#60;/span>

          &#60;button type="button" class="btn btn-secondary" (click)="boxIsDisabled = !boxIsDisabled">
          Toggle disablebox
          &#60;/button>
        &#60;/div>
        
        // Directive
        export class DisableElementDirective &#123;
          @Input() set disableElement(disable: boolean) &#123;
            if (disable) &#123;
              this.renderer.setStyle(this.element.nativeElement, 'opacity', '.5');
            } else &#123;
              this.renderer.setStyle(this.element.nativeElement, 'opacity', '1');
            }
          };
      
          constructor(private element: ElementRef, private renderer: Renderer2) &#123;
      
          }
        }
      </pre>
      <li>A 'boxIsDisabled' értékét megkapja a setter method 'disable' argomentuma</li>
      <li>Így lehet feltételesen használni egy direktívát</li>
    </ul>
    <br>
    <h5 #customclassdirective data-anchor="customclassdirective">Custom class directive</h5>
    <ul>
      <li>Az ngClass direktíva újraírását nézzük meg, hogy megértsük a működését, illetve elsajátítsuk a megfelelő
        gondolkodást, ha hasonló direktívát szeretnénk implementálni</li>
      <li>Az ngClass-nak alapesetben egy objektumot adunk ([ngClass]="&#123;class: boolean}")</li>
      <li>Azt kell elérnünk, hogy a saját custom class direktívánk ugyanezt a működést eredményezze</li>
      <br>
      <div [customClass]="{class1:true,class2:true,class3:false,class4:true}">Element with custom class directive</div>
      <pre>
        // Parent
        &#60;div [customClass]="&#123;class1:true,class2:true,class3:false,class4:true}">
          Element with custom class directive
        &#60;/div>

        // Directive
        export class CustomClassDirective &#123;
          @Input('customClass') set addClasses(classes: Object) &#123;
              const classEntries = Object.entries(classes);
              // for (let  i = 0; i < classEntries.length; i++) &#123;...}
              for (let [className, condition] of Object.entries(classes)) &#123;
                  // const [className, condition] = i;
                  if (condition) &#123;
                      this.renderer.addClass(this.element.nativeElement, className);
                  }
      
              };
          };
      
          constructor(private element: ElementRef, private renderer: Renderer2) &#123;
          }
        }

        // Result
        &#60;div class="class1 class2 class4">Element with custom class directive&#60;/div>
      </pre>
      <li>Array destructuring-et használtunk, azaz felbontottuk minden ciklusban a két elemből álló tömböt ([className,
        condition])</li>
      <li>Az osztály neve csak abban az eseten kerül az host elemhez hozzáadásra, amennyiben a kondíció boolean értéke
        true</li>
      <li>Az 'addClass' setter metódus alias-a a fenti példában megegyezik a szelektor nevével, így a template-ben nem
        szükséges külön alkalmaznunk a direktíva nevét, hanem property binding-ot alkalmazunk ( [customClass]="" )</li>
      <li>A 'classes' paraméterbe kerül bele a template-ből átadott objektum, amin Object.entries() metódussal tudunk
        végig iterálni</li>
      <li>A @Input('customClass') alias nélkül is megoldható a feladat</li>
      <pre>
        @Input() set customClass(classes: Object) &#123;
          ...
        }
      </pre>
      <li>A setter metódus nevének kell ebben az esetben megegyeznie a szelektoréval</li>
    </ul>
    <br>
    <h5 #customstyledirective data-anchor="customstyledirective">Custom style directive</h5>
    <ul>
      <li>Az ngStyle, ha még feltétele is van, az alábbi példa szerint működik</li>
      <br>
      <div [ngStyle]="{'background-color': backgroundColorToggler ? 'red' : 'green'}">ngStyle Example</div>
      <button class="btn btn-secondary" (click)="backgroundColorToggler = !backgroundColorToggler">
        Background toggler
      </button>
      <div>Toggler: {{backgroundColorToggler}}</div>
      <pre>
        &#60;div [ngStyle]="&#123;'background-color': backgroundColorToggler ? 'red' : 'green'}">ngStyle Example&#60;/div>

        &#60;button class="btn btn-secondary" (click)="backgroundColorToggler != backgroundColorToggler">
          Background toggler
        &#60;/button>
      </pre>
      <li>A továbbiakban létrehozunk egy direktívát, amiben szeretnénk a DOM elemről referenciát kapni, amihez ismét az
        ElementRef osztályt injektáljuk (és persze a Renderer2-őt is)</li>
      <li>A host elem megkapja az alias-át a 'style' setter metódusnak, és property bindging-gal objektumot adunk át
      </li>
      <li>A 'style' setter paramétereként megérkezik az objektum, amin Object.entries() method, és array destructuring
        segítségével végig megyünk, és a lentebb látható módon beállítjuk a stílusokat</li>
      <li>Az első tömbelem a property, a második pedig az érték</li>
      <br>
      <div [customStyle]="{'background-color': 'blue', color: 'white'}">Custom style directive is used</div>
      <pre>
        // Parent 
        &#60;div [customStyle]="&#123;'background-color': 'blue', color: 'white'}">Custom style directive is used&#60;/div>

        // Directive
        export class CustomStyleDirective &#123;
          @Input('customStyle') set style(styles: Object) &#123;
              for (let [property, value] of Object.entries(styles)) &#123;
                  this.renderer.setStyle(this.element.nativeElement, property, value);
              }
          };
      
          constructor(private element: ElementRef, private renderer: Renderer2) &#123;
          }
      }
      </pre>
      <li>Ebben az esetben is alkalmazhatunk feltételeket a template-ben</li>
    </ul>
    <br>
    <h5 #customstructuraldirective data-anchor="customstructuraldirective">Custom structural directive</h5>
    <ul>
      <li>A struktúrális direktívák elé * jelet helyezünk, ezzel mondjuk meg, hogy struktúrális direktívát használunk
      </li>
      <li>Az ngIf struktúrális direktívával például könnyen eltüntethetünk DOM elemeket</li>
      <br>
      <div>A</div>
      <div *ngIf="displayCenterElem">B</div>
      <div>C</div>
      <pre>
        &#60;div>A&#60;/div>
        &#60;div *ngIf="displayCenterElem">B&#60;/div>
        &#60;div>C&#60;/div>
      </pre>
      <button class="btn btn-secondary btn-sm" (click)="displayCenterElem = !displayCenterElem">
        Toggle center elem visibility ({{displayCenterElem}})
      </button>
      <li>Az Angular ilyenkor több dolgot is elvégez a háttérben
        <ul>
          <li>ng-template-be ágyazza a kódrészletet</li>
          <li>Az ngIf direktívát ráhelyezi az ng-template tag-re</li>
          <li>A csillag jelet eltünteti, és attribútum direktívaként alkalmazza az ngIf direktívát</li>
        </ul>
      </li>
      <br>
      <div>A</div>
      <ng-template [ngIf]="displayCenterElem">
        <div>B</div>
      </ng-template>
      <div>C</div>
      <pre>
        &#60;div>A&#60;/div>

        &#60;ng-template [ngIf]="displayCenterElem">
          &#60;div>B&#60;/div>
        &#60;/ng-template>

        &#60;div>C&#60;/div>
      </pre>
      <li>A motorháztető alatt az Angular nem használja a * jelet, csak arra szükséges, hogy jelezzük az Angularnak,
        hogy struktúrális direktívát használunk, az Angulárnak pedig el kell végeznie néhány dolgot a renderelés előtt
      </li>
      <li>Az így kapott kód egyenértékű azzal a kóddal, amin elhelyeztük az *ngIf struktúrális direktívát
        <ul>
          <li>Ez onnan is látható, hogy az átalakított kód pontosanugyanúgy működik</li>
        </ul>
      </li>
      <br>
      <li>Felmerülhet a kérdés, hogy mit tegyünk, ha az ngIf-nek else ágat is szeretnénk adni</li>
      <br>
      <div>A</div>
      <div *ngIf="displayCenterElem; else centerElemIsHidden">B</div>
      <div>C</div>
      <ng-template #centerElemIsHidden>-</ng-template>
      <pre>
        &#60;div>A&#60;/div>
        &#60;div *ngIf="displayCenterElem; else centerElemIsHidden">B&#60;/div>
        &#60;div>C&#60;/div>
        &#60;ng-template #centerElemIsHidden>-&#60;/ng-template>
      </pre>
      <li>A háttérben az Angular az alábbi kódot valósítja meg</li>
      <button class="btn btn-secondary btn-sm" (click)="displayCenterElem = !displayCenterElem">
        Toggle center elem visibility ({{displayCenterElem}})
      </button>
      <br>
      <div>A</div>
      <ng-template [ngIf]="displayCenterElem" [ngIfElse]="centerElemIsHidden">
        <div>B</div>
      </ng-template>
      <div>C</div>
      <ng-template #centerElemIsHidden>-</ng-template>
      <pre>
        &#60;div>A&#60;/div>

        &#60;ng-template [ngIf]="displayCenterElem" [ngIfElse]="centerElemIsHidden">
          &#60;div>B&#60;/div>
        &#60;/ng-template>

        &#60;div>C&#60;/div>

        &#60;ng-template #centerElemIsHidden>-&#60;/ng-template>
      </pre>
      <li>Így működnek a struktúrális direktívák</li>
      <br>
      <li>Nézzük meg ezek után, miképp tudunk mi is létrehozni saját struktúrális direktívát
        <ul>
          <li>Ahhoz, hogy struktúrális direktívát készítsünk, két dologra van szükségünk
            <ul>
              <li>Hozzáférésünk kell, hogy legyen a HTML elemhez, amit hozzá akarunk adni a template-hez, vagy
                eltávolítani belőle</li>
              <li>Szükségünk van a helyre is, ahonnan el akarjuk távolítani, vagy meg kívánjuk jeleníteni</li>
            </ul>
          </li>
          <li>Mindkét információt át kell adnunk a direktívánknak</li>
          <li>A konstruktorba két osztályt szükséges beinjektálnunk
            <ul>
              <li>TemplateRef (HTML elem)</li>
              <li>ViewContainerRef (hely)</li>
            </ul>
          </li>
          <br>
          <div>A</div>
          <div *if="displayCenterElem">B</div>
          <div>C</div>
          <button class="btn btn-secondary btn-sm" (click)="displayCenterElem = !displayCenterElem">
            Toggle center elem visibility ({{displayCenterElem}})
          </button>
          <pre>
            // Parent
            &#60;div>A&#60;/div>
            &#60;div *if="displayCenterElem">B&#60;/div>
            &#60;div>C&#60;/div>

            &#60;button class="btn btn-secondary btn-sm" (click)="displayCenterElem = !displayCenterElem">
              Toggle center elem visibility (&#123; &#123;displayCenterElem}})
            &#60;/button>

            // Directive
            @Directive(&#123;
              selector: '[if]'
            })
            
            export class IfDirective &#123;
                @Input() set if(condition: boolean) &#123;
                    if (condition) &#123;
                        this.template.createEmbeddedView(this.view); // Metódus, ami elkészíti, és beágyazza a template-be a view-t 
                    } else &#123;
                        this.template.clear();
                    }
                }
            
                constructor(private view: TemplateRef&#60;any>, private template: ViewContainerRef) &#123;
                }
            }
          </pre>
          <li>Amikor az 'if' direktíva szelektorát alkalmazzuk bármelyik DOM elemen, az az elem a direktíva 'view'
            property-jének kerül átadásra (referencia), és a host elemet körülölelő ng-template referenciáját megkapja a
            'template'</li>
          <li>Létrehoztunk ezután egy, a szelektor nevével megegyező setter metódust, amiben kialakítottuk a logikát
            <ul>
              <li>Alias-t is beállíthatnánk (if), és ugyanazt a működést kapnánk</li>
            </ul>
          </li>
          <li>Amennyiben true értéket kap a setter metódusa, a template-be beágyazásra kerül a view, false esetén pedig
            kiürítjük a template-et</li>
          <li>A struktúrális direktívánkkal ellátott DOM elemet az Angular körbeöleli ng-template tag-gel</li>
          <li>Ezzel megvalósítottuk az *ngIf struktúrális direktíva működését</li>
        </ul>
      </li>
    </ul>
  </ul>
</div>

<div>
  <h3 #hostlistener data-anchor="hostlistener">HostListener</h3>
  <ul>
    <li>Dekorátor</li>
    <li>Ha egy DOM esemény (például egy kattintás) megtörténik a host elemen (Dom elem, amelyhez a komponens, vagy
      direktíva hozzá van rendelve), akkor a listener reagál rá, és meghív egy eseménykezelő metódust, amely
      az eseményt feldolgozza
    </li>
    <li>Bármilyen elemen gondoljuk használni a létrehozott direktívánkat, szükségünk lesz az elem referenciájára</li>
    <li>Azt az elemem, amire rákerül a dekorátor, host-nak nevezzük</li>
    <li>A direktíván keresztül hozzáférhetünk a host referenciájához</li>
    <pre>
      export class HighlightDirective &#123;
        constructor(private element: ElementRef, private renderer: Renderer2) &#123;
        }
      }
    </pre>
    <li>Amikor a 'highlight' class példányosodik, akkor az Angular beinjektál egy példányt a Renderer2 osztályból, amit
      átad a renderer paraméternek
    </li>
    <li>A mouse enter, és a mouse out eventet szeretnénk figyelni</li>
    <li>A hostlistener-rel a host-on eseményeket figyelhetünk meg</li>
    <li>A @HostListener vár egy string paramétert, az event nevét</li>
    <pre>
      @HostListener('mouseenter') onMouseEnter() &#123;
      }

      @HostListener('mouseout') onMouseOut() &#123;
      }
    </pre>
    <li>A mouseenter és mouseout események figyelésére lesz szükségünk</li>
    <li>Enter esetén az onMouseEnter() method (event handler function), out esetén pedig az onMouseOut() metódus (event
      handler function) fog lefutni
    </li>
    <br>
    <div highlight (mouseEvent)="hostListenerMouseEvent($event)">This is a highlighted DIV</div>
    <pre>
      {{ hostListenerMouseEventCounter | json }}
    </pre>
    <li>Emlékeztető: A komponensben használt CSS osztályok csak az adott komponensen belül működnek</li>
    <pre>
      // Directive
      export class HighlightDirective &#123;
        @Output() mouseEvent: EventEmitter&#60;string> = new EventEmitter&#60;string>();

        constructor(private element: ElementRef, private renderer: Renderer2) &#123;
        }

        @HostListener('mouseenter') onMouseEnter() &#123;
          this.mouseEvent.emit('in');
          this.renderer.setStyle(this.element.nativeElement, 'transition', '.5s');
          this.renderer.setStyle(this.element.nativeElement, 'color', '#9345e1');
        }

        @HostListener('mouseout') onMouseOut() &#123;
          this.mouseEvent.emit('out');
          this.renderer.setStyle(this.element.nativeElement, 'transition', '.5s');
          this.renderer.setStyle(this.element.nativeElement, 'color', '#B2B1BC');
        }
      }

      // PARENT
      &#60;div highlight (mouseEvent)="hostListenerMouseEvent($event)">This is a highlighted DIV&#60;/div>
      &#60;pre>
        &#123; &#123; hostListenerMouseEventCounter | json }}
      &#60;/pre>

      hostListenerMouseEvent(direction: string) &#123;
        if (direction === 'in') &#123;
        this.hostListenerMouseEventCounter.in++;
        }
        if (direction === 'out') &#123;
          this.hostListenerMouseEventCounter.out++;
        }
      }
    </pre>
    <li>A direktíva értesíti a "szülő" komponenst arról, ha lefutott valamelyik event handler function, megváltoztatva a
      'hostListenerMouseEventCounter' valamelyik értékét
    </li>
    <br>
    <li>
      <h5 #eventbindingvshostlistener data-anchor="eventbindingvshostlistener">Event binding vs HostListener</h5>
      <ul>
        <li></li>
        <app-child [shownData]="'listener'"></app-child>
        <br>
        <pre>
          // PARENT
          &#60;app-child [shownData]="'listener'">&#60;/app-child>

          // CHILD
          &#60;input type="text" [value]="textValue" (focus)="onTextInputFocus($event)"> // Event binding (focus)
          &#60;button class="btn btn-secondary">Click on me&#60;/button>
        </pre>
        <li>Ahányszor megtörténik a focus az input mezőn, le fog futni a 'onTextInputFocus' függvény</li>
        <li>Amennyiben a direktívából szeretnénk kezelni a focus event-et, nem használhatunk event binding-ot</li>
        <li>Oldjuk meg azt, hogy a focus event-re a direktívánkban futtassunk valamilyen logikát</li>
        <li></li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #hostbinding data-anchor="hostbinding">HostBinding</h3>
  <ul>
    <li>Dekorátor</li>
    <li>Az @HostBinding a host elem egy property-jét (pl. attribútumát, stílusát vagy osztályát) köti össze a direktíva
      vagy komponens egy property-jével
    </li>
    <li>Ez lehetővé teszi, hogy a direktíva vagy komponens belső állapotának változásai automatikusan frissítsék a host
      elem tulajdonságait
    </li>
    <li>Bármilyen elemen is használjuk a szelektort, meg szeretnénk kapni annak referenciáját</li>
    <pre>
      constructor(private element: ElementRef, private renderer: Renderer2) &#123;
      }
    </pre>
    <li>A private access modifier-rel a Typescript a motorháztető alatt létrehozza a classra lokális property-t</li>
    <br>
    <button class="btn btn-secondary" hover>HOVER button</button>
    <br>
    <li>Létrehozva egy property-t a direktívában, össze tudjuk közni azt egy DOM elem property-vel</li>
    <pre>
      @HostBinding('style.backgroundColor') backgroundColor: string = '#212121';
    </pre>
    <li>Amikor a gomb kirenderelődik a weboldalon, a DOM-ban ezen gomb objektuma létrejön
      <ul>
        <li>Ez az objektum property-kkel rendelkezik, amiket összeköthetünk a direktíva property-jeivel</li>
        <li>Minden DOM elemnek van style property-je</li>
      </ul>
    </li>
    <li>A HostBinding argomentuma egy DOM elem property
      <ul>
        <li>Például 'style.backgroundColor' (DOM property)</li>
      </ul>
    </li>
    <pre>
      // PARENT
      &#60;button class="btn btn-secondary" hover>HOVER button&#60;/button>

      // DIRECTIVE
      export class HoverDirective &#123;
        @HostBinding('style.backgroundColor') backgroundColor: string = '#212121';
        @HostBinding('style.border') border: string = '2px dotted #FF1111';
        @HostBinding('style.color') color: string = '#FF1111';

        constructor(private element: ElementRef, private renderer: Renderer2) &#123;

        }
      }
    </pre>
    <li>A gombra aggatott direktíva a HostBinding segítségével 3 style property-t változtat meg</li>
    <pre>
      export class HoverDirective &#123;
        @HostBinding('style.color') color: string = '#b2b1bc';
        @HostBinding('style.backgroundColor') backgroundColor: string = '#5c636a';
        @HostBinding('style.border') border: string = '2px dotted #565e64';

        @HostListener('mouseenter') mouseEnter() &#123;
          this.color = '#FF1111';
          this.backgroundColor = '#212121';
          this.border = '2px dotted #FF1111';
        }

        @HostListener('mouseout') mouseOut() &#123;
          this.color = '#b2b1bc';
          this.backgroundColor = '#5c636a';
          this.border = '2px solid #565e64';
        }

        constructor(private element: ElementRef, private renderer: Renderer2) &#123;

        }
      }
    </pre>
    <li>A fenti példában kombináltuk a HostBinding-ot HostListenerrel, hover effekt megvalósítása végett</li>
    <br>
    <li>
      <h5 #propertyvshostbinging data-anchor="propertyvshostbinging">Property binding vs HostBinding</h5>
      <ul>
        <li>A komponens property binding-ja, és a direktíva HostBinding-ja közötti különbséget nézzük meg</li>
        <br>
        <app-child [shownData]="'binding'"></app-child>
        <pre>
          // PARENT
          &#60;app-child [shownData]="'binding'">&#60;/app-child>

          // CHILD
          &#60;input sample type="text" [value]="textValue"> // Property binding
          &#60;button class="btn btn-secondary">Click on me&#60;/button>

          textValue: string = 'This is a beautiful day';

          // DIRECTIVE
          inputValue: string = 'It\s raining over there';
        </pre>
        <li>A '[value]' bindingra a fenti megvalósításban már nincs is szükség</li>
        <li>Property binding-gal nem tudjuk odaadni a direktívából a kívánt értéket ('inputValue') a child komponensben
          lévő inputnak (ami a host)
          <ul>
            <li>Itt jön képbe a HostBinding</li>
            <pre>
              @HostBinding('value') inputValue: string = 'It\s raining over there';
            </pre>
            <li>A child komponensben megadott 'textValue' értékét felülírja az 'inputValue'</li>
          </ul>
        </li>
        <li>Property binding komponensben
          <ul>
            <li>Szögletes zárójelbe írt property név, Typescript kifejezés értékkel</li>
            <li>Direktívával ezen a módon nem tudunk property-t bekötni</li>
            <app-child [shownData]="'listener'"
              (textInputFocusEvent)="increaseTextInputFocusNumber($event)"></app-child>
            Number of focuses in input field: {{ textInputFocusCounter }}
            <pre>
              // Parent
              &#60;app-child [shownData]="'listener'" (textInputFocusEvent)="increaseTextInputFocusNumber($event)">&#60;/app-child>
              Number of focuses in input field: &#123; &#123; textInputFocusCounter }}

              increaseTextInputFocusNumber(e: any) &#123;
                this.textInputFocusCounter++;
              }

              // Child
              &#60;input type="text" [value]="textValue" (focus)="onTextInputFocus($event)">

              @Output() textInputFocusEvent: EventEmitter&#60;void>  = new EventEmitter&#60;void>

                onTextInputFocus(event: any) &#123;
                  this.textInputFocusEvent.emit();
                }
            </pre>
            <li>A direktívából ezt nem tudjuk megtenni (event binding-gal)</li>
            <app-child [shownData]="'listener2'"
              (textInputFocusEventFromDirective)="increaseTextInputFocusNumber2($event)"></app-child>
            Number of focuses in input field: {{ textInputFocusCounter2 }}
            <pre>
              // Parent
              &#60;app-child [shownData]="'listener2'" (textInputFocusEventFromDirective)="increaseTextInputFocusNumber2()">&#60;/app-child>

              increaseTextInputFocusNumber2(e: any) &#123;
                this.textInputFocusCounter2++;
              }

              // Child
              &#60;input sample type="text" [value]="textValue" (textInputFocusEventOutput)="onTextInputFocusFromDirective($event)">

              @Output() textInputFocusEventFromDirective: EventEmitter&#60;void>  = new EventEmitter&#60;void>;

                onTextInputFocusFromDirective(event: any) &#123;
                  this.textInputFocusEventFromDirective.emit();
                }

              // Directive
              @Output() textInputFocusEventOutput: EventEmitter&#60;void>  = new EventEmitter&#60;void>;
                @HostListener('focus') focusEventHappened() &#123;
                  this.textInputFocusEventOutput.emit();
                }

            </pre>
            <li>Hostlistener segítségével kezelhetők az események direktívák használatával</li>
          </ul>
        </li>
      </ul>
    </li>

  </ul>
</div>

<div>
  <h3 #ngswitch data-anchor="ngswitch">ngSwitch</h3>
  <ul>
    <li>Beépített struktúrális direktíva</li>
    <li>Manipulálja a DOM-ot, elemet elvéve, vagy hozzáadva</li>
    <li>Egyetlen 'view'-t jelenít meg sok 'view' közül annak függvényében, hogy milyen értéket adunk az ngSwitch-ben
      definiált változónak</li>
    <br>
    <div [ngSwitch]="switchTab">
      <span *ngSwitchDefault>No tab</span>
      <span *ngSwitchCase="1">Tab 1</span>
      <span *ngSwitchCase="2">Tab 2</span>
      <span *ngSwitchCase="3">Tab 3</span>
      <span *ngSwitchCase="4">Tab 4</span>
    </div>
    <span *ngFor="let b of [1, 2, 3, 4]">
      <button class="btn btn-secondary" (click)="switchTab = b">{{b}}</button>
    </span>
    <pre>
      &#60;div [ngSwitch]="switchTab">
        &#60;span *ngSwitchDefault>No tab&#60;/span>
        &#60;span *ngSwitchCase="1">Tab 1&#60;/span>
        &#60;span *ngSwitchCase="2">Tab 2&#60;/span>
        &#60;span *ngSwitchCase="3">Tab 3&#60;/span>
        &#60;span *ngSwitchCase="4">Tab 4&#60;/span>
      &#60;/div>
      &#60;span *ngFor="let b of [1, 2, 3, 4]">
        &#60;button class="btn btn-secondary" (click)="switchTab = b">&#123; &#123;b}}&#60;/button>
      &#60;/span>

      switchTab: number = 0;
    </pre>
    <li>A switchTab változó értéke szerint kívánunk megjeleníteni tartalmat</li>
    <li>Az [ngSwitch] nem a direktíva, ami manipulálni fogja a DOM-ot (ezért a szögletes zárójel, és semmi csillag)</li>
    <li>Az ngSwitch egy kifejezést vár</li>
    <li>A struktúrális direktíva neve ngSwitchCase
      <ul>
        <li>Az ngSwitch értékének változása határozza meg, melyik case jelenik meg a DOM-ban</li>
      </ul>
    </li>
    <li>Az ngSwitchDefault szintén struktúrális direktíva (manipulálja a DOM-ot)
      <ul>
        <li>Amennyiben a 'switchTab' property nem vesz fel olyan értéket, ami egyezik valamelyik ngSwitchCase-ben
          definiált értékkel, akkor default 'ágba' futunk, és az abban lévő tartalom renderelődik</li>
      </ul>
    </li>
    <li>Amennyiben true/false értéket alkalmazunk, mint ngSwitchCase, ne felejtsük el, hogy az ngSwitch-nek boolean
      értéket szükséges adnunk, különben anomáliákba ütközhetünk</li>
  </ul>
</div>

<div>
  <h3 #viewencapsulation data-anchor="viewencapsulation">View encapsulation</h3>
  <ul>
    <li>Adat és működés elrejtése a külvilág elől.</li>
    <li>Amikor létrehozunk egy komponenst, definiálunk egy szelektort (selector), template-et (templateUrl), és stílust
      (styleUrl)
      <ul>
        <li>Ahogy arról már szó esett, az adott komponensben definiált CSS szabályok más komponensekre nem érvényesülne
        </li>
        <li>Angularban ezt jelenti a view encapsulation</li>
      </ul>
    </li>
    <li>A view encapsulation egy viselkedés, ahol is a stílusok az adott komponensbe vannak enkapszulálva, és nincsenek
      hatással más komponensekre</li>
    <li>Az enkapszuláció a komponens dekorátorában változtatható meg</li>
    <pre>
      @Component(&#60;
        selector: 'app-angular',
        templateUrl: './angular.component.html',
        styleUrls: ['./angular.component.scss'],
        encapsulation: ViewEncapsulation.Emulated // default
      })
    </pre>
    <li>Angularban 3 féle enkapszuláció létezik
      <ol>
        <li>ViewEncapsulation.None
          <ul>
            <li>A komponensben használt stílusok globálisan érvényesek az egész alkalmazásra</li>
          </ul>
        </li>
        <li>ViewEncapsulation.Emulated
          <ul>
            <li>Ez az alapértelmezett (a stílusok csak az adott komponensre vonatkoznak)</li>
            <li>A stílusok a böngészőben globálisan vannak beillesztve a &#60;style> tagekben</li>
            <li>Az Angular egyedi attribútumokat generál az elemekhez
              <ul>
                <li>Adott komponens összes DOM eleme ugyanazt az azonosítót kapja</li>
                <li>Ezek az egyedi azonosítók a DevTools-ban is látszanak</li>
              </ul>
            </li>
            <pre>
              // app.component
              &#60;div _ngcontent-c6>
                ...
                &#60;app-other-component _ngcontent-c6>&#60;/app-other-component>
              &#60;/div>

              // app-other-component.component
              &#60;div _ngcontent-c13>
                ...
              &#60;/div>

              // Style
              div[_ngcontent-c6] &#123; color: blue; }
              div[_ngcontent-c13] &#123; background-color: brown; }
            </pre>
          </ul>
        </li>
        <li>ViewEncapsulation.ShadowDOM
          <ul>
            <li>A legteljesebb izolációs megoldás, mivel a böngésző natív Shadow DOM funkcióját használja</li>
            <li>A stílusok ebben a módban csak az adott komponensre érvényesek</li>
            <li>A main DOM és a Shadow DOM renderelése külön történik</li>
            <pre>
              // DevTools
              &#60;app-child _ngcontent-uhh-c12="" ng-reflect-input-data="[object Object]" ng-reflect-shown-data="labels">
                #shadow-root (open)
              &#60;/app-child>
            </pre>
            <li>A komponensnek saját DOM-fája van, amely a 'Shadow root' nevű speciális gyökérelemből indul ki</li>
            <li>Amikor ShadowDOM enkapszulációt használunk, az alábbiak történnek
              <ol>
                <li>Az adott komponens egy shadow root-ot hoz létre, amely gyakorlatilag a komponens saját DOM-fája.
                </li>
                <li>A komponens HTML és CSS részei ebbe a shadow root-ba kerülnek, így izolálva lesznek a fő DOM-fától.
                </li>
                <li>A böngészők külön támogatják a Shadow DOM-ot, így a külső szkriptek és stílusok alapértelmezetten
                  nem tudnak beavatkozni a shadow root-ba zárt elemekbe.</li>
              </ol>
            </li>
          </ul>
        </li>
      </ol>
    </li>
  </ul>
</div>

<div>
  <h3 #service data-anchor="service">Service</h3>
  <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr;">
    <div style="grid-column: 1/5; border: 1px solid black; padding: 20px;">
      <div><small>// comp1</small></div>
      <h6>Header</h6>
      <button class="btn btn-secondary">Subscribe</button>
    </div>
    <div style="grid-column: 1/2; border: 1px solid black; padding: 20px;">
      <div><small>// comp2</small></div>
      <div>Menu</div>
      <button class="btn btn-secondary">Subscribe</button>
    </div>
    <div style="grid-column: 2/5; border: 1px solid black; padding: 20px;">
      <div><small>// comp3</small></div>
      <div>Content</div>
      <button class="btn btn-secondary">Subscribe</button>
    </div>
  </div>
  <br>
  <ul>
    <li>Adott 3 darab komponensünk, mind ellátva subscribe gombbal</li>
    <li>Mindegyik feliratkozás gomb ugyanazt a funkciót fogja ellátni, ugyanaz a logika fog lefutni</li>
    <li>A példa kedvéért feltételezzük, hogy ez 3 egymástól teljesen független komponens</li>
    <li>Az alábbiak a hátrányai, ha minden komponensben megvalósítanánk ugyanazt a feliratkozási logikát
      <ul>
        <li>Ismételjük ugyanazt a kódot</li>
        <li>A komponens class-nak a feladata, hogy a UI-t biztosítsa a felhasználónak
          <ul>
            <li>A subscription logic-nak semmi köze a UI-hoz (business logic)</li>
          </ul>
        </li>
        <li></li>
      </ul>
    </li>
    <li>Egy különálló, centralizált helyre érdemes elhelyeznünk a logikát, amit service-szel tudunk elérni</li>
    <li>Előnyei
      <ul>
        <li>Újra felhasználható kódot kapunk, bármelyik komponensben felhasználhatjuk</li>
        <li>A UI logic megmarad a komponens class-nak, a business logic-ot pedig service class-ok biztosítják</li>
        <li>A unit test komponens létrehozása nélkül is működik - Megkönnyíti a tesztelést, debuggolást</li>
      </ul>
    </li>
    <li>Service-t érdemes akkor is alkalmazni, ha kettő (vagy több) egymástól teljesen független (non-related) komponens
      közti kommunikációt szeretnénk megvalósíttani</li>
    <br>
    <h5 #servicecreateanduse data-anchor="servicecreateanduse">Create and use</h5>
    <ul>
      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr;">
        <app-comp1 style="grid-column: 1/5; border: 1px solid black; padding: 20px;"></app-comp1>
        <app-comp2 style="grid-column: 1/2; border: 1px solid black; padding: 20px;"></app-comp2>
        <app-comp3 style="grid-column: 2/5; border: 1px solid black; padding: 20px;"></app-comp3>
      </div>
      <br>
      <li>Az egyes komponensek tartalma látszik</li>
      <pre>
      // Parent
      &#60;div>
        &#60;app-comp1>&#60;/app-comp1>
        &#60;app-comp2>&#60;/app-comp2>
        &#60;app-comp3>&#60;/app-comp3>
      &#60;/div>

      // Comp1 
      &#60;div>&#60;small>// comp1&#60;/small>&#60;/div>
      &#60;h6>Header&#60;/h6>
      &#60;button class="btn btn-secondary" (click)="onSubscribe()">Subscribe&#60;/button>
      </pre>
      <li>
        <ul>
          <li>A fájl elnevezése *name*.service.ts</li>
          <li>Létrehozható az alábbi parancsokkal
            <ul>
              <li>ng generate service / ng g service / ng generate s / ng g s</li>
            </ul>
          </li>
          <li>A service nem más, mint egy Typescript class
            <ul>
              <li>Ahhoz, hogy más fájlokban is tudjuk használni a class-t, exportálnunk szükséges</li>
            </ul>
            <pre>
        // Service
        export class SubscriptionService &#123;
          onSubscribeClicked() &#123;
              alert('clicked');
          }
        }
      </pre>
          </li>
          <li>A service-eknél nem használunk dekorátort</li>
          <li>Amennyiben bármelyik komponensben rákattintunk a Subscribe gombra, ugyanazt a logikát szeretnénk
            lefuttatni,
            amit a service tartalmaz</li>
          <li>Használható úgy például, hogy az egyes komponenseinkben példányosítjuk a 'SubscriptionService' osztályt
          </li>
          <pre>
      // Comp1
      import &#123; SubscriptionService } from 'src/shared/services/subscription.service';

      onSubscribe() &#123;
        let subService = new SubscriptionService();
        subService.onSubscribeClicked();
      }
    </pre>
          <li>Miután rendelkezésünkre áll egy példány az osztályból, használhatjuk a service class metódusait</li>
          <li>A service metódusok egyébként paramétereket is fogadhatnak</li>
          <li>Amennyiben minden komponensben példányosítjuk a service-t, úgy ugyanazt a business logikát futtathatjuk
          </li>
          <li>Amennyiben valamiért eltávolításra kerül a 'SubscriptionService' osztály, vagy megváltoztatják, az
            hatással
            lesz
            a komponensekre, amikben új példányt hoztunk létre, ami hibákhoz vezethet</li>
          <li>Amikor explicit módon példányosítunk service class-t, szorosan összekötjük azt a komponens osztályunkkal,
            ami
            erősen nem best practice</li>
          <li>Ehelyett megmondhatjuk az Angularnak, hogy injektáljon be egy példányt a service osztályból a komponens
            osztályunkba</li>
        </ul>
      </li>
    </ul>
    <br>
    <h5 #servicecomponentinteraction data-anchor="servicecomponentinteraction">Component interaction</h5>
    <ul>
      <li>A service-k használhatók komponensek közti kommunikációra</li>
      <li>Például két, egymástól teljesen független komponens között</li>
      <li>Jelen példánkban a user-details, és a user-list komponens testvérek, nincs köztük szülő-gyerek kapcsolat</li>
      <li>Azt szeretnénk elérni, hogy amikor valamelyik gombot megnyomjuk, megjelenjenek a felhasználó adatai</li>
      <li>A felhasználóink a UserService-ben vannak deklarálva, ahonnan lekérhetjük az összes felhasználót, és újat is
        hozhatunk létre</li>
      <pre>
        <b>// user.service</b>
          export class UserService &#123;
            users: User[] = [
                new User('Carl Smith', 'male', 'Monthly', 'active'),
                new User('Johanna Bree', 'female', 'Monthly', 'inactive'),
                new User('Max King', 'male', 'Yearly', 'active')
            ];

            getAllUsers() &#123;
              return this.users;
          }
      
          addNewUser(&#123; name, gender, subType, status }: &#123; name: string, gender: string, subType: string, status: string }) &#123;
              let user = new User(name, gender, subType, status);
              this.users.push(user);
      
              // this.logger.logMessage(name, status);
      
              this.subService.logMessage(name, status);
          }

          // Az alábbi kiegészítéseket szükséges megtennünk

          OnUserClickedEvent: EventEmitter&#60;User | null> = new EventEmitter&#60;User | null>;

          onShowUserDetails(user: (User | null)) &#123;
            this.OnUserClickedEvent.emit(user);
          }
      </pre>
      <li>Létrehoztunk egy User típusú Eventemittert, és egy methodot, ami User típusú adatot fogad (vagy null-t), majd
        kibocsátja az
        OnUserClickedEvent-ben található felhasználót</li>
      <pre>
        <b>// user-list.component</b>
        &#60;table style="table-layout: fixed">
          &#60;tr>
              &#60;th>Name&#60;/th>
              &#60;th>Gender&#60;/th>
              &#60;th>Sub type&#60;/th>
              &#60;th>Status&#60;/th>
              &#60;th>
                  &#60;button class="btn btn-dark" (click)="onUserDetailChange(null)">
                      &#60;i class="bi bi-toggle-on">&#60;/i>
                  &#60;/button>
              &#60;/th>
          &#60;/tr>
          &#60;tr *ngFor="let user of userList">
              &#60;td>&#123; &#123;user.name}}&#60;/td>
              &#60;td>&#123; &#123;user.gender}}&#60;/td>
              &#60;td>&#123; &#123;user.subType}}&#60;/td>
              &#60;td>&#123; &#123;user.status}}&#60;/td>
              &#60;td *ngIf="type ===  'interaction'">
                  &#60;button class="btn btn-dark" (click)="onUserDetailChange(user)">
                      &#60;i class="bi bi-toggle-off">&#60;/i>
                  &#60;/button>
              &#60;/td>
          &#60;/tr>
        &#60;/table>

        export class UserListComponent &#123;
          @Input() type: 'interaction' | '' = '';
        
          userList: User[] = this.userService.getAllUsers();
        
          constructor(@Inject(USER_TOKEN) private userService: UserService) &#123;
        
          }
        
          onUserDetailChange(user: (User | null)) &#123;
            this.userService.onShowUserDetails(user);
          }
        }
      </pre>
      <li>A user listába bekerült minden oszlopba egy gomb
        <ul>
          <li>A header részben lévő null-t küld tovább az 'onUserDetailChange' metódusnak (ezért kellett a User típusok
            mellett megengedni a null-t is), a többi sor pedig egy User objektumot, az aktuális sor adatait</li>
          <li>Az 'onUserDetailChange' függvény a UserService 'onShowUserDetails' függvényének továbbítja az aktuálisan
            kiválasztott felhasználó adatait (vagy null-t)</li>
        </ul>
      </li>
      <li>A kibocsátott User (vagy null) adatot szeretnénk elkapni a user-details komponensben, ezért ott fel kell
        iratkoznunk erre az EventEmitterre
        <ul>
          <li>Így értesülhetünk arról, hogy változás történt</li>
          <li>A UserService osztályból szükségünk van egy példányra</li>
        </ul>
      </li>
      <pre>
        &#60;div>
          &#60;div>
              &#60;img src="https://img.icons8.com/?size=100&id=23265&format=png&color=000000" alt="">
          &#60;/div>
          &#60;div *ngIf="userIsSelected; else noUser">
              &#60;div>&#60;b>Name: &#60;/b>&#123; &#123;selectedUser?.name}}&#60;/div>
              &#60;div>&#60;b>Gender: &#60;/b>&#123; &#123;selectedUser?.gender}}&#60;/div>
              &#60;div>&#60;b>Subscription: &#60;/b>&#123; &#123;selectedUser?.subType}}&#60;/div>
              &#60;div>&#60;b>Status: &#60;/b>&#123; &#123;selectedUser?.status}}&#60;/div>
          &#60;/div>
      
          &#60;ng-template #noUser>
              No user is selected
          &#60;/ng-template>
        &#60;/div>

        export class UserDetailsComponent implements OnInit &#123;
          userIsSelected: boolean = false;
          selectedUser!: User | null;
        
          // userService = inject(UserService); // nem működik így jelen esetben
          userService = inject(USER_TOKEN);
        
          ngOnInit(): void &#123;
            this.userService.OnUserClickedEvent.subscribe((user: (User | null)) => &#123;
              user ? this.userIsSelected = true : this.userIsSelected = false;
              this.selectedUser = user;
            })
          }
        }
      </pre>
      <li>A 'selectedUser' property mögé szükség volt a ?-re, mert null értéket is felvehet a változó</li>
      <li>Az injektálás Injection token segítségével történt, mert a Dependency injection témakörben a UserService-nek
        token-t hoztunk létre a module-ben</li>
      <pre>
        export const USER_TOKEN = new InjectionToken&#60;UserService>('USER_SERVICE');

        providers: [
          ScrollingService,
          SubscriptionService,
          // &#123;provide: 'USER_SERVICE', useClass: UserService},
          &#123;provide: USER_TOKEN, useClass: UserService},
          LoggerService
        ]
      </pre>
      <li>Az OnInit életciklusban feliratkozunk a UserService 'OnUserClickedEvent'-jére, és értesülünk arról, ha
        valamelyik gombra rákattintott a felhasználó
        <ul>
          <li>Ezzel egyidőben a 'userIsSelected' változó értékét is változtatjuk attól függően, hogy null érkezett-e,
            mert amennyiben igen, akkor az ngIf else ága lép életbe, ami egy template-et jelenít meg</li>
        </ul>
      </li>
      <li>Oldjuk meg még azt, hogy a UI-on a gombok aszerint változzanak (toggle-on / toggle-off), hogy mit aktiváltunk
        <ul>
          <li>Ehhez a user-list komponensünkben szükséges némi kiegészítést tenni</li>
        </ul>
      </li>
      <pre>
      <b>// user.list</b>

      &#60;button class="btn btn-dark" (click)="onUserDetailChange(null, 0)">
        &#60;i class="bi" [ngClass]="activeButton === 0 ? 'bi-toggle-on' : 'bi-toggle-off'">&#60;/i>
      &#60;/button>

      &#60;tr *ngFor="let user of userList; let index = index">
        ...
            &#60;button class="btn btn-dark" (click)="onUserDetailChange(user, (index+1))">
                &#60;i class="bi" [ngClass]="activeButton === (index + 1) ? 'bi-toggle-on' : 'bi-toggle-off'">&#60;/i>
            &#60;/button>
      &#60;/tr>

      activeButton: number = 0;

      onUserDetailChange(user: (User | null), index: number) &#123;
        this.userService.onShowUserDetails(user);
        this.activeButton = index || 0;
      }
      </pre>
      <br>
      <app-user-list [type]="'interaction'"></app-user-list>
      <br>
      <app-user-details></app-user-details>
    </ul>
  </ul>
</div>

<div>
  <h3 #dependencyinjection data-anchor="dependencyinjection">Dependency injection</h3>
  <ul>
    <li>Technika, vagy design pattern (tervezési minta), amikor az osztály külső forrásból kapja a függőségeit, nem
      pedig saját maga hozza létre</li>
    <li>A dependencia két komponens közti kapcsolat, amelyben az egyik a másikra támaszkodik a megfelelő működés
      érdekében</li>
    <li>Az osztályok nem maguk hozzák létre a szükséges függőségeiket, hanem ezeket kívülről kapják meg</li>
    <li>A DI használatos ahelyett, hogy új példányt hozzunk létre egy osztályból</li>
    <pre>
      let subService = new SubscriptionService(); // Kerülendő
    </pre>
    <ul>
      <li>Ebben az esetben a komponens maga hozza létre a "függőségét"</li>
    </ul>
    <li>Növeli az újrahasznosíthatóságot, tesztelhetőséget és karbantarthatóságot</li>
    <pre>
      export class Comp1Component &#123;
        onSubscribe() &#123;
          let subService = new SubscriptionService();
          subService.onSubscribeClicked();
        }
      }
    </pre>
    <ul>
      <li>Explicit módon hoztuk létre a 'SubscriptionService' osztályt</li>
      <li>Ebben az esetben a 'Comp1Component' komponens függ a 'SubscriptionService' osztálytól, hogy megfelelően
        működjön</li>
      <li>A 'SubscriptionService' dependenciája a 'Comp1Component' komponensnek</li>
      <li>Amennyiben a 'SubscriptionService' class megváltozik, az hatással lesz a komponens működésére</li>
    </ul>
    <pre>
      export class SubscriptionService &#123;
        onSubscribeClicked() &#123;
            alert('clicked');
        }
      }

      ⌄⌄⌄⌄ megváltoztatjuk ⌄⌄⌄⌄⌄

      export class SubscriptionService &#123;
        constructor(name: string) &#123;}

        onSubscribeClicked() &#123;
            alert('clicked');
        }
      }
    </pre>
    <ul>
      <li>Ahány helyen létrehoztunk egy új példányát a SubscriptionService classnak a változtatás előttig, egyiknél sem
        adtuk meg a kötelező paraméterét a konstruktornak</li>
      <li>Így a komponensünk, vagy komponenseink funkcionalitását tönkretesszük</li>
    </ul>
    <li>Dependency injection esetén arra utasítjuk az Angular injector-át, hogy szolgáltasson egy példányt a
      dependenciából
      <ul>
        <li>Az adott paraméter megkapja a megfelelő példányt az injektor segítségével</li>
        <pre>
          constructor(private myService: MyService) &#123;ß
            // myService egy példánya a MyService osztálynak, amit az injektor ad
          }
        </pre>
      </ul>
    </li>
    <li>A komponens dekorátorában, providers kulcs alatt (tömb) a komponensbe injektálandó dependenciát
      <ul>
        <li>Enélkül hibára futunk</li>
        <pre>
          @Component(&#123;
            selector: 'app-comp1',
            templateUrl: './comp1.component.html',
            styleUrls: ['./comp1.component.scss'],
            providers: [SubscriptionService]
          })
        </pre>
        <li>Ebben az esetben csak erre a komponensre korlátozzuk a 'SubscriptionService' használatát</li>
        <li>Amennyiben máshol is szeretnénk használni, például egy egész modulban, úgy a modul NgModul dekorátorában
          szükséges megadnunk</li>
        <pre>
            @NgModule(&#123;
              providers: [
                SubscriptionService
              ]
            })
          </pre>
        <li>Egy másik megoldás, hogy a service-ben adjuk meg, hogy legyen elérhető az egész alkalmazásban (globálisan)
        </li>
        <pre>
            @Injectable(&#123; providedIn: 'root' })
        </pre>
      </ul>
    </li>
    <li>A privát property kap egy példányt a service-ből, és mivel access modifiert is használtunk, így class property-t
      hoz létre a Typescript</li>
    <pre>
        export class Comp1Component &#123;
          constructor(private subscription: SubscriptionService) &#123;
          }
        
          onSubscribe() &#123;
            this.subscription.onSubscribeClicked();
          }
        }
    </pre>
    <li>Innentől az Angular már tudja, miképp injektáljon, de azt még nem, hogy mit
      <ul>
        <li>Ezért szükséges a provide-olás a komponensben, a modulban, vagy a service-ben (providedIn: 'root')</li>
        <li>A komponens dekorátorában, a providers tömbben felsorolhatjuk az összes dependenciát</li>
      </ul>
    </li>
    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr;">
      <app-comp1 style="grid-column: 1/5; border: 1px solid black; padding: 20px;"></app-comp1>
      <app-comp2 style="grid-column: 1/2; border: 1px solid black; padding: 20px;"></app-comp2>
      <app-comp3 style="grid-column: 2/5; border: 1px solid black; padding: 20px;"></app-comp3>
    </div>
    <li>Csak a comp1 komponensbe történt dependency injection, a másik két komponensben explicit módon van létrehozva a
      service osztály
      <ul>
        <li>Ez a komponens már nincs szoros összefüggésben a service class-szal</li>
      </ul>
    </li>
    <br>
    <h5 #hierarchicaldependencyinjection data-anchor="hierarchicaldependencyinjection">Hierarchical dependency injection
    </h5>
    <ul>
      <li>Ahány komponensbe injektálunk egy adott service-t, annyi példány lesz belőle, azaz mind különböző lesz</li>
      <li>Amennyiben csinálunk valamit az egyik példánnyal, az semmilyen hatással sem lesz a többire</li>
      <li>Minden komponensnek saját, egyedi példánya lesz</li>
      <li>Onnantól, hogy egy adott komponensbe provide-olunk egy függőséget, a komponens összes gyerekébe, azok
        gyerekeibe, és így tovább, is injektálásra kerül ugyanaz a példány
        <ul>
          <li>Ezt nevezzük hierarchikus injektálásnak</li>
        </ul>
      </li>
      <li>Tehát, nincs szükség arra, hogy a szülőn túl a "leszármazottaknak" a providers tömbben megmondjuk, hogy mit
        szeretnénk injektálni), mert "megöröklik" a példányt), hacsak kifejezetten azt nem szeretnénk, hogy egy másikat
        kapjanak</li>
      <li>Minden komponens rendelkezik saját injektorral, amely "örökölhet" a szülő injektoraitól, de ha egy gyerek
        komponens explicit módon meghatároz egy szolgáltatást a saját providers tömbjében, az új példányt fog létrehozni
        (dependency override)
      </li>
      <li>Root komponensben szolgáltatott függőség esetén minden komponens, direktíva, és service ugyanazt az instanciát
        fogja használni (kivéve override esetén)
        <ul>
          <li>Singleton pattern, ugyanazt a példányt használjuk az egész alkalmazásban</li>
        </ul>
      </li>
    </ul>
    <br>
    <app-user-list></app-user-list>
    <br>
    <div style="display: inline-grid;">
      <input type="text" placeholder="name" [(ngModel)]="newUserObj.name">
      <input type="text" placeholder="gender" [(ngModel)]="newUserObj.gender">
      <input type="text" placeholder="subType" [(ngModel)]="newUserObj.subType">
      <input type="text" placeholder="status" [(ngModel)]="newUserObj.status">
      <button class="btn btn-secondary" (click)="createNewUser()">Create new user</button>
    </div>
    <pre>
    // User.ts (model)
    export class User &#123;

      name: string = '';
      gender: string = '';
      subType: string = '';
      status: string = '';
  
      constructor(name: string, gender: string, subType: string, status: string) &#123;
          this.name = name;
          this.gender = gender;
          this.subType = subType;
          this.status = status;
      }
    } 

    // user.service.ts
    export class UserService &#123;
      users: User[] = [
          new User('Carl Smith', 'male', 'Monthly', 'active'),
          new User('Johanna Bree', 'female', 'Monthly', 'inactive'),
          new User('Max King', 'male', 'Yearly', 'active')
      ];
  
      getAllUsers() &#123;
          return this.users;
      }
  
      addNewUser(&#123;name, gender, subType, status}: &#123;name: string, gender: string, subType: string, status: string}) &#123;
          let user = new User(name, gender, subType, status);
  
          this.users.push(user);
      }
    }

    // user-list.component
    &#60;table>
      &#60;tr>
        &#60;th>Name&#60;/th>
        &#60;th>Gender&#60;/th>
        &#60;th>Sub type&#60;/th>
        &#60;th>Status&#60;/th>
      &#60;/tr>
      &#60;tr *ngFor="let user of userList">
          &#60;td>&#123; &#123;user.name}}&#60;/td>
          &#60;td>&#123; &#123;user.gender}}&#60;/td>
          &#60;td>&#123; &#123;user.subType}}&#60;/td>
          &#60;td>&#123; &#123;user.status}}&#60;/td>
      &#60;/tr>
    &#60;/table>

    providers: [UserService]

    userList: User[] = this.userService.getAllUsers();

    // Parent
    &#60;app-user-list>&#60;/app-user-list>

    &#60;input type="text" placeholder="name">
    &#60;input type="text" placeholder="gender">
    &#60;input type="text" placeholder="subType">
    &#60;input type="text" placeholder="status">
    &#60;button class="btn btn-secondary">Create new user&#60;/button>

    providers: [UserService]

    createNewUser() &#123;
      this.userService.addNewUser(&#123;...this.newUserObj})
    }
  </pre>
    <ul>
      <li>A modellünk leírja a user-ünk paramétereit</li>
      <li>A service-ünkben készítettünk egy 3 emelből álló user tömböt, 3 user osztályt példányosítva</li>
      <li>A getAllUsers metódus visszaadja az összes felhasználót</li>
      <li>A felhasználókat kilistázzuk a user-list komponensben</li>
      <li>Mivel a parent komponensben, és a user-list komponensben is provide-oltuk a UserService-t, ezért a kettő más
        példányt fog kapni a service-ből, ezért van az, hogy új usert készítve nem látjuk azt megjelenni a listában</li>
      <li>Az a példány, amelyikhez hozzáadjuk a felhasználót, nem ugyanaz, mint amelyiket megjelenítjük táblázatban</li>
      <li>Amennyiben csak a parent komponensben provide-oljuk a service-t, úgy a user-list komponens automatikusan
        "megörökli" a UserService ugyanazon példányát (avagy oda is injektálásra kerül)
        <ul>
          <li>A user-list komponensben a fenti példában ezt írtuk felül egy másik példány provide-olásával</li>
        </ul>
      </li>
      <li>A user-list komponensből, ha eltávolítjuk a provider-ek közül a UserService-t, a példányok meg fognak egyezni,
        és a lista bővítés is működni fog.</li>
      <li>Az ilyen esetekben az app.module.ts fájlba érdemes provide-olni a service-t</li>
    </ul>
    <br>
    <h5 #injectingserviceintoservice data-anchor="injectingserviceintoservice">Injecting service into service</h5>
    <ul>
      <li>Service-be is injektálhatunk service-t</li>
      <li>Az explicit példányosítást érdemes kerülni
        <ul>
          <li>A UserService szorosan függésbe kerül a LoggerService-szel</li>
          <li>Továbra sem jó practice</li>
        </ul>
      </li>
      <pre>
      // let logger = new LoggerService();
      // logger.logMessage(name, status);
    </pre>
      <li>3 dologra lesz szükségünk a service injektálásához
        <ol>
          <li>Meg kell mondanunk az Angularnak, hogy hogyan injektálja a LoggerService-t a UserService-be</li>
          <pre>
          constructor(private logger: LoggerService) &#123;

          }
        </pre>
          <li>Azt is meg kell mondanunk az Angularnak, hogy mit injektáljon
            <ul>
              <li>Ha valamit be akarunk injektálni egy service class-ba, akkor egy speciális metadatát szükséges
                használnunk</li>
              <li>Egy speciális metadatát használhatunk, az @Injectable-t</li>
            </ul>
          </li>
          <li>Prodide-olnunk kell a service-t
            <ul>
              <li>A best practice a module class-t választani
                <ul>
                  <li>@ngModul dekorátorral dekorált</li>
                </ul>
              </li>
            </ul>
          </li>
        </ol>
      </li>
      <li>Az @Injectable megmondja az Angularnak, hogy a service osztályba lehet injektálni</li>
      <li>A beinjektálandó service-ben nem szükséges használni, csak ott, ahová injektálnánk
        <ul>
          <li>Az Angular újabb verzióinál ugyanakkor ajánlott minden service-hez hozzáadni az @Injectable() dekorátort
          </li>
        </ul>
      </li>
      <li>A logger paraméterben ilyen módon egy LoggerService class példányunk lesz</li>
      <pre>
      // user.service.ts
      @Injectable()

      export class UserService &#123;
        constructor(private logger: LoggerService) &#123;

        }

        addNewUser(&#123;name, gender, subType, status}: &#123;name: string, gender: string, subType: string, status: string}) &#123;
          let user = new User(name, gender, subType, status);
          this.users.push(user);
  
          this.logger.logMessage(name, status);
        }
      }

      // logger.service.ts
      export class LoggerService &#123;
        private messageSubject: Subject&#60;string> = new Subject&#60;string>();
    
        get message$(): Observable&#60;string> &#123;
            return this.messageSubject.asObservable();
        }
        
    
        logMessage(name: string, status: string) &#123;
            const message = `A new user with name $&#123;name} with status $&#123;status} is added to user list`;
            this.logMessageEvent(message);
        }
    
        private logMessageEvent(message: string) &#123;
            this.messageSubject.next(message);
        }
      }
    </pre>
      <li>messageSubject: Kívülről hozzá nem férhető Subject típus</li>
      <li>message$: Getter, amely az Observable-t adja vissza, így kívülről csak feliratkozni lehet rá, de nem lehet
        módosítani a Subject értékét</li>
      <li>logMessage(): Kívülről nem elérhető függvény, ami az üzenetet állítja be, és meghívja a belső
        logMessageEvent()-et, hogy
        frissítse az adatfolyamot</li>
      <li>logMessageEvent(): Elküldi a feliratkozottaknak a message-t</li>
      <br>
      <div style="display: inline-grid;">
        <input type="text" placeholder="name" [(ngModel)]="newUserObj.name">
        <input type="text" placeholder="gender" [(ngModel)]="newUserObj.gender">
        <input type="text" placeholder="subType" [(ngModel)]="newUserObj.subType">
        <input type="text" placeholder="status" [(ngModel)]="newUserObj.status">
        <button class="btn btn-secondary" (click)="createNewUser()">Create new user</button>
      </div>
      <br>
      <div>Sent messages:</div>
      <ul *ngFor="let m of messageLogArray">
        <li>{{m}}</li>
      </ul>
    </ul>
    <br>
    <h5 #injectiontoken data-anchor="injectiontoken">Injection token</h5>
    <ul>
      <li>Amikor a modulunk providers tömbjébe service-t helyezünk el, a függöny mögött az Angular típuskonverziót
        végez,
        a tömbelemből objektumot képez, aminek két property-je van</li>
      <pre>
          providers: [UserService]
  
          ↓↓↓↓↓
  
          providers: [&#123;provide: UserService, useClass: UseService}]
      </pre>
      <li>Átírva objektumra az Angular ugyanúgy tudja értelmezni, nem befolyásolja a működést</li>
      <li>A provide értéke egy egyedi azonosító, ami regisztrálja a class-t, és ezt token-nek is nevezzük
        <ul>
          <li>A dependency injection rendszerének szüksége van erre a tokenre, hogy megtalálja a provider-t a providers
            tömbben</li>
          <li>Lehet string, vagy injection token</li>
        </ul>
      </li>
      <li>A useClass azt mondja meg, melyik osztályt szükséges a token számára példányosítani</li>
      <pre>
        providers: [
          &#123;provide: 'USER_SERVICE', useClass: UserService},
          LoggerService
        ],
      </pre>
      <li>Átírva a provide property-t egyedi stringre, hibát kapunk
        <ul>
          <li>No provider for UserService!</li>
          <li>Ez azért van, mert új tokent adtunk meg a provide property-nek</li>
          <li>A használt komponensek konstruktorában az Angular nem tudja, hogy milyen token-t kell injektálnia</li>
          <li>Ezekre a helyekre a UserService class-t (useClass-t) szeretnénk injektálni, ahol a token 'USER_SERVICE',
            és
            ezt meg is kell mondanunk az Angularnak</li>
          <li>Szóval azokban a komponensekben, ahol ezidáig be volt injektálva a UserService class, némi változtatást
            szükséges ecsetelnünk</li>
          <pre>
              constructor(@Inject('USER_SERVICE') private userService: UserService) &#123;
  
              }
          </pre>
          <li>A string token használatával könnyebb hibákba futni, például elírni a unique token-t, valamint komplexebb
            applikációkban nehezebb a kód karbantartása
            <ul>
              <li>Emiatt jön a képbe az injection token</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Injection token
        <ul>
          <li>String érték helyett használhatjuk</li>
          <li>Első körben létre kell hozni a token-t</li>
          <pre>
            ...
  
            export const USER_TOKEN = new InjectionToken&#60;>('USER_SERVICE');
  
            @ngModule(&#123;
              ...
              providers: [
                &#123;provide: USER_TOKEN, useClass: UserService},
              ]
            })
          </pre>
          <li>Létre kell hozni egy UserService típusú injection token-t</li>
          <li>Paraméterként string-et fogad, ami bármi lehet, praktikusan, ami leírja, mit csinál a token</li>
          <li>Ezzel létrehoztunk egy egyedi token-t a UserService osztálynak</li>
          <li>Ugyancsak változást kell ecsetelnünk a komponensekben</li>
          <pre>
            import &#123; USER_TOKEN } from 'src/shared/shared.module';
  
            constructor(@Inject(USER_TOKEN) private userService: UserService) &#123;
  
            }
          </pre>
          <li>Az Injection Token különösen hasznos az alábbi esetekben
            <ol>
              <li>Alapértelmezett konfigurációs adatok injektálása</li>
              <li>Interfészek vagy absztrakt osztályok injektálása</li>
              <li>Többféle implementáció használata egy szolgáltatáshoz</li>
              <li>Több érték egyidejű injektálása egy tömb formájában</li>
              <li>Futásidőbeli konfigurációk kezelése</li>
            </ol>
          </li>
        </ul>
      </li>
      <li>Az egyes service-ek @Injectable() dekorátorába megadhatunk egy objektumot
        <ul>
          <li>Ezzel elérhetjük, hogy tulajdonképpen az app.module-ból provide-oljuk a service-t</li>
          <pre>
            @Injectable(&#123;
                providedIn: 'root'
            })
          </pre>
          <li>Ez után már nem szükséges explicit módon az app.module-ban provide-olnunk a service-t</li>
        </ul>
      </li>
      <li>Létezik egy másik, új megoldás is arra, hogy megkérjük az Angulart, hogy injektáljon egy service-t</li>
      <pre>
        /* constructor(private logger: LoggerService) &#123;
  
        } */
    
        subService = inject(LoggerService);
    
        getAllUsers() &#123;
            return this.users;
        }
    
        addNewUser(&#123; name, gender, subType, status }: &#123; name: string, gender: string, subType: string, status: string }) &#123;
            let user = new User(name, gender, subType, status);
            this.users.push(user);
    
            // this.logger.logMessage(name, status);
    
            this.subService.logMessage(name, status);
        }
      </pre>
      <ul>
        <li>A constructor helyett egy inject metódust használhatunk.</li>
        <li>Angular 14-től elérhető</li>
      </ul>
    </ul>
  </ul>
</div>

<div>
  <h3 #observable data-anchor="observable">Observable</h3>
  <ul>
    <li>Az Observable-t aszinkron adatok kezelésére használjuk</li>
    <li>Promise-t is használhatunk ugyanerre a célra
      <ul>
        <li>Javascriptbe épített feature</li>
      </ul>
    </li>
    <li>Tehát az Angularban az aszinkron adatok kezelésére Observable-t, és Promise-t is használhatunk</li>
    <li>Mi is az az aszinkron adat / művelet?
      <ul>
        <li>A Javascript egy egyszálas programozási nyelv
          <ul>
            <li>A kód sorról sorra hajtódik végre</li>
            <li>A mennyiben egy sor lefutása hosszú időt vesz igénybe, addig a következő sornak várnia kell</li>
            <li>Ha egy HTTP szerverhez fordulunk adatért, az adat, mint válasz érkezik a szervertől, ami időt vesz
              igénybe, amíg megérkezik, és a következő sor kód csak ez után fut le</li>
          </ul>
        </li>
        <li>Mivel a szinkron kód blokkolja a futást (blocking), ezért használjuk az aszinkron programozást
          (non-blocking)
          <ul>
            <li>Az aszinkron kód nem a szinkron egy szálon kerül futtatásra, hanem a háttérben</li>
            <li>Nem blokkolja a fő szálat</li>
            <li>Amennyiben HTTP kérést intézünk, az meg tud történni a háttérben, majd a következő sor futtatásra kerül
              a fő szálon</li>
            <li></li>
          </ul>
        </li>
        <li>Az aszinkron kód egy bizonyos idő után adatot nyújt
          <ul>
            <li>Miután megvártuk, megkaptuk, utána felhasználhatjuk a kódunkban</li>
            <li>A kezelésére használhatjuk a Promise-t, és az Observable-t</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Adatfolyam
      <ul>
        <li>Az Angular applikációnkból szeretnénk adatot lekérni egy szervertől
          <ol>
            <li>HTTP kérést intézünk a szerver felé</li>
            <li>Az adatot a szerver HTTP válasz formájában küldi el az applikációnak</li>
          </ol>
        </li>
        <li>A szerver adatbázisból, vagy Web API-n keresztül szolgál ki</li>
        <li>Az adat könnyen lehet nagy mennyiségű</li>
        <li>A szerver 2 féle módon küldheti el nekünk az adatot
          <ul>
            <li>Megkapjuk az összes adatot egyszerre</li>
            <li>Kis részekre bontva küldi el a szerver az adatot
              <ul>
                <li>Videó streaming esetében evidens, hogy részenként érdemes elküldeni a videót, különben rengeteget
                  kellene várniuk a felhasználóknak, hogy el tudják kezdeni nézni, amit szeretnének</li>
                <li>Szétdarabolva a user-nek csak addig szükséges várni, amíg az első adatcsomag megérkezik</li>
                <li>Ezt nevezik adatfolyamnak (streaming of data)</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Promise vs Observable
      <ul>
        <li>Promise
          <ul>
            <li>Adatot igér egy adott időn belől</li>
            <li>Az így kapott adat lehet valóban adat, vagy valamilyen hiba
              <ul>
                <li>Egy HTTP kérésnél például vagy megkapjuk a kért adatot, vagy egy error objektumot, ha valami hiba
                  történt</li>
              </ul>
            </li>
            <li>A Promise nem tudja kezelni az adatfolyamokat
              <ul>
                <li>Mindig egy "értékkel", egyetlen adattal tér vissza</li>
                <li>Ha mégis ezzel próbálkozunk, a Promise az első adatcsomagnál resolve ágba fut</li>
                <li>A további csomagokat már nem is kezeli</li>
              </ul>
            </li>
            <li>Akkor is visszatér adattal, ha semmi sem használja a visszaadott adatot</li>
            <li>A Javascript natívan tartalmazza</li>
          </ul>
        </li>
        <li>Observable
          <ul>
            <li>Egyszerűen tudja kezelni az adatfolyamokat</li>
            <li>Több "értékkel", több adattal térhet vissza</li>
            <li>Csak abban az esetben kapunk tőle adatot, ha van is olyan kódunk, ami használni fogja azt
              <ul>
                <li>Máskülönben az Observable nem küld adatot</li>
              </ul>
            </li>
            <li>Az Observable nincs benne sem a Javascriptben, sem az Angularban natívan
              <ul>
                <li>A Javascript egy könyvtára, az RxJS biztosítja
                  <ul>
                    <li>Reactive Extension Library for Javascript</li>
                    <li>Az RxJS Observer pattern-t használ
                      <img src="assets/imgs/observer_pattern.png" style="width: 100%; max-width: 500px;">
                      <ul>
                        <li>Ebben a mintában van egy EventEmitter-ünk, amit Observable-nek is nevezhetünk
                          <ul>
                            <li>Ez az Observable eseményt fog magából kibocsátani</li>
                            <li>Az alábbi 3 esemény kibocsátására képes
                              <ol>
                                <li>next</li>
                                <li>error</li>
                                <li>complete</li>
                              </ol>
                            </li>
                          </ul>
                        </li>
                        <li>Emellett van egy Observer-ünk is, amit Event Listener-nek, vagy Subscriber-nek is
                          nevezhetünk
                          <ul>
                            <li>Figyelni fogja, hogy történik-e esemény</li>
                            <li>Feliratkozik az Observable-re</li>
                          </ul>
                        </li>
                        <li>Amikor az Observer elkap egy eseményt, Event Handler-ek segítségével kezeli azt
                          <ul>
                            <li>Az Observer Handler-ek segítségével logikákat tud futtani</li>
                            <li>Ha bekövetkezik az esemény a Subscriber kezelheti az eseményt, ha akarja, valamilyen kód
                              futtatásával</li>
                            <li>Az eseményeket úgy képes kezelni, hogy a subscribe() metódusnak callback
                              függvényként átadja a next(), error() vagy complete() függvényeket.
                              <ol>
                                <li>next(): amikor új adat érkezik az adatfolyamból</li>
                                <li>error(): ha hiba történik</li>
                                <li>complete(): ha az adatfolyam befejeződik</li>
                              </ol>
                            </li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Egy függvény, ami adathalmazt konvertál Observable típussá</li>
            <li>Tekinthetünk úgy rá, mint egy általános adathalmaz körüli csomagolásra</li>
            <li>Tehát ne felejtsük el, hogy amikor Observable-t használunk, alapvetően Observer mintát fogunk használni,
              ahol egy Observable kibocsát egy event-et, az Observer pedig figyel erre az eseményre, és futtathat
              függvényeket
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <h5 #createanduseobservable data-anchor="createanduseobservable">Create and use</h5>
    <ul>
      <li>Az RxJS segítségünkre lehet, hogy async adatfolyamokkal dolgozzunk
        <ul>
          <li>Operátorokat és metódusokat kínál, amiket Observable típuson alkalmazhatunk az adat manipulálása végett
          </li>
        </ul>
      </li>
      <li>Az Observer patternben 2 fő játékos vesz részt
        <ol>
          <li>Observable
            <ul>
              <li>Kibocsát magából adatot</li>
            </ul>
          </li>
          <li>Observer
            <ul>
              <li>Megkapja az Observable által kibocsátott adatot, amennyiben fel van rá iratkozva, és Handler
                segítségével (opcionális) fel tudja használni</li>
            </ul>
          </li>
        </ol>
      </li>
      <li>A kiindulási alap</li>
      <pre>
        <b>// Parent</b>
        &#60;app-observable>&#60;/app-observable>

        <b>// app-observable</b>
        &#60;div class="rounded-border">
          &#60;div *ngFor="let d of data">
            &#60; &#60;d}}
          &#60;/div>
      
          &#60;button class="btn btn-secondary">Get data&#60;/button>
        &#60;/div>

        <datalist></datalist>ata: number[] = [];
      </pre>
      <li>Először is készítsünk egy Observable-t
        <ul>
          <li>Meg kell hívnunk a konstruktorát (és importálnunk az rxjs könyvtárból) az Observable-nek, és egy
            property-hez rendelni</li>
          <li>Az RxJS installálásra kerül az Angular CLI-vel együtt</li>
          <li>A package.json fájlban is látható</li>
        </ul>
      </li>
      <pre>
        dataObservable = new Observable();
      </pre>
      <li>Ugyanakkor ahhoz, hogy ez az Observable adatot bocsásson ki, callback function-nel kell kiegészítenünk</li>
      <pre>
        dataObservable = new Observable(() => &#123;

        });
      </pre>
      <li>A callback függvény argomentumot kap</li>
      <pre>
        dataObservable = new Observable((observer) => &#123;

        });
      </pre>
      <li>Az argomentum (observer) az RxJS által a callback függvénybe injektált
        <ul>
          <li>Az 'observer' nem más, mint a Subscriber/Observer</li>
          <li>Tehát azok a feliratkozók, akik az Observerre feliratkoznak</li>
        </ul>
      </li>
      <li>Ha valamilyen értéket szeretnénk emit-álni, a next() metódust szükséges meghívnunk
        <ul>
          <li>Az 'observer' "megkapja" az összes subscriber-t, akik feliratkoztak az Observable-re</li>
        </ul>
      </li>
      <pre>
        dataObservable = new Observable((observer) => &#123;
          observer.next();
        });
      </pre>
      <li>Tegyük fel, hogy egy 5 elemű szám tömböt szeretnénk kiküldeni</li>
      <pre>
        dataObservable = new Observable&#60;number[]>((observer) => &#123;
          observer.next([1, 2, 3, 4, 5]);
        });
      </pre>
      <li>Ez utóbbi esetben már megadtuk az Observable típusát is</li>
      <li>A 'dataObservable' tehát a next() metódusban lévő adatot küldi ki
        <ul>
          <li>Fontos újra megjegyezni, hogy csakis kizárólag akkor, ha van Subscriber</li>
        </ul>
      </li>
      <li>Iratkozzunk fel a Get data gomb megnyomására a 'dataObservable'-re</li>
      <pre>
        <b>// Observable / Event emitter</b>
        dataObservable = new Observable((observer) => &#123;
          observer.next([1, 2, 3, 4, 5]);
        });

        <b>// Observer / Event listener</b>
        this.dataObservable.subscribe();
      </pre>
      <li>Amikor a 'dataObservable' adatot bocsájt ki, a 'this.dataObservable.subscribe()' észlelni fogja</li>
      <li>Egyelőre még semmit sem tesz az Observer azzal az adattal, amit kibocsát az Observable
        <ul>
          <li>Ehhez Handler (Event handler) függvény használata szükséges</li>
          <li>Az Observable next eventet küld, ezért a feliratkozásnál callback függvényt kell átadnunk</li>
          <li>A subscribe() függvény 3 callback function függvényt fogad
            <ol>
              <li>next()
                <ul>
                  <li>Akkor fut le, ha az Observable next() event-et emitál</li>
                </ul>
              </li>
              <li>error()
                <ul>
                  <li>Akkor fut le, ha az Observable error() event-et emitál</li>
                </ul>
              </li>
              <li>complete()
                <ul>
                  <li>Akkor fut le, ha az Observable complete() event-et emitál</li>
                </ul>
              </li>
            </ol>
          </li>
          <li>Mindhárom callback függvény opcionális</li>
        </ul>
      </li>
      <li>Először a next() callback függvényt kezeljük le (Handler / Event handler), és adjuk oda a data tömbnek, ami
        jön benne</li>
      <pre>
        getAsyncDataByClick() &#123;
          this.dataObservable.subscribe(
            (next: number[]) => &#123;
              this.data = next;
            }
          )
        }
      </pre>
      <li>Ezután gombnyomásra már megjelennek a tömb elemei
        <ul>
          <li>Gombnyomásra feliratkozunk az Observable-re</li>
          <li>A next paraméterben megkapjuk az emit-ált adatot
            <ul>
              <li>Tetszőlegesen el lehet nevezni</li>
            </ul>
          </li>
          <li>Végül a 'data' tömb megkapja az elküldött adatot</li>
        </ul>
      </li>
    </ul>
    <br>
    <app-observable [tempSwitcher]="'array'"></app-observable>
    <br>
    <li>Jelenleg a fenti Observable egyetlen adatot ad vissza, egy tömböt
      <ul>
        <li>Adatfolyam is megvalósítható, és ezt is fogjuk az alábbiakban megnézni</li>
        <li>Több next() hívásunk is lesz</li>
      </ul>
    </li>
    <pre>
      data2: number[] = [];

      dataObservable2 = new Observable&#60;number>((observer) => &#123;
        observer.next(1);
        observer.next(2);
        observer.next(3);
        observer.next(4);
        observer.next(5);
      });

      getAsyncDataByClick2() &#123;
        this.dataObservable2.subscribe&#123;
          (next: number) => &#123;
            this.data2.push(next);
          }
        )
      }
    </pre>
    <li>Minden alkalommal, amikor a next() metódust meghívjuk, adat emitálás történik</li>
    <li>Az Observer next() callback function-je immáron nem tömb, hanem egy primitív érték</li>
    <li>Amikor meghívjuk a 'getAsyncDataByClick2' függvényt, a subscribe() aktiválódik, és a már meglévő Observable újra
      elküldi az értékeit (1, 2, 3, 4, 5), és ezek hozzáadódnak a data2 tömbhöz</li>
    <app-observable [tempSwitcher]="'arrayStream'"></app-observable>
    <li>Az értékek nagyon gyorsan hozzáadódnak a data2 tömbhöz, ezért tűnik úgy, mintha egy az egyben csak átadná az
      Observable az Observernek az összes értéket, egyszerre, de a valóságban egymás után történik a pusholás</li>
    <pre>
      dataObservable3 = new Observable&#60;number>((observer) => &#123;
        setTimeout(() => &#123;
          observer.next(1);
        }, 1000);
        setTimeout(() => &#123;
          observer.next(2);
        }, 2000);
        setTimeout(() => &#123;
          observer.next(3);
        }, 3000);
        setTimeout(() => &#123;
          observer.next(4);
        }, 4000);
        setTimeout(() => &#123;
          observer.next(5);
        }, 5000);
      });
    </pre>
    <app-observable [tempSwitcher]="'arraySteamWithTimeOut'"></app-observable>
    <li>Így látszik, hogy az adatfolyam egymás után, sorban küldi el a számokat, nem egyszerre kapjuk meg az adatot</li>
    <li>A fentiek mind cold Observable-ök, nincs lehetőség később más/újabb adatcsomagot kibocsátani, mindig ugyanazt az
      értéket fogják kiadni magukból</li>
    <br>
    <h5 #errorandcomplete data-anchor="errorandcomplete">Error and complete</h5>
    <ul>
      <li>Az Observer első callback függvénye a Handler, ami kezeli az Observable által kibocsátott adatot
        <ul>
          <li>Amikor meghívjuk a next metódust, az Observable kibocsát magából egy next event-et</li>
          <li>Feliratkozva az Observable-re, figyelünk a next event-ekre</li>
        </ul>
      </li>
      <li>A második callback function az error(), itt tudjuk a hibát kezelni</li>
      <li>Ahhoz, hogy hibát bocsássunk ki, az error() methodot szükséges használnunk</li>
      <li>Error után az Observable már nem bocsát ki semmilyen értéket, így a 4, és 5 nem fognak már megérkezni az
        Observer-höz</li>
      <pre>
        dataObservable4 = new Observable&#60;number>((observer) => &#123;
          setTimeout(() => &#123;observer.next(1)}, 1000);
          setTimeout(() => &#123;observer.next(2)}, 2000);
          setTimeout(() => &#123;observer.next(3)}, 3000);
          setTimeout(() => &#123;observer.error(new Error('Something went wrong'))}, 3000);
          setTimeout(() => &#123;observer.next(4)}, 4000);
          setTimeout(() => &#123;observer.next(5)}, 5000);
        });
      
        getAsyncDataByClick4() &#123;
          this.dataObservable4.subscribe(
            (next: number) => &#123;
              this.data4.push(next);
            }
          )
        }
      </pre>
      <app-observable [tempSwitcher]="'error'"></app-observable>
      <li>A DevTools Console-jába kiírodik ezáltal a hibaüzenet, amit megfogalmazunk
        <ul>
          <li>Az ERROR string a 3-mas szám után még bekerül a tömb elemei közé</li>
          <li>A fenti példában a hibát nem kezeltük, és nem is elegáns a felhasználó felé ilyen formán hibát mutatni
          </li>
          <pre>
            ...
            setTimeout(() => &#123;observer.error('Something went wrong')}, 3000);
            ...

            getAsyncDataByClick4() &#123;
              this.dataObservable4.subscribe(
                (next: number) => &#123;
                  this.data4.push(next);
                },
                (error) => &#123; // 
                  this.data4.push('ERROR');
                  console.error(error);
                }
              )
            }
          </pre>
          <li>Az error paraméter a subscribe metódus hibakezelő callback függvényében
            <ul>
              <li>A paraméter egy objektumot rejt, aminek a message kulcsában található az Observable által kibocsátott
                hibaüzenet</li>
              <li>Tetszőlegesen megválasztható szó</li>
            </ul>
          </li>
          <li>A console-ba kiírjuk a hibaüzenetet ('Something went wrong')</li>
          <li>Amennyiben a new Error('Something went wrong') kóddal operálunk, az Observer error ágában a message kulcs
            alatt találjuk a stringet</li>
        </ul>
      </li>
      <li>A kódban a subscribe method-ot az IDE depricated-nek (elavult) jelöli
        <ul>
          <li>Integrated Development Environment, azaz integrált fejlesztőkörnyezet</li>
          <li>Ennek oka, hogy a legutóbbi RxJS verziók esetében nem javasolt a callback function-ök ilyen módú megadása
          </li>
        </ul>
      </li>
      <li>Adat, és error emit-álás mellett complete jelet is kiadhatunk
        <ul>
          <li>Azt jelenti, hogy az Observable sikeresen befejezte az adatfolyamot</li>
          <li>A complete method-nak nincs argomentuma</li>
          <li>Módunkban áll valamilyen logikát futtatni, ha az Observable befejezte az adatok küldését</li>
          <li>Az Observernél a 3. (argomentum nélküli )callback function-t használhatjuk erre
            <ul>
              <li>Névtelen függvény</li>
            </ul>
          </li>
        </ul>
        <pre>
          data5: any[] = [];

          dataObservable5 = new Observable&#60;number>((observer) => &#123;
            setTimeout(() => &#123; observer.next(1) }, 1000);
            setTimeout(() => &#123; observer.next(2) }, 2000);
            setTimeout(() => &#123; observer.next(3) }, 3000);
            setTimeout(() => &#123; observer.next(4) }, 4000);
            setTimeout(() => &#123; observer.next(5) }, 5000);
            setTimeout(() => &#123; observer.complete() }, 6000);
          });

          getAsyncDataByClick5() &#123;
            this.dataObservable5.subscribe(
              (next: number) => &#123;
                this.data5.push(next);
              },
              (err) => &#123;
              },
              () => &#123;
                this.data5 = ['Data stream successfully completed'];
              }
            )
          }
        </pre>
        <app-observable [tempSwitcher]="'complete'"></app-observable>
      </li>
      <br>
      <li>Amennyiben a complete event-et 3000 ms után bocsátjuk ki, a 4-es és 5-ös csomag nem fog megérkezni az
        Observer-nek</li>
      <li>Ha az error és a complete event-et egyszerre emit-áljuk, az error érkezik meg előbb, és a complete sem fog
        érvényesülni, ugyanúgy, ahogy a maradék adatcsomag</li>
    </ul>
    <br>
    <li>Nézzük meg a callback function átadást úgy, hogy az IDE ne panaszkodjon, hogy depricated
      <ul>
        <li>A 3 különálló callback függvény helyett objektumot adunk át, és ebben az objektumban van 3 függvény
          <ol>
            <li>next(value) &#123;}</li>
            <li>error(err) &#123;}</li>
            <li>complete() &#123;}</li>
          </ol>
        </li>
        <pre>
        <b>// Depricated</b>
          getAsyncDataByClick6() &#123;
            this.dataObservable6.subscribe(
              (next: number) => &#123;
                this.data6.push(next);
              },
              (err) => &#123;
                this.data6.push(err.message);
              },
              () => &#123;
                this.data6 = ['Data stream successfully completed'];
              }
            )
          }

          // ----- VS ----- //

          <b>// Not depricated</b>
          getAsyncDataByClick6() &#123;
            this.dataObservable6.subscribe(&#123;
              next(value: any) &#123;
                this.data6.push(value);
              },
              error(err) &#123;
                this.data6.push(err.message);
              },
              complete() &#123;
                this.data6 = ['Data stream successfully completed'];
              }
            })
          }
        </pre>
        <li>Hibára fogunk futni a felső, újabb megközelítéssel</li>
        <ul>
          <li>A 'this' szó az objektumra mutat, és nem az app komponensre</li>
          <pre>
            Property 'data6' does not exist on type 'Partial&#60;>Observer&#60;number>>
          </pre>
          <li>Ennek kiküszöbölésére 2 módszer létezik
            <ol>
              <li>Létrehozunk egy konstanst (változót), ami tartalmazza a komponens példányának referenciáját</li>
              <pre>
                getAsyncDataByClick6() &#123;
                  const that = this
                  this.dataObservable6.subscribe(&#123;
                    next(value: any) &#123;
                      that.data6.push(value);
                    },
                    error(err) &#123;
                      that.data6.push(err.message);
                    },
                    complete() &#123;
                      that.data6 = ['Data stream successfully completed'];
                    }
                  })
                }
              </pre>
              <li>A másik, elegánsabb verzió, hogy arrow function-öket alkalmazunk</li>
              <pre>
                data6: any[] = [];

                dataObservable6 = new Observable&#60;number>((observer) => &#123;
                  setTimeout(() => &#123; observer.next(1) }, 1000);
                  setTimeout(() => &#123; observer.next(2) }, 2000);
                  setTimeout(() => &#123; observer.next(3) }, 3000);
                  setTimeout(() => &#123; observer.next(4) }, 4000);
                  setTimeout(() => &#123; observer.next(5) }, 5000);
                  setTimeout(() => &#123; observer.complete() }, 6000);
                });

                getAsyncDataByClick6() &#123;
                  this.dataObservable6.subscribe(&#123;
                    next: (value: any) => &#123; this.data6.push(value) },
                    error: (err) => &#123; this.data4.push(err.message) },
                    complete: () => &#123; this.data6 = ['Data stream successfully completed'] }
                  })
                }
              </pre>
            </ol>
          </li>
        </ul>
        <app-observable [tempSwitcher]="'depricated'"></app-observable>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #rxjs data-anchor="rxjs">RxJS</h3>
  <ul>
    <li><a [routerLink]="['/', 'rxjs']">Mi is az az RxJS?</a></li>
    <br>
    <h5 #ofandfrom data-anchor="ofandfrom">Of and from</h5>
    <ul>
      <li>of
        <ul>
          <li>Lényege az, hogy a paraméterként átadott értékekből egy Observable-t hoz létre, amely azokat az értékeket
            egymás után kibocsátja</li>
          <li>Az adatfolyam végén complete event-et küld</li>
          <li>Automatikusan complete event-et küld</li>
          <pre>
            data: any[] = [];
            data2: any[] = [];
            array1: any[] = [1, 3, 5, 7, 9];
            array2: any[] = ['A', 'B', 'C', 'D'];

            ownObservable = of(this.array1);
            ownObservable2 = of(...this.array1);

            ofClicked() &#123;
              this.ownObservable.subscribe(&#123;
                next: (value) => &#123;
                  this.data.push(value);
                },
                error: (err) => &#123; },
                complete: () => &#123;
                  this.data.push('completed');
                }
              });
              this.ownObservable2.subscribe(&#123;
                next: (value) => &#123;
                  this.data2.push(value);
                },
                error: (err) => &#123; },
                complete: () => &#123;
                  this.data2.push('completed');
                }
              })
            }
          </pre>
          <li>
            <ol>
              <li>Spread operátor használata: Minden egyes szám külön-külön elemként kerül a data tömbbe, mint pl. [1,
                3, 5, 7, 9, 'completed']</li>
              <li>Spread operátor nélküli használat: Az array1 tömb egyetlen elemként kerül a data tömbbe, tehát a
                kimenet [ [1, 3, 5, 7, 9], 'completed' ] lesz, ahol az első elem egy tömb</li>
            </ol>
          </li>
          <br>
          <app-angular-rxjs [tempSwitcher]="'of'" (subscriptionsChanged)="testFunction($event)"></app-angular-rxjs>
          <br>
          <li>Átadhatunk több argomentumot is az of()-nak
            <ul>
              <li>Az alábbi példában két tömb kerül kiküldédre</li>
              <li>Végül egy completed string egy tömbben</li>
            </ul>
          </li>
          <pre>
            data3: any[] = [];

            ownObservable3 = of(this.array1, this.array2);

            ofClicked3() &#123;
              this.ownObservable3.subscribe(&#123;
                next: (val) => &#123;
                  this.data3.push(val);
                },
                error: (err) => &#123; },
                complete: () => &#123;[]
                  this.data3.push(['completed']);
                },
              });
            }
          </pre>
          <app-angular-rxjs [tempSwitcher]="'of3'" (subscriptionsChanged)="testFunction($event)"></app-angular-rxjs>
        </ul>
      </li>
      <br>
      <li>from
        <ul>
          <li>Egyetlen iterálható (array, string, Promises) argomentumot/értéket fogad, amit Observable típussá
            konvertál</li>
          <li>Az of() operátor tömbként küldte volna ki egyszerre, de itt nem ezt láthatjuk</li>
          <li>A tömb elemei egymás után kerülnek emit-álásrs</li>
          <li>Lényegében ez a különbség az of() és a from() operátor között</li>
          <li>Ez az operátor is automatikusan kiküldi a complete jelzést a stream végén</li>
          <pre>
            data4: any[] = [];
            array4: any[] = ['A', 'W', 'S', 'D']

            ownObservable4 = from(this.array4);

            fromClicked4() &#123;
              this.ownObservable4.subscribe(&#123;
                next: (val) => &#123;
                  this.data4.push(val);
                },
                error: (err) => &#123; },
                complete: () => &#123;
                  this.data4.push('completed');
                }
              });
            }
          </pre>
          <app-angular-rxjs [tempSwitcher]="'from'" (subscriptionsChanged)="testFunction($event)"></app-angular-rxjs>
          <br>
          <li>A from() operátor a legalkalmasabb arra, hogy egy Promise-t Observable típussá konvertáljunk
            <pre>
              data5: any[] = [];
              data6: any[] = [];
              promiseData: Promise&#60;any> = new Promise((resolve, reject) => &#123;
                resolve([10, 20, 30]); // A Promise ezzel az adattal tér vissza
              });

              ownObservable5 = from(this.promiseData);
              ownObservable6: Observable&#60;any> = new Observable;

              fromClicked5() &#123;
                this.ownObservable5.subscribe(&#123;
                  next: (val) => &#123;
                    this.data5.push(val);
                  },
                  error: (err) => &#123; },
                  complete: () => &#123;
                    this.data5.push('completed');
                  }
                });

                this.promiseData.then((resolvedValue) => &#123;
                  this.ownObservable6 = from(resolvedValue);
                  // this.ownObservable6 = of(...resolvedValue); // Ugyanazt az eredményt adja

                  this.ownObservable6.subscribe(&#123;
                    next: (val) => &#123;
                      console.log(val);
                      this.data6.push(val);
                    },
                    error: (err) => &#123; },
                    complete: () => &#123;
                      this.data6.push('completed');
                    }
                  });
                });
            </pre>
            <ul>
              <li>A 'promiseData' egy Promise; egy aszinkron művelet, ami a későbbiekben [10, 20, 30] tömböt szolgáltat
              </li>
              <li>Amikor a 'promiseData' beteljesedik (resolve), akkor az értéke [10, 20, 30] lesz</li>
              <li>Hozzáférni az értékhez a then metódussal lehetséges</li>
              <li>Az 'ownObservable5'-be a from operátor segítségével elemenként kerülnek be a Promise által
                szolgáltatott tömb elemei.</li>
              <li>A promiseData-t 'ownObservable6' esetében feloldjuk, hogy of(), vagy from(), és spread operátor
                segítségével ne egy tömb kerüljön 'data6' változóba, hanem egyesével a tömb elemei</li>
              <li>Végül mindkét esetben, amikor sikeresen elhelyezkedtek az adatok, a subscribe metódusban található
                objektumban lévő complete kulcsok alatt található függvények futnak le, és a logika alapján a megfelelő
                tömbbe bekerülnek a complete szavak</li>
              <br>
              <li>from(this.promiseData): A Promise feloldása után a teljes tömb egyetlen értékként kerül az Observable
                adatfolyamába</li>
              <li>of(this.promiseData): A Promise objektum maga kerül az Observable adatfolyamába, így a data7
                tartalmazni fogja a [object Promise] értéket, és nem a Promise feloldása után visszakapott tömb elemeit
              </li>
            </ul>
          </li>
          <app-angular-rxjs [tempSwitcher]="'promise'" (subscriptionsChanged)="testFunction($event)"></app-angular-rxjs>
          <li>A data7 esetében azt látjuk, hogy az Observable előbb kerül complete állapotba, mint ahogy feloldódna a
            Promise (.then())
          </li>
          <li>Az 'ownObservable7' esetében a feloldásnál használt spread operátor miatt az elemek egyesével kerülnek be
            a data7 tömbbe</li>
          <li>Az of nem oldja fel a Promise-t
            <ul>
              <li>from(promise): A Promise feloldódik, és a feloldott értéket kapod meg az Observable adatfolyamban</li>
              <li>of(promise): A Promise nem oldódik fel; a Promise objektumot magát kapod meg az Observable
                adatfolyamban</li>
            </ul>
          </li>
        </ul>
      </li>
      <br>
      <h5 #fromevent data-anchor="fromevent">FromEvent</h5>
      <ul>
        <li>Lehetővé teszi, hogy Observable típust készítsünk DOM eseményből</li>
        <li>Például egy gombra való kattintás (click) eventet fog létrehozni</li>
        <li>A gombnak létrehozunk egy template reference variable-t, és a kontrollerben bekérjük a referenciáját</li>
        <pre>
          &#60;button #createbutton class="btn btn-secondary" (click)="fromClicked5()">Create new item&#60;/button>

          @ViewChild('createbutton') // alias, vagy referencia változó, argomentumként átadva
          createButton!: // a gomb referenciáját tárolja - megmondtuk a Typescriptnek, hogy higyje el, hogy lesz értéke
          ElementRef // gomb, úgyhogy ElementRef
        </pre>
        <li>A fromEvent() operátor paraméterei
          <ul>
            <li>Első paramétere az elem, aminek az eseményére figyelni szeretnék</li>
            <li>Második paraméter az event neve</li>
            <li>Ez a két kötelező paraméter</li>
          </ul>
        </li>
        <pre>
          onCreateButtonClicked() &#123;
            fromEvent(this.createButton.nativeElement, 'click'); // Observable-t ad vissza
          }
        </pre>
        <li>A 'createButtonObservable' property fogja tartalmazni a fromEvent visszatérési értékét</li>
        <li>Iratkozzunk fel az Observable-re</li>
        <pre>
          onCreateButtonClicked() &#123;
            this.createButtonObservable = fromEvent(this.createButton.nativeElement, 'click'); // Observable-t ad vissza
            this.createButtonObservable
              .subscribe(&#123; // ne felejtsünk el objektumot használni
                next: (val) => &#123;
                  console.log(val);
                },
                error: (err) => &#123; },
                complete: () => &#123; }
              });
          }
        </pre>
        <li>Amikor az 'onCreateButtonClicked' metódust meghívjuk, egy Observable keletkezik a click event-ből, és
          feliratkorunk erre az Observable-re</li>
        <li>Az ngAfterViewInit életciklusban akár meg is lehet hívni a függvényt, mert akkor már a view inicializálódott
        </li>
        <li>Minden kattintásnál elkapjuk az eventet, és hozzáadunk az item-container class-szal rendelkező elemhez egy
          div-et</li>
        <li>A counter változóval az elemek szövege számozott lesz</li>
        <pre>
          &#60;ng-container *ngIf="tempSwitcher === 'fromevent'">
            &#60;div class="rounded-border">
                &#60;div #itemContainer class="item-container">&#60;/div>
        
                &#60;button #createbutton class="btn btn-secondary">Create new item&#60;/button>
            &#60;/div>
          &#60;/ng-container>

          @ViewChild('createbutton') // alias, vagy referencia változó, argomentumként átadva
          createButton!: // a gomb referenciáját tárolja - megmondtuk a Typescriptnek, hogy higyje el, hogy lesz értéke
            ElementRef // gomb, úgyhogy ElementRef

          createButtonObservable: Observable&#60;Event> = new Observable&#60;Event>;

          @ViewChild('itemContainer') itemContainer!: ElementRef;

          onCreateButtonClicked() &#123;
            let counter = 0;
            this.createButtonObservable = fromEvent(this.createButton.nativeElement, 'click'); // Observable-t ad vissza
            this.createButtonObservable
              .subscribe(&#123; // ne felejtsünk el objektumot használni
                next: (val) => &#123;
                  this.createNewItem(++counter); // pre increment operator
                },
                error: (err) => &#123; },
                complete: () => &#123; }
              });
          }

          ngAfterViewInit(): void &#123;
            if (this.tempSwitcher === 'fromevent') &#123; // Különben elszállna a JS futás
              this.onCreateButtonClicked();
            }
          }

          createNewItem(counter: number) &#123;
            const newElem = document.createElement('div');
            newElem.innerText = 'Elem ' + counter;
            this.itemContainer.nativeElement.appendChild(newElem);
          }
        </pre>
        <app-angular-rxjs [tempSwitcher]="'fromevent'" (subscriptionsChanged)="testFunction($event)"></app-angular-rxjs>
        <li>++counter: pre increment operator
          <ul>
            <li>Emiatt az első hozzáadott item elnevéze 'Elem 1</li>
          </ul>
        </li>
        <li>counter++: post increment operator
          <ul>
            <li>Ezt használva először átadásra kerül a deklarált 0, és csak a createNewItem() függvény hívása után nő
              meg a counter értéke</li>
          </ul>
        </li>
      </ul>
    </ul>
    <br>
    <h5 #mapoperator data-anchor="mapoperator">Map</h5>
    <ul>
      <li>A kibocsátott adat valamilyen módú transformálására ad lehetőséget</li>
      <li>from() operátor segítségével számokat létrehozunk egy Observable-t, ami elemenként fogja kibocsátani az
        adatokat</li>
      <pre>
          data8: any[] = [];
          array8: any[] = [2, 4, 6, 8, 10];

          ownObservable8 = from(this.array8);
        </pre>
      <li>Gombnyomásra kiírjuk az értékeket, mint korábban</li>
      <pre>
          fromClicked8() &#123;
            this.ownObservable8.subscribe(&#123;
              next: (value) => &#123;
                this.data8.push(value);
              },
              error: (err) => &#123;},
              complete: () => &#123;},
            })
          }

          &#60;ng-container *ngIf="tempSwitcher === 'map'">
            &#60;div class="rounded-border">
                &#60;div>
                  &#60;span>Data 8+:&#60;/span>
                    &#60;span *ngFor="let d of data8">
                        &#123; &#123;d}}
                    &#60;/span>
                    &#60;span *ngFor="let d of data8_trans">
                        &#123; &#123;d}}
                    &#60;/span>
                &#60;/div>
        
                &#60;button class="btn btn-secondary" (click)="fromClicked8()">FROM + MAP&#60;/button>
                &#60;button class="btn btn-danger" (click)="data8 = []; data8_trans = []">Clear data&#60;/button>
            &#60;/div>
          &#60;/ng-container>
        </pre>
      <li>Szeretnénk mondjuk elérni, hogy az emit-ált adat minden értéke legyen 5-tel megszorozva
        <ul>
          <li>A pipe metódusnak operátorokat tudunk megadni</li>
          <li>A map operátor argomentumaként callback function-t kell megadnunk</li>
          <pre>
            map(() => &#123; })
          </pre>
          <li>Fontos észben tartani, hogy minden RxJS operátor egy method</li>
          <pre>
            transformObservable8 = this.ownObservable8.pipe(
              map((val) => val * 5)
            );

            fromClicked8() &#123;
              ...
              this.transformObservable8.subscribe(&#123;
                next: (value) => &#123;
                  this.data8_trans.push(value);
                },
                error: (err) => &#123; },
                complete: () => &#123; },
              });
            }
          </pre>
          <li>A 'transformObservable8' Observable a map operátor segítségével az logika szerinti értékeket fogja egymás
            után kibocsátani</li>
          <li>A map operátor egy értéket fog kapni
            <ul>
              <li>A forrás Observable értékei érkeznek egyesével, egymás után</li>
            </ul>
          </li>
          <li>Mivel nem nyitottuk ki a map-et, így nincs szükség a return-re</li>
          <pre>
              map((val) => val * 5)

              ===== ugyanazt jelenti =====

              map((val) => &#123;
                return val * 5;
              })
            </pre>
          <li>A transzformált Observable-re ugyancsak feliratkoztunk, és egy másik változóba push-oltuk az érkező
            értékeket</li>
          <li>Természetesen az eredeti Observable-ön is lehetett volna alkalmazni a map-et</li>
          <pre>
            ownObservable8 = from(this.array8).pipe(
              map( (val) => val * 5)
            );
          </pre>
        </ul>
      </li>
      <app-angular-rxjs [tempSwitcher]="'map'" (subscriptionsChanged)="testFunction($event)"></app-angular-rxjs>
    </ul>
    <br>
    <h5 #filteroperator data-anchor="filteroperator">Filter</h5>
    <ul>
      <li>Lehetővé teszi, hogy csak azokat az értékeket engedje át egy Observable adatfolyamában, amelyek megfelelnek
        egy feltételnek</li>
      <li>A filter segítségével kiszelektáltuk, és csak azokat a számokat engedtük át a szűrőn, amik oszthatók néggyel
      </li>
      <li>Boolean értékkel szükséges visszatérnünk</li>
      <pre>
        data9: any[] = [];
        data9_filtered: any[] = []; // az eredménye 4 8 12 lesz
        array9: any[] = [2, 4, 6, 8, 10, 12];

        ownObservable9 = from(this.array9);
        filterObservable9 = this.ownObservable9.pipe(
          filter((val) => val % 4 === 0)
        );

        fromClicked9() &#123;
          this.ownObservable9.subscribe(&#123;
            next: (value) => &#123;
              this.data9.push(value);
            },
            error: (err) => &#123; },
            complete: () => &#123; },
          });
          this.filterObservable9.subscribe(&#123;
            next: (value) => &#123;
              this.data9_filtered.push(value);
            },
            error: (err) => &#123; },
            complete: () => &#123; },
          });
        }
      </pre>
      <app-angular-rxjs [tempSwitcher]="'filter'" (subscriptionsChanged)="testFunction($event)"></app-angular-rxjs>
      <li>Bármilyen operátort is akarunk használni egy Observable-ön, először a pipe metódust kell alkalmaznunk
        <ul>
          <li>Az operátorok láncba fűzése is lehetséges</li>
          <pre>
            data10: any[] = [];
            array10: any[] = [2, 4, 6, 8, 10, 12];
            // map: 10, 20, 30, 40, 50, 60
            // filter: 20, 40, 60

            ownObservable10 = from(this.array10);
            mapFilterObservable10 = this.ownObservable10.pipe(
              map( (val) => val * 5),
              filter((val) => val % 4 === 0)
            );

            fromClicked10() &#123;
              this.mapFilterObservable10.subscribe(&#123;
                next: (value) => &#123;
                  this.data10.push(value);
                },
                error: (err) => &#123; },
                complete: () => &#123; },
              });
            }
          </pre>
          <app-angular-rxjs [tempSwitcher]="'mapfilter'"
            (subscriptionsChanged)="testFunction($event)"></app-angular-rxjs>
          <li>A sorrend rendkívül fontos, mert az adott operátor mindig az előző operátor végeredményével dolgozik</li>
          <li>Természetesen az Observable deklarálása, és az operátorok használata egy lépésben is tökéletesen működik
          </li>
          <pre>
            Obs = from(this.array10).pipe(
              map( (val) => val * 5),
              filter((val) => val % 4 === 0)
            )
          </pre>
        </ul>
      </li>
      <li>A feliratkozásokat egyrészt érdemes elrakni, másrészt pedig OnDestroy lifecycle hookban leiratkozni róluk
        <ul>
          <li>Téves! Az error() és complete() ágakba futáskor automatikusan megtörténik a leiratkozás</li>
        </ul>
      </li>
      <li>RxJS komponens feliratkozások száma: {{rxjsSubscriptionsCounter}}</li>
      <pre>
        subscriptions: Subscription[] = [];

        this.obs1 = this.ownObservable.subscribe(&#123;
          next: (value) => &#123;
            this.data.push(value);
          },
          error: (err) => &#123; },
          complete: () => &#123;
            this.data.push('completed');
          }
        });

        this.subscriptions = [...this.subscriptions, this.obs1];

        ngOnDestroy(): void &#123;
          this.subscriptions.forEach(sub => sub.unsubscribe());
        }
      </pre>
      <br>
    </ul>
    <h5 #subjects data-anchor="subjects">Subjects</h5>
    <ul>
      <li>Service, és EventEmitter segítségével adatot tudunk továbbítani egyik komponensből a másikba
        <ul>
          <li>Annak ellenére, hogy nincsenek kapcsolatban</li>
          <li>Ugyanezt a koncepciót használjuk fel</li>
        </ul>
      </li>
      <br>
      <app-new-task></app-new-task>
      <app-show-task></app-show-task>
      <br>
      <ul>
        <pre>
            &#60;app-new-task>&#60;/app-new-task>
            &#60;app-show-task>&#60;/app-show-task>
          </pre>
        <li>A két komponens nem áll szülő-gyerek kapcsolatban (testvérek / sibling-ek)</li>
        <li>Az input mező two-way data binding-ja miatt, bármit gépelünk bele, az értéke hozzárendelődik a
          kontrollerben található 'newTask' változóhoz/property-hez</li>
        <li>A gomb elemen egy click eventet készítettünk</li>
        <li>A bevitt értéket a 'app-show-task' komponensnek szeretnénk átadni</li>
        <li>A service-t érdemes ellátni dekorátorral</li>
        <pre>
            @Injectable(&#123;
              providedIn: 'root'
            })
          </pre>
        <li>Készítettünk egy EventEmittert a service-ünkbe
          <ul>
            <li>Amikor a felhasználó megnyomja a 'Create task' gombot, akkor meg kell hívnunk a service 'onCreateTask'
              metódusát, ami emit-álni fog adatot
              <ul>
                <li>Ehhez az 'app-new-task' komponensünkbe dependency injection segítségével behívjuk a service-t
                  <ul>
                    <li>Vagy az Angular 14-ben bevezetett 'inject' lehetőséget használjuk
                      <ul>
                        <li>Alternatív megközelítése a DI-nek</li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <pre>
                    constructor(private taskService: TaskService) &#123;

                    }

                    ===== mindkét megoldás jó =====

                    taskService: TaskService = inject(TaskService);
                  </pre>
              </ul>
            </li>
            <li>Erre az event-re feliratkozunk az 'app-show-task' komponensben
              <ul>
                <li>A subscribe callback függvénye minden esetben meghívódik, amikor az Observable kap egy új értéket
                </li>
                <li>Az EventEmitter kibocsátott értékét fogja megkapni a </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Tehát ezen a módon (Service, és EventEmitter) megvalósítható 2 komponens közti kommunikáció</li>
        <pre>
            <b>// app-new-task.html</b>

            &#60;div class="rounded-border">
              &#60;input type="text" [(ngModel)]="newTask"> <!-- Two-way data binding -->
              &#60;button type="button" class="btn btn-secondary" (click)="onCreateNewTask()">Create task&#60;/button>
            &#60;/div>

            <b>// app-new-task.ts</b>

            export class NewTaskComponent &#123;
              newTask: string = '';
              taskService: TaskService = inject(TaskService);
            
              onCreateNewTask() &#123;
                this.taskService.onCreateTask(this.newTask);
                this.newTask = '';
              }
            }
          
            <b>// app-show-task.html</b>

            &#60;div class="rounded-border">
              &#60;div *ngFor="let task of tasks">
                &#123; &#123;task}}
              &#60;/div>
            &#60;/div>

            <b>// app-show-task.ts</b>

            export class ShowTaskComponent implements OnInit &#123;
              tasks: string[] = ['Task1', 'Task2', 'Task3'];
              taskService: TaskService = inject(TaskService);
            
              ngOnInit(): void &#123;
                this.taskService.createTask.subscribe((taskName) => &#123; // callback function, a taskName a névtelen függvény argomentuma
                  console.log('taskName: ', taskName);
                  this.tasks.push(taskName);
                })
              }
            }

            <b>// task.service.ts</b>

            @Injectable(&#123;
              providedIn: 'root'
            })
            
            export class TaskService &#123;
                createTask: EventEmitter&#60;string> = new EventEmitter&#60;string>();
            
                onCreateTask(taskName: string) &#123;
                    this.createTask.emit(taskName);
                }
            }
          </pre>
        <li>Ugyanezt az eredményt érhetjük el, ha Subject-et használunk
          <ul>
            <li>Speciális Observable, ami multicast-olást tesz lehetővé az Observer-ek felé</li>
            <li>Hasonlóan működik, mint az EventEmitter</li>
            <li>A Subject-nek nincs emit() metódusa</li>
            <li>Mivel egy speciális típusú Observable, ezért next() methodot szükséges használunk</li>
            <pre>
                export class TaskService &#123;
                  // createTask: EventEmitter&#60;string> = new EventEmitter&#60;string>();
                  createTask: Subject&#60;string> = new Subject&#60;string>(); // () --> a Subject class konstruktorát hívjuk meg
              
                  onCreateTask(taskName: string) &#123;
                      // this.createTask.emit(taskName);
                      this.createTask.next(taskName);
                  }
                }
              </pre>
          </ul>
        </li>
        <li>Lényegében ennyi létrehozni egy Subject-et (ami nem más, mint egy speciális Observable)
          <ul>
            <li>Property, ami egy Subject, megadni neki a típusát</li>
            <li>Érték emit-áláshoz pedig a Subject-en a next() methodot kell használni</li>
          </ul>
        </li>
        <li>Mi most csak egy Observer-t szolgáltunk ki adattal
          <ul>
            <li>Ahány komponensnek szeretnénk továbbítani ezt az adatot, annyiban szükséges Observer-t létrehozni</li>
          </ul>
        </li>
        <li>Fontos megjegyezni, hogy Observable létrehozására nagyon ritkán van szükség
          <ul>
            <li>Nem arról van szó, hogy nem dolgozunk Observable-ökkel, de inkább bizonyos logika megírása után
              Observable-t kapunk, semmint, hogy létrehozzuk
              <ul>
                <li>Pl.: HTTP request / response (Observable-lel térnek vissza)</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <br>
    </ul>
    <h5 #observablesvssubjects data-anchor="observablesvssubjects">Observables vs Subjects</h5>
    <ul>
      <li>Mind az Observable, mind a Subject lehetővé teszi az adatok aszinkron kezelését</li>
      <pre>
        <b>// Observable példakód</b>
        const observable = new Observable(subscriber => &#123;
          subscriber.next('Data 1');
          subscriber.next('Data 2');
          subscriber.complete();
        });
        
        observable.subscribe(data => console.log(data));
  
        <b>// Subject példakód</b>
        const subject = new Subject();
  
        subject.subscribe(data => console.log('Observer 1: ', data));
        subject.subscribe(data => console.log('Observer 2: ', data));
  
        subject.next('Data 1'); // Mindkét observer megkapja
        subject.next('Data 2'); // Mindkét observer megkapja
      </pre>
      <li>Observable
        <ul>
          <li>Unicast jellegű
            <ul>
              <li>Minden feliratkozónak külön adatfolyamot hoz létre</li>
              <li>Az Observer-ek egyedi példányt kapnak a teljes adatfolyamból</li>
              <li>Minden feliratkozóhoz külön indítja el a belső folyamatát (például egy HTTP kérést)
                <ul>
                  <li>Minden egyes feliratkozó esetében új HTTP-kérés indul</li>
                </ul>
              </li>
            </ul>
          </li>
          <pre>
            <b>// Observable</b>
            let obs = new Observable((observer: Observer&#60;string>) => &#123; // Explicit típusú a paraméter
              observer.next('Hello');    // Küldi a "Hello" adatot
              observer.next('World');    // Küldi a "World" adatot
              observer.complete();       // Lezárja az Observable-t
            });

            <b>// Observer</b>
            obs.subscribe(&#123;
              next: (val) => console.log(val),              // Megkapjuk az adatot
              error: (err) => console.error('Error:', err), // Kezelhetjük a hibát
              complete: () => console.log('Completed')      // Az Observable lezárult
            });
          </pre>
          <li>Nem tud közvetlenül adatokat küldeni, feliratkozáskor a forrás csak akkor küld adatokat, ha az adatok
            rendelkezésre állnak
            <ul>
              <li>Eleve csak akkor küldi el a rendelkezésre álló adatot, ha feliratkozik rá valaki</li>
            </ul>
          </li>
          <li>Nem tartalmaz kezdeti értéket</li>
          <li>Jellemzően a HTTP kérések, események, vagy olyan aszinkron folyamatok esetén használjuk, ahol az
            adatfolyamnak nincs szüksége interakcióra</li>
          <pre>
            const httpObservable = this.http.get('/api/data'); // Observable-t ad vissza

            httpObservable.subscribe(data => console.log('Feliratkozó 1:', data)); // Új HTTP kérés
            httpObservable.subscribe(data => console.log('Feliratkozó 2:', data)); // Új HTTP kérés
          </pre>
          <li>Observable létrehozásakor egy (névtelen) callback function-t kell átadni az Observable
            konstruktorának, és ez a függvény egy observer objektumot kap paraméterként
            <ul>
              <li>Az observer objektummal vezérelhető az Observable által küldött adat, hiba, és a lezárás</li>
              <li>Az observer típusa Observer, amelynek 3 fő metódusa van</li>
              <pre>
                next(value: T): void: Adat küldése a feliratkozottaknak
                error(err: any): void: Hiba átadása, ami az Observable végét is jelenti
                complete(): void: Jelzi, hogy az adatfolyam befejeződött, nincs több adat
              </pre>
            </ul>
          </li>
          <li>Minden esetben csak adatot tud kibocsátani, fogadni nem</li>
          <br>
          <li>Az alábbi példa szemlélteti, hogy 2 feliratkozó esetén 2 külön adatfolyam jön létre
            <ul>
              <li>Teljesen más értékeket kapnak</li>
            </ul>
          </li>
          <br>
          <app-subject [tempSwitcher]="'observable'"></app-subject>
          <pre>
            <b>// subject.html</b>
            &#60;div>Observer 1 value: &#123; &#123;observer1}}&#60;/div>
            &#60;div>Observer 2 value: &#123; &#123;observer2}}&#60;/div>
            &#60;button class="btn btn-secondary" (click)="onSubscribeObservable()">Subscribe obervers&#60;/button>

            <b>// subject.ts</b>
            obs = new Observable((observer: Observer&#60;number>) => &#123;
              observer.next(Math.floor(Math.random() * (100 - 0 + 1) + 0));
            });
            observer1: number = 0;
            observer2: number = 0;

            onSubscribeObservable() &#123;
              this.obs.subscribe(&#123; // Subscriber 1
                next: (val) => &#123;
                  this.observer1 = val;
                },
                error: (err) => &#123; },
                complete: () => &#123; },
              });
          
              this.obs.subscribe(&#123; // Subscriber 2
                next: (val) => &#123;
                  this.observer2 = val;
                },
                error: (err) => &#123; },
                complete: () => &#123; },
              });
            }
          </pre>
          <li>Fontos megjegyezni, hogy az adatfolyamokról manuálisan nem szükséges leiratkozni
            <ul>
              <li>Mind error(), mind pedig complete() események esetében automatikusan megtörténik a leiratkozás</li>
            </ul>
          </li>
          <pre>
            <b>// Példa API hívásra 1</b>
  
            &#60;div *ngIf="fetchCompleted; else loading">
              &#60;ng-container *ngIf="posts.length; else error">
                  &#60;div *ngFor="let p of posts; let last = last" [ngStyle]="&#123;
                  'padding-bottom': !last ? '10px' : '0',
                  'margin-bottom': !last ? '10px' : '0',
                  'border-bottom': !last ? '1px solid #9d2626' : 'none'}">
                      &#60;small>&#60;b>ID: &#60;/b>&#123; &#123;p.id}}&#60;/small>
                      &#60;small>&#60;b>UserID: &#60;/b>&#123; &#123;p.userId}}&#60;/small>
                      &#60;small>&#60;b>Title: &#60;/b>&#123; &#123;p.title}}&#60;/small>
                      &#60;small>&#60;b>Body: &#60;/b>&#123; &#123;p.body}}&#60;/small>
                  &#60;/div>
              &#60;/ng-container>
              &#60;br>
              &#60;div>&#123; &#123;fetchCompleted ? 'Fetch was successful' : 'Error'}}&#60;/div>
            &#60;/div>
        
            &#60;ng-template #loading>
                Loading posts...
            &#60;/ng-template>
        
            &#60;ng-template #error>
                Error
            &#60;/ng-template>
  
            // -----
  
            private apiUrl = 'https://jsonplaceholder.typicode.com/posts?_limit=5';
  
            posts: Post[] = [];
            
            fetchCompleted: boolean = false;
  
            constructor(private http: HttpClient) &#123;
              this.fetchPosts().subscribe(&#123;
                next: (val) => &#123;
                  this.posts = val;
                },
                error: (err) => &#123;
                  this.posts = [err.message]
                },
                complete: () => &#123;
                  this.fetchCompleted = true;
                }
              });
            }
  
            // API hívás, amely Observable-t ad vissza
            fetchPosts(): Observable&#60;Post[]> &#123; // Érdemes rest-api.service.ts-be elhelyezni 
              return this.http.get&#60;Post[]>(this.apiUrl); // Az Observable közvetlenül visszatér
            }
          </pre>
          <li>Ismételt, vagy frissülő adatok esetén előnyösebb</li>
          <br>
          <app-angular-api [tempSwitcher]="'api'"></app-angular-api>

          <pre>
              <b>// Példa API hívásra 2</b>
  
              &#60;ng-container *ngIf="tempSwitcher === 'api2'">
                &#60;div *ngIf="posts$ | async as posts2; else loading">
                    &#60;ng-container *ngIf="posts2.length; else error">
                        &#60;div *ngFor="let p of posts2; let last = last" [ngStyle]="&#123;
                        'padding-bottom': !last ? '10px' : '0',
                        'margin-bottom': !last ? '10px' : '0',
                        'border-bottom': !last ? '1px solid #9d2626' : 'none'}">
                            &#60;small>&#60;b>ID: &#60;/b>&#123; &#123;p.id}}&#60;/small>
                            &#60;small>&#60;b>UserID: &#60;/b>&#123; &#123;p.userId}}&#60;/small>
                            &#60;small>&#60;b>Title: &#60;/b>&#123; &#123;p.title}}&#60;/small>
                            &#60;small>&#60;b>Body: &#60;/b>&#123; &#123;p.body}}&#60;/small>
                        &#60;/div>
                    &#60;/ng-container>
                    &#60;br>
                    &#60;div>&#123; &#123;fetchCompleted ? 'Fetch was successful' : 'Error'}}&#60;/div>
                &#60;/div>
            
                &#60;ng-template #loading>
                    Loading posts...
                &#60;/ng-template>
            
                &#60;ng-template #error>
                    Error
                &#60;/ng-template>
            &#60;/ng-container>
  
            // -----
  
            private apiUrl = 'https://jsonplaceholder.typicode.com/posts?_limit=5';
  
            posts$: Observable&#60;Post[]> = new Observable();
  
            fetchCompleted: boolean = false;
  
            constructor(private http: HttpClient) &#123;
              this.posts$ = this.fetchPosts().pipe(
                tap(() => &#123;
                  this.fetchCompleted2 = true;
                }),
                catchError((err) => &#123;
                  return throwError(() => new Error('Fetch failed'));
                })
              );
            }
  
            // API hívás, amely Observable-t ad vissza
            fetchPosts(): Observable&#60;Post[]> &#123; // Érdemes rest-api.service.ts-be elhelyezni 
              return this.http.get&#60;Post[]>(this.apiUrl); // Az Observable közvetlenül visszatér
            }
          </pre>
          <li>Az | async pipe automatikusan feliratkozik az Observable-re, és elvégzi a feliratkozás megszüntetését is
          </li>
          <li>Praktikusabb, ha csak egyszer kell lekérdezni az adatokat</li>
          <br>
          <app-angular-api [tempSwitcher]="'api2'"></app-angular-api>
          <br>
          <li>Az Observable használatára csak ritkán, speciális esetekben van szükség
            <ul>
              <li>A HTTPClient például Observable-lel tér vissza, így máris nincs arra szükség, hogy new Observable-t
                létrehozzunk</li>
            </ul>
          </li>
        </ul>
      </li>
      <br>
      <li>Subject
        <ul>
          <li>Lényegében nem más, mint egy Observable</li>
          <li>Lehetővé teszi, hogy új értékeket küldjünk a feliratkozott Observer-eknek
            <ul>
              <li>Mi magunk is bocsáthatunk ki adatokat az next() metódussal</li>
            </ul>
          </li>
          <li>Multicast jellegű
            <ul>
              <li>Ugyanazt az adatfolyamot megosztja minden feliratkozó között</li>
              <li>Egyetlen adatforrás több feliratkozóhoz juttatja el ugyanazt az adatot</li>
              <pre>
                const subject = new Subject&#60;string>();

                subject.subscribe(data => console.log('Feliratkozó 1:', data)); 
                subject.subscribe(data => console.log('Feliratkozó 2:', data)); 
                
                subject.next('Hello'); // Mindkét feliratkozó ugyanazt az adatot kapja: "Hello"
              </pre>
            </ul>
          </li>
          <li>Egyik fő célja a komponensek közti (könnyű) kommunikáció
            <ul>
              <li>Jellemzően akkor használjuk, amikor különböző komponensek közötti kommunikációra van szükség, vagy ha
                az adatok dinamikusan változnak, és azt az összes Observernek azonnal jelezni kell</li>
            </ul>
          </li>
          <li>A feliratkozottak csak onnantól kapnak üzenetet, hogy feliratkoztak, korábbi eseményekről nincs
            tudomásuk
            <ul>
              <li>Erre kivétel a BehaviorSubject, vagy a ReplaySubject</li>
            </ul>
          </li>
          <li>Subject esetében a leiratkozás nem történik meg automatikusan
            <ul>
              <li>Amikor feliratkozunk egy Subject-re, akkor létrejön egy Subscription</li>
              <li>A Subscription-ről az unsubscribe() metódussal tudunk leiratkozni</li>
              <li>A leiratkozás célja, hogy megszüntessük a kapcsolatot a Subject-tel, így elkerülve a nem kívánt
                adatfolyamokat és a memóriaszivárgást</li>
            </ul>
          </li>
          <li>Az Observable-lel ellentétben egy új Subject nem fogad paraméter</li>
          <li>Nem csak adatot kibocsátani, de fogadni is tud</li>
          <br>
          <li>Az alábbi példa szemlélteti, hogy minden feliratkozó ugyanazon az adatfolyamon osztozik</li>
          <br>
          <app-subject [tempSwitcher]="'subject'"></app-subject>
          <pre>
            &#60;b>// subject.html&#60;/b>
            &#60;div>Subject subscriber 1 value: &#123; &#123;sub1}}&#60;/div>
            &#60;div>Subject subscriber 2 value: &#123; &#123;sub2}}&#60;/div>
            &#60;button class="btn btn-secondary" (click)="onSubscribeSubject()">Subject subscription&#60;/button>

            <b>// subject.ts</b>
            subject: Subject&#60;number> = new Subject&#60;number>();
              sub1: number = 0;
              sub2: number = 0;
              subscriptions: Subscription[] = [];

              onSubscribeSubject() &#123; // Subscriber 1
                let subscriber1 = this.subject.subscribe(&#123;
                  next: (val) => &#123;
                    this.sub1 = val;
                  },
                  error: (err) => &#123; },
                  complete: () => &#123; },
                });
            
                let subscriber2 = this.subject.subscribe(&#123; // Subscriber 2
                  next: (val) => &#123;
                    this.sub2 = val;
                  },
                  error: (err) => &#123; },
                  complete: () => &#123; },
                });

                this.subscriptions = [...this.subscriptions, subscriber1];
                this.subscriptions = [...this.subscriptions, subscriber2];
            
                this.subject.next(Math.floor(Math.random() * (100 - 0 + 1) + 0));

                ngOnDestroy(): void &#123;
                  this.subscriptions.forEach(sub => &#123;
                    sub.unsubscribe();
                  });
                }
              }
          </pre>
        </ul>
      </li>
      <br>
      <li>A Subject adatforrásként, és "adatfogyasztóként" is működik
        <ol>
          <li>Data provider: Továbbküldi az adatokat a rá feliratkozott összes Observer-nek</li>
          <li>Data consumer: Képes adatokat fogadni más Observable-okból, vagy forrásokból</li>
        </ol>
        <br>
        <ul>
          <li>A következőkben AJAX hívást végzünk RxJS segítségével</li>
          <li>Observable-t kapunk vissza, amit a 'userData' változóban tárolunk</li>
          <li>Ahányszor csak az Observable adatot emit-ál, logikát szeretnénk futtatni
            <ul>
              <li>Ehhez next() callback függvényt kell átadnunk, ami meg fogja kapni az Observable által küldött adatot
              </li>
            </ul>
          </li>
          <li>Amennyiben 3 Observer iratkozik fel az Observable-re, úgy 3 API hívás történik
            <ul>
              <li>Az Observable unicast, minden feliratkozónak külön adatfolyama van</li>
              <li>A randomuser.me sajátosságából adódik, hogy minden requestnél más random generált felhasználót ad
                vissza</li>
              <li>(Nem is feltétlen sorrendben érkezik meg a válasz)</li>
            </ul>
          </li>
          <br>
          <app-subject [tempSwitcher]="'observable2'"></app-subject>
          <pre>
            <b>// subject.html</b>
            &#60;button class="btn btn-secondary" (click)="onAjaxCallWith3Subscribers()">AJAX call with 3 Subscribers&#60;/button>
            &#60;div *ngFor="let status of ajaxStatuses">
              &#123; &#123;status}}
            &#60;/div>

            <b>// subject.ts</b>
            ajaxStatuses: string[] = [];

            onAjaxCallWith3Subscribers() &#123;
              this.ajaxStatuses = [];
              const userData = ajax('https://randomuser.me/api/') // GET metódus, mert nem speifikáltuk a metódust
          
              userData.subscribe(&#123;
                next: (res) => &#123;
                  this.ajaxStatuses.push('AJAX call 1 status code: ' + res.status + ' (UserName: ' + (res.response as any).results[0].name.first + ' ' + (res.response as any).results[0].name.last + ')');
                }
              });
              userData.subscribe(&#123;
                next: (res) => &#123;
                  this.ajaxStatuses.push('AJAX call 2 status code: ' + res.status + ' (UserName: ' + (res.response as any).results[0].name.first + ' ' + (res.response as any).results[0].name.last + ')');
                }
              });
              userData.subscribe(&#123;
                next: (res) => &#123;
                  this.ajaxStatuses.push('AJAX call 3 status code: ' + res.status + ' (UserName: ' + (res.response as any).results[0].name.first + ' ' + (res.response as any).results[0].name.last + ')');
                }
              });
            }
          </pre>
          <br>
          <ul>
            <li>Ugyanez megoldható Subject-tel</li>
            <li>Ne felejtsük el, hogy a Subject ugyanazt az adatot szolgáltatja minden feliratkozónak</li>
            <li>A Subject-et ebben az esetben, mint consumer használjuk
              <ul>
                <li>A Subject nem adatot szolgáltat, hanem fogad</li>
                <li>Az AJAX kérés válaszát fogadja</li>
                <li>Amit az AJAX kérés visszaad Observable-t, Subjectté transformálódik</li>
              </ul>
            </li>
            <li>Az API hívás csak egyszer történik meg, és minden feliratkozó ugyanazt az adatot kapja meg</li>
          </ul>
          <br>
          <app-subject [tempSwitcher]="'subject2'"></app-subject>
          <pre>
            <b>// subject.html</b>
            &#60;button class="btn btn-secondary" (click)="onAjaxCallWith3Subscribers2()">AJAX call with 3 Subscribers&#60;/button>
            &#60;div *ngFor="let status of ajaxStatuses">
                &#123; &#123;status}}
            &#60;/div>

            <b>// subject.ts</b>
            onAjaxCallWith3Subscribers2() &#123;
              this.ajaxStatuses = [];
              const apiSubject: Subject&#60;AjaxResponse&#60;any>> = new Subject&#60;AjaxResponse&#60;any>>();
              const userData = ajax('https://randomuser.me/api/') // GET metódus, mert nem speifikáltuk a metódust
          
              apiSubject.subscribe(&#123;
                next: (res) => &#123;
                  this.ajaxStatuses.push('AJAX call 1 status code: ' + res.status + ' (UserName: ' + (res.response as any).results[0].name.first + ' ' + (res.response as any).results[0].name.last + ')');
                }
              });
              apiSubject.subscribe(&#123;
                next: (res) => &#123;
                  this.ajaxStatuses.push('AJAX call 1 status code: ' + res.status + ' (UserName: ' + (res.response as any).results[0].name.first + ' ' + (res.response as any).results[0].name.last + ')');
                }
              });
              apiSubject.subscribe(&#123;
                next: (res) => &#123;
                  this.ajaxStatuses.push('AJAX call 1 status code: ' + res.status + ' (UserName: ' + (res.response as any).results[0].name.first + ' ' + (res.response as any).results[0].name.last + ')');
                }
              });
          
              userData.subscribe(apiSubject);
            }
          </pre>
        </ul>
      </li>
    </ul>
    <br>
    <h5 #behaviorsubject data-anchor="behaviorsubject">Behaviour Subject</h5>
    <ul>
      <li>Speciális típusú Subject</li>
      <li>Tárol egy kezdeti / aktuális értéket</li>
      <li>A feliratkozók azonnal megkapják a legutóbbi kibocsátott értéket, akkor is, ha a feliratkozás előtt történt az
        érték kibocsátása</li>
      <li>Egyszerre lehet adatforrás (data provider) és feliratkozás-kezelő (data consumer)</li>
      <li>Különösen hasznos komponensek közötti állapotmegosztásra</li>
      <li>A Subject nem kaphat initial value-t, de a BehaviorSubject igen</li>
      <li>A kezdeti érték azonnal kiküldésre kerül, ahogy feliratkozik rá valaki</li>
      <li>Az alábbi példában nem bocsátunk ki értéket a next() metódussal a (Behavior)Subject-ből, csupán kezdeti
        értéket adunk neki</li>
      <br>
      <app-subject [tempSwitcher]="'behaviorSubject'"></app-subject>
      <pre>
        <b>// subject.html</b>
        &#60;button class="btn btn-secondary" (click)="onTestBehaviorSubject()">Test BehaviorSubject&#60;/button>
        &#60;div>
            &#60;pre>&#123; &#123;behaviorStatuses | json}}&#60;/pre>
        &#60;/div>
        &#60;button *ngIf="(behaviorStatuses | json) !== '&#123;}'" class="btn btn-secondary" (click)="newValueForBehaviorSubject()">
            New value for BehaviorSubject
        &#60;/button>

        <b>// subject.ts</b>
        statuses: any = &#123;};
        behaviorSubject: BehaviorSubject&#60;string> = new BehaviorSubject&#60;string>('Initial data');

        onTestBehaviorSubject() &#123;
          this.behaviorSubject.subscribe(&#123;
            next: (val) => &#123;
              if (this.behaviorStatuses['subscriber_1'] === undefined) &#123;
                this.behaviorStatuses['subscriber_1'] = [];
              };
              if (!this.behaviorStatuses['subscriber_1'].includes(val)) &#123;
                this.behaviorStatuses['subscriber_1'].push(val);
              };
            }
          });
          this.behaviorSubject.subscribe(&#123;
            next: (val) => &#123;
              if (this.behaviorStatuses['subscriber_2'] === undefined) &#123;
                this.behaviorStatuses['subscriber_2'] = [];
              };
              if (!this.behaviorStatuses['subscriber_2'].includes(val)) &#123;
                this.behaviorStatuses['subscriber_2'].push(val);
              };
            }
          })
      
          /// subject.next(...); // nem történik adatküldés
        }
      
        newValueForBehaviorSubject() &#123;
          this.behaviorSubject.next('Next value');
      
          this.behaviorSubject.subscribe(&#123;
            next: (val) => &#123;
              if (this.behaviorStatuses['subscriber_3'] === undefined) &#123;
                this.behaviorStatuses['subscriber_3'] = [];
              };
              if (!this.behaviorStatuses['subscriber_3'].includes(val)) &#123;
                this.behaviorStatuses['subscriber_3'].push(val);
              };
            }
          })
        }
      </pre>
      <li>Mindkét feliratkozó a feliratkozás pillanatában ('Test BehaviorSubject' gomb megnyomásakor) megkapja a kezdeti
        értékét a BehaviorSubject-nek ('Initial data')
      <li>Az ezt követően megjelenő gomb ('New value for BehaviorSubject') megnyomásakor pedig egyrészt új értéket
        bocsátunk ki ('Next value'), majd ezután feliratkozunk egy újabb Observerrel a BehaviorSubject-re</li>
      <li>A debug adatokból láthatjuk, hogy az először feliratkozók a kezdeti értéket is megkapják, de miután már újabb
        adatot szolgáltattunk a "csatornán", az ezt követően feliratkozó már csak a legfrisebb értéket kapja meg</li>
      <br>
    </ul>
    <br>
    <h5 #replaysubject data-anchor="replaysubject">Replay Subject</h5>
    <ul>
      <li>Subject, ami megismétli a korábbi értékeket sorban az új feliratkozók számára</li>
      <li>Bufferben tárolja az összes kiküldött értékét
        <ul>
          <li>A bufferSize és windowTime argomentumokkal állítható a buffer mérete
            <ul>
              <li>bufferSize: Értékek darabszáma (alapértelmezett: végtelen)
                <ul>
                  <li>Egy új feliratkozó maximum ennyi darabszámú értéket kaphat</li>
                  <pre>
                    replaySubject: ReplaySubject&#60;any> = new ReplaySubject&#60;any>(2);
                  </pre>
                  <li>Így az utolsó 2 érték lesz a bufferben</li>
                </ul>
              </li>
              <li>windowSize: Értékek megőrzésének ideje (alapértelmezett: végtelen)</li>
            </ul>
          </li>
        </ul>
      </li>
      <br>
      <app-subject [tempSwitcher]="'replaySubject'"></app-subject>
      <pre>
        <b>// subject.html</b>
        &#60;button class="btn btn-secondary" (click)="onTestReplaySubject()" [disabled]="(replayStatuses | json) !== '&#123;}'">
          Test RelaySubject
        &#60;/button>
        &#60;div>
            &#60;pre>&#123; &#123;replayStatuses | json}}&#60;/pre>
        &#60;/div>
        &#60;input #replayInput type="number" placeholder="new value">
        &#60;button class="btn btn-secondary" (click)="addNewReplaySubjectValue(replayInput.value); replayInput.value = ''">Add&#60;/button>

        <b>// subject.ts</b>
        replaySubject: ReplaySubject&#60;any> = new ReplaySubject&#60;any>();
        replayStatuses: any = &#123;};

        onTestReplaySubject() &#123;
          this.replaySubject.next(100);
          this.replaySubject.next(200);
          this.replaySubject.next(300);
      
          this.replaySubject.subscribe(&#123; // Subscriber 1
            next: (val) => &#123;
              if (this.replayStatuses['subscriber_1'] === undefined) &#123;
                this.replayStatuses['subscriber_1'] = [];
              };
              this.replayStatuses['subscriber_1'].push(val);
            }
          });
      
          this.replaySubject.subscribe(&#123; // Subscriber 2
            next: (val) => &#123;
              if (this.replayStatuses['subscriber_2'] === undefined) &#123;
                this.replayStatuses['subscriber_2'] = [];
              };
              this.replayStatuses['subscriber_2'].push(val);
            }
          });
      
          this.replaySubject.next(400);
      
          this.replaySubject.subscribe(&#123; // Subscriber 3
            next: (val) => &#123;
              if (this.replayStatuses['subscriber_3'] === undefined) &#123;
                this.replayStatuses['subscriber_3'] = [];
              };
              this.replayStatuses['subscriber_3'].push(val);
            }
          });
        }
      
        addNewReplaySubjectValue(val: string) &#123;
          this.replaySubject.next(parseInt(val));
        }
      </pre>
      <li>A 'Test ReplaySubject' gombra kattintva láthatjuk, hogy mindhárom feliratkozó megkapta az összes kibocsátott
        értéket, pedig a harmadik már az első két érték kibocsátása után iratkozott fel'</li>
      <br>
      <app-subject [tempSwitcher]="'replaySubject2'"></app-subject>
      <pre>
        <b>// subject.html</b>
        &#60;button class="btn btn-secondary" (click)="onTestReplaySubject2()" [disabled]="(replayStatuses2 | json) !== '&#123;}'">
          Test RelaySubject (bufferSize: 2)
        &#60;/button>
        &#60;div>
            &#60;pre>&#123; &#123;replayStatuses2 | json}}&#60;/pre>
        &#60;/div>

        <b>// subject.ts</b>
        replaySubject2: ReplaySubject&#60;any> = new ReplaySubject&#60;any>(2);
        replayStatuses2: any = &#123;};

        onTestReplaySubject2() &#123;
          this.replaySubject2.next(100);
          this.replaySubject2.next(200);
          this.replaySubject2.next(300);
      
          this.replaySubject2.subscribe(&#123; // Subscriber 1
            next: (val) => &#123;
              if (this.replayStatuses2['subscriber_1'] === undefined) &#123;
                this.replayStatuses2['subscriber_1'] = [];
              };
              this.replayStatuses2['subscriber_1'].push(val);
            }
          });
      
          this.replaySubject2.subscribe(&#123; // Subscriber 2
            next: (val) => &#123;
              if (this.replayStatuses2['subscriber_2'] === undefined) &#123;
                this.replayStatuses2['subscriber_2'] = [];
              };
              this.replayStatuses2['subscriber_2'].push(val);
            }
          });
      
          this.replaySubject2.next(400);
      
          this.replaySubject2.subscribe(&#123; // Subscriber 3
            next: (val) => &#123;
              if (this.replayStatuses2['subscriber_3'] === undefined) &#123;
                this.replayStatuses2['subscriber_3'] = [];
              };
              this.replayStatuses2['subscriber_3'].push(val);
            }
          });
        }
      </pre>
      <li>Az első, 100-as értéket egyik feliratkozó sem fogja megkapni, mert 3 értéket bocsátottunk ki, de a buffer 2
        értéket tárol, így a Subscriber 1 és 2 már csak a 200-at, és a 300-at kapja meg</li>
      <li>A harmadik feliratkozó előtt történik egy újabb értékkibocsátás, a 400, így a harmadik feliratkozó pedig a
        300-a, és a 400-at fogja megkapni</li>
      <li>Ha manuálisan akarjuk megadni első paraméternek a "végtelen", a legnagyobb biztonságo értéke a
        'Number.MAX_SAFE_INTEGER'
        <ul>
          <li>A gyakorlatban végtelenhez közeli buffer méretet biztosít</li>
          <li>Így közel végtelen eltárolt elemszám mellett időablakot is be tudunk állítani</li>
          <li>Ugyanakkor a angular/core-ban szerepel egy változó: Infinity</li>
        </ul>
      </li>
      <br>
      <app-subject [tempSwitcher]="'replaySubject3'"></app-subject>
      <pre>
        <b>// subject.html</b>
        &#60;button class="btn btn-secondary" (click)="onSubscribeReplaySubject()">Subscribe to MessageService&#60;/button>
        &#60;br>
        &#60;div>Subscription status: &#123; &#123;replaySubjectSubscriptionIsDone ? 'active' : 'inactive'}}&#60;/div>
        &#60;br>
        &#60;input [(ngModel)]="newReplaySubjectMessage" placeholder="Type something..." />
        &#60;button (click)="sendReplaySubjectMessage()">Send&#60;/button>
        &#60;br>
        &#60;div>Messages from the last 5 secs:&#60;/div>
        &#60;br>
        &#60;ul>
            &#60;li *ngFor="let message of replaySubjectMessages">&#123; &#123; message }}&#60;/li>
        &#60;/ul>

        <b>// subject.ts</b>
        replaySubjectMessages: string[] = [];
        newReplaySubjectMessage = '';
        replaySubjectSubscriptionIsDone: boolean = false;
        replaySubjectSubscription: Subscription | null = null;
        messageService: MessageService = inject(MessageService);

        onSubscribeReplaySubject() &#123;
          this.replaySubjectSubscriptionIsDone = true;
          let replayTimer = timer(0, 5000).subscribe(() => &#123;
            this.replaySubjectMessages = [];
            this.replaySubjectSubscription?.unsubscribe();
      
            this.replaySubjectSubscription = this.messageService.messages$.subscribe((message) => &#123;
              this.replaySubjectMessages.push(message);
            });
      
            this.subscriptions = [...this.subscriptions, this.replaySubjectSubscription, replayTimer];
          });
        }
      
        sendReplaySubjectMessage() &#123;
          if (this.newReplaySubjectMessage) &#123;
            this.messageService.addMessage(this.newReplaySubjectMessage);
            this.newReplaySubjectMessage = '';
          }
        }

        <b>// message.service.ts</b>
        export class MessageService &#123;
          private messageSubject = new ReplaySubject&#60;string>(Infinity, 5000);
      
          get messages$() &#123;
              return this.messageSubject.asObservable();
          }
      
          addMessage(message: string) &#123;
              this.messageSubject.next(message);
          }
        }
      </pre>
      <li>Amennyiben eliratkoztunk a MessageService-re, üzenet küldésekor a ReplaySubject-ben ~5 másodpercig elérhető
        lesz az input mezőbe beírt, és elküldött üzenet</li>
      <li>6 másodpercenként a timer segítségével újra feliratkozás történik a ReplaySubject-re, így mindig csak az ~5
        másodpercen belül hozzáadott üzenetek jelennek meg</li>
    </ul>
    <br>
    <h5 #asyncsubject data-anchor="asyncsubject">Async Subject</h5>
    <ul>
      <li>Csak az utolsó kibocsátott értéket adja tovább a feliratkozóknak, miután a Subject complete állapotba került
        <ul>
          <li>Az utolsó emitált értékét csak akkor adja tovább a feliratkozóknak, ha meghívjuk a complete() metódusát
          </li>
        </ul>
      </li>
      <li></li>
      <app-subject [tempSwitcher]="'asyncSubject'"></app-subject>
      <pre>
        <b>// subject.html</b>
          &#60;input #asyncInput1 type="text" value="333">
          &#60;input #asyncInput2 type="text" value="444">
          &#60;input #asyncInput3 type="text" value="555">
          &#60;button class="btn btn-secondary"
              (click)="onTestAsyncSubject(asyncInput1.value, asyncInput2.value, asyncInput3.value)">
              Test AsyncSubject
          &#60;/button>
          &#60;div>Latest: &#123; &#123; asyncSubValue }}&#60;/div>
          &#60;button class="btn btn-secondary" (click)="onSubscribeOnAsyncSubjectLater()">
              Another Subscription
          &#60;/button>
          &#60;div>Value sent to the second subscriber: &#123; &#123; asyncSubValue2 }}&#60;/div>

        <b>// subject.ts</b>
        asyncSubject: AsyncSubject&#60;any> = new AsyncSubject&#60;any>();
          asyncSubValue: any = '';
          asyncSubValue2: any = '';

        onTestAsyncSubject(val1: any, val2: any, val3: any) &#123;
          /* let asyncSub = this.asyncSubject.subscribe(&#123; // Mindegy, mikor/hol iratkozunk fel
            next: (val) => &#123; this.asyncSubValue = val },
            error: (err) => &#123; },
            complete: () => &#123; },
          }); */
      
          this.asyncSubject.next(val1);
          this.asyncSubject.next(val2);
          this.asyncSubject.next(val3);
          this.asyncSubject.complete();
          this.asyncSubject.next(666);
      
          let asyncSub = this.asyncSubject.subscribe(&#123;
            next: (val) => &#123; this.asyncSubValue = val },
            error: (err) => &#123; },
            complete: () => &#123; },
          });
      
          this.subscriptions = [...this.subscriptions, asyncSub];
        }
      
        onSubscribeOnAsyncSubjectLater() &#123;
          let asyncSub2 = this.asyncSubject.subscribe(&#123;
            next: (val) => &#123; this.asyncSubValue2 = val },
            error: (err) => &#123; },
            complete: () => &#123; },
          });
      
          this.subscriptions = [...this.subscriptions, asyncSub2];
        }
      </pre>
      <li>Az utolsó input mezőt megváltoztatva is az 555 marad az 'asyncSubValue' változóban, mivel az AsyncSubject
        complete() metódusa már lefutott, így minden feliratkozó az idők végezetéig ezt az értéket kapja majd meg</li>
      <li>A complete metódus után kibocsátott 400-as érték már nem számít</li>
      <li>A következő feliratkozó is az 555-ös (vagy a módosított 3.) értéket fogja megkapni</li>
      <li>A complete signal emit-álását követően az Observable (Subject) nem tud több értéket kibocsátani magából</li>
    </ul>
    <br>
    <h5 #promisevsobservable data-anchor="promisevsobservable">Promise vs Observable</h5>
    <ul>
      <li>Az Observable-t aszinkron adatok kezelésére használjuk, és Promise-szal is tudunk aszinkron adatot kezelni
        <ul>
          <li>Azt fogjuk most megnézni, hogy melyiket mikor érdemes használni.</li>
        </ul>
      </li>
      <br>
      <table style="width: 100%; table-layout: fixed">
        <tr>
          <th>Promise</th>
          <th>Observable</th>
        </tr>
        <tr>
          <td>Natív Javascript</td>
          <td>RxJS könyvtár szolgáltatja</td>
        </tr>
      </table>
      <br>
      <li>Promise
        <ul>
          <li>Nincs szükség importálásra</li>
        </ul>
      </li>
      <li>Observable<ul>
          <li>Az RxJS könyvtárból importáljuk</li>
        </ul>
      </li>
      <pre>
        <b>// Promise</b>
        promise: Promise&#60;any> = new Promise&#60;any>((resolve, reject) => &#123; // 2 argomentumot fogad a callback function
          // logic
        }); 
  
        <b>// Observable</b>
        import &#123; Observable } from 'rxjs';
        observable: Observable&#60;any> = new Observable&#60;any>(() => &#123; // callback function
          // Logic
        });
      </pre>
      <table style="width: 100%; table-layout: fixed">
        <tr>
          <th>Promise</th>
          <th>Observable</th>
        </tr>
        <tr>
          <td>
            <div><i>Eager</i></div>
            <div>Azonnal elkezdi a végrehajtást, amint létrejön, függetlenül attól, hogy van-e rá feliratkozás</div>
          </td>
          <td>
            <div><i>Lazy</i></div>
            <div>A végrehajtása csak akkor kezdődik el, amikor feliratkoznak rá</div>
          </td>
        </tr>
      </table>
      <br>
      <li>Promise
        <ul>
          <li>A lenti példában látszik, hogy a Promise azonnal beleír a megfelelő változóba</li>
        </ul>
      </li>
      <li>Observable<ul>
          <li>A lenti példában látszik, hogy ahhoz, hogy az Observable-ben lévő logika lefusson, fel kell rá iratkoznunk
            (a gombbal)</li>
        </ul>
      </li>
      <br>
      <app-subject [tempSwitcher]="'promisevsobservable'"></app-subject>
      <pre>
        &#60;div>Promise: &#123; &#123; promiseCalledText }}&#60;/div>
        &#60;div>Observable: &#123; &#123; observableCalledText }}&#60;/div>
        &#60;button type="button" class="btn btn-secondary" (click)="subToObs()">Subscribe to Observable&#60;/button>
  
        <b>// Promise</b>
        promise: Promise&#60;any> = new Promise&#60;any>((resolve, reject) => &#123; // (resolve, reject) => &#123;} - callback function
          this.promiseCalledText = 'Promise is called';
        });
  
        <b>// Observable</b>
        observable: Observable&#60;any> = new Observable&#60;any>((sub) => &#123; // () => &#123;} - callback function
          this.observableCalledText = 'Observable is called';
          sub.next('Observable is called');
        });
  
        subToObs() &#123;
          this.observable.subscribe(&#123;
            next: (val) => &#123; },
            error: (err) => &#123; },
            complete: () => &#123; }
          });
        }
      </pre>
      <table style="width: 100%; table-layout: fixed">
        <tr>
          <th>Promise</th>
          <th>Observable</th>
        </tr>
        <tr>
          <td>
            <div>Egyetlen értéket képes kibocsátani</div>
          </td>
          <td>
            <div>Egy, vagy több érték kiküldésére is képes</div>
          </td>
        </tr>
      </table>
      <br>
      <li>Promise
        <ul>
          <li>A lenti példában a Promise callback függvényében több resolve hívás szerepel, de csak az első resolve
            hívás
            teljesül, mivel a Promise állapotát csak egyszer lehet megváltoztatni</li>
        </ul>
      </li>
      <li>Observable<ul>
          <li>Adatfolyamok kezelésére alkalmas</li>
          <li>Az Observable callback függvényében lévő összes next metódus hívása kibocsátja az adatokat, így a
            feliratkozók egymás után megkapják mindegyik next által küldött értéket</li>
        </ul>
      </li>
      <br>
      <app-subject [tempSwitcher]="'promisevsobservable2'"></app-subject>
      <pre>
        &#60;div>Promise:
          &#60;ul *ngFor="let promText of promiseGetText">
              &#60;li>&#123; &#123; promText }}&#60;/li>
          &#60;/ul>
        &#60;/div>
        &#60;div>Observable:
            &#60;ul *ngFor="let obsText of observableGetText">
                &#60;li>&#123; &#123; obsText }}&#60;/li>
            &#60;/ul>
        &#60;/div>
        &#60;button type="button" class="btn btn-secondary" (click)="getDataFromPromiseAndObservable()">
            Get Promise and Observable data
        &#60;/button>
        &#60;button type="button" class="btn btn-danger" (click)="promiseGetText = []; observableGetText = []">
            Clear given data
        &#60;/button>
  
        promiseGetText: string[] = [];
        observableGetText: string[] = [];
      
        promise: Promise&#60;any> = new Promise&#60;any>((resolve, reject) => &#123;
          this.promiseCalledText = 'Promise is called';
          resolve('Promise data 1');
          resolve('Promise data 2');
          resolve('Promise data 3');
        });
      
        observable: Observable&#60;any> = new Observable&#60;any>((sub) => &#123;
          this.observableCalledText = 'Observable is called';
          sub.next('Observable data 1');
          sub.next('Observable data 2');
          sub.next('Observable data 3');
        });
  
        getDataFromPromiseAndObservable() &#123;
          this.promise.then((data) => &#123;
            this.promiseGetText.push(data);
          });
      
          this.observable.subscribe(&#123;
            next: (val) => &#123; this.observableGetText.push(val) },
            error: (err) => &#123; },
            complete: () => &#123; }
          });
        }
      </pre>
      <table style="width: 100%; table-layout: fixed">
        <tr>
          <th>Promise</th>
          <th>Observable</th>
        </tr>
        <tr>
          <td>
            <div>Success (resolve) és error (reject) metódusa létezik</div>
          </td>
          <td>
            <div>Success, error, és complete metódusa is létezik</div>
          </td>
        </tr>
      </table>
      <br>
      <li>Promise
        <ul>
          <li>Az adat emit-áláshoz (resolve) metódust használunk</li>
          <li>Hiba küldéséhez (reject) method-ot alkalmazunk</li>
        </ul>
      </li>
      <li>Observable<ul>
          <li>(next): Adatküldés</li>
          <li>(error): Hibaküldés</li>
          <li>(complete): Sikeresen vége az adatfolyamnak</li>
        </ul>
      </li>
      <br>
      <table style="width: 100%; table-layout: fixed">
        <tr>
          <th>Promise</th>
          <th>Observable</th>
        </tr>
        <tr>
          <td>
            <div>Mindig aszinkron adattal tér vissza</div>
          </td>
          <td>
            <div>Szinkron, és aszinkron adattal is képes visszatérni</div>
          </td>
        </tr>
      </table>
      <br>
      <li>Promise
        <ul>
          <li>Még ha a Promise azonnal teljesülne is, az értéket a JavaScript eseményciklus következő futtatási körében
            kapjuk meg</li>
          <pre>
              const promise = new Promise(resolve => resolve('Promise data'));
              console.log('Before Promise');
              promise.then(data => console.log(data));
              console.log('After Promise');
  
              // Before Promise
              // After Promise
              // data
            </pre>
        </ul>
      </li>
      <li>Observable<ul>
          <li>A feliratkozás pillanatában azonnal is küldhet értéket (szinkron), vagy később, aszinkron módon</li>
          <li>Nagy rugalmasságot ad a szinkron és aszinkron adatáramlások kezelésében</li>
          <pre>
            const observable = new Observable(subscriber => &#123;
              subscriber.next('Synchronous data');  // Szinkron kibocsátás
              setTimeout(() => subscriber.next('Asynchronous data'), 1000);  // Aszinkron kibocsátás
            });
            
            console.log('Before Observable');
            observable.subscribe(data => console.log(data));  // Azonnali és késleltetett adat is megérkezik
            console.log('After Observable');
  
            // Before Observable
            // Synchronous data
            // After Observable
            // Asynchronous data
          </pre>
        </ul>
      </li>
      <style>
        table,
        th,
        td {
          border: 1px solid black;
          border-collapse: collapse;
        }

        th,
        td {
          padding: 10px;
        }
      </style>
    </ul>
    <br>
    <h5 #unsubscribefromobservable data-anchor="unsubscribefromobservable">Unsubscribe from Observable</h5>
    <ul>
      <li>Az Observable adatot emit-ál, és amikor feliratkozunk az Observable-re, a Subscriber megkapja az adatot, amit
        az Observable bocsát ki</li>
      <li>Amennyiben nem szeretnénk több adatot kapni/fogadni az Observable-től, leiratkozhatunk</li>
      <li>Az interval() metódus Observable-t készít ( Observalbe&#123;number> )
        <ul>
          <li>Meghatározott időközönként (ms) bocsát ki értékeket</li>
          <li>Az értékek egy folyamatosan növekvő számsor, 0-val kezdve</li>
        </ul>
      </li>
      <br>
      <app-subject [tempSwitcher]="'unsubscribe'"></app-subject>
      <pre>
        <b>// subject.html</b>
        Subscription 1:
        &#60;div>
            &#60;span *ngFor="let val of counterValues1">
                &#123; &#123;val}}
            &#60;/span>
        &#60;/div>
        Subscription 2:
        &#60;div>
            &#60;span *ngFor="let val of counterValues2">
              &#123; &#123;val}}
            &#60;/span>
        &#60;/div>
        &#60;button class="btn btn-secondary" (click)="subscribeOnCounter()">Subscribe&#60;/button>
        &#60;button class="btn btn-danger" (click)="unsubscribeOnCounter1()">Unsubscibe 1&#60;/button>
        &#60;button class="btn btn-danger" (click)="unsubscribeOnCounter2()">Unsubscibe 2&#60;/button>
        &#60;button class="btn btn-warning" (click)="counterValues1 = []; counterValues2 = []">Clear&#60;/button>

        <b>// subject.ts</b>
        counter = interval(1000);
        counterValues1: any[] = [];
        counterValues2: any[] = [];
        counterSubscription1: Subscription | null = null;
        counterSubscription2: Subscription | null = null;

        subscribeOnCounter() &#123;
          if (!this.counterSubscription1) &#123;
            this.counterSubscription1 = this.counter.subscribe(&#123;
              next: (val) => &#123;
                this.counterValues1.push(val);
              },
              error: (err) => &#123; },
              complete: () => &#123; }
            });
          }
      
          if (!this.counterSubscription2) &#123;
            this.counterSubscription2 = this.counter.subscribe(&#123;
              next: (val) => &#123;
                this.counterValues2.push(val);
              },
              error: (err) => &#123; },
              complete: () => &#123; }
            });
          }
        }
      
        unsubscribeOnCounter1() &#123;
          if (this.counterSubscription1) &#123;
            this.counterSubscription1.unsubscribe();
          };
          this.counterSubscription1 = null;
        }
      
        unsubscribeOnCounter2() &#123;
          if (this.counterSubscription2) &#123;
            this.counterSubscription2.unsubscribe();
          };
          this.counterSubscription2 = null;
        }
      </pre>
      <li>Feliratkozás után (Subscribe gomb) a subscribe() metódus objektumában (ami paraméter), a next kulcsban
        található callback function-ben kapjuk meg a kiküldött értékeket
      </li>
      <li>Az értek egy 0-val induló számsor</li>
      <li>Az interval egészen addig bocsátja ki a számokat, amíg le nem iratkozunk róla (Unsubscribe gomb)
        <ul>
          <li>Egy bizonyos idő elteltével el fog fogyni a memória</li>
        </ul>
      </li>
      <li>Újrafeliratkozáskor elölről kezdi a számlálást
        <ul>
          <li>A fenti példában a tömböt, amit feltölt, nem ürítjük ki leiratkozáskor automatikusan</li>
          <li>A tömb kiürítését a Clear gombbal tehetjük meg
            <ul>
              <li>Akár leiratkozás nélkül is</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>A két Subscription egyszerre történik, de leiratkozni külön-külön is lehet</li>
      <li>Ha nincs feliratkozó az interval-ra (vagy mindenki leiratkozott), akkor nem bocsát ki értéket</li>
    </ul>
  </ul>
</div>

<div>
  <h3 #signal data-anchor="signal">Signal</h3>
  <ul>
    <li>Angular 16-ban mutatták be
      <ul>
        <li>Inkább csak, mint development preview, a későbbiekben fog végleges formát ölteni (Angular 17?)</li>
      </ul>
    </li>
    <li>A best practice-ek még váratnak magukra, ki kell "fejlődniük"</li>
    <li>Tulajdonképpen egy értéket tárol, aminek változásáról értesülni tudunk
      <ul>
        <li>Primitív értékeket, és komplex adatokat is tartalmazhat</li>
      </ul>
    </li>
    <li>Az Angular ezelőtt a change detection cycle-re alapozott, ha változás történt, lefutott a cycle, és frissítette
      a UI-t
      <ul>
        <li>Például, ha egyzerűen csak egyszerűen csak egy property értékét változatjuk gombbal</li>
        <li>Amikor megváltozik a property értéke, lefut a change detection cycle
          <ul>
            <li>Eközben azonosítja, hogy az adat változott-e, vagy sem</li>
          </ul>
        </li>
        <li>A gombok click eventet kapnak, amit érzékel az Angular</li>
        <li>Amennyiben változik az érték, egyrészt frissül a property, másrészt kirenderelődik az új érték (amennyiben
          kint van a UI-on)</li>
        <li>Ez az elvárt működés</li>
      </ul>
    </li>
    <li>A probléma az, hogy ha a gombot megnyomjuk, és nem módosít a gombnyomás értéken, a change detection akkor is
      lefut
      <ul>
        <li>A click event hatására az Angularnak meg kell néznie, hogy történt-e változás</li>
      </ul>
    </li>
    <li>Annak, hogy a DoCheck lefut akkor is, ha nem történik érdembeli változás, negatív hatása lehet a teljesítményre
    </li>
    <li>A színfalak mögött a zone.js library felelős a change detection-ök lefutásáért
      <ul>
        <li>A bundle méretének növekedését is eredményezi</li>
        <li>A bundle-ök tartalmazzák a third party kódokat is, amiket az alkalmazásunkban használunk</li>
        <li>Ilyen külső könyvtár a zone.js is
          <ul>
            <li>Az Angular rá támaszkodik a change detection végett</li>
          </ul>
        </li>
        <li>A zone.js nem mondja meg az Angularnak, hogy melyik komponens melyik része változott meg
          <ul>
            <li>Így a teljes komponens fa frissülni fog</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A zone.js hátrányai kiküszöbölése végett jött létre a Signal
      <ul>
        <li>Egy alternatív megközelítése a change detection-nek, és a UI frissítésnek</li>
        <li>Megszabadulhatunk a zone.js library használatától</li>
        <li>Nincs automatikus változás észlelés, mi mondhatjuk meg az Angularnak, hogy mikor történt változás</li>
        <li>Csak azok a részek kerülnek frissítésre, ami valóban változott</li>
        <li>Jobb teljesítményre, és kisebb bundle méretre számíthatunk</li>
      </ul>
    </li>
    <pre>
      <b>// signals.component.html</b>
      &#60;div class="rounded-border">
        &#60;div>
            &#60;button class="btn btn-light" (click)="decreaseCounter()">-&#60;/button>
            &#60;span>&#123; &#123; counter }}&#60;/span>
            &#60;button class="btn btn-light" (click)="increaseCounter()">+&#60;/button>
            &#60;button class="btn btn-warning" (click)="0">Click event only&#60;/button>
        &#60;/div>
    
        &#60;div>
            &#60;button class="btn btn-danger" (click)="messages = []">Clear messages&#60;/button>
        &#60;/div>
    
        &#60;div>
            &#60;div *ngFor="let m of messages; let i = index">
                &#123; &#123;i + 1}}. &#123; &#123; m }}
            &#60;/div>
        &#60;/div>
      &#60;/div>

      <b>// signals.component.ts</b>
      export class SignalsComponent implements DoCheck &#123;
        counter: number = 0;
        messages: string[] = [];
      
        decreaseCounter() &#123;
          this.counter--;
        }
      
        increaseCounter() &#123;
          this.counter++;
        }
      
        ngDoCheck(): void &#123;
          this.messages.push('doCheck lifecycle hook');
        }
      }
    </pre>
    <li>Jelen alkalmazás sajátossága, hogy egy változás hatására kétszer megy végbe a change detection</li>
    <li>A Clear messages gombra kattintás után is lefut a cycle</li>
    <li>Garázdálkodva az oldalon, a messages-be írt logok száma igencsak megnőhet</li>
    <br>
    <app-signals [tempSwitcher]="'default'"></app-signals>
  </ul>
  <br>
  <h5 #creatingandusingsignals data-anchor="creatingandusingsignals">Creating and using signals</h5>
  <ul>
    <li>A signal objektumot fog visszaadni, aminek van néhány metódusa
      <ul>
        <li>A number típusunk ezen túl Signal&#60;number> lesz</li>
        <li>Argomentumként meg kell adnunk kezdeti értéket</li>
        <li>Aritmetikus operátorokat (-- / ++) nem tudunk a továbbiakban használni</li>
        <li>String interpolációt használva láthatjuk, hogy egy függvényt tartalmaz</li>
        <pre>
          &#123; &#123; counter2 }}

          ↓↓↓↓↓

          function signalFn() &#123; producerAccessed(node); return node.value; }
        </pre>
        <li>Amennyiben a függvényt hívjuk meg a template-ben, megkapjuk a "becsomagolt" értéket</li>
        <pre>
          &#123; &#123; counter2() }}

          ↓↓↓↓↓

          0
        </pre>
        <li>Az Angular innentől tudni fogja, hol használtuk a signal-t, és amennyiben változik, visszatér ide, és
          frissíti
          <ul>
            <li>Nem rendereli újra a teljes komponenst</li>
          </ul>
        </li>
        <li>A signal immutable állapotot kezel, amely explicit módon frissíthető
          <ul>
            <li>Writeable signal
              <ul>
                <li>A signal értéke explicit módon módosítható</li>
                <li>Ez az alapértelmezett viselkedése a signal() által létrehozott objektumoknak</li>
                <li>Támogatja az érték beállítását, frissítését vagy mutálását</li>
                <li>Mindig van egy kezdeti értéke</li>
              </ul>
            </li>
            <li>Az Angular 3 metódust biztosít signal esetében az érték frissítése végett
              <ol>
                <li>set()
                  <ul>
                    <li>Az új érték explicit beállításához</li>
                  </ul>
                </li>
                <li>update()
                  <ul>
                    <li>Az érték részleges frissítésére vagy kalkulációk elvégzésére</li>
                  </ul>
                </li>
                <li>mutate()
                  <ul>
                    <li>Közvetlen módosításra, ha az érték egy referencia típus (pl. objektum vagy tömb)</li>
                  </ul>
                </li>
              </ol>
            </li>
            <li>Readonly signal
              <ul>
                <li>Csak lekérdezhető, de az értéke nem módosítható közvetlenül</li>
                <li>Amennyiben megadjuk a signal típusát, readonly signal-t kapunk eredményül</li>
                <li>A computed() függvény segítségével a signal értékét más signal-ok alapján számítja ki</li>
              </ul>
            </li>
          </ul>
        </li>
        <br>
        <app-signals [tempSwitcher]="'numberSignal'"></app-signals>
        <pre>
          <b>// signals.component.html</b>
          &#60;div class="rounded-border">
            &#60;div>
                &#60;button class="btn btn-light" (click)="decreaseCounter2()">-&#60;/button>
                &#60;span>&#123; &#123; counter2() }}&#60;/span>
                &#60;button class="btn btn-light" (click)="increaseCounter2()">+&#60;/button>
                &#60;button class="btn btn-warning" (click)="0">Click event only&#60;/button>
            &#60;/div>
        
            &#60;div>
                &#60;button class="btn btn-danger" (click)="messages = []">Clear messages&#60;/button>
            &#60;/div>
        
            &#60;div>
                &#60;div *ngFor="let m of messages; let i = index">
                    &#123; &#123;i + 1}}. &#123; &#123; m }}
                &#60;/div>
            &#60;/div>
          &#60;/div>

          <b>// signals.component.ts</b>
          export class SignalsComponent implements DoCheck &#123;
            // counter2: Signal&#60;number> = signal(0); // readonly signal
            // counter2 = computed(() => this.counter2() * 2); // readonly signal
            counter2 = signal(0); // writeable signal
            messages2: string[] = [];

            constructor() &#123;
              const readonlySignal = () => counter2(); // readonly signal, sima getter funkcióként működik, így az értéke kívülről nem módosítható
            }
          
            decreaseCounter2() &#123;
              // this.counter2.set(1); // az értéket fixen 1-re állítja be, ami itt nekünk nem jó
              // this.counter2.set(this.counter2() - 1); // kiolvassuk az előző értéket, és kivonunk egyet, de ajánlatosabb az update metódus
              this.counter2.update(val => val - 1);
            }
          
            increaseCounter2() &#123;
              // this.counter2.set(1); // az értéket fixen 1-re állítja be, ami itt nekünk nem jó
              // this.counter2.set(this.counter2() + 1); // kiolvassuk az előző értéket, és hozzáadunk egyet, de ajánlatosabb az update metódus
              this.counter2.update(val => val + 1);
            }
          
            ngDoCheck(): void &#123;
              this.messages.push('doCheck lifecycle hook');
            }
          }
        </pre>
        <li>Update esetében az új érték nem függ az előző értéktől (mint set esetében)
          <ul>
            <li>Az update metódus callback függvényének argomentumában lesz benne az aktuális értéke a signalnak</li>
          </ul>
        </li>
        <li>A mutate metódus is frissítésre való
          <ul>
            <li>Ugyanúgy működik, mint az update, de csak mutable értékeken használható</li>
            <li>Referencia típusú adat (objektum, tömb) közvetlen megváltoztatására képes
              <ul>
                <li>A teljes érték lecserélése helyett csak az érték egy részét módosítja</li>
              </ul>
            </li>
            <li>Callback függvényt vár</li>
            <li>Az update method felülírni tudja az értéket</li>
          </ul>
        </li>
        <pre>
          <b>// signals.component.html</b>
          &#60;div class="rounded-border">
            &#60;div>
                &#60;button class="btn btn-light" (click)="decreaseCounter2()">-&#60;/button>
                &#60;span>&#123; &#123; counter2() }}&#60;/span>
                &#60;button class="btn btn-light" (click)="increaseCounter2()">+&#60;/button>
                &#60;button class="btn btn-warning" (click)="0">Click event only&#60;/button>
            &#60;/div>
        
            &#60;div>
                &#60;button class="btn btn-danger" (click)="clearMessage2()">Clear messages&#60;/button>
            &#60;/div>
        
            &#60;div>
                &#60;div *ngFor="let m of messages2(); let i = index">
                    &#123; &#123;i + 1}}. &#123; &#123; m }}
                &#60;/div>
            &#60;/div>
          &#60;/div>

          <b>// signals.component.ts</b>
          counter2 = signal(0);
          messages2 = signal&#60;string[]>([]); // a signal generic type

          decreaseCounter2() &#123;
            this.counter2.update(val => val - 1);
            // this.messages2.update( (val) => val.push('Decrease')); // nem működik, mert immutable type
            // this.messages2.update(val => [...val, `Decreased: $&#123;this.counter2()}`]); // tud működni update-tel, de nem akarunk új tömböket létrehozni
            this.messages2.mutate(val => val.pop());
          }

          increaseCounter2() &#123;
            this.counter2.update(val => val + 1);
            // this.messages2.update( (val) => val.push('Increase')); // nem működik, mert immutable type
            // this.messages2.update(val => [...val, `Increased: $&#123;this.counter2()}`]); // tud működni update-tel, de nem akarunk új tömböket létrehozni
            this.messages2.mutate(val => val.push(`Current value is $&#123;this.counter2()}`));
          }

          clearMessage2() &#123;
            this.messages2.mutate(val => []);
          }
        </pre>
        <table style="width: 100%; table-layout: fixed">
          <thead>
            <tr>
              <th>Metódus</th>
              <th>Használat</th>
              <th>Példa</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>set</td>
              <td>Teljes érték cseréje</td>
              <td><code>signal.set(newValue)</code></td>
            </tr>
            <tr>
              <td>update</td>
              <td>Érték frissítése egy függvénnyel</td>
              <td><code>signal.update(value => value + 1)</code></td>
            </tr>
            <tr>
              <td>mutate</td>
              <td>Referenciatípusok közvetlen módosítása</td>
              <td><code>signal.mutate(obj => obj.key = x)</code></td>
            </tr>
          </tbody>
        </table>
        <br>
        <app-signals [tempSwitcher]="'arraySignal'"></app-signals>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #computedvalueandeffect data-anchor="computedvalueandeffect">Computed value and effect</h5>
  <ul>
    <li>computed() függvény
      <ul>
        <li>Függvény (importálni kell a @angular/core-ból)</li>
        <li>Arra használjuk, hogy kiszámoljunk egy értéket egy signalból</li>
        <li>Callback függvényt adunk neki</li>
        <pre>
          counter2 = signal(0);

          doubleCounter = computed(() => this.counter2() * 2);
        </pre>
        <li>Ezen a módon signalból számolunk értéket</li>
        <li>Signallal tér vissza, amit tárolja a kikalkulált értéket</li>
        <li>Akármikor változik a counter2 signal, a doubleCounter property frissül</li>
        <br>
        <app-signals [tempSwitcher]="'computed'"></app-signals>
        <br>
        <li>A doubleCounter signalnak is megjegyzi a helyét az Angular, és csak azt frissíti, amikor szükséges</li>
        <li>Tehát a computed függvény egy okos, egyszerű módja értékek kiszámításának, amik signal-okon alapulnak</li>
      </ul>
    </li>
    <li>effect() függvény
      <ul>
        <li>Függvény (importálni kell a @angular/core-ból)</li>
        <li>Akkor használjuk, amikor le szeretnénk futtatni valamilyen logikát, amikor egy signal értéke megváltozik
        </li>
        <li>Nem arra használjuk, hogy a signal értékét megváltoztassuk</li>
        <li>A metódust bárhol használhatjuk, konstruktorban, OnInitben, stb.</li>
        <li>Amennyiben a függvényben nem használunk signalt, az effekt függvény nem fog meghívódni
          <ul>
            <li>Nem tudja a metódus, hogy melyik signal esetében hívódjon meg</li>
          </ul>
        </li>
        <pre>
          constructor() &#123;
            effect(() => console.log('counter: ' + this.counter2()));
          }
        </pre>
        <li>A signalban lévő érték változásakor a console-ba kiíródik a számláló értéke</li>
      </ul>
    </li>
    <li>A későbbiekben a signal több funkciót is fog kapni
      <ul>
        <li>Például esélyes, hogy a change detection-re fog egy jobb opciót kínálni</li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #routingandguards data-anchor="routingandguards">Routing and guards</h3>
  <ul>
    <li>Alapértelmezetten az index.html-ben találjuk az app-root tag-et, ami az app komponenst rendereli</li>
    <li>Az app.module.ts nem része az app komponensnek</li>
    <li>A routing lehetővé teszi, hogy az alkalmazás egyik részéről átmenjünk egy másik részére
      <ul>
        <li>Átnavigálhatunk az egyik template-ből egy másik template-be</li>
      </ul>
    </li>
    <li>Új Angular projekt létrehozásakor a router modul is letöltésre kerül</li>
    <pre>
      <b>// package.json</b>
      "dependencies": &#123;
        ...
        "@angular/animations": "^15.2.0",
        ...
      }
    </pre>
    <li>Az app komponens a root komponens, amit az index.html fájlban használunk
      <ul>
        <li>Az applikáció futtatásakor az app komponens lerenderelődik</li>
      </ul>
    </li>
    <pre>
      &#60;!doctype html>
      &#60;html lang="en">
      &#60;head>
        &#60;meta charset="utf-8">
        &#60;title>Angular&#60;/title>
        &#60;base href="/">
        &#60;meta name="viewport" content="width=device-width, initial-scale=1">
        &#60;link rel="icon" type="image/x-icon" href="favicon.ico">
      &#60;/head>
      &#60;body>
      &#60;app-root>&#60;/app-root> // app komponens
      &#60;/body>
      &#60;/html>
    </pre>
    <li>Egy új route készítésének 3 lépése
      <ol>
        <li>A Routes tömbben route objektum definiálása
          <ul>
            <li>Az adott modul routing.module.ts fájljában definiálhat</li>
            <li>A module.ts fájlban is definiálhatóak a route-ok</li>
            <li>Routes típusú változó</li>
            <li>Egy objektum egy route-ot definiál
              <ul>
                <li>Egy "sima" route létrehozásához két property-t definiálunk benne
                  <ol>
                    <li>path</li>
                    <li>component</li>
                  </ol>
                </li>
              </ul>
            </li>
            <pre>
            <b>// app-routing.module.ts</b>
            const routes: Routes = [ // array of Route objects
              &#123;
                path: 'angular',
                component: AngularComponent // komponens, aminek a template-jét be akarjuk tölteni
                loadChildren: () => import('./angular/navi/navi.module').then(m => m.NaviModule), // Lazy load
              },
            ]

            <b>// navi-routing.module.ts</b>
            const routes: Routes = [
              &#123; path: '', component: HomeComponent },
              &#123; path: 'home', component: HomeComponent },
              &#123; path: 'about', component: AboutComponent },
              &#123; path: 'contact', component: ContactComponent },
              &#123; path: 'about', component: AboutComponent, outlet: 'navi', data: &#123; typeSwitcher: 'navi-outlet' } },
              &#123; path: 'contact', component: ContactComponent, outlet: 'navi', data: &#123; typeSwitcher: 'navi-outlet' } },
              &#123; path: 'about', component: AboutComponent, outlet: 'test', data: &#123; typeSwitcher: 'test-outlet' } },
              &#123; path: 'contact', component: ContactComponent, outlet: 'test', data: &#123; typeSwitcher: 'test-outlet' } },
              &#123; path: 'about', component: AboutComponent, outlet: 'secondary', data: &#123; typeSwitcher: 'secondary-outlet' } },
              &#123; path: 'code', component: CodeComponent, outlet: 'navi' },
            ];
            </pre>
            <li>http://localhost:4200/angular
              <ul>
                <li>A http://localhost:4200 a root URL</li>
                <li>Az 'angular' a path</li>
              </ul>
            </li>
            <li>Az alapértelmezett root url-ünk a http://localhost:4200/, jelen oldalon az url-ünk pedig, amennyiben nem
              navigáltunk tovább, http://localhost:4200/angular, ahol az angular rész a path</li>
            <li>A routes tömb megadásával az Angular még "nem tud" ezekről a route-okról</li>
          </ul>
        </li>
        <li>Regisztrálni szükséges a route-okat
          <ul>
            <li>A RouterModule importálását el kell végezni</li>
            <pre>
            <b>// app-routing.module.ts</b>
            @NgModule(&#123;
              imports: [RouterModule.forRoot(routes)], 
              exports: [RouterModule]
            })
  
            <b>// app.module.ts</b>
            @NgModule(&#123;
              ...
              imports: [
                ...
                AppRoutingModule
              ],
            })

            <b>// navi-routing.module.ts</b>
            @NgModule(&#123;
              imports: [RouterModule.forChild(routes)],
              exports: [RouterModule]
            })

            <b>// navi.module.ts</b>
            @NgModule(&#123;
              declarations: [
                NaviComponent,
                HeaderComponent,
                FooterComponent,
                AboutComponent,
                ContactComponent,
                CodeComponent,
                HomeComponent,
                NotfoundComponent,
              ],
              imports: &#123;
                ...
                NaviRoutingModule
              ],
              exports: [
                NaviComponent
              ]
            })
          </pre>
            <li>A forRoot() metódus azt mondja meg, hogy a routes, amit átadunk, a teljes applikációra van definiálva
              <ul>
                <li>A forChild() metódus a gyerek modulokban használandó</li>
              </ul>
            </li>
            <li>Innentől az Angular ismeri a route-okat</li>
          </ul>
        </li>
        <li>Most már csak azt kell megmondanunk hogy amikor az adott url-re navigálás történik, hol jelenjen meg a
          megfelelő template
          <ul>
            <li>Ennek megvalósítása router-outlet direktívával történik
              <ul>
                <li>Megmondja az Angularnak, hogy ahol a direktíva van, ott jelenik meg a template</li>
                <pre>
                  <b>// angular.component.html</b>
                  &#60;app-navi>&#60;/app-navi>

                  <b>// navi.component.html</b>
                  &#60;app-header>&#60;/app-header>
                  &#60;div class="navi-content">
                      &#60;router-outlet>&#60;/router-outlet>
                  &#60;/div>
                  &#60;app-footer>&#60;/app-footer>
                </pre>
                <li>Nem szükséges külön importálni a router-outlet-et, megtörténik a RouterModule importálásával</li>
              </ul>
            </li>
          </ul>
        </li>
      </ol>
    </li>
    <li>Jelen applikációban az angular komponensünk tartalmaz egy navi module-t, ami pedig egy navi komponenst, és
      gyerekeket</li>
    <pre>
      app
      ├── app.component.ts
      ├── app-routing.module.ts
      ├── angular
      │   ├── angular.component.ts
      │   └── navi
      │       ├── navi.module.ts           // Modul, amely tartalmazza a gyerek komponenseket és a hozzájuk tartozó útvonalakat
      │       ├── navi-routing.module.ts   // A `navi` modul route konfigurációi, ide tartoznak a gyerek komponensek
      │       ├── header
      │       │   └── header.component.ts
      │       ├── home
      │       │   └── home.component.ts
      │       ├── footer
      │       │   └── footer.component.ts
      │       ├── code
      │       │   └── code.component.ts
      │       ├── contact
      │       │   └── contact.component.ts
      │       └── about
      │           └── about.component.ts

    </pre>
    <li>Megadhatunk alapértelmezett útvonalat
      <ul>
        <li>Amikor az adott path-re érkezünk, be fog töltődni</li>
        <li>A path üres string</li>
        <pre>
          <b>// navi-routing.module.ts</b>
          const routes: Routes = [
            &#123; path: '', component: HomeComponent },
            ...
          ]
        </pre>
        <li>Az app module esetében az alkalmazás betöltődésekor betöltődik az alapértelmezett útvonal, amennyiben
          definiáltuk, és amennyiben a root URL-t gépeltük be
          <ul>
            <li>Ugyanez igaz bármely gyerek modul-ra, természetesen akkor nem a root URL-t adjuk meg, hanem a modul
              alapértelmezett/kezdő útvonalát (feature module route)</li>
          </ul>
        </li>
        <li>Redirect opciónk is van
          <ul>
            <li>
              A redirectTo kulccsal valósítható meg
            </li>
            <pre>
              const routes: Routes = [
                &#123; path: '', redirectTo: 'home', pathMatch: 'full' },
                &#123; path: 'home', component: HomeComponent },
              ]
            </pre>
            <li>pathMatch
              <ul>
                <li>Megmondja, hogy az útvonalak hogyan illeszkedjenek a URL-hez</li>
                <li>2 opciónk van
                  <ol>
                    <li>'full'
                      <ul>
                        <li>Az útvonal pontosan meg kell egyezzen a megadott URL-lel</li>
                        <li>Csak akkor aktiválódik az útvonal, ha az URL teljesen megegyezik az útvonal path értékével
                        </li>
                      </ul>
                    </li>
                    <li>'prefix'
                      <ul>
                        <li>Az útvonal akkor aktiválódik, ha az URL a megadott path-el kezdődik</li>
                        <li>Hasznos, ha több al-útvonal van</li>
                      </ul>
                    </li>
                  </ol>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Not found url
      <ul>
        <li>Elődordul(hat), hogy olyan URL-re tévedünk, ami nincs definiálva
          <ul>
            <li>Pl.: http://localhost:4200/angular/services</li>
            <li>Alapértelmezetten a root URL-re leszünk átirányítva</li>
            <li>Cannot match any routes hibát is kapunk a DevTools Console fülön</li>
          </ul>
        </li>
        <li>Definiáljunk a routes tömb végén egy útvonalat, ami akkor fog aktiválódni, ha az útvonalak egyike sem
          egyezett
          <ul>
            <li>A path kulcs értéke '**'</li>
            <li>Majd megválaszthatjuk (component: NotfoundComponent), hogy ezen az útvonalon milyen template-et
              szeretnénk megjeleníteni</li>
            <pre>
              const routes: Routes = [
                ...
                &#123; path: '**', component: NotfoundComponent }
              ]
            </pre>
            <li>Beírva így egy nem létező route-ot, a 'NotfoundComponent' template-je fog megjelenni</li>
            <li>Csak akkor hívódik meg ez a route, ha a felette lévőkkel nincs egyezés</li>
            <li>Wildcard route-mnak nevezik</li>
            <li>Tulajdonképpen minden route path-ra match-el
              <ul>
                <li>Az Angular felülről lefelé check-olja a tömbben, hogy van-e path egyezés</li>
                <li>Ha a tömb első elemének rakjuk be, mindig csak ez az oldal fog megjelenni, ezért fontos a végére
                  hagyni</li>
              </ul>
            </li>
            <li>A 404 response státuszt ezzel még nem állítottuk be
              <ul>
                <li>Kliens oldalon vagyunk, nem is tudjuk manipulálni a szerver válaszát</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #routerlink data-anchor="routerlink">routerLink</h5>
  <ul>
    <li>Az Angularban többféleképpen is meg lehet oldani az alkalmazáson belüli navigációt
      <ol>
        <li>routerLink direktíva
          <ul>
            <li>A legelterjedtebb módja az Angular alkalmazáson belüli navigációnak</li>
            <li>A router állapotát frissíti, és betölti a kívánt komponenst anélkül, hogy az oldal újratöltődne</li>
            <pre>
              &#60;a [routerLink]="['/home']">Home&#60;/a>
            </pre>
          </ul>
        </li>
        <li>Router.navigate metódus
          <ul>
            <li>Nem jár oldal újratöltéssel</li>
            <pre>
              router: Router = inject(Router);

              navigateToHome() &#123;
                this.router.navigate(['/', 'angular', 'home']);
              }
            </pre>
          </ul>
        </li>
        <li>href attribútum használata natív a tag-en
          <ul>
            <li>A href közvetlenül a böngészőt utasítja az URL megnyitására, ami az oldal teljes újratöltését
              eredményezi</li>
            <pre>
                &#60;a href="/angular/home" role="'button'">Home&#60;/a>
            </pre>
            <li>Érdemes a role attribútumot a fenti értékkel megadni
              <ul>
                <li>Gyakran használatos olyan esetekben, amikor a link valójában egy akció (például mentés, törlés), és
                  nem csupán navigáció, de vizuálisan mégis gombhoz hasonló viselkedést várunk tőle</li>
                <li>Egyes böngészők különféle módon stílusozhatják</li>
                <li>A komponensek nem töltődnek újra, és az alkalmazás állapota sem változik meg</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Location service használata
          <ul>
            <li>Közvetlen URL manipulációt jelent, így nem ideális</li>
            <li>Csak a cím mezőt módosítja a megadott útvonallal, de nem hajt végre tényleges navigációt és nem váltja
              ki az Angular router eseményeit sem</li>
            <pre>
              location: Location = inject(Location);

              navigateToHome() &#123;
                this.location.go('/home');
              }
            </pre>
          </ul>
        </li>
      </ol>
    </li>
    <li>A routerLink a legelterjedtebb és ajánlott módszer, mivel az Angular routerrel szorosan együttműködik, és
      újratöltés nélküli navigációt eredményez</li>
    <li>Amennyiben navigáció során frissül az oldal, újratöltődik az applikáció, és elveszítjük az app állapotait</li>
    <br>
    <li>
      routerLink
      <ul>
        <li>HTML elemekre helyezhető attribútum direktíva</li>
        <li>Segítségével egy adott útvonalra (route-ra) navigálhatunk, amikor a felhasználó az adott elemre kattint</li>
        <li>Nem küldünk új kérést a szerver felé</li>
        <li>Mindig csak az adott template megjelenítéséhez szükséges fájlok töltődnek le</li>
        <li>Az alkalmazás nem indul újra navigálásokkor</li>
        <pre>
          &#60;a [routerLink]="['/', 'angular']">Angular&#60;/a>
        </pre>
        <li>Elkapja a click eventet, meggátolja az alapértelmezett működést</li>
        <li>Megnézi, mit adtunk meg a direktívának, és hogy van-e egyező route</li>
        <li>Kiegészítő paraméterek is megadhatók a direktívának</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #activerouterlink data-anchor="activerouterlink">activeRouterLink</h5>
  <ul>
    <li>Angular direktíva, amelyet arra használunk, hogy CSS osztályt alkalmazzunk arra az elemre, amelyik routerLink
      attribútuma az éppen aktív útvonalra mutat</li>
    <li>Vizuálisan kiemelhetjük a felhasználónak, melyik oldal vagy szekció van éppen betöltve</li>
    <li>Beállíthatjuk, hogy az adott elem kapjon egy meghatározott CSS osztályt, amikor az útvonal aktív</li>
    <pre>
      &#60;a [routerLink]="['/', 'angular']" [routerLinkActive]="'active'">Angular&#60;/a> // egy CSS osztály
      &#60;a [routerLink]="['/', 'angular']" [routerLinkActive]="'active green'">Angular&#60;/a> // több CSS osztály
    </pre>
    <li>A szögletes []-ben lévő attribútumok mindig Typescript kifejezést várnak, ezért stringként szükséges megadnunk a
      class-okat</li>
    <li>A routerLinkActive direktíva csak akkor működik, ha az adott HTML elemen routerLink direktíva is található</li>
    <li>Tulajdonképpen az adott elemhez CSS osztályt ad hozzá / vesz el</li>
    <li>Célja, hogy látható legyen, melyik route aktív</li>
    <li>Amennyiben egy child route aktív, úgy az összes parent route is aktív lesz</li>
    <pre>
      &#60;a [routerLink]="['/']" [routerLinkActive]="'active'">Root&#60;/a> // ez is aktív lesz, ha a lentire kattintunk
      &#60;a [routerLink]="['/', 'angular']" [routerLinkActive]="'active'">Angular&#60;/a>
    </pre>
    <li>Ezt a problémát oldja fel egy másik direktíva, a [routerLinkActiveOptions]</li>
    <br>
    <li>routerLinkActiveOptions
      <ul>
        <li>Attribútum direktíva</li>
        <li>Objektumot fogad</li>
        <li>Használatával szabályozhatjuk, hogy egy adott link mikor tekinthető aktívnak</li>
        <pre>
          &#60;a [routerLink]="['/']" [routerLinkActive]="'active'" [routerLinkActiveOptions]="&#123;exact: true}">Root&#60;/a>
          &#60;a [routerLink]="['/', 'angular']" [routerLinkActive]="'active'">Angular&#60;/a>
        </pre>
        <ol>
          <li>exact: true
            <ul>
              <li>Biztosítja, hogy a link csak akkor kapja meg az aktív osztályt, ha az útvonal pontosan egyezik</li>
              <li>Különösen akkor hasznos, ha van egy alapútvonal (/angular), és ezen belül további alútvonalak
                (/angular/about)</li>
            </ul>
          </li>
          <li>exact: false
            <ul>
              <li>Az alapértelmezett viselkedés</li>
            </ul>
          </li>
        </ol>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #relativevsabsoluteroutepath data-anchor="relativevsabsoluteroutepath">Relative vs absolute route path</h5>
  <ul>
    <li>routerLinknek kétféleképpen tudunk megadni útvonalat
      <ol>
        <li>A path előtt / jellel
          <ul>
            <li>Abszolút útvonal/path</li>
            <li>A root URL-hez tevődik hozzá</li>
            <pre>
              // Current route: http://localhost:4200/angular
              &#60;a [routerLink]="/angular/home">Home&#60;/a> // ['/', 'angular', 'home']
              // Result: http://localhost:4200/angular/home
            </pre>
          </ul>
        </li>
        <li>A path előtt / jel nélkül
          <ul>
            <li>Relatív útvonal/path</li>
            <li>Hozzáadódik a jelenleg aktív route-hoz
              <ul>
                <li>De csakis kizárólag akkor, ha a link definiálva van a jelenleg aktív route-ban</li>
              </ul>
            </li>
            <pre>
              // Current route: http://localhost:4200/angular
              &#60;a [routerLink]="angular/home">Home&#60;/a> // ['angular', 'home']
              // Result: http://localhost:4200/angular/angular/home
            </pre>
            <li>Amennyiben a routerLinket ./ jelet kezdjük, is relatív útvonalat használunk</li>
            <li>../ jelet használva egy szinttel feljebb lépünk, majd a további útvonal hozzáadódik az aktív útvonalhoz
            </li>
            <pre>
              Active route: http://localhost:4200/angular/about
              [routerLink]=['../', 'contact'] // relative path
              Result: http://localhost:4200/angular/contact

              Active route: http://localhost:4200/angular/about
              [routerLink]=['../', '../' 'contact'] // relative path
              Result: http://localhost:4200/contact
            </pre>
          </ul>
        </li>
      </ol>
    </li>
    <li>Két &#60;router-outlet>&#60;/router-outlet> egy template-ben nem lehet, a másikat / többit nevesíteni
      szükséges, mert az Angular alapértelmezés szerint csak az első router-outlet-et fogja figyelembe venni az
      útvonalak megjelenítésekor
      <ul>
        <li>A kezdeti template megjelenik, de a változásokra érzéketlen a másik / többi router-outlet</li>
      </ul>
    </li>
    <pre>
      <b>// parent</b>
      &#60;button [routerLink]="[&#123; outlets: &#123; secondary: ['about'] } }]" class="btn btn-secondary">Relative: About&#60;/button>
      &#60;button [routerLink]="['/', 'angular']" class="btn btn-secondary">Absolute: Angular&#60;/button>
      &#60;app-navi [tempSwitcher]="'relativeabsolute'">&#60;/app-navi>
      <div>Current route: &#123; &#123; currentRoute }}</div>

      <b>// routing</b>
      &#123;
        path: 'angular',
        component: AngularComponent,
        children: [
          ...
          &#123; path: 'about', component: AboutComponent, outlet: 'secondary', data: &#123; typeSwitcher: 'secondary-outlet' } },
        ]
      }

      <b>// navi component</b>
      &#60;ng-container *ngIf="tempSwitcher == 'relativeabsolute'">
        &#60;router-outlet name="secondary">&#60;/router-outlet>
      &#60;/ng-container>

      <b>// about component</b>
      &#60;div *ngIf="typeSwitcher == 'default'" class="rounded-border">
        &#60;h6>About&#60;/h6>
      &#60;/div>
    </pre>
    <button [routerLink]="[{ outlets: { secondary: ['about'] } }]" class="btn btn-secondary">Relative: About</button>
    <button [routerLink]="['/', 'angular']" class="btn btn-secondary">Absolute: Angular</button>
    <br>
    <br>
    <div>Current route: {{ currentRoute }}</div>
    <br>
    <div class="rounded-border">
      <app-navi [tempSwitcher]="'relativeabsolute'"></app-navi>
    </div>
  </ul>
  <br>
  <h5 #navigatingprogramatically data-anchor="navigatingprogramatically">Programatically navigating between routes</h5>
  <ul>
    <li>Lehetőségünk van a controller-ben megírni a navigációs logikát</li>
    <li>Szükségünk van egy Router class példányra a komponens osztályunkban</li>
    <pre>
      constructor(private _router: Router) &#123;}
      // or
      _router: Router = inject(Router);
    </pre>
    <li>A Router navigate() metódusát használva elnavigálhatunk egyik route-ról másikra
      <ul>
        <li>Tömböt fogad argomentumnak</li>
        <pre>
          this._router.navigate(['angular', 'contact']); // abszolute path
        </pre>
      </ul>
    </li>
    <li>A router navigateByUrl metódusa szintén útvonal változtatásra használható
      <ul>
        <li>Argoumentumnak stringet fogad</li>
        <li>A root URL utáni teljes útvonalat várja</li>
        <pre>
          this._router.navigateByUrl('angular/contact'); // absolute path
        </pre>
      </ul>
    </li>
    <li>Mindkét fenti metódus abszolút útvonal
      <ul>
        <li>Ezért nem szükséges egyik argomentumát sem / jellel kezdeni</li>
      </ul>
    </li>
    <li>A router navigateByUrl metódusa szintén útvonal változtatásra használható
      <ul>
        <li>Argoumentumnak stringet fogad</li>
        <li>A root URL utáni teljes útvonalat várja</li>
        <pre>
          this._router.navigateByUrl('angular/contact'); // absolute path
        </pre>
      </ul>
    </li>
    <li>Mindkét fenti metódus alapértelmezetten abszolút útvonal
      <ul>
        <li>Ezért nem szükséges egyik argomentumát sem / jellel kezdeni</li>
        <li>Amennyiben relatív útvonalat szeretnénk a navigate metódus a tömb mellett egy objektumban megadhatjuk
          <ul>
            <li>A relativeTo kulcsot kell használnunk</li>
            <li>Emellett pedig szükségünk van a jelenlegi aktív route-ra (ActivatedRoute class példányára)</li>
            <pre>
              constructor(private _activeRoute: ActivatedRoute) &#123; }
              // or
              private _activeRoute: ActivatedRoute = inject(ActivatedRoute);

              navigateToContact() &#123;
                this._router.navigate(['angular', 'contact'], &#123;relativeTo: _activeRoute});
              }
            </pre>
            <li>Az ActivatedRoute információt tárol a jelenleg aktív route-ról</li>
          </ul>
        </li>
      </ul>
    </li>

    <pre>
      <b>// parent.html</b>
      &#60;button class="btn btn-secondary" (click)="navigateToContact()">Navigate to Contact&#60;/button>
      &#60;button [routerLink]="['/angular']" class="btn btn-secondary">Back to Angular&#60;/button>
      &#60;div>Current route: &#123; &#123; currentRoute }}&#60;/div>

      <b>// parent.ts</b>
      let lastRoute = this._router.events.subscribe((event) => &#123;
        if (event instanceof NavigationEnd) &#123;
          this.currentRoute = event.url;
        }
      });
      this.subscriptions = [...this.subscriptions, lastRoute];

      navigateToContact() &#123;
        this._router.navigate(['/', 'angular', 'contact']); // absolute path
      }

      ngOnDestroy(): void &#123;
        if (this.subscriptions) &#123;
          this.subscriptions.forEach(sub => &#123;
            sub.unsubscribe();
          })
        }
      }
    </pre>
    <br>
    <button class="btn btn-secondary" (click)="navigateToContact()">Navigate to Contact</button>
    <button [routerLink]="['/angular']" class="btn btn-secondary">Back to Angular</button>
    <br>
    <br>
    <div>Current route: {{ currentRoute }}</div>
  </ul>
  <br>
  <h5 #routeparameters data-anchor="routeparameters">Route parameters</h5>
  <ul>
    <li>A route paraméter a dinamikus része a route-nak
      <ul>
        <li>Változtatható az értéke</li>
        <li>Kettőspont és válozónév</li>
      </ul>
    </li>
    <li>Átadhatunk extra információt adott route-oknak</li>

    <li>A route vége dinamikus paraméter</li>
    <pre>
        http://localhost:4200/angular/about/1
        http://localhost:4200/angular/about/2
        http://localhost:4200/angular/about/3
      </pre>
    <li>Beállításának lépései az alábbiak
      <ol>
        <li>Útvonal megadása
          <ul>
            <pre>
                <b>// navi-routing.component.ts</b>
                const routes: Routes = [
                  &#123; path: 'about/:id', component: AboutComponent }, // az :id a dinamikus paraméter
                ];
              </pre>
            <li>Amit megadunk az url-ben/route-ban az about után, az foglalja el az 'id' helyét</li>
            <pre>
                http://localhost:4200/angular/about/page // jelen esetben a page
              </pre>
            <li>Ezen a módon több dinamikus paraméter is meghatározható</li>
            <pre>
                const routes: Routes = [
                  &#123; path: 'about/:id/:name/:category', component: AboutComponent }, // 3 dinamikus paraméter van a route végén
                ];
    
                http://localhost:4200/angular/about/5/john/news // 3 dinamikus paraméter van a route végén
              </pre>
            <li>Esetünkben az about komponensnek van egy gyereke, az 'app-about-details', és ez a komponens fogja
              megjeleníteni a dinamikus útvonalunknak megfelelő template-et</li>
            <pre>
                  &#123; path: 'about/:id', component: AboutDetailsComponent },
                </pre>
          </ul>
        </li>
        <li>Paraméter lekérdezése
          <ul>
            <li>A kontrollerben ki kell olvasnunk az 'id' paramétert</li>
            <li>Ehhez a jelenleg aktív route-ról kérünk be informiót az ActivatedRoute segítségével</li>
            <pre>
                <b>// about-details.component.ts</b>

                constructor() &#123;
                  this.id = this._activeRouter.snapshot.params['id']; // régi megadási mód
                  // or
                  this.id = this._activeRouter.snapshot.paramMap.get('id'); // új megadási mód
                }
              </pre>
            <li>A paraméter, amit keresünk, az 'id'</li>
            <pre>
                &#123; path: 'about', component: AboutComponent },
                &#123; path: 'about/:id', component: AboutDetailsComponent },
              </pre>
            <li>Visszakapjuk az 'id'-ban tárolt értéket
              <ul>
                <li>String value</li>
              </ul>
            </li>
            <li>A snapshot property az aktuális útvonal (route) paramétereinek egy adott időpontban rögzített
              pillanatképét tartalmazza</li>
            <li>A pillanatkép az útvonalhoz kapcsolódó paraméterek értékét jelenti a lekérdezés időpontjában, és az
              értékek nem frissülnek automatikusan, ha az útvonal paraméterei később megváltoznak
              <ul>
                <li>Egy egyszeri lekérés, amely az aktuális útvonal állapotát tükrözi, de nem figyeli a későbbi
                  változásokat</li>
                <li>Ha például a felhasználó egy új paramétert ad meg az URL-ben, a snapshot nem fogja ezt a
                  frissítést lekövetni</li>
              </ul>
            </li>
            <li>Ha figyelni kell az útvonal paramétereinek változását a komponens élettartama alatt, akkor a paramMap
              Observable változatát érdemes használni
              <ul>
                <li>Automatikusan követi az URL-ben lévő paraméterek változásait, így mindig az aktuális értéket
                  kapod, amikor az paraméter frissül</li>
              </ul>
            </li>
          </ul>
        </li>
      </ol>
    </li>
    <li>A dinamikus paraméterek működését a témakör alján lévő példa szemlélteti
      <ul>
        <li>'navigateByUrl'-rel az About oldalra szükséges navigálnunk</li>
        <button type="button" class="btn btn-primary btn-sm anchor" (click)="scrollToAnchor('naviexample')">
          Scroll to example
        </button>
      </ul>
    </li>
    <li>Megvalósítása a következőképpen történt</li>
    <pre>
        <b>// navi-routing.module.ts</b>
        const routes: Routes = [
          ...
          &#123; path: 'about', component: AboutComponent },
          &#123; path: 'about/:id', component: AboutDetailsComponent },
          ...
        ];

        <b>// app-about.component.html</b>
        &#60;div *ngIf="typeSwitcher == 'default'" class="rounded-border">
          &#60;h6>About&#60;/h6>
          &#60;div *ngFor="let num of [1, 2, 3, 4, 5]">
              &#60;button [routerLink]="['/', 'angular', 'about', num]" type="button" class="btn btn-secondary">
                  Go to: &#123; &#123;num}}
              &#60;/button>
          &#60;/div>
        &#60;/div>

        <b>// app-about-details.component.html</b>
        &#60;div class="rounded-border">
            &#60;ng-container *ngIf="aboutData.id; else noData">
                &#60;h6>#&#123; &#123;aboutData.id}} - &#123; &#123;aboutData.title}}&#60;/h6>
                &#60;p>&#123; &#123;aboutData.text}}&#60;/p>
            &#60;/ng-container>
            &#60;button [routerLink]="['..']" class="btn btn-secondary">Go back&#60;/button>
        &#60;/div>

        &#60;ng-template #noData>
            &#60;p>Non-existent data&#60;/p>
        &#60;/ng-template>

        <b>// app-about-details.component.ts</b>
        export class AboutDetailsComponent &#123;
          private _router: Router = inject(Router);
          private _activeRouter: ActivatedRoute = inject(ActivatedRoute);
          aboutDetailsService: AboutDetailsService = inject(AboutDetailsService);
        
          id: number = 0;
          aboutData: any = &#123;};
        
          constructor() &#123;
            // this.id = this._activeRouter.snapshot.params['id']; // régebbi megoldás
            this.id = +(this._activeRouter.snapshot.paramMap.get('id') ?? 0);
            this.aboutData = this.aboutDetailsService.aboutDetailsArray.find(data => data.id === this.id) ?? 0;
          }
        }

        <b>// about-details.service.ts</b>
        export class AboutDetailsService &#123;
          aboutDetailsArray: any[] = [
            &#123; id: 1, title: 'Mind what', text: 'Mind what no by kept. Celebrated no he decisively thoroughly. Our asked sex point her she seems. New plenty she horses parish design you. Stuff sight equal of my woody. Him children bringing goodness suitable she entirely put far daughter.' },
            &#123; id: 2, title: 'Started joy', text: 'Started several mistake joy say painful removed reached end. State burst think end are its. Arrived off she elderly beloved him affixed noisier yet. An course regard to up he hardly. View four has said does men saw find dear shy. Talent men wicket add garden.' },
            &#123; id: 3, title: 'Unpleasant excellence', text: 'Unpleasant nor diminution excellence apartments imprudence the met new. Draw part them he an to he roof only. Music leave say doors him. Tore bred form if sigh case as do. Staying he no looking if do opinion. Sentiments way understood end partiality and his.' },
            &#123; id: 4, title: 'Ecstatic endeavor', text: 'Dissuade ecstatic and properly saw entirely sir why laughter endeavor. In on my jointure horrible margaret suitable he followed speedily. Indeed vanity excuse or mr lovers of on. By offer scale an stuff. Blush be sorry no sight. Sang lose of hour then he left find.' },
            &#123; id: 5, title: 'Talking improve', text: 'Oh to talking improve produce in limited offices fifteen an. Wicket branch to answer do we. Place are decay men hours tiled. If or of ye throwing friendly required. Marianne interest in exertion as. Offering my branched confined oh dashwood.' },
          ];
        }
      </pre>
    <li>Tegyük fel, hogy a szeretnénk navigálni a dinamikus route-ok között
      <ul>
        <pre>
          <b>// about-details.component.html</b>
          &#60;button [routerLink]="['/', 'angular', 'about', aboutData.id - 1]" class="btn btn-secondary">Previous&#60;/button>
          &#60;button [routerLink]="['..']" class="btn btn-secondary">Go to angular route&#60;/button>
          &#60;button [routerLink]="['/', 'angular', 'about', aboutData.id + 1]" class="btn btn-secondary">Next&#60;/button>

          <b>// about-details.component.ts</b>
          constructor() &#123;
            this.id = +(this._activeRouter.snapshot.paramMap.get('id') ?? 0); // a + jel számmá alakítja az eredményt
            ...
          }
        </pre>
        <li>Az 'aboutData.id' tartalmazza az aktuális értékét a dinamikus route-nek</li>
        <li>Önmagában ez így semmi mást sem csinál, mint az URL-ben változtatja a dinamikus paramétert
          <ul>
            <li>A template nem változik</li>
            <li>Ez a gond a snapshot propertyvel</li>
            <li>Az aktív route változik, de a snapshot nem</li>
            <li>Amikor megnyitjuk az app-about-details komponenst, akkor létrejön belőle egy instance
              <ul>
                <li>Ehhez meghívásra kerül a konstruktora, de a komponens életciklusa alatt csak egyszer</li>
                <li>A konstruktorban pedig készítettünk egy "pillanatképet", ami a példány létrejöttekor elkészült, de
                  frissebb érték nem fog belekerülni</li>
              </ul>
            </li>
            <li>A Previous vagy a Next gombra kattintva a route változni fog, de a konstruktor nem fog újra meghívódni
              <ul>
                <li>Az 'this.id' (ami alapján előre, vagy hátra navigálnánk) értéke nem fog változni</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A megoldás Observable használata
          <ul>
            <li>Az ActivatedRoute-nak 2 olyan metódusa is van, ami Observable-lel tér vissza
              <ol>
                <li>param
                  <ul>
                    <li>Fel lehet rá iratkozni</li>
                    <li>A subsctibe metódusnak callback function-t adunk át</li>
                    <li>A callback függvény minden alkalommal meghívódik, amikor a param értéke megváltozik</li>
                    <pre>
                      <b>// about-details.component.html</b>
                      &#60;button [routerLink]="['/', 'angular', 'about', (aboutData.id - 1)]" class="btn btn-secondary"
                          [disabled]="aboutData.id === 1">
                          Previous (&#123; &#123;aboutData.id - 1}})
                      &#60;/button>
                      &#60;button [routerLink]="['..']" class="btn btn-secondary">Go to angular route&#60;/button>
                      &#60;button [routerLink]="['/', 'angular', 'about', (aboutData.id + 1)]" class="btn btn-secondary"
                          [disabled]="aboutData.id > 4">
                          Next (&#123; &#123;aboutData.id + 1}})
                      <&#60;button>

                      <b>// about-details.component.ts</b>
                      this._activeRouter.params.subscribe((data) => &#123; // deprecated !
                        this.id = +data['id']; // data.id --> Property 'id' comes from an index signature, so it must be accessed with ['id']
                        this.aboutData = this.aboutDetailsService.aboutDetailsArray.find(data => data.id === this.id) ?? 0;
                      });
                    </pre>
                    <li>A data paraméterben fogjuk megkapni a frissített route-ot</li>
                  </ul>
                </li>
                <li>paramMap
                  <ul>
                    <li>Annyiban különbözik a param-tól, hogy az aktuális aktív route-ot</li>
                    <li>Valamint a get() metódussal olvasható ki az érték</li>
                    <pre>
                      <b>// about-details.component.html</b>
                      &#60;button [routerLink]="['/', 'angular', 'about', (aboutData.id - 1)]" class="btn btn-secondary"
                          [disabled]="aboutData.id === 1">
                          Previous (&#123; &#123;aboutData.id - 1}})
                      &#60;/button>
                      &#60;button [routerLink]="['..']" class="btn btn-secondary">Go to angular route&#60;/button>
                      &#60;button [routerLink]="['/', 'angular', 'about', (aboutData.id + 1)]" class="btn btn-secondary"
                          [disabled]="aboutData.id > 4">
                          Next (&#123; &#123;aboutData.id + 1}})
                      <&#60;button>

                      <b>// about-details.component.ts</b>
                      this._activeRouter.paramMap.subscribe(data => &#123; // ez használatos
                        this.id = +(data.get('id') ?? 0);
                        this.aboutData = this.aboutDetailsService.aboutDetailsArray.find(data => data.id === this.id) ?? 0;
                      });
                    </pre>
                  </ul>
                </li>
              </ol>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Mindig jó practice leiratkozni a subscription-ökről</li>
    <pre>
      paramMapObs: Subscription | null = null;

      constructor() &#123;
        this.paramMapObs = this._activeRouter.paramMap.subscribe(data => &#123;
          this.id = +(data.get('id') ?? 0);
          this.aboutData = this.aboutDetailsService.aboutDetailsArray.find(data => data.id === this.id) ?? 0;
        });
      }

      ngOnDestroy(): void &#123;
        this.paramMapObs?.unsubscribe();
      }
    </pre>
  </ul>
  <br>
  <h5 #querystringinroute data-anchor="querystringinroute">Query string in route</h5>
  <ul>
    <li>Mi is az a query string?
      <ul>
        <li>Opcionális adat, amit route-on keresztül tudunk átadni a komponensnek</li>
        <li>A route végéhez adódnak hozzá ? után, & jellel elválasztva
          <ul>
            <li>Kulcs-érték párosok</li>
          </ul>
        </li>
        <pre>
          http://localhost:4200/angular/about?title=about-us
          http://localhost:4200/angular/about?id=12345&category=news
        </pre>
        <li>A query string kiolvasásához szükségünk van az ActivatedRoute-ra
          <ul>
            <li>A jelenleg aktív route-ról tartalmaz információt</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A célunk az lesz, hogy az app-about komponensben lévő 5 gombot filterezzük
      <ul>
        <li>A query paraméter kiolvasása 2 módon történhet
          <ol>
            <li>queryParam (Observable)
              <pre>
                this._activeRoute.snapshot.queryParams['search'];
              </pre>
            </li>
            <li>queryParamMap (Observable)
              <pre>
                this.searchString = this._activeRoute.snapshot.queryParamMap.get('search') ?? '';
              </pre>
            </li>
          </ol>
        </li>
        <pre>
          <b>// home.component.html</b>
          &#60;div class="input-group">
            &#60;span class="input-group-text">Search/Filter buttons on About page&#60;/span>
            &#60;input #querystring type="text" class="form-control" placeholder="Query string">
            &#60;button [routerLink]="'about'" [queryParams]="&#123;search: querystring.value}"
                class="btn btn-outline-primary" type="button">
                Search
            &#60;/button>
          &#60;/div>
        </pre>
        <li>A template reference variable használata itt nem a legjobb megoldás, mert ha még benne állunk az input
          mezőben, és úgy nyomunk a gombra, akkor üres stringet fogunk kapni query paraméterként
          <ul>
            <li>Az ngModel megoldja a problémát</li>
            <pre>
              queryString: string = '';

              &#60;span class="input-group-text" id="basic-addon1">Search/Filter buttons on About page&#60;/span>
              &#60;input #querystring type="text" class="form-control" placeholder="Query string"
                    [(ngModel)]="queryString">
              &#60;button [routerLink]="'about'" [queryParams]="&#123;search: queryString}" class="btn btn-outline-primary"
                  type="button" id="button-addon2">
                  Search
              &#60;/button>
            </pre>
          </ul>
        </li>
        <li>A query paramétert a 'queryParams'-ban adjuk meg
          <ul>
            <li>A queryParams - elvileg - property binding</li>
            <li>A query paraméter kulcsának megadtuk a 'search' szót, az értéket pedig az input mezőbe beírt karakterek
              adják</li>
            <li>Megvalósul az about page-re navigálás</li>
            <li>A paraméterek vesszővel elválasztva adhatók meg</li>
          </ul>
        </li>
        <pre>
          <b>// about.component.ts</b>
          constructor() &#123;
            this.searchString = this._activeRoute.snapshot.queryParamMap.get('search') ?? '';

            // szűrés/filter
            if (this.searchString === undefined || this.searchString === '') &#123; // ha nincs search query string, vagy üres string, akkor az összes gomb megjelenik
              this.aboutData = this.aboutDetailsService.aboutDetailsArray.map(data => &#123;
                return &#123; id: data.id, label: data.title };
              });
            } else &#123; // ha megadtunk search kulcsú query stringet, akkor a filter segítségével szűkítünk
              this.aboutData = this.aboutDetailsService.aboutDetailsArray
                .map(data => (&#123; id: data.id, label: data.title }))
                .filter(data => data.label.toLowerCase().includes(this.searchString.toLowerCase()));
            }
          }
        </pre>
        <li>Az about page-re ugorva szerepelni fog a query-nkben a ?search=*begépelt érték*
          <ul>
            <li>Ha az érték üres string, belefutunk az if statementbe, és minden gomb megjelenik</li>
            <li>Az ActivatedRoute service, és a snapshot, queryParamMap, get metódusokkal hozzájuthatunk a search kulcsú
              query paraméterhez</li>
          </ul>
        </li>
        <li>A komponens class-ban is megvalósítható a route és param összeállítása
          <ul>
            <li>A Rouer service navigate metódusának első argomentum egy tömb, ahol a route-ot határozzuk meg, a második
              argomentum pedig egy objektum, ahol meghatározható a queryParams property</li>
            <pre>
              export class HomeComponent &#123;
                router: Router = inject(Router);
                activeRouter: ActivatedRoute = inject(ActivatedRoute);
              
                search(val: string) &#123;
                  this.router.navigate(['about'], &#123; relativeTo: this.activeRouter, queryParams: &#123; search: val } });
                }
              }
            </pre>
            <li>A relativeTo kulcs megadása is szükséges annak érdekében, hogy megfelelően történjen a navigálás
              <ul>
                <li>Nélküle abszolút útvonalat használna a navigate()</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Az about komponensben egyelőre nem tudjuk nyomon követni a route változását
          <ul>
            <pre>
              <b>// about.component.ts</b>
              constructor() &#123;
                this.searchString = this._activeRoute.snapshot.queryParamMap.get('search') ?? '';
              }
            </pre>
            <li>A komponens betöltődésekor megkapjuk a pillanatképet</li>
            <li>A route meg fog változni, de a searchString nem frissül</li>
            <li>Az about komponens példányunk változatlan, aminek a konstruktora már korábban lefutott</li>
            <li>Ezt a problémát is 2 módon oldhatjuk meg, Observable segítségével
              <ol>
                <li>queryParams (Observable)
                  <ul>
                    <li>A jelenleg aktív route-ot tartalmazza, amit a callback függvény paraméteréből kapunk meg</li>
                    <pre>
                      this._activeRoute.queryParams.subscribe((data) => &#123; // depricated !
                        this.searchString = data['search'] ?? '';
                      });
                    </pre>
                  </ul>
                </li>
                <li>queryParamMap (Observable)
                  <ul>
                    <li>Frissebb feature, ezt érdemes használni</li>
                    <pre>
                      this._activeRoute.queryParamMap.subscribe((data) => &#123;
                      this.searchLoading = true;
                        this.searchString = data.get('search') ?? '';

                        if (this.searchString === undefined || this.searchString === '') &#123; // a szűrés logikája is átkerül a callback function-be
                          this.aboutData = this.aboutDetailsService.aboutDetailsArray.map(data => &#123;
                            return &#123; id: data.id, label: data.title };
                          });
                        } else &#123;
                          this.aboutData = this.aboutDetailsService.aboutDetailsArray
                            .map(data => (&#123; id: data.id, label: data.title }))
                            .filter(data => data.label.toLowerCase().includes(this.searchString.toLowerCase()));
                        }
                      });
                    </pre>
                    <li>Minden változáskor meghívódik a callback függvény</li>
                  </ul>
                </li>
              </ol>
            </li>
            <li>Mindkét esetben callback function-t adunk át, ami meghívódik, amikor az Observable új adatot emit-ál
            </li>
            <li>Az about komponensben is megvalósítható a keresés frissítése</li>
            <pre>
              <b>// about.component.html</b>
              &#60;input type="text" class="form-control" placeholder="Query string" aria-label="Query string"
                    [(ngModel)]="searchString" (keyup)="onFilterChange()">

              <b>// about.component.ts</b>
              this._router.navigate(['.'], &#123; relativeTo: this._activeRoute, queryParams: &#123; search: this.searchString } });
            </pre>
            <li>Így az aktuális route-on maradunk, csupán a query paramétert változtatjuk meg</li>
          </ul>
        </li>
        <li>A subscription-t leginkább az ngOnInit() életciklus metódusban érdemes elhelyezni
          <ul>
            <li>A konstruktorban általában nem végzünk komplex logikát, csak a komponens objektumainak inicializálására
              használjuk</li>
            <li>az ngOnInit() lifecycle hookban már biztosan inicializálva vannak azok a szolgáltatások és
              változók, amelyekre szükség lehet</li>
            <li>Az alkalmazás ezen állapotában van készen arra, hogy megkezdje a navigációs logika kezelését</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #fragmentinroute data-anchor="fragmentinroute">Fragment in route</h5>
  <ul>
    <li>Nézzük meg, mi a route fragment, és mire használhatjuk
      <ul>
        <li>Az URL # után található része</li>
        <li>Általában egy oldal adott részére való ugrásra használják</li>
        <pre>
          http://localhost:4200/angular#jumpToExample
        </pre>
        <button [routerLink]="['/angular']" [fragment]="'jumpToExample'" class="btn btn-secondary">Jump to
          example</button>
        <button [routerLink]="['/', 'angular']" class="btn btn-secondary">Erase fragment</button>
        <br>
        <br>
        <li>Ha az URL már tartalmazza a fragment-et, nem görgőz a gomb a megfelelő helyre</li>
        <li>Önmagában nem használható, meg kell adni a routerLinket</li>
        <li>Attribute binding (elvileg!)</li>
        <li>A fragment-nek azt az 'id' értéket adjuk meg, ahová az oldalon navigálni/ugrani szeretnénk</li>
        <li>Mivel az URL-ben helyezzük el a fragmentet, így bekerül az ActivatedRoute-ba</li>
        <li></li>
        <pre>
          this._activeRouter.fragment.subscribe(id => &#123;
            this.jumpToSection(id ?? '');
          });
        </pre>
        <li>A fragment Observable-t ad vissza
          <ul>
            <li>Fel tudunk rá iratkozni</li>
            <li>A subscribe-nak callback function-t adunk</li>
            <li>A callback függvény minden alkalommal meghívódik, amikor változik a fragment</li>
          </ul>
        </li>
        <li>Az ugrás/görgőzés nem történik meg önmagától, a logikáról magunknak kell gondoskonunk</li>
        <pre>
          jumpToSection(id: string) &#123;
            document.getElementById(id)?.scrollIntoView(&#123; behavior: 'smooth' });
          }
        </pre>
        <li>Amennyiben az adott route-ra úgy érkezünk, hogy már az URL részét képzi a fragment, és az OnInit-ben
          helyeztük el a függvényhívást, ami a görgetés/ugrást végzi, az oldal tetejére érkezünk, mert egy későbbi
          lifecycle hookra (amikor már betöltődött a tartalom) van szükségünk.</li>
        <pre>
          <b>// angular.component.html</b>
          &#60;button [routerLink]="['/angular']" [fragment]="'jumpToExample'" class="btn btn-secondary">
            Jump to example
          &#60;/button>

          &#60;h5 #naviexample id="jumpToExample" data-anchor="naviexample">Navigation example&#60;/h5>

          <b>angular.component.ts</b>
          this._activeRouter.fragment.subscribe(id => &#123;
            this.jumpToSection(id ?? '');
          });

          jumpToSection(id: string) &#123;
            document.getElementById(id)?.scrollIntoView(&#123; behavior: 'smooth' });
          }
        </pre>
        <li>A subscription-t leginkább az ngOnInit() életciklus metódusban érdemes elhelyezni
          <ul>
            <li>A konstruktorban általában nem végzünk komplex logikát, csak a komponens objektumainak inicializálására
              használjuk</li>
            <li>az ngOnInit() lifecycle hookban már biztosan inicializálva vannak azok a szolgáltatások és
              változók, amelyekre szükség lehet</li>
            <li>Az alkalmazás ezen állapotában van készen arra, hogy megkezdje a navigációs logika kezelését</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #childroutes data-anchor="childroutes">Child routes</h5>
  <ul>
    <li>Egy route egy másik route-on</li>
    <li>Nested route-nak is nevezik</li>
    <pre>
      <b>// navi-routing.module.ts</b>
      ...
        &#123; path: 'about', component: AboutComponent },
        &#123; path: 'about/:id', component: AboutDetailsComponent },
      ...
    </pre>
    <li>Látható, hogy az 'about' route-nak már van path-e</li>
    <li>Az 'about/:id' helyett készíthetünk egy child route-ot</li>
    <pre>
      <b>// navi-routing.module.ts</b>
      &#123;
        path: 'about', component: AboutComponent, children: [
          &#123; path: ':id', component: AboutDetailsComponent }
        ]
      },
      // &#123; path: 'about/:id', component: AboutDetailsComponent },
    </pre>
    <li>A children tömbben specifikálhatjuk a gyerek route-okat</li>
    <li>Ahhoz, hogy a gyerek route megjelenjen az oldalon, az about komponensbe router-outletet kellett elhelyezni</li>
    <pre>
      &#60;h6>About&#60;/h6>
      &#60;button [routerLink]="['..']" type="button" class="btn btn-secondary">
          Home
      &#60;/button>
      &#60;div class="row">
          &#60;div class="col-12 col-sm-6 col-md-6 col-lg-6 col-xl-3 col-xxl-3">
              &#60;div class="input-group mb-3">
                  &#60;span class="input-group-text" id="basic-addon1">Search&#60;/span>
                  &#60;input type="text" class="form-control" placeholder="Query string" aria-label="Query string"
                      [(ngModel)]="searchString" (keyup)="onFilterChange()">
              &#60;/div>
          &#60;/div>
      &#60;/div>
      &#60;div *ngFor="let data of aboutData">
          &#60;button [routerLink]="['/', 'angular', 'about', data.id]" type="button" class="btn btn-secondary">
              #&#123; &#123; data.id}} &#123; &#123; data.label }}
          &#60;/button>
      &#60;/div>
      &#60;router-outlet>&#60;/router-outlet>
    </pre>
    <li>Az about komponens a szülő route</li>
  </ul>
  <br>
  <h5 #routemodule data-anchor="routemodule">Route module</h5>
  <ul>
    <li>Az app modulon túl más modul(ok)ban, szeparáltan is kezelhetjük a route-jainkat</li>
    <li>Egyszerűbbé, és átláthatóbbá tehető az alkalmazásunk</li>
    <li>Egy új module-ban definiálhatjuk az útvonalakat</li>
    <li>Module készítésekor a névkonvenció a *NÉV*.module.ts</li>
    <li>A mostani új modulunkat a navi modul rootjában helyeztük el</li>
    <pre>
    const routes: Routes = [
      &#123; path: '', component: HomeComponent },
      &#123; path: 'home', component: HomeComponent },
      &#123;
        path: 'about', component: AboutComponent, children: [
          &#123; path: ':id', component: AboutDetailsComponent }
        ]
    },
      // &#123; path: 'about/:id', component: AboutDetailsComponent },
      &#123; path: 'contact', component: ContactComponent },
      &#123; path: 'about', component: AboutComponent, outlet: 'navi', data: &#123; typeSwitcher: 'navi-outlet' } },
      &#123; path: 'contact', component: ContactComponent, outlet: 'navi', data: &#123; typeSwitcher: 'navi-outlet' } },
      &#123; path: 'about', component: AboutComponent, outlet: 'test', data: &#123; typeSwitcher: 'test-outlet' } },
      &#123; path: 'contact', component: ContactComponent, outlet: 'test', data: &#123; typeSwitcher: 'test-outlet' } },
      &#123; path: 'about', component: AboutComponent, outlet: 'secondary', data: &#123; typeSwitcher: 'secondary-outlet' } },
      &#123; path: 'code', component: CodeComponent, outlet: 'navi' },
    ];

    @NgModule(&#123;
        imports: [RouterModule.forChild(routes)],
        exports: [RouterModule]
    })

    export class RoutingModule &#123; }
    </pre>
    <li>Ahhoz, hogy module class-t hozzunk létre, az @ngModule() dekorátort szükséges használnunk
      <ul>
        <li>Metadata objektumot adunk át neki</li>
      </ul>
    </li>
    <li>A komponensek deklarálását elvégeztük a navi module-ben, így a routing module-ban már nem szükséges ezt megtenni
    </li>
    <li>Az eredeti module-unkból át kell vinnünk a 'RouterModule'-t a routing fájlba
      <ul>
        <li>A dekorátor imports kulcsa alatt adható meg</li>
      </ul>
    </li>
    <li>Valamint a exports kulcs alatt meghatározunk mindent, amit ki szeretnénk exportálni a fájlból
      <ul>
        <li>Azt exportáljuk ki, amit más fájlokban is szeretnénk használni</li>
        <li>Jelen esetben a RouterModule exportálandó</li>
      </ul>
    </li>
    <li>Az erdeti module fájlban a létrehozott routing module-t importálni szükséges</li>
    <br>
    <li>A --routing paranccsal létrehozott module-ok már ilyen szeparált módon keletkeznek</li>
    <pre>
      ng g m *path/name* --routing
    </pre>
    <li>Best practice, hogy a routing külön fájlban legyen</li>
  </ul>
  <br>
  <h5 #authservice data-anchor="authservice">Auth service</h5>
  <ul>
    <li>Egy egyszerű authentikációs szolgáltatást fogunk implementálni</li>
    <pre>
      <b>// AuthUser interface</b>
      export class AuthUser &#123;

        id: number = 0;
        name: string = '';
        gender: string = '';
        username: string = '';
        password: string = '';
        status: string = '';
    
        constructor(id: number, name: string, gender: string, username: string, password: string, status: string) &#123;
            this.id = id;
            this.name = name;
            this.gender = gender;
            this.username = gender;
            this.password = gender;
            this.status = status;
        }
      }

      <b>// AuthUser service</b>
      import &#123; Injectable } from "@angular/core";
      import &#123; AuthUser } from "../models/AuthUser";

      @Injectable(&#123;
          providedIn: 'root'
      })

      export class AuthUserService &#123;
          users: AuthUser[] = [
              new AuthUser(31927, 'Carl Smith', 'male', 'cath123', '123', 'active'),
              new AuthUser(87078, 'Johanna Bree', 'female', 'breeJ', 'bree', 'inactive'),
              new AuthUser(54394, 'Max King', 'male', 'maxi05', 'max', 'active'),
              new AuthUser(23740, 'Claire Whitmore', 'female', 'more-claire', 'moremore', 'active'),
              new AuthUser(17669, 'Julia Yellowstone', 'female', 'LiaYeNe', 'lia', 'inactive'),
              new AuthUser(47590, 'Adam Black', 'male', 'blackadam', 'blad', 'active'), // negyedévente
          ];
      }
    </pre>
    <li>A fenti kód / adatok alapján a cél az lesz, hogy a védett route-okhoz csak a fenti user-ek férjenek hozzá</li>
    <pre>
      <b>// Auth service</b>
      @Injectable(&#123;
        providedIn: 'root'
      })
      
      export class AuthService &#123;
          isLogged: boolean = false; // property
      
          private _authUserService: AuthUserService = inject(AuthUserService);
      
          login(username: string, password: string) &#123;
              let user = this._authUserService.users.find(u => (u.username === username && u.password === password));

              this.isLogged = !!user; // boolean értékre "konvertálunk"

              return user;
          }

          logoff() &#123;
            this.isLogged = false;
          }

          isAuthenticated() &#123;
            return this.isLogged;
          }
      }
    </pre>
    <li>A login metódusban azt fogjuk megvizsgálni, hogy a belépni kívánó felhasználó létezik-e az "adatbázisunkban"
      <ul>
        <li>Ehhez bekérjük a felhasználó nevét, és jelszavát paraméterként</li>
      </ul>
    </li>
    <li>A UserService-be be kell injektálnunk az AuthUser class egy példányát</li>
    <li>A login függvényben megkeressük a users tömbben azt az elemet, ahol a felhasználónév, és a jelszó megegyezik a
      login metódus paramétereivel
      <ul>
        <li>A find metódus végigmegy a tömb összes elemén</li>
        <li>Találat esetén a teljes user objektumot megkapjuk
          <ul>
            <li>Hiányában az eredmény undefined</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A logoff függvényben csak simán az isLogged property-t beállítjuk false értékre</li>
    <li>Az isAuthenticated pedig visszaadja az isLogged értékét</li>
    <br>
    <li>A példakódban a Login gomb megnyomásakor meghívjuk a login() metódust</li>
    <br>
    <button [routerLink]="['/angular']" [fragment]="'jumpToExample'" class="btn btn-secondary">Jump to
      example</button>
    <br>
    <li>A header komponensben lévő login gombbal átnavigálhatunk arra az oldalra (login), ahol megadhatjuk a
      credential-t</li>
    <pre>
      <b>// navi-routing.component.ts</b>
      &#123; path: 'login', component: LoginComponent },

      <b>// header.component.html</b>
      &#60;button class="btn btn-primary">&#60;a [routerLink]="['/', 'angular', 'login']">Login&#60;/a>&#60;/button>

      <b>// login.component.html</b>
      &#60;div class="input-group">
        &#60;span class="input-group-text">Username and password&#60;/span>
        &#60;input #username type="text" aria-label="username" class="form-control" placeholder="username" required>
        &#60;input #password type="text" aria-label="password" class="form-control" placeholder="password" required>
        &#60;button class="btn btn-outline-primary" type="submit" id="button-addon2">Login&#60;/button>

        &#60;div style="text-align: center;">&#123; &#123;message}}&#60;/div>
      &#60;/div>

      <b>// login.component.ts</b>
      export class LoginComponent &#123;
        @ViewChild('username') username!: ElementRef; // az felhasználónevet tartalmazó input element referenciájának tárolására
        @ViewChild('password') password!: ElementRef;  // a jelszót tartalmazó input element referenciájának tárolására

        private _authService: AuthService = inject(AuthService);

        message: string = '';
      
        onLogin() &#123;
          const username = this.username.nativeElement.value;
          const password = this.password.nativeElement.value;
      
          const user = this._authService.login(username, password);
      
          !user ? this.message = 'Incorrect credentials!' : this.message = `Hi there $&#123;user.name}!`;
        }
      }
    </pre>
    <li>A login gombra kattintást követően el kell döntenünk, hogy a felhasználónk jogosult-e a belépésre</li>
    <li>A template reference változó, és a viewchild dekorátor segítségével az input mezőkbe beírt értékek kinyerhetők
      a kontroller onLogin() függvényében</li>
    <li>A login komponensben való ellenőrzéshez meg kell hívnunk az auth service login() metódusát
      <ul>
        <li>User objektumot kapunk, ha van találat, ellenkező esetben undefined a visszatérési érték</li>
        <li>Majd a kapott eredmény alapján a message property-be kiírjuk, hogy mi lett a belépés eredménye</li>
      </ul>
    </li>
    <li>Sikeres login esetén navigáljunk el az about oldalra</li>
    <pre>
      !user ? this.message = 'Incorrect credentials!' : (this.message = `Hi there $&#123;user.name}!`, this._router.navigate(['..', 'angular', 'about']));
    </pre>
    <li>A logoff funkcionalitást is megvalósítjuk</li>
    <li>A kiválasztott dinamikus paraméterhez tarozó gomb a routerLinkActive végett piros színű</li>
    <pre>
      <b>// header.component.html</b>
      &#60;button class="btn btn-primary">&#60;a [routerLink]="['/', 'angular', 'login']" [routerLinkActive]="'btn-danger'"
        [queryParams]="&#123;logout: true}">Logout&#60;/a>&#60;/button>

      <b>// login.component.ts</b>
      ngOnInit(): void &#123;
        this._activeRouter.queryParamMap.subscribe(queries => &#123;
          const logout = Boolean(queries.get('logout')); // = !!queries.get('logout');
          if (logout) &#123;
            this._authService.logoff();
          }
        })
      }
    </pre>
    <li>Amennyiben az AuthService-ben létrehozunk egy BehaviorSubject-et, és a login/logoff függvényekben állítjuk az
      értékét, valamint feliratkozunk rá a header komponensben, úgy nyomon tudjuk követni, hogy éppen be vagyunk-e
      jelentkezve</li>
    <pre>
        <b>// auth.service.ts</b>
        isLoggedIn$: BehaviorSubject&#60;boolean> = new BehaviorSubject&#60;boolean>(false);

        login(username: string, password: string) &#123;
          ...
          this.isLoggedIn$.next(true);
        }

        logoff() &#123;
          ...
          this.isLoggedIn$.next(false);
        }
      
      <b>// header.component.html</b>
      isLoggedIn: &#123; &#123;isLoggedIn}}

      <b>// header.component.ts</b>
      ngOnInit(): void &#123;
        this._authService.isLoggedIn$.subscribe(val => &#123;
          this.isLoggedIn = val;
        });
      }
      </pre>
  </ul>
  <br>
  <h5 #routeguards data-anchor="routeguards">Route guards</h5>
  <ul>
    <li>Olykor szükség lehet arra, hogy valamilyen logikát lefuttassunk az előtt, hogy a user-t egy adott oldalra
      navigálnánk, vagy esetleg utána</li>
    <li>Rendkívül hasznos, mikor bizonyos felhasználók számára csak bizonyos oldalak elérését kívánjuk megengedni
      <ul>
        <li>Például csak a bejelentkezett felhasználók számára elérhető egy oldal</li>
        <li>Az elnavigálás előttre pedig jó példa lehet, hogy mondjuk a felhasználó változtatott a profil adatain, de
          úgy kezdeményez navigációt, hogy nem mentette el a változtatásokat
          <ul>
            <li>Ilyenkor confim ablakot dobhatunk számára, hogy biztosan "kilép"-e mentés nélkül</li>
          </ul>
        </li>
        <li>Ezek megvalósítására elérhető a Route Guards</li>
        <li>Route paramétereket validálhatunk az oldal megjelenítése előtt</li>
        <li>Akár adatot csatolhatunk</li>
      </ul>
    </li>
    <br>
    <li>Route Guards
      <ul>
        <li>Feltétel mentén döntést hozhatunk a segítségükkel arról, hogy a felhasználó navigálhat-e az oldalra, vagy
          elnavigálhat-e róla</li>
        <li>Route védelmet, logikák futtatását biztosítja</li>
        <pre>
          ng generate guard
        </pre>
        <li>Az Angularban összesen 5 Route Guard létezik
          <ol>
            <li>CanActivate
              <ul>
                <li>Akkor fut le, mielőtt egy komponenshez navigálunk</li>
                <li>Ellenőrzi, hogy a felhasználó hozzáfér-e az adott útvonalhoz (például jogosultsági szint,
                  bejelentkezés)</li>
                <li>Az olyan oldalak védelme, amelyekhez csak bejelentkezett felhasználók férhetnek hozzá.</li>
              </ul>
            </li>
            <li>CanActivateChild
              <ul>
                <li>Akkor fut le, amikor egy komponens gyermekeinek útvonalaihoz próbálunk navigálni</li>
                <li>Hasonló a `CanActivate`-hez, de kifejezetten gyermek útvonalakra vonatkozik</li>
                <li>Adminisztrációs oldalak vagy összetett hierarchiák kezelése, ahol a fő oldal és annak gyermek
                  oldalai is védelemre szorulnak</li>
              </ul>
            </li>
            <li>CanDeactivate
              <ul>
                <li>Akkor fut le, amikor egy komponensből elnavigálunk</li>
                <li>Ellenőrzi, hogy a felhasználó elhagyhatja-e az oldalt (például ha űrlap adatokat töltött ki, de még
                  nem mentette el)</li>
                <li>Űrlapok védelme az adatvesztés elkerülése érdekében.</li>
              </ul>
            </li>
            <li>Resolve
              <ul>
                <li>Akkor fut le, mielőtt egy útvonal betöltődik, és lehetővé teszi adatok előzetes lekérdezését</li>
                <li>Az oldal betöltése előtt előkészít egy vagy több adatot, így a komponens a már lekért adatokkal
                  töltődhet be</li>
                <li>Előre betöltött adatokkal rendelkező oldalak, például profiloldalak, ahol az adatot még az oldal
                  megjelenése előtt lekérjük</li>
                <li>Gyakran használatos SEO adatok előre betöltésére</li>
              </ul>
            </li>
            <li>CanLoad
              <ul>
                <li>Akkor fut le, mielőtt egy lazán betöltött modul (lazy-loaded module) betöltődik</li>
                <li>Megakadályozza egy modul betöltését, ha a felhasználó nem rendelkezik a szükséges jogosultságokkal
                </li>
                <li>Olyan modulok esetében, amelyeket csak speciális jogosultsággal rendelkező felhasználók tölthetnek
                  be, pl. adminisztrációs felület</li>
              </ul>
            </li>
          </ol>
        </li>
      </ul>
    </li>
    <li>Angular 15-től kezdve lehetőségünk van egy újabb módon implementálni a Route Guard-okat
      <ol>
        <li>Angular 14
          <ul>
            <li>Service class-t kellett létrehozni, ami megörökli azt az interface-t, amit a guard használni fog, majd
              az interface által nyújtott metódust alkalmazni</li>
            <pre>
              <b>// példa</b>
              export class AuthGuard implements CanActivate &#123; // CanActivate interface implementálása

                canActivate(): boolean &#123; // CanActivate interface által szolgáltatott metódus használata
                  if (/* your authentication condition */) &#123;
                    return true;
                  } else &#123;
                    this.router.navigate(['/login']);
                    return false;
                  }
                }
              }
            </pre>
            <li>Attól függően, hogy milyen guard-ot használunk, vagy boolean értékkel, vagy valamilyen adattal térünk
              vissza</li>
            <li>Végül a routes objektumunkban hozzárendeljük a guard service-t az útvonal route guard property-jéhez
            </li>
            <pre>
              <b>// példa</b>
              &#123;
                path: 'protected',
                component: ProtectedComponent,
                canActivate: [AuthGuard] // Itt rendeljük hozzá a guard szolgáltatást az útvonalhoz
              }
            </pre>
            <li>Röviden, a guardokat mindig @Injectable szolgáltatásokként kellett megírni különálló osztályok
              formájában, amelyek implementálták a megfelelő guard interfészeket (például CanActivate, CanLoad, stb.)
            </li>
            <li>Használható, de deprecated</li>
          </ul>
        </li>
        <li>Angular 15+
          <ul>
            <li>Nem szükséges többé service class-t létrehozni, és implementálni a megfelelő route guard service-t
              <ul>
                <li>Nincs külön osztály, kevesebb a kód, könnyebben tesztelhető, gyorsabban definiálható</li>
              </ul>
            </li>
            <li>Az új megközelítéssel egyszerű függvényekkel is létrehozhatók guardok, ami könnyebb és rugalmasabb</li>
            <li>A definiált függvényt szükséges megadni a routes objektum route guard property-jénél</li>
            <pre>
              <b>// példa</b>
              export const authGuard: CanActivateFn = (route, state) => &#123;
                return inject(AuthService).isLoggedIn();
              };

              &#123;
                path: 'protected',
                component: ProtectedComponent,
                canActivate: [authGuard] // függvény neve
              }
            </pre>
          </ul>
        </li>
      </ol>
    </li>
    <li>canActivate
      <ul>
        <li>A jogosulatlan felhasználókat meggátoljuk a route-ra való lépéstől</li>
        <li>Angular 14-
          <ul>
            <li>Implementálás lépései
              <ol>
                <li>Service létrehozása, amiben implementáljuk a CanActivate interface-t</li>
                <li>Szervizben a canActivate metódus létrehozása</li>
                <li>canActivate method-ból boolean-nal visszatérés</li>
                <li>Guard átadása route-nak</li>
              </ol>
            </li>
            <pre>
              <b>// navi-routing.module.ts</b>
              const routes: Routes = [
                ...
                &#123;
                  path: 'about', component: AboutComponent, children: [
                    &#123; path: ':id', component: AboutDetailsComponent, canActivate: [AuthGuardService] }
                  ]
                },
                ...
              ];

              <b>// auth-guard.service.ts</b>
              @Injectable(&#123;
                providedIn: 'root'
              })
              
              export class AuthGuardService implements CanActivate &#123;
                  authService: AuthService = inject(AuthService);
                  router: Router = inject(Router);
              
                  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&#60;boolean | UrlTree> | Promise&#60;boolean | UrlTree> | boolean | UrlTree &#123;
                      let isLoggedIn = this.authService.isAuthenticated();
              
                      if (!isLoggedIn) &#123;
                          this.router.navigate(['angular', 'login']);
                      }
              
                      return isLoggedIn;
                  }
              }

              <b>// auth.service.ts</b>
              ...
              isAuthenticated() &#123;
                return this.isLogged;
              }
            </pre>
            <li>A routingban a a canActivate guard egy tömb</li>
            <li>Ha az about page-en a goombokra bejelentkezés nélkül kattintunk, navigáció történik a login oldalra</li>
            <li>A canActivate metódus lefutásakor az AuthService-től elkérjük az isLogged boolean változó értékét</li>
          </ul>
        </li>
        <li>Angular 15+ (CanActivateFn)
          <ul>
            <pre>
              <b>// navi-routing.module.ts</b>
              const routes: Routes = [
                &#123; path: '', component: HomeComponent },
                &#123; path: 'home', component: HomeComponent },
                &#123;
                  path: 'about', component: AboutComponent, children: [
                    &#123; path: ':id', component: AboutDetailsComponent, canActivate: [CanActivate] }
                  ]
                },
              ]

              <b>// auth.guard.ts</b>
              export const CanActivate = () => &#123;
                const authService: AuthService = inject(AuthService);
                const router: Router = inject(Router);
            
                let isLoggedIn = authService.isAuthenticated();
            
                if (!isLoggedIn) &#123;
                    router.navigate(['angular', 'login']);
                }
            
                return isLoggedIn;
              }
            </pre>
            <li>Alapvetően a route-ban függvényt adunk át
              <ul>
                <pre>
                  &#123; path: ':id', component: AboutDetailsComponent, canActivate: [ () => &#123; return true } ] }
                </pre>
                <li>Ha nem egysoros kódot akarunk átadni, akkor máshol szükséges megfogalmaznunk a logikánkat</li>
              </ul>
            </li>
            <li>Ahhoz, hogy az auth.guard.ts fájlban lévő függvényt a route-ban tudjuk használni, exportálnunk kell a
              class-t
              <ul>
                <li>A függvényben definiáljuk az AuthService-t, és a Router-t</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>CanActivateChild
      <ul>
        <li>Child route-ra navigálás előtt fut le</li>
        <li>Nagyon hasonlít a CanActivate-re</li>
        <pre>
          &#123;
            path: 'about', component: AboutComponent, children: [
              &#123; path: ':id', component: AboutDetailsComponent, canActivate: [CanActivate] } // csak a child route-ot védi
            ]
          },

          &#123;
            path: 'about', component: AboutComponent, canActivate: [CanActivate], // a szülőt, és a gyerekeket is védi
            path: 'about', component: AboutComponent, children: [
              &#123; path: ':id', component: AboutDetailsComponent }
            ]
          },
        </pre>
        <li>A CanActivate a szülő, és a gyerek route-okat is védi</li>
        <li>A CanActivateChild akkor jön jól, ha a szülő komponenshez biztosítani szeretnénk hozzáférést - mondjuk -
          minden felhasználónak, de a gyerekekhez nem</li>
        <pre>
            &#123;
            path: 'about', component: AboutComponent, children: [
              &#123; path: ':id', component: AboutDetailsComponent, canActivate: [CanActivate] }
              ..., canActivate: [CanActivate],
              ..., canActivate: [CanActivate],
            ]
          },
          </pre>
        <li>A valóságban egy szülőnek akár 15-20 gyerek útvonala is lehet</li>
        <li>Ahelyett, hogy minden egyes gyerek route-on használjuk a canActivate guard-ot, a szülőre helyezhetjük a
          CanActvateChild guard-ot</li>
        <pre>
          &#123;
            path: 'about', component: AboutComponent, canActivateChild: [], children: [
              &#123; path: ':id', component: AboutDetailsComponent }
            ]
          },
        </pre>
        <li>A canActivateChild service class nevet, vagy függvényt fogad</li>
      </ul>
      <ol>
        <li>Angular 14-
          <ul>
            <pre>
              <b>// navi-routing.module.ts</b>
              &#123;
                path: 'about', component: AboutComponent, canActivateChild: [AuthGuardService], children: [
                  &#123; path: ':id', component: AboutDetailsComponent }
                ]
              },

              <b>// auth-guard.service.ts</b>
              canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&#60;boolean | UrlTree> | Promise&#60;boolean | UrlTree> | boolean | UrlTree &#123;
                let isLoggedIn = this.authService.isAuthenticated()
        
                if (!isLoggedIn) &#123;
                    this.router.navigate(['angular', 'login']);
                }
        
                return isLoggedIn;
              }

              canActivateChild(childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&#60;boolean | UrlTree> | Promise&#60;boolean | UrlTree> | boolean | UrlTree &#123;
                return this.canActivate(childRoute, state);
                // return this.canActivate(this.activeRoute.snapshot, this.router.routerState.snapshot);
              }
            </pre>
            <li>A route-nál, a canActivateChild property végett az Angular tudja, hogy a szervizben a canActivateChild
              metódust kell meghívnia</li>
          </ul>
        </li>
        <li>Angular 15+ (CanActivateChildFn)
          <ul>
            <pre>
              <b>// navi-routing.module.ts</b>
              &#123;
                path: 'about', component: AboutComponent, canActivateChild: [CanActivateChild], children: [
                &#123; path: ':id', component: AboutDetailsComponent }
                ]
              },

              <b>// auth.guard.ts</b>
              export const CanActivate = () => &#123;
                const authService: AuthService = inject(AuthService);
                const router: Router = inject(Router);
            
                let isLoggedIn = authService.isAuthenticated();
            
                if (!isLoggedIn) &#123;
                    router.navigate(['angular', 'login']);
                }
            
                return isLoggedIn;
              }
              
              export const CanActivateChild = () => &#123;
                  return CanActivate();
              }
            </pre>
            <li></li>
          </ul>
        </li>
      </ol>
      <ul>
        <li>Fontos megjegyezni, hogy ha a szülőn CanActivate guard-ot használunk, az vonatkozik a szülőre, és a
          gyerekekre is, viszont, ha CanActivateChild guard-ot használunk, akkor a szülő "védetlen" marad, csakis
          kizárólag a gyerekekre vonatkozik</li>
      </ul>
    </li>
    <li>CanDeactivate
      <ul>
        <li>Azt szeretnénk megvalósítani, hogy ha a user el akar navigálni a contact page-ről úgy, hogy félbehagyja a
          form kitöltését, gátoljuk meg a navigációt, figyelmeztessük a usert</li>
        <li>Angular 14-
          <ul>
            <pre>
              <b>// contact.coomponent.html</b>
              &#60;div class="row">
                &#60;div class="col-12 col-lg-4">
                    &#60;div class="input-group mb-3">
                        &#60;input type="text" class="form-control" placeholder="First name" [(ngModel)]="firstName">
                    &#60;/div>
                &#60;/div>
        
                &#60;div class="col-12 col-lg-4">
                    &#60;div class="input-group mb-3">
                        &#60;input type="text" class="form-control" placeholder="Last name" [(ngModel)]="lastName">
                    &#60;/div>
                &#60;/div>
        
                &#60;div class="col-12 col-lg-4">
                    &#60;textarea class="form-control" placeholder="Message"
                        [(ngModel)]="message">&#60;/textarea>
                &#60;/div>
            &#60;/div>
        
            &#60;input type="submit" class="btn btn-primary" value="Submit" (click)="onSubmit()">

            <b>// contact.coomponent.ts</b>
            firstName: string = '';
            lastName: string = '';
            message: string = '';

            isSubmitted: boolean = false;

            onSubmit() &#123;
              this.isSubmitted = true;
              this.firstName = '';
              this.lastName = '';
              this.message = '';
            }
          
            canExit() &#123;
              if ((this.firstName || this.lastName || this.message) && !this.isSubmitted) &#123;
                return confirm('Contact form have unsaved changes. Do you want to exit?');
              } else &#123;
                return true;
              }
            }

            <b>// auth-guard.service.ts</b>
            export class AuthGuardService implements CanActivate, CanActivateChild, CanDeactivate&#123;ContactComponent> &#123;
              ...
              canDeactivate(component: ContactComponent, currentRoute: ActivatedRouteSnapshot, currentState: RouterStateSnapshot, nextState: RouterStateSnapshot): Observable&#60;boolean | UrlTree> | Promise&#60;boolean | UrlTree> | boolean | UrlTree &#123;
                return component.canExit();
              }
            }

            <b>// navi-routing.module.ts</b>
            &#123; path: 'contact', component: ContactComponent, canDeactivate: [AuthGuardService] },
            </pre>
            <li>A CanDeactivate interface típusának ContactComponent-et adtunk meg</li>
            <li>A canDeactivate metódus 4 paramétert fogad
              <ol>
                <li>Component, aminek a típusa az a komponens, amin használni szeretnénk a guard-ot</li>
                <li>ActivatedRouteSnapshot, az aktuális útvonal pillanatfelvétele, amely információt ad az aktív route
                  paramétereiről</li>
                <li>RouterStateSnapshot, A jelenlegi router állapotának pillanatfelvétele, amely tartalmazza az aktuális
                  útvonal teljes hierarchiáját</li>
                <li>RouterStateSnapshot (opcionális), A következő router állapotának pillanatfelvétele, amely az útvonal
                  célját és annak hierarchiáját jelzi</li>
              </ol>
            </li>
            <li>Valamilyen módon/formában boolean értéket kell visszakapnunk a függvényből</li>
            <li>Amennyiben a felhasználó már beírt valamit a mezőkbe, szeretnénk tudni, hogy valóban el akar-e navigálni
            </li>
            <li>A confirm függvény true value-t ad vissza, ha a felhasználó az 'OK' gombra kattint, és false-t, ha a
              Cancel-re</li>
            <li>A canExit metódus alapján döntjük el, hogy történik-e navigálás</li>
            <li>A canDeactivate metódusunkban van egy példányunk a komponensből
              <ul>
                <li>Így a komponensen meg tudjuk hívni a canExit függvényt</li>
              </ul>
            </li>
            <li>Jelen konstellációban csakis kizárólag a ContactComponent-en használhatjuk a CanDeactivate guard-ot
              <ul>
                <li>Használhatunk egy interface-t az auth-guard.service-ben (class és Injectable előtt)</li>
                <pre>
                  <b>// auth-guard.service.ts</b>
                  export interface DeactivateComponent &#123;
                    canExit: () => &#123;}
                  }

                  @Injectable(&#123;
                    providedIn: 'root'
                  })

                  export class AuthGuardService implements CanActivate, CanActivateChild, CanDeactivate&#60;DeactivateComponent> &#123;
                    canDeactivate(component: DeactivateComponent, currentRoute: ActivatedRouteSnapshot, currentState: RouterStateSnapshot, nextState: RouterStateSnapshot): Observable&#60;boolean | UrlTree> | Promise&#60;boolean | UrlTree> | boolean | UrlTree &#123;
                      return component.canExit();
                    }
                  }

                  <b>// contact.component.html</b>
                    export class ContactComponent implements DeactivateComponent &#60;
                      ...
                      canExit() &#123;
                        if ((this.firstName || this.lastName || this.message) && !this.isSubmitted) &#123;
                          return confirm('Contact form have unsaved changes. Do you want to exit?');
                        } else &#123;
                          return true;
                        }
                      }
                    }                  
                </pre>
                <li>Ettől kezdve bármelyik komponensen szeretnénk használni a canDeactivate metódust, annak a
                  komponensnek örökölnie kell (implementálni kell benne) a DeactivateComponent-et
                  <ul>
                    <li>Ahol a Deactivate interface-t implementáljuk, annak a komponensnek rendelkezdnie kell canExit
                      metódussal</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Angular 15+
          <ul>
            <li>Szintén függvényt vár a route
              <ul>
                <li>A névtelen függvénynek ezúttal bemeneti paramétere is van</li>
                <li>A bemeneti paraméternek pedig típust szükséges megadnunk, ami komponens osztály típusú</li>
                <pre>
                  &#123; path: 'contact', component: ContactComponent, canDeactivate: [(component: ContactComponent) => &#123;return component.canExit()}] },
                </pre>
                <li>Az interface most a szervizben maradt, de természetesen máshol illik ilyenkor elhelyezni</li>
                <li>A guard függényünket máshol is létrehozhatjuk, nem kötelező a route-nál megadni</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Resolve
      <ul>
        <li>Akkor használjuk, ha valamilyen adatot szeretnénk betölteni navigálás előtt</li>
        <li>A valóságban nem lokális változókból érkeznek a különféle tömbelemek, hanem adatbázisból, API-on keresztül
          <ul>
            <li>Az adathalmaz lekérésének ideje másodpercekbe is telhet</li>
            <li>HTTP kérés-választ fogunk szimulálni</li>
          </ul>
        </li>
        <pre>
          <b>// about.component.html</b>
          &#60;div class="input-group">
            &#60;span class="input-group-text" id="basic-addon1">
                &#60;span *ngIf="!searchLoading">Search&#60;/span>
                &#60;div *ngIf="searchLoading" class="spinner-border spinner-border-sm text-warning" role="status">
                    &#60;span class="sr-only">&#60;/span>
                &#60;/div>
            &#60;/span>
            &#60;input type="text" class="form-control" placeholder="Query string" aria-label="Query string"
                [(ngModel)]="searchString" (keyup)="onFilterChange()">
          &#60;/div>

          &#60;ng-container *ngIf="aboutData.length; else listloading">
            &#60;div *ngFor="let data of aboutData">
                &#60;button [routerLink]="['/', 'angular', 'about', data.id]" [routerLinkActive]="'btn-danger'" type="button"
                    class="btn btn-secondary">
                    #&#123; &#123;data.id}} &#123; &#123;data.label}}
                &#60;/button>
            &#60;/div>
            &#60;router-outlet>&#60;/router-outlet>
          &#60;/ng-container>
    
          &#60;ng-template #listloading>
              &#60;span *ngIf="searchLoading">Loading...&#60;/span>
              &#60;span *ngIf="searchString && !searchLoading">No results...&#60;/span>
          &#60;/ng-template>

          <b>// about.component.ts</b>
          if (this.searchString === undefined || this.searchString === '') &#123;
            this.aboutDetailsService.getAllDetails().subscribe((details) => &#123; // típus meghatározás: (details: Details[])
              this.aboutData = details.map(detail => &#123;
                return &#123; id: detail.id, label: detail.title };
              });
              this.searchLoading = false;
            });
          } else &#123;
            this.aboutDetailsService.getAllDetails().subscribe(details => &#123;
              this.aboutData = details
                .map(data => (&#123; id: data.id, label: data.title }))
                .filter(data => data.label.toLowerCase().includes(this.searchString.toLowerCase()));
              this.searchLoading = false;
            });
          }

          onFilterChange() &#123;
            this.searchLoading = true;
            this._router.navigate(['.'], &#123; relativeTo: this._activeRoute, queryParams: &#123; search: this.searchString } });
          }

          <b>// about-details.service.ts</b>
          aboutDetailsArray: any[] = [
            &#123; id: 1, title: 'Mind what', text: 'Mind what no...' },
            &#123; id: 2, title: 'Started joy', text: 'Started several mistake...' },
            &#123; id: 3, title: 'Unpleasant excellence', text: 'Unpleasant nor...' },
            &#123; id: 4, title: 'Ecstatic endeavor', text: 'Dissuade ecstatic and....' },
            &#123; id: 5, title: 'Talking improve', text: 'Oh to talking...' },
          ];

          getAllDetails() &#123;
            return new Observable&#60;any[]>((sub) => &#123;
                setTimeout(() => &#123; // első oparaméter a callback function
                    sub.next(this.aboutDetailsArray);
                }, 3000) // második paraméter a timer
            });
            // return this.aboutDetailsArray; // korábbi lekérdezéshez volt szükséges
          }
        </pre>
        <li>A getAllDetails függvény ahelyett (korábbi állapot/verzió helyett) nem adja vissza azonnal a
          aboutDetailsArray tömböt, hanem egy Observable-t hoz létre, és a setTimeout segítségével 3 másodperc
          késleltetéssel küldi el az adatokat a subscribereknek</li>
        <li>Az about komponensben található keresés mező értékének változásával megváltoztatjuk a search query
          paramétert, és ezzel együtt egy boolean értéket igazzá teszünk
          <ul>
            <li>A boolean határozza meg, hogy a töltés szimbólum megjelenik-e az input mező előtt</li>
          </ul>
        </li>
        <li>Az about kontrollerében feliratkozunk a query param változásokra, és attól függően, hogy mi a query param
          értéke, lekérjük az about details komponensben található tömböt, valamint a már említett boolean változót
          false értékbe állítjuk</li>
        <br>
        <li>A következőkben azt fogjuk megvalósítani, hogy csak akkor tudjunk navigálni az oldalra, ha már betöltődtek
          az adatok</li>
        <li>Resolve guard implementálása
          <ul>
            <li>Angular 14-
              <ol>
                <li>Service class készítése, ami örökli a Resolve interface-t (implements Resolve)
                  <ul>
                    <li>Adatot fog magából emit-álni</li>
                  </ul>
                </li>
                <li>resolve metódus létrehozása
                  <ul>
                    <li>Paraméterként ActivatedRouteSnapshot-ot, és RouterStateSnapshot-ot fogad</li>
                  </ul>
                </li>
                <li>About-details szerviz injektálása</li>
                <li>resolve property route-hoz adása
                  <ul>
                    <li>Más guard-októl eltérően objektumot fogad</li>
                    <li>Egy választható kulcsot, és a szerviz nevét</li>
                  </ul>
                </li>
              </ol>
              <ul>
                <li>Mivel az útvonalra ráraktuk a Resolve guardot, és megadtuk a service nevét, és az útvonal megkeresi
                  a szervizben az implementált resolve metódust</li>
                <li>A resolve function-ben visszaadott érték a route-ban lévő resolve property-ben lévő objektum
                  általunk megadott kulcsnak kerül átadásra
                  <ul>
                    <li>&#123;details: *resolve metódus által visszaadott érték*}</li>
                  </ul>
                </li>
                <li>A route resolve-jában megadott útvonal elérhető az ActivatedRoute-ban</li>
                <li>Annak érdekében, hogy ne legyen minden kattintásnál blokkolva az about page, a footerből elérhető
                  Resolve oldalra került rá a guard, így arra kattintva 3mp-ig nem történik meg az oda navigálás
                  <ul>
                    <li>Azaz addig, amíg az about-details.service.ts-ben lévő setTimeout véget nem ér</li>
                  </ul>
                </li>
              </ul>
            </li>
            <pre>
              <b>// navi-routing.module.ts</b>
              &#123; path: 'resolve', component: ResolveComponent, resolve: &#123; details: AuthGuardService } },

              <b>// auth-guard.service.ts</b>
              export class AuthGuardService implements CanActivate, CanActivateChild, CanDeactivate&#60;DeactivateComponent>, Resolve&#60;any[]> &#123; // any[] helyett lehetne Detail[]
                ...
                resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): any[] | Observable&#60;any[]> | Promise&#60;any[]> &#123; // ha Detail[]-öt specifikáltunk volna az implementálásánál, akkor Detail[] lehetne a visszatérési érték típusa
                  /*
                  let detailList: any[] = []
                  this.aboutDetailsService.getAllDetails().subscribe((details: any[]) => &#123; // aszinkron művelet, így a detailList = [] előbb fog visszatérni
                      details = detailList;
                  });
                  return detailList;
                  */
          
                  return this.aboutDetailsService.getAllDetails(); // így Observable-lel térünk vissza, hiszen a getAllDetails metódus Observable-lel tér vissza
                }
              }
            </pre>
            <li>Angular 15+
              <ul>
                <li>A route-nál az objektumban nem service class-t adunk meg, hanem egy függvényt
                  <ul>
                    <li>resolve: &#123; details: () => &#123; } }</li>
                    <li>Nem egysoros logika esetén érdemes a függvényt máshol megírni</li>
                  </ul>
                </li>
                <li>A függvényünkben az auth-details service injektására van szükség</li>
                <pre>
                  <b>// navi-routing.module.ts</b>
                  &#123; path: 'resolve', component: ResolveComponent, resolve: &#123; details: resolve } },
  
                  <b>// auth.guard.ts</b>
                  export const resolve = () => &#123;
                    const aboutDetailsService: AboutDetailsService = inject(AboutDetailsService);
                    return aboutDetailsService.getAllDetails();
                  }
                </pre>
                <li>Az adatok "betöltése" közben a felhasználó nem tudja, mi zajlik a háttérben</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Ne felejtsük el, hogy amelyik route-hoz csatoljuk a Resolve guardot, tulajdonképpen ahhoz a roue-hoz
          adatokat is csatolunk
          <ul>
            <li>Be fogja tölteni az adatokat, mielőtt a route-ra navigálna az Angular</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #navigationevents data-anchor="navigationevents">Navigation events</h5>
  <ul>
    <li>Azok a speciális események, amelyek az Angular Router moduljában következnek be egy navigációs folyamat során
      <ul>
        <li>Például egy új oldalra vagy útvonalra való áttéréskor</li>
      </ul>
    </li>
    <li>A navigáció során a Router különböző eseményeket generál, amelyekre feliratkozhatunk és figyelhetünk
      <ul>
        <li>Lehetőséget ad például töltés szimbólumok megjelenítésére</li>
      </ul>
    </li>
    <li>Az egyik route-ról a másik route-ra áttérve a háttérben navigációs események láncolata következik be
      <ul>
        <li>A navigáció kezdetétől a navigáció végéig jelen vannak</li>
      </ul>
    </li>
    <li>A RouterModule importálásánál a forRoot metódusnak adhatunk második paraméterként egy anonymous object-et
      <ul>
        <li>Ebben az objektumban engedélyezhetjük a route váltáskor a háttérben zajló események logolását a DevTools
          Console fülére</li>
      </ul>
    </li>
    <pre>
      <b>// app-routing.module.ts</b>
      @NgModule(&#123;
        imports: [RouterModule.forRoot(routes, &#123;
          enableTracing: true,
        })],
        exports: [RouterModule]
      })
    </pre>
    <li>Olykor érdemes a fontosabb event-ekre feliratkozni, és valamilyen logikát végrehajtani</li>
    <li>A Resolve guard-nál megoldottuk, hogy a navigációs példában, ha a footerben lévő Resolve menüpontra kattintunk,
      akkor az oldal csak 3mp múlva töltődjön be (szimulált adatlekérés, ami időbe telik)
      <ul>
        <li>A felhasználónak mindeközben fogalma sincs, mi történik, hiheti azt, hogy nem is elérhető a kért oldal</li>
        <li>Kattintáskor 'NavigationStart', a template betöltődésekor pedig 'NavigationEnd' event történik</li>
      </ul>
    </li>
    <li>Navigációs eseményekkel megoldható, hogy amíg - mondjuk - töltődik egy oldal, addig valamiképp jelezzük a
      felhasználónak, hogy éppen töltés zajlik
      <pre>
      <b>// navi.component.html</b>
      &#60;app-header>&#60;/app-header>
      &#60;div class="navi">
        &#60;div class="navi-content">
            &#60;router-outlet>&#60;/router-outlet>
            &#60;router-outlet name="navi">&#60;/router-outlet>
            &#60;router-outlet name="test">&#60;/router-outlet>
        &#60;/div>
        &#60;div *ngIf="showLoader" class="navi-overlay">
            &#60;div class="navi-loader">
                &#60;div class="spinner-border text-warning" role="status">
                    &#60;span class="visually-hidden">Loading...&#60;/span>
                &#60;/div>
            &#60;/div>
        &#60;/div>
      &#60;/div>
      &#60;app-footer>&#60;/app-footer>

      <b>// navi.component.scss</b>
      .navi &#123;
        position: relative;
    
        .navi-content &#123;
            display: grid;
            height: 400px;
            overflow: auto;
            padding: 1em;
        }
    
        .navi-overlay &#123;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000000;
            opacity: .5;
        }
      }

      <b>// navi.component.ts</b>
      private _router: Router = inject(Router);
      showLoader: boolean = false;

      ngOnInit(): void &#123;
        this._router.events.subscribe((routerEvent: Event) => &#123; // callback function, ami az event object-et kapja meg
        if (routerEvent instanceof NavigationStart) &#123;
          // if (routerEvent.url === '/angular/resolve') &#123; // arra lenne hivatott, hogy ha a contact page-ről elnavigálunk, de a confirm-nél Cancel-re kattintunk, ne jöjjön elő az overlay, de a lenti NavigationCancel sokkal elegánsabb
          this.showLoader = true;
          // }
        }

          if (routerEvent instanceof NavigationEnd || routerEvent instanceof NavigationCancel || routerEvent instanceof NavigationError) &#123; // NavigationError, hogy ha hiba történik, ne maradjon ott az overlay
            // if (routerEvent.url === '/angular/resolve') &#123;
            this.showLoader = false;
            //}
          }
        })
      }

      <b>// navi-routing.module.ts</b>
      &#123; path: 'resolve', component: ResolveComponent, resolve: &#123; details: resolve } },

      <b>// auth-guard.service.ts</b>
      resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): any[] | Observable&#60;any[]> | Promise&#60;any[]> &#123;
        return this.aboutDetailsService.getAllDetails();
      }

      <b>// about-details.service.ts</b>
      getAllDetails() &#123;
        return new Observable&#60;any[]>((sub) => &#123;
            setTimeout(() => &#123;
                sub.next(this.aboutDetailsArray);
            }, 3000);
        });
      }
      </pre>
      <ul>
        <li>A router event-ekkel való műveletekhez szükséges injektálni a Router egy példányát</li>
        <li>A Router-nek feliratkozunk az event-jeire
          <ul>
            <li>Az event metódus egy Observable, Event típusú adatot fog kibocsátani</li>
            <li>Bármilyen route event érkezik, és a 'routerEvent' változó tárolja az éppen aktuális eseményt
              <ul>
                <li>A 'routerEvent' Event típusú</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A végeredmény, hogy ha a resolve page-re navigálunk, akkor amíg le ne telik a 3 másodperc, amit a
          getAllDetails függvényben van definiálva, addig egy overlay-t láthatunk a content előtt, és spinnerrel a
          közepén</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #routedata data-anchor="routedata">Route data</h5>
  <ul>
    <li>Statikus és dinamikus adatot is tudunk átadni</li>
    <li>A query paramétertől (?search=term), és a route paramétertől (/users/:id) eltérő megoldás</li>
    <li>Az about page-en fogjuk megvalósítani az adat átadást, amikor a goombokra kattinttunk</li>
    <li>Stattikus adat
      <ul>
        <pre>
          <b>// navi-routing.module.ts</b>
          const routes: Routes = [
            ...
            &#123;
              path: 'about', component: AboutComponent, canActivateChild: [CanActivateChild], children: [
                &#123; path: ':id', component: AboutDetailsComponent, data: &#123; order: 'test', price: 2990} }
              ]
            },
            ...
          ]

          <b>// about-details.component.html</b>
          &#123; &#123;dataFromRoute | json}}

          <b>// about-details.component.ts</b>
          dataFromRoute = &#123;};

          ngOnInit(): void &#123;
            this._activeRouter.data.subscribe(data => &#123;
              this.dataFromRoute = data;
            });
          }
        </pre>
        <li>Statikus adatot adtunk át a '/angular/about/:id' útvonalnak</li>
        <li>Amikor csak az Observable (data) adatot emit-ál, átadja a statikus adat értékét a callback függvény
          paraméterének, amit a data változón keresztül érhetünk el.</li>
      </ul>
    </li>
    <li>Dinamikus adat
      <ul>
        <pre>
          <b>// navi-routing.module.ts</b>
          const routes: Routes = [
            ...
            &#123;
              path: 'about', component: AboutComponent, canActivateChild: [CanActivateChild], children: [
                &#123; path: ':id', component: AboutDetailsComponent } } // nincs data
              ]
            },
            ...
          ]

          <b>// about.component.html</b>
          &#123;div *ngFor="let data of aboutData">
            &#123;button [routerLink]="['/', 'angular', 'about', data.id]" [state]="data" // state attribútum
            [routerLinkActive]="'btn-danger'" type="button" class="btn btn-secondary">
                #&#123; &#123;data.id}} &#123; &#123;data.label}}
            &#123;/button>
          &#123;/div>
          &#123;router-outlet>&#123;/router-outlet>

          <b>// about-details.component.html</b>
          &#123; &#123;dataFromRoute | json}}

          <b>// about-details.component.ts</b>
          dataFromRoute: any;

          constructor() &#123;
            ...
            this.dataFromRoute = this._router.getCurrentNavigation()?.extras.state; // ngOnInit-ben nem működik
            // history.state // ngOnInit-ben is működik
          }
        </pre>
        <li>Ilyen módon a state-tel elkérjük az adott dinamukus route-hoz tartozó adatot, amit a gyerek route-on meg
          tudunk kaparintani</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #naviexample id="jumpToExample" data-anchor="naviexample">Navigation example</h5>
  <div class="rounded-border" style="background-color: #3c3c3c">
    <app-navi [tempSwitcher]="'default'"></app-navi>
  </div>
</div>

<div>
  <h3 #pipes data-anchor="pipes">Pipes</h3>
  <ul>
    <li>Segítségükkel adatot alakíthatunk át még azelőtt, hogy a UI-on megjelenne</li>
    <li>Bemenetként megkapják az eredeti adatot, változást hajtanak végre (formai, vagy egyéb)</li>
    <br>
    <li>uppercase pipe
      <ul>
        <li>String karakterlánc minden betűjét nagybetűsíti</li>
        <li>&#123; &#123; string | uppercase }}</li>
      </ul>
    </li>
    <li>lowercase pipe
      <ul>
        <li>String karakterlánc minden betűjét kisbetűsíti</li>
        <li>&#123; &#123; string | lowercase }}</li>
      </ul>
    </li>
    <li>date pipe
      <ul>
        <li>String, Number, és Date típusokon lehet alkalmazni</li>
        <li>Paramétereket is fogad
          <ol>
            <li>format (optional)</li>
            <li>timezone (optional)</li>
            <li>locale (optional)</li>
          </ol>
        </li>
        <pre>
          Original (new Date()): Thu Aug 12 1993 02:00:00 GMT+0200 (Central European Summer Time)
          &#123; &#123; student.birth | date: 'yyyy-MM-dd': undefined: undefined }} // timezone és locale marad default érték: undefined
          Result: 1993-08-12
        </pre>
        <li>Amikor pipe-nak paramétert akarunk átadni, kettősponttal tesszük</li>
        <li></li>
      </ul>
    </li>
    <li>percent pipe
      <ul>
        <li>Áttranszformálja a számot/stringet egy százalékértékké (string)</li>
        <pre>
          Original: 0.5666666666666667
          &#123; &#123; (student.marks / totalMarks) | percent }}
          Result: 57%

          Original:
          &#123; &#123; (student.marks / totalMarks) | percent: '3.1-3' }}
          Result: 057,667%

          Original:
          &#123; &#123; (student.marks / totalMarks) | percent: '2.1-2' }} // minIntegerDigits.minFractionDigits-MaxFractionDigits
          Result: 57,67%
        </pre>
        <li>A paraméter első száma azt jelenti, hogy az egész számjegyek számának legalább mennyinek kell lennie</li>
        <li>A pont utáni rész azt jelzi, hogy legalább mennyi, de legfeljebb mennyi tizedesjegyet kell megjeleníteni
        </li>
      </ul>
    </li>
    <li>currency pipe
      <ul>
        <li>Számot alakít át pénznemre (string)</li>
        <li>Az input szám és string lehet</li>
        <pre>
          // Az applikációnk globális locale-je 'en-US'
          Original: 1990
          &#123; &#123; student.fees | currency }}
          Result: $1,990.00	

          // Az applikációnk globális locale-je 'hu-HU'
          Original: 1990
          &#123; &#123; student.fees | currency }}
          Result: 1 990,00 USD	

          Original: 1990
          &#123; &#123; student.fees | currency: 'HUF' }}
          Result: 1 990,00 HUF

          Original: 1990
          &#123; &#123; student.fees | currency: 'hello' }}
          Result: 1 990,00 hello

          Original: 1990
          &#123; &#123; student.fees | currency: 'INR': true: '2.2-3': 'en-US' }} // a locale-t a globális beállítás miatt vissza kellett állítani en-US, hogy szimbólum tudjon megjelenni
          Result: ₹1,990.00

          Original: 1990
          &#123; &#123; student.fees | currency: 'INR': false: '2.1-3': 'en-US' }} // a locale-t a globális beállítás miatt vissza kellett állítani en-US, hogy szimbólum tudjon megjelenni
          Result: INR1,990.0	

        </pre>
        <li>Paraméterek
          <ol>
            <li>currencyCode (string - ISO4217)</li>
            <li>display (string / boolean)
              <ul>
                <li>code: pénznem kódja (USD)</li>
                <li>symbol: pénznem szimbóluma ($)</li>
                <li>symbol-narrow: pénznem rövidített szimbóluma (CA$ helyett $)</li>
              </ul>
            </li>
            <li>digitInfo
              <ul>
                <li>minIntegerDigits.minFractionDigits-MaxFractionDigits</li>
              </ul>
            </li>
            <li>locale</li>
          </ol>
        </li>
      </ul>
    </li>
    <li>Lehetőség van láncba kötni pipe-okat
      <ul>
        <li>A formázás a sorrenden alapul</li>
        <li>A második pipe az első pipe kimenetét formázza, és így tovább</li>
        <pre>
          Original (new Date()): Thu Aug 12 1993 02:00:00 GMT+0200 (Central European Summer Time)
          &#123; &#123; student.birth | date: 'fullDate' }}
          Result: 1993. augusztus 12., csütörtök
          &#123; &#123; student.birth | date: 'fullDate' | uppercase }}
          Result: 1993. AUGUSZTUS 12., CSÜTÖRTÖK
        </pre>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #custompipe data-anchor="custompipe">Creating custom pipe</h5>
  <ul>
    <li>3 egyszerű lépéssel léttrehozható
      <ol>
        <li>Typescript class létrehozása, és exportálása
          <ul>
            <li>A neve egyezményesen 'Pipe'-ra végződik</li>
          </ul>
        </li>
        <li>Az osztály @Pipe dekorátorral való elláttása</li>
        <li>PipeTransform interface öröklés és transform metódus implementálás</li>
      </ol>
    </li>
    <li>Készítsünk egy olyan percent pipe-ot, aminek meg lehet adni paraméterként a teljes mennyiség darabszámát,
      azaz nem egy osztásra fogjuk rárakni, hanem egy számra
      <ul>
        <li>Fájlnév: *name*.pipe.ts</li>
        <li>A dekorátorba kerülő metadata objektumban meghatározhatjuk a pipe nevét</li>
        <pre>
          @Pipe(&#123;
            name: 'procent'
          })
        </pre>
        <li>Ahhoz, hogy használni lehessen a pipe-ot, az aktuális modulunkban deklarálni szükséges
          <ul>
            <li>Ezen projekt esetében a shared modulban</li>
            <pre>
              <b>// shared.module.ts</b>
              @NgModule(&#123;
                declarations: [
                  ...
                  ProcentPipe
                ],
                ...
              })

              <b>// app.module.ts</b>
              @NgModule(&#123;
                imports: [
                  ...
                  SharedModule
                ],
              })
            </pre>
          </ul>
        </li>
        <li>A pipe használatakor a transform method fog meghívódni</li>
        <pre>
          transform(value: any, ...args: any[]) &#123;
            ...
          }
        </pre>
        <li>A transform első paramptere az az érték, amin a pipe-ot használjuk, a második paramétere pedig a
          template-ben a pipe-nak megadott paraméterek</li>
        <li>A ...args argomentum azt segíti, hogy ne kelljen meghatározni, hogy hány paramétere van a pipe-nek
          <ul>
            <li>Spread operátor a ...</li>
            <li>A pipe-nak átadott második, harmadik, és így tovább, paramétereket gyűjti össze</li>
            <li>Akkor van rá szükség, ha változó számú argomentumot kap/kaphat a pipe</li>
            <li>Az alábbi módon lokálisan eltárolhatjuk az első paraméter (value) után érkező argomentumokat</li>
            <pre>
              transform(value: any, ...args: any[]) &#123;
                const [arg1, arg2] = args; // arg1 a pipe 2. argomentuma, arg2 a pipe 3. argomentuma
              }
            </pre>
            <li>Ez a teljesen általános használata, de nyugodtan személyre is szabhatjuk a pipe transform paramétereit,
              azok típusát</li>
            <pre>
                transform(value: number, total: number) &#123;
                  ...
                }

                transform(value: any, args: [number, number]) &#123; // itt már nincs értelme a spread operátornak, mert fixen 2 számot definiálunk
                  ...
                }
              </pre>
          </ul>
        </li>
        <pre>
          <b>// procent.pipe.ts</b>
          @Pipe(&#123;
            name: 'procent'
          })
          
          export class ProcentPipe implements PipeTransform &#123;
            transform(value: any, args: [number, number?]) &#123;
              const [total, fraction] = args;
              return (((value / total) * 100).toFixed(fraction || 0)).toString() + '%';
          }

            transform(value: any, ...args: any[]) &#123; // változó számú argomentum esetén
              const [total, fraction] = args;
              return (((value / total) * 100).toFixed(fraction || 0)).toString() + '%';
            }
          }

          <b>// piping.component.ts</b>
          &#123; &#123; student.marks | procent: [totalMarks, 2] }} // fix számú argomentum esetén

          &#123; &#123; student.marks | procent: totalMarks: 2 }} // változó számú argomentum esetén
        </pre>
        <li>A toFixed egy olyan függvény, ami integer-t fogad, és a paraméterével azt határozzuk meg, hogy hány digit
          jelenjen meg a tizedesvessző után</li>
        <li>A [number, number?] típusmegadással úgy is működőképes marad a pipe-unk, ha nem adunk meg második tömbelemet
          a második argomentumban [totalMarks]
          <ul>
            <li>Ebben az esetben a fraction 0 lesz</li>
            <li>Illetve ezen típus definiálásával meghatároztuk, hogy a pipe-unk argomentumként egy tömböt vár, két
              elemmel
              <ul>
                <li>Egy kötelezőt (első), és egy opcionálisat (második)</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #customfilterpipe data-anchor="customfilterpipe">Custom filter pipe</h5>
  <ul>
    <li>A lentebb lévő példában fogjuk megoldani a filter dropdown szűrését</li>
    <li>A pipe-ot ehhez a students tömbön használjuk
      <ul>
        <li>A transform függvényünk első paramétereként fog érkezni a student tömb</li>
      </ul>
    </li>
    <li>Szükségünk lesz továbbá arra az értékre, ami alapján szűrni szeretnénk
      <ul>
        <li>Ez lesz a 'filterLabel', ami none, male, female értéket vehet fel</li>
        <li>Amennyiben none érkezik a filterBy paraméteren keresztük, akkor a teljes listával vissza is térünk, hiszen
          nincs szükség szűrésre
          <ul>
            <li>Abban az esetben is így teszünk, ha üres string érkezik a filterBy-ba, vagy ha a lista üres</li>
          </ul>
        </li>
      </ul>
    </li>
    <pre>
      <b>// piping.component.html</b>
      &#60;div class="filter-dropdown">
        &#60;button class="btn btn-secondary dropdown-toggle dark" type="button" id="filter1"
            data-bs-toggle="dropdown" aria-expanded="false">
            Filter: &#123; &#123; filterLabel }}
        &#60;/button>
        &#60;ul class="dropdown-menu dropdown-menu-dark" aria-labelledby="filter1">
            &#60;li *ngFor="let fd of filterDropdown; let index = index">
                &#60;a class="dropdown-item" [ngClass]="&#123;'active': fd.active}" (click)="onFilterChange(index)">
                  &#123; &#123;fd.label}}
                &#60;/a>
            &#60;/li>
        &#60;/ul>
      &#60;/div>

      &#60;tr *ngFor="let student of students | filter: filterLabel">
        ...
      &#60;/tr>

      <b>// piping.component.ts</b>
      export class PipingComponent implements OnInit &#123;
        private _studentService: StudentService = inject(StudentService);
      
        students: Student[] = []
        totalMarks: number = 0;
      
        filterDropdown: any[] = [
          &#123; label: 'none', active: true },
          &#123; label: 'female', active: false },
          &#123; label: 'male', active: false },
        ]
        filterLabel: string = '';
      
        ngOnInit(): void &#123;
          this.students = this._studentService.students;
          this.totalMarks = this._studentService.totalMarks;
          this.onFilterChange();
        }
      
        onFilterChange(index = 0) &#123;
          this.filterDropdown.forEach(f => f.active = false);
          this.filterDropdown[index].active = true;
          this.filterLabel = this.filterDropdown[index].label;
        }
      }

      <b>// filter.pipe.ts</b>
      @Pipe(&#123;
        name: 'filter',
        pure: true
      })
      
      export class FilterPipe implements PipeTransform &#123;
          transform(list: Student[], filterBy: string) &#123; // a Student[] típus meghatározza, hogy csak ilyen típust fogadhat, szóval nem lesz általánosan használható a pipe listák szűrésére
              if (filterBy === 'none' || filterBy === '' || !list.length) &#123;
                  return list;
              }
      
              return list.filter(student => student.gender === filterBy); // anonym callback function
          }
      }
    </pre>
    <li>A filter method a megadott feltétel mentén eldönti, hogy amit majd az összes tömbelemen való loop-olás
      befejeztével visszaad, új tömb, milyen elemeket tartalmazzon
      <ul>
        <li>Paraméterként callback függvényt kér</li>
        <li>Csak azokat az elemeket adja vissza az új tömbben, amelyekre a callback true-t ad vissza</li>
      </ul>
    </li>
    <li>A filter-ezést, sort-olás megvalósítható pipe-pal, de nem tartozik a best practice-ek közé</li>
  </ul>
  <br>
  <h5 #pureandimpurepipe data-anchor="pureandimpurepipe">Pure and impure pipe</h5>
  <ol>
    <li>Pure
      <ul>
        <li>Alapértelmezetten minden pipe pure pipe</li>
        <li>A pipe csak akkor fut le, ha a bemeneti érték (value) ténylegesen változik</li>
        <li>Ha ugyanazt az adatot kapja, akkor nem hajt végre újraszámítást
          <ul>
            <li>A pipe első paramétere (value), amin alkalmazzuk a pipe-ot</li>
            <li>Alkalmazás teljesítmény növelés érdekében</li>
          </ul>
        </li>
        <li>Bármikor egy primitív típusnak változik meg az értéket, az "pure change"
          <ul>
            <li>Primitív típusok: string , number , bigint , boolean , symbol , null és undefined</li>
          </ul>
        </li>
        <li>Ha referencia típus esetében referencia változás történik, az szintén "pure change"
          <ul>
            <li>Referencia típusok: object, array, function, map és set</li>
            <li>Például tömbhöz elemet hozzáadva nem fog lefutni egy pure pipe, mivel az nem egy "pure change", nem
              változik meg vele a tömb referenciája
              <ul>
                <li>A tömb változik, de a referenciája nem</li>
              </ul>
            </li>
            <li>Ha mondjuk rest operátorral lemásoljuk a tömböt, megváltozik a referenciája a tömbnek, és máris "pure
              change" történik
              <ul>
                <li>A beágyazott elemek (itt nincsenek) referenciája változatlan marad, hiszen shallow copy-t végzünk
                  csak</li>
              </ul>
              <ul>
                <pre>
                  <b>// student.service.ts</b>
                  createNewStudent(
                    name: string,
                    gender: string,
                    birth: Date,
                    course: string,
                    marks: number,
                    fee: number) &#123;
                    let id = this.students.length + 1;
                    // this.students.push(new Student(id, name, gender, birth, course, marks, fee));

                    let studentsCopy = [...this.students]; // rest operátor
                    studentCopy.push(new Student(id, name, gender, birth, course, marks, fee));
                    this.students = studentCopy;
                  }
                </pre>
                <li>Ebben az esetben, meghívva a createNewStudent függvényt, megváltozik a this.students memóriában
                  elfoglalt helye, így ismét "pure change" történik, azaz lefut a pipe</li>
              </ul>
            </li>
          </ul>
        </li>
        <pre>
            @Pipe(&#123;
              name: 'filter',
              pure: true
            })
          </pre>
      </ul>
    </li>
    <li>Impure
      <ul>
        <li>A pipe mindig le fog futni, amikor az Angular észleli, hogy a komponens újra renderelésre kerül, még akkor
          is, ha az adat nem változott</li>
        <li>Hasznos, ha a pipe olyan adatokat dolgoz fel, amelyek nem közvetlenül a komponens bemeneti adatforrásai</li>
        <pre>
            @Pipe(&#123;
              name: 'filter',
              pure: false
            })
          </pre>
        <li>Az objektumok, tömbök, függvények és minden más típus, ami referencia alapján van kezelve (nem primitív
          típusok), nem hoz létre "pure change"-t azzal, ha mondjuk property-je változik
        </li>
        <li>Az impure pipe minden change detection során meghívódik
          <ul>
            <li>Teljesítményigényes</li>
          </ul>
        </li>
      </ul>
    </li>
  </ol>
  <ul>
    <li>A pipe nem javasolt filter-ezésre, sort-olásra
      <ul>
        <li>A pure pipe-ok egyik hátránya, hogy ha éppen szűrve, vagy rendezve van például egy listánk, és változtatunk
          benne mondjuk a szűrt értéken (pl. a students tömbben az egyik tanuló nemét átállítjuk az ellenkezőre, mint,
          amire szűrtünk), akkor is jelen marad a listában az elem</li>
        <li>Előnye egyébként, hogy nagyon gyors</li>
        <li>A pipe-ot impure-ra állítva ez a hátrány megszűnik
          <ul>
            <li>Ugyanakkor az impure pipe használata teljes mértékben kerülendő</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Ha egy változó referencia típusú, akkor nem az értéket tárolja, hanem az érték tárolási helyére mutat, tehát
      maga a változó nem tartalmazza az objektumot, hanem arra mutat</li>
    <li>Ha egy referencia típusú objektum tulajdonságát változtatjuk meg, de a referencia maga nem változik, akkor az
      objektum ugyanaz marad, csak az egyik jellemzőjét (property) módosítottuk</li>
    <pre>
      let person = &#123; name: 'John', age: 30 };
      let referenceToPerson = person;

      referenceToPerson.age = 31;  // A "person" objektum age tulajdonsága megváltozik, de a referencia ugyanaz marad
    </pre>
    <li>Ha az objektum referencia változik, akkor az a külső szemlélő számára is világos jele a változásnak, mivel új
      példány jön létre</li>
    <li>egy referencia típusú adat esetén a változások nem minősülnek "pure change"-nek, ha csak a tulajdonságok
      módosulnak, de az objektum referencia változatlan marad</li>
    <br>
    <li>A tiszta függvények esetében fontos, hogy az adatok módosítása mindig új példányt (referenciát) hozzon létre,
      hogy az eredmény egyértelmű és átlátható legyen</li>
  </ul>
  <br>
  <h5 #filteringwithoutpipe data-anchor="filteringwithoutpipe">Filtering without pipe</h5>
  <ul>
    <li>A pipe használata nem javasolt szűrésre és rendezésre</li>
    <li>A kontroller rétegben leírható a filter / sort logika
      <ul>
        <li>Amennyiben alkalmazásszerte szeretnénk használni, létrehozhatunk egy service-t</li>
      </ul>
    </li>
    <li>A student service-ben fogjuk megvalósítani a filter-t
      <ul>
        <li></li>
      </ul>
    </li>
    <pre>
      <b>// piping.component.html</b>
      &#60;div class="filter-dropdown">
        &#60;button class="btn btn-secondary dropdown-toggle dark" type="button" id="filter2"
            data-bs-toggle="dropdown" aria-expanded="false">
        return this.students.filter(student => student.gender === filterBy); // anonym callback function
            Service filter: &#123; &#123; filterLabel }}
        &#60;/button>
        &#60;ul class="dropdown-menu dropdown-menu-dark" aria-labelledby="filter2">
            &#60;li *ngFor="let fd of filterDropdown; let index = index">
                &#60;a class="dropdown-item" [ngClass]="&#123;'active': fd.active}" (click)="onFilterChange2(index)">
                    &#123; &#123;fd.label}}
                &#60;/a>
            &#60;/li>
        &#60;/ul>
      &#60;/div>

      <b>// piping.component.ts</b>
      onFilterChange2(index: number) &#123;
        this.filterDropdown.forEach(f => f.active = false);
        this.filterDropdown[index].active = true;
        this.filterLabel = this.filterDropdown[index].label;
        this.students = this._studentService.filterStudentByGender(this.filterLabel);
      }

      <b>// filter.service.ts</b>
      filterStudentByGender(filterBy: string) &#123;
        console.log(filterBy);
        if (filterBy === 'none' || filterBy === '' || !this.students.length) &#123;
            return this.students;
        }

        return this.students.filter(student => student.gender === filterBy); // anonym callback function
      }
    </pre>
  </ul>
  <br>
  <h5 #asyncpipe data-anchor="asyncpipe">Async pipe</h5>
  <ul>
    <li>Aszinkron adatokat kezel a template-ben
      <ul>
        <li>Object (Subject), Promise</li>
      </ul>
    </li>
    <li>Az Angular reaktív adatkezelésének egy hasznos része</li>
    <li>Automatikusan feliratkozik a forrásra, és frissíti a UI-t, amikor az adatváltozás történik
      <ul>
        <li>Amint az adat elérhető, az async pipe frissíti az értékeket a template-ben</li>
      </ul>
    </li>
    <li>Az async pipe segítségével nem kell expliciten subscribelni az Observable-ra vagy Promise-ra, és nem kell
      manuálisan kezelni az adatot a komponensben</li>
    <li>Szimulálni fogjuk azt, mintha HTTP kérést intéznénk
      <ul>
        <li>Promise-szal, vagy Observable-lel dolgozunk, setTimeout segítségével</li>
      </ul>
    </li>
    <pre>
      <b>// piping.component.html</b>
      &#60;div>Total students: &#123; &#123; totalStudents | async }}&#60;/div>

      <b>// piping.component.ts</b>
      // ez esetben csak a template betöltődésekor kapjuk meg az értéket, új student hozzáadásánál nem frissül
      /* totalStudents: Promise&#60;any> = new Promise&#60;any>((resolve, reject) => &#123; // a resolve, és a reject is callback függvény
        setTimeout(() => &#123; // a setTimeout első argomentuma egy anonym callback function  
          resolve(this.students.length);
        }, 2000);
      }); */

      totalStudents!: Promise&#60;number>;

      createNewUser() &#123;
        this._studentService.createNewStudent('Steven Static', 'male', new Date('2000-01-01'), 'mba', 500, 2000);
        this.totalStudents = this.getTotalNumberOfStudents();
      }

      getTotalNumberOfStudents(): Promise&#60;number> &#123;
        return new Promise((resolve, reject) => &#123;
          setTimeout(() => &#123;
            resolve(this.students.length);
          }, 2000);
        });
      }
    </pre>
    <li>A totalStudents aszinkron adat, 2 másodperc után fogjuk megkapni</li>
    <li>A template-ben meg kellett mondanunk az Angularnak, hogy aszinkron adatot várunk, és amikor megkaptuk, jelenítse
      meg
      <ul>
        <li>Erre használtuk az async pipe-ot</li>
        <li>Async pipe nélkül ennyit látunk: Total students: [object Promise]</li>
      </ul>
    </li>
    <li>A getTotalNumberOfStudents meghívása 2 másodperc után Promise-t ad vissza, ami tartalmazza a student tömb
      hosszút</li>
  </ul>
  <br>
  <h5 #pipeexample data-anchor="pipeexample">Pipe example</h5>
  <app-piping></app-piping>
</div>

<div>
  <h3 #dynamiccomponents data-anchor="dynamiccomponents">Dynamic components</h3>
  <ul>
    <li>Teljesen általános komponens, ami dinamikusan készülnek el futási időben</li>
    <li>Egy nagyon egyszerű példa rá, amikor törölni szeretnénk egy listaelemet, és megjelenik egy "megerősítő" ablak
      <ul>
        <li>Csak akkor renderelődik a böngészőben, amikor a törlés gombra kattint a user</li>
      </ul>
    </li>
    <li>A dinamikus komponensek betöltésének 2 módja van
      <ol>
        <li>ngIf directive
          <pre>
            &#60;app-delete *ngIf="confirmDelete">&#60;/app-delete>
          </pre>
          <ul>
            <li>Ez a megoldás használandó</li>
          </ul>
        </li>
        <li>Dinamic component loader
          <pre>
            loadComponent(data) &#123;
              ...
            }
          </pre>
          <ul>
            <li>Korábban volt használatos</li>
            <li>Mindent meg kell írni, amit lényegében az ngIf teljes mértékben elvégez</li>
          </ul>
        </li>
      </ol>
    </li>
  </ul>
  <br>
  <h5 #dynamiccomponentsngif data-anchor="dynamiccomponentsngif">ngIf</h5>
  <ul>
    <li>Az ngIf direktívát használjuk a komponenes dinamikus renderelésére</li>
    <li>A dinamikus komponensnek custom property binding-gal adatot adhatunk át ( @Input() [] ), és custom event
      binding-gal pedig adatot emit-álhatunk a komponensből ( @Output() () )</li>
    <pre>
        <b>// angular.component.html</b>
        &#60;app-users>&#60;/app-users>

        <b>// users.component.html</b>
        &#60;div class="user-content">
          &#60;table class="table table-dark table-striped table-hover">
              &#60;thead>
                  &#60;tr>
                      &#60;th scope="col">Name&#60;/th>
                      &#60;th scope="col">Gender&#60;/th>
                      &#60;th scope="col">Subscription&#60;/th>
                      &#60;th scope="col">Status&#60;/th>
                      &#60;th scope="col">&#60;/th>
                  &#60;/tr>
              &#60;/thead>
              &#60;tbody>
                  &#60;tr *ngFor="let user of userList">
                      &#60;td>&#123; &#123; user.name }}&#60;/td>
                      &#60;td>&#123; &#123; user.gender }}&#60;/td>
                      &#60;td>&#123; &#123; user.subType }}&#60;/td>
                      &#60;td>&#123; &#123; user.status }}&#60;/td>
                      &#60;td>
                          &#60;button class="btn btn-danger" (click)="deleteUser(user)">
                              &#60;i class="bi bi-trash">&#60;/i>
                          &#60;/button>
                      &#60;/td>
                  &#60;/tr>
                  &#60;tr>
              &#60;/tbody>
          &#60;/table>
        &#60;/div>
        
        &#60;app-confirm-delete #confirmDelete *ngIf="showConfirmDeleteComponent" [user]="selectedUser"
            (showDeleteConfirmWindow)="showConfirmDeleteComponent = $event">&#60;/app-confirm-delete>

        <b>// users.component.ts</b>
        export class UsersComponent implements OnInit &#123;
          @ViewChild('confirmDelete') confirmDelete!: ConfirmDeleteComponent;
        
          userList: User[] = [];
          private _userService: UserService = inject(UserService);
        
          showConfirmDeleteComponent: boolean = false;
          selectedUser!: User;
        
          constructor() &#123;
          }
        
          ngOnInit(): void &#123;
            this._userService.getAllUsersWithFakeAPI().subscribe((users: User[]) => &#123;
              this.userList = users;
            });
          }
        
          deleteUser(user: User) &#123;
            this.selectedUser = user;
            this.showConfirmDeleteComponent = true;
          }
        }

        <b>// confirm.component.html</b>
        &#60;div class="confirm-overlay">
          &#60;div class="confirm-box">
              &#60;div class="confirm-text">
                  &#60;h6>&#123; &#123; user.name }}&#60;/h6>
                  &#60;div>Do you want to delete the user?&#60;/div>
              &#60;/div>
              &#60;div class="confirm-button-container">
                  &#60;button class="btn btn-danger" (click)="confirmDelete()">Confirm&#60;/button>
                  &#60;button class="btn btn-secondary" (click)="cancelDelete()">Cancel&#60;/button>
              &#60;/div>
          &#60;/div>
        &#60;/div>

        <b>// confirm.component.ts</b>
        export class ConfirmDeleteComponent &#123;
          @Input() user!: User;
          @Output() showDeleteConfirmWindow: EventEmitter&#60;boolean> = new EventEmitter&#60;boolean>;
        
          private _userService: UserService = inject(UserService);
        
          confirmDelete() &#123;
            this._userService.deleteUser(this.user.name);
            this.showDeleteConfirmWindow.next(false);
          }
        
          cancelDelete() &#123;
            this.showDeleteConfirmWindow.next(false);
          }
        }

        <b>// user.service.ts</b>
        export class UserService &#123;
          ...
          users: User[] = [
              new User('Carl Smith', 'male', 'Monthly', 'active'),
              new User('Johanna Bree', 'female', 'Monthly', 'inactive'),
              new User('Max King', 'male', 'Yearly', 'active')
          ];
          ...
          getAllUsersWithFakeAPI() &#123;
            setTimeout(() => &#123;
                this.usersSubject.next(this.users); // Az adatok elküldése a Subjecten keresztül
            }, 2000);
            return this.usersSubject.asObservable(); // Observable-t adunk vissza
          }
          ...
          deleteUser(userName: string) &#123;
            let selectedUserIndex = this.users.findIndex(user => user.name === userName);
            console.log(selectedUserIndex);
            this.users.splice(selectedUserIndex, 1);
          }
        }

        <b>// shared.moodule.ts</b>
        @NgModule(&#123; // a shared modulba fel kellett venni a providers tömbbe a UserService-t
          ...
          providers: [
            ...
            UserService,
          ]
        })
      </pre>
  </ul>
  <br>
  <h5 #dynamiccomponentsprogramatically data-anchor="dynamiccomponentsprogramatically">Programatically</h5>
  <ul>
    <li>A confirm delete komponens szelektorját a template-ben nem használjuk</li>
    <li>Egy, a kontrollerben megírt metóduson keresztül jelenítjük meg a komponenst</li>
    <li>A felhasználó adatait ugyanúgy átadjuk a kontroller rétegnek a template-ből</li>
    <li>Az első dolog, amit meg kell tennünk, hogy az app-confirm-delete komponensből készítünk egy példányt
      <ul>
        <li>A new ConfirmDeleteComponent nem fog működni, mert csakis kizárólag egy példány jön létre a komponensről
          <ul>
            <li>Egy Javascript objektum jön létre pusztán</li>
          </ul>
        </li>
        <li>Az Angular a háttérben a komponens rendereléséig sok mindent végez a háttérben, nem csak a példányosítást
        </li>
        <li>ComponentFactoryResolver
          <ul>
            <li>Angular tool</li>
            <li>Deprecated</li>
            <li>Injektálni szükséges</li>
            <li>A resolveComponentFactory() metódusának a példányosítani kívánt komponenst kell odaadni
              <ul>
                <li>Component Factory-t ad vissza, nem magát a komponenest
                  <ul>
                    <li>A visszaadott factory "tudja", hogyan lehet létrehozni a komponenst</li>
                  </ul>
                </li>
              </ul>
            <li>Megmondhatjuk, hogy a DOM-ban hova renderelődjön ki a template
              <ul>
                <li>A template-ben létrehozunk egy konténert, például egy div tag-et</li>
                <li>Erről a konténerről szükségünk van egy ViewContainerRef-re, hogy meg tudjuk mondani az
                  Angularnak, hogy hova tegye a komponensünket
                  <ul>
                    <li>A referenciát használva az Angular manipulálni tudja a konténert</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Direktívát hozunk lére, amit ráaggatunk a konténerünkre
              <ul>
                <li>A direktívába beinjektáljuk a ViewContainerRef-et, és így elrakjuk változóba a konténerünk
                  referenciáját</li>
              </ul>
            </li>
            <li>A user komponensben ViewChild dekorátorral tudunk hozzáférni a view container direktívához
              <ul>
                <li>A ViewChild szépen megtalálja az első előfordulását a ViewcontainerDirective szelektorának
                </li>
                <li>Az Angular régebbi verzióiban a ViewChildnak meg kellet adni az options objectben a
                  &#123;static: false} kulcs-érték pár</li>
              </ul>
            </li>
            <li>A container proooperty így tartalmaz egy ViewcontainerDirective referenciát
              <ul>
                <li>Ezt a property-t használva hozzáférhettünk a ViewContainerRef-hez
                  <ul>
                    <li>Ahhoz a property-hez, amibe elraktuk a beinjektált ViewContainerRef-et</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>A rendereléskor visszakapjuk a komponens referenciáját
              <ul>
                <li>A referencia segítségével fel tudunk iratkozni a showDeleteConfirmWindow EventEmitter-re</li>
                <li>A showDeleteConfirmWindow egy EventEmitter, az EventEmitter pedig az RxJS Subject kiterjesztése, így
                  fel lehet rá iratkozni</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <pre>
      // viewcontainer.directive.ts
      @Directive(&#123;
        selector: '[appContainer]'
      })
      export class ViewContainer&#123;
          constructor(public viewContainer: ViewContainerRef) &#123;
          }
      }

      // users.component.html
        ...
        &#60;button class="btn btn-danger" (click)="showConfirmDelete(user)">
          &#60;i class="bi bi-trash">&#60;/i>
        &#60;/button>
        ...
        &#60;div appContainer>
          <!-- app-confirm-delete component-->
        &#60;/div>

      // users.component.ts
      @ViewChild(ViewContainer, &#123; static: false }) container!: ViewContainer;
      private confirmationSubscription: Subscription = new Subscription();
      ...
      showConfirmDelete(user: User) &#123;
        const confirmDeleteComponenetFactory =
          this._componentFactoryResolver
            .resolveComponentFactory(ConfirmDeleteComponent);
    
        const containerViewRef = this.container.viewContainer;  // a template-ben lévő div referenciáját tartalmazza
    
        containerViewRef.clear();  // ha esetleg a div containerünk nem üres, kitöröljük a tartalmát
    
        const componentRef = containerViewRef.createComponent(confirmDeleteComponenetFactory); // renderelés
        componentRef.instance.user = user; // user átadása a példánynak
    
        this.confirmationSubscription = componentRef.instance.showDeleteConfirmWindow.subscribe((data) => &#123;
          this.confirmationSubscription.unsubscribe; // egyből le is iratkozunk róla
          containerViewRef.clear();
      
          if (data) &#123;
            this.selectedUser = user;
            this._userService.deleteUser(this.selectedUser.name);
          }
        });
      }
    </pre>
  </ul>
  <br>
  <app-users></app-users>
</div>

<div>
  <h3 #httpclient data-anchor="httpclient">HTTPClient</h3>
  <ul>
    <li>A lokálisan, tehát böngésző memóriájában tárolt adatok esetén, ha újraindítjuk az alkalmazásunkat, a kezdeti
      definiált állapot fog visszaállni, mindenféle változtatás elveszik
      <ul>
        <li>Tartós memória tár lehet a LocalStorage, SessionStorage
          <ul>
            <li>Kliens oldalon könnyen hozzájuk lehet férni, így érzékeny adatokat nem szabad tárolni</li>
          </ul>
        </li>
        <li>Minél több, és nagyobb adattal dolgozunk lokálisan, annál jobban lassítjuk az alkalmazásunkat</li>
      </ul>
    </li>
    <li>A valóságban maximum igen kevés adatot tárolunk lokálisan
      <ul>
        <li>Adatbázisba mentjük az adatokat</li>
        <li>Az adatbázisban jelen lesznek a frissített adatok, így az app újratöltésekor a már frissített adatokat
          kapjuk meg, nem a kezdeti állapotot</li>
        <li>A mentés, és visszatöltés backend szerver segítségével történik</li>
        <li>HTTP kérést intézünk a szerver felé, és fetch-eljük az adatokat</li>
      </ul>
    </li>
    <li>Fontos megjegyezni, hogy közvetlenül sosem csatlakozunk adatbázishoz
      <ul>
        <li>Adatbázishoz csatlakozáshoz Login credential-öket szükséges használnunk
          <ul>
            <li>Amennyiben Angularban tárolnánk, könnyen kiolvasható lenne bárki számára, mivel az Angular egy
              client-side framework</li>
          </ul>
        </li>
        <li>API-n keresztül csatlakozunk az adatbázishoz
          <ul>
            <li>Neki küldünk kéréseket, és tőle kapjuk a válaszokat</li>
            <li>Az API pedig közvetlenül a szerverrel kommunikál</li>
            <li>A RestAPI a legeltejedtebb API</li>
            <li>Tekinthetünk úgy rá, mint egy web applikációra
              <ul>
                <li>Rendelkezik URL-rel</li>
                <li>URL-rel fordulhatunk hozzá, és attól függően, hogy mi az URL, küld választ</li>
              </ul>
            </li>
            <li>JSON-ként kapjuk meg a választ, amit át tudunk alakítani Javascript objektummá</li>
            <li>API készítéséhez server-side nyelveket használunk
              <ol>
                <li>Python</li>
                <li>NodeJS</li>
                <li>PHP</li>
                <li>etc.</li>
              </ol>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Tehát az Angular-t egyértelműen használhatjuk arra, hogy API-hoz csatlakozzunk
      <ul>
        <li>Az API fogja tartalmazni a kódot, ami kommunikál az adatbázissal</li>
        <li>A továbbiakban egy ingyenes, online, a Google által biztosított API-t fogunk használni, amit FireBase-nek
          hívnak</li>
      </ul>
    </li>
    <li>HTTP request
      <ol>
        <li>URL
          <ul>
            <li>Ide küldjük a request-et</li>
            <li>API esetében API endpointnak is nevezzük</li>
            <pre>
              https://domain.com/api/users/id
            </pre>
            <li>Nem HTML-t fog visszaadni, hanem - leggyakrabban - JSON-t</li>
            <li>Ahhoz, hogy kérést küldjünk, ismernünk kell az API endpoint URL-jét</li>
          </ul>
        </li>
        <li>HTTP method
          <ul>
            <li>Nem csak az URL fontos része a HTTP kérésnek</li>
            <li>A HTTP-protokoll egy része</li>
            <li>A metódus definiálja, hogy milyen típusú kérést szeretnénk intézni az endpoint felé</li>
            <li>Példák
              <ul>
                <li>GET
                  <ul>
                    <li>Adat lekérés adatbázisból</li>
                    <li>Idempotens, azaz ugyanaz a kérés ugyanazt az eredményt adja</li>
                    <li>Nem módosít adatot a szerveren (adatbázisban)</li>
                  </ul>
                </li>
                <li>POST
                  <ul>
                    <li>Új rekord az adatbázisban</li>
                    <li>Body-t is küldünk, ami tartalmazza az adatot, amit létre szeretnénk hozni</li>
                    <li>Nem idempotens, avagy többszöri végrehajtás többszörös erőforrás létrehozást eredményez(het)
                    </li>
                  </ul>
                </li>
                <li>PUT
                  <ul>
                    <li>Adatbázis rekord frissítés</li>
                    <li>Általában idempotens</li>
                  </ul>
                </li>
                <li>DELETE
                  <ul>
                    <li>Rekord törlése adatbázisból</li>
                    <li>Nem feltétlenül idempotens</li>
                  </ul>
                </li>
                <li>PATCH
                  <ul>
                    <li>Adatbázis rekord frissítés</li>
                    <li>Általában idempotens</li>
                  </ul>
                </li>
                <li>HEAD
                  <ul>
                    <li>Csak az erőforrás metaadatait kéri le</li>
                    <li>Ha például csak azt szeretnéd ellenőrizni, hogy egy erőforrás létezik-e</li>
                    <li>Hasonló a GET-hez, de a válaszban nincs törzs</li>
                  </ul>
                </li>
                <li>OPTIONS
                  <ul>
                    <li>Lekéri, hogy egy adott erőforráson milyen műveletek / metódusok érhetők el</li>
                    <li>API ellenőrzése kiváló</li>
                  </ul>
                </li>
                <li>TRACE
                  <ul>
                    <li>A HTTP-kérés útvonalának nyomkövetése, gyakran hibakeresési célra</li>
                  </ul>
                </li>
                <li>CONNECT
                  <ul>
                    <li>Egy TCP-alagút létrehozása, például HTTPS forgalomhoz proxykon keresztül</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Kiegészítő metaadat
          <ul>
            <li>Header-nek nevezik</li>
            <li>A legtöbb esetben a kliens oldalon állítjuk be / elő
              <ul>
                <li>Általában nem szükséges explicit módon megadni</li>
                <li>Amennyiben a kérést böngészőből küldjük a szerver felé, akkor a böngésző a kliens, és ő állítja elő
                  a header-üket</li>
                <li>Angularban manuálisan előállítható</li>
              </ul>
            </li>
            <li></li>
          </ul>
        </li>
        <li>Request body
          <ul>
            <li>Az adat, amit el szeretnénk küldeni a kéréssel</li>
            <li>Például egy új rekord létrehozásakor el szükséges küldenünk azok az adatokat / paramétereket /
              tulajdonságokat, amik jellemzik majd ezt az új rekordot</li>
            <li>Nem minden request-nek kell body-val rendelkeznide, de a POST, PUT, PATCH metódusoknak mindenképpen</li>
          </ul>
        </li>
      </ol>
    </li>
    <li>Frontend developerként nincs ráhatásunk a HTTP response-ra
      <ul>
        <li>A backend developer-ek feladata</li>
      </ul>
    </li>
    <li>noSQL adatbázis
      <ul>
        <li>Adatbázis-kezelő rendszer, amely nem a hagyományos, relációs modellre (pl. táblák, sorok, oszlopok) épül,
          hanem másfajta struktúrákat használ az adatok tárolására és kezelésére</li>
        <li>A tervezésük gyakran az egyszerűbb adattárolásra és gyors elérésre fókuszál</li>
        <li>Az adatok különböző formátumúak lehetnek ugyanabban az adatbázisban</li>
        <li>Könnyebben skálázható</li>
        <li>Nem minden NoSQL rendszer támogatja az SQL-lekérdezéseket, ami megnehezítheti a használatot azok számára,
          akik az SQL-hez szoktak</li>
      </ul>
    </li>
    <li>Firebase
      <ul>
        <li>Segítségével noSQL adatbázisokat hozhatunk létre</li>
        <li>A Firebase endpointokat is létrehoz</li>
        <li>Nem csak egy adatbázis, hanem egy komplett backend megoldás</li>
        <li>Realtime adatbázis létrehozásakor kapunk egy URL-t, ami része az API endpointunknak</li>
        <li>Nem táblákkal, sorokkal, oszlopokkal fogunk dolgozni, hanem kollekciókkal, amik dokumentumokat tartalmaznak,
          és egy dokumentum nem más, mint egy JSON objektum</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #httpclientpost data-anchor="httpclientpost">POST</h5>
  <ul>
    <pre>
      <b>// navi.routing.module.ts</b>
      &#60; path: 'dashboard', component: DashboardComponent, outlet: 'http' },

      <b>// navi.component.html</b>
      &#60;ng-container *ngIf="tempSwitcher == 'http'">
        &#60;button *ngIf="showUserManagementStartButton" [routerLink]="['/', 'angular', &#123; outlets: &#123; http: ['dashboard'] } }]"
            class="btn btn-primary">
            Start user management
        &#60;/button>
        &#60;router-outlet name="http">&#60;/router-outlet>
      &#60;/ng-container>

      <b>// navi.component.ts</b>
      constructor() &#123;
        this._router.url.includes('http:dashboard') ? this.showUserManagementStartButton = false : this.showUserManagementStartButton = true;
      }

      ngOnInit(): void &#123;
        this._router.events.subscribe((routerEvent: Event) => &#123; // callback function, ami az event object-et kapja meg
          ...
          if (routerEvent instanceof NavigationEnd || routerEvent instanceof NavigationCancel || routerEvent instanceof NavigationError) &#123;
            ...
            this._router.url.includes('http:dashboard') ? this.showUserManagementStartButton = false : this.showUserManagementStartButton = true;
          }
        })
      }

      <b>// dashboard.component.html</b>
      &#60;form #taskForm="ngForm" class="accordion-body" (ngSubmit)="onFormSubmitted(taskForm)">
        &#60;input type="text" class="form-control" name="name" ngModel>
        &#60;textarea class="form-control" name="description" ngModel>&#60;/textarea>

        &#123;input type="text" class="form-control" name="user" ngModel>

        &#60;div> // bootstrap dropdown element
          &#60;button class="btn btn-secondary dropdown-toggle dark" type="button"
              id="status" data-bs-toggle="dropdown" aria-expanded="false">
              &#123; &#123;taskData?.priority || 'Priority'}}
          &#60;/button>
          &#60;ul class="dropdown-menu dropdown-menu-dark" aria-labelledby="priority">
              &#60;li>&#60;a class="dropdown-item" (click)="userManagementSelection('priority', 'low')">Low&#60;/a>&#60;/li>
              &#60;li>&#60;a class="dropdown-item"(click)="userManagementSelection('priority', 'medium')">Medium&#60;/a>&#60;/li>
              &#60;li>&#60;a class="dropdown-item"(click)="userManagementSelection('priority', 'high')">High&#60;/a>&#60;/li>
              &#60;li>&#60;a class="dropdown-item"(click)="userManagementSelection('priority', 'critical')">Critical&#60;/a>&#60;/li>
          &#60;/ul>
          &#60;input type="hidden" class="form-control" name="priority" ngModel>
        &#60;/div>

        &#60;input type="text" class="form-control" name="date" ngModel>

        &#60;div> // bootstrap dropdown element
          &#60;button class="btn btn-secondary dropdown-toggle dark" type="button"
              id="status" data-bs-toggle="dropdown" aria-expanded="false">
              &#123; &#123;taskData?.status || 'Status'}}
          &#60;/button>
          &#60;ul class="dropdown-menu dropdown-menu-dark" aria-labelledby="status">
              &#60;li>&#60;a class="dropdown-item" (click)="userManagementSelection('status', 'open')">Open&#60;/a>&#60;/li>
              &#60;li>&#60;a class="dropdown-item" (click)="userManagementSelection('status', 'in progress')">In progress&#60;/a>&#60;/li>
              &#60;li>&#60;a class="dropdown-item"(click)="userManagementSelection('status', 'completed')">Completed&#60;/a>&#60;/li>
          &#60;/ul>
          &#60;input type="hidden" class="form-control" name="status" ngModel>
        &#60;/div>

        &#60;div class="container">
          &#60;div class="row">
              &#60;div class="col m-3">
                  &#60;button class="btn btn-primary ms-3" type="submit">Save&#60;/button>
              &#60;/div>
          &#60;/div>
        &#60;/div>
      &#60;/form>

      <b>// dashboard.component.ts</b>
      export class DashboardComponent &#123;
        @ViewChild('taskForm') taskForm!: NgForm;
        taskData: any = &#123;};
      
        userManagementSelection(column: string, value: string) &#123;
          this.taskForm.form.patchValue(&#123; [column]: value }); // FormControl értékadás programatikusan
          this.taskData[column] = value; // a gombon megjelenő kiválasztott értéket biztosítja
        }
      
        createTask(form: NgForm) &#123;
          const headers = new HttpHeaders(
            &#123; 'My-Header': 'hi-there' }
          );
          this._http.post&#60; &#123; name: string }>('https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json', form.value, &#123; headers })
            .subscribe(&#123;
              next: (val) => console.log(val)
            });
          this.taskForm.reset();
          this.taskData = &#123;};
        }
      }
    </pre>
    <li>Amennyiben a megfelelő outlet route-on tartózkodunk, a 'UserManagementStartButton' gomb eltűnik, akkor is, ha
      közvetlenül erre a route-ra érkezünk az app betöltődésekor</li>
    <li>Template Driven Form-ot használunk ahhoz
      <ul>
        <li>Benne a hidden mezőkkel csak létrehozzuk a FormControl-t, és a dropdownok változtatásával kerülnek bele
          értékek
        </li>
      </ul>
    </li>
    <li>A 'Save' gomb megnyomásával POST request-et szeretnénk küldeni a Firebase adatbázisunkba
      <ul>
        <li>POST metódus esetén a body-ban az adatot is el kell küldenünk</li>
        <li>A DB-ben Task collection-t fogunk létrehozni</li>
      </ul>
    </li>
    <li>A HTTP request lépései
      <ol>
        <li>HTTPClientModule importálása a modulunkban</li>
        <li>HTTPClient példány injektálása a komponensünk kontrollerébe</li>
        <li>POST request készítése
          <ul>
            <li>Az első két paramétere kötelező, az URL, és a body</li>
          </ul>
        </li>
        <pre>
          <b>// Adatbázis URL-je</b>
          https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app

          <b>// POST metódus az adatbázis felé</b>
          https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json // task kollekció

          <b>// POST</b>
          this._http.post('https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json', form.value); // ebben a formában még nem fog történni request
        </pre>
      </ol>
    </li>
    <li>Amennyiben nem létezett a Firebase-en a kollekciónk, úgy '/tasks.json' URL-lel létrehozzuk</li>
    <li>POST request esetén JSON adatot szükséges küldenünk a body-ban
      <ul>
        <li>A HTTPClient POST methodja megteszi ezt helyettünk automatikusan</li>
      </ul>
    </li>
    <li>A POST metódus Obsevable-lel tér vissza
      <ul>
        <li>A HTTP-hívás csak akkor hajtódik végre, ha valaki feliratkozik rá</li>
        <li>Az első request vissza térési értéke az alábbi</li>
        <pre>
          this._http.post&#60; &#123; name: string }>('https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json', form.value)
            .subscribe(&#123;
              next: (val) => console.log(val)
            });

          &#123; name: -OC2inGEgSNtiDrp6T9q }
        </pre>
      </ul>
    </li>
    <li>Két request történik a szerver felé
      <ul>
        <li>Ez a böngésző alapértelmezett viselkedése</li>
        <li>Az első request metódusa OPTIONS
          <ul>
            <li>Ellenőrzés történik, hogy lehet-e POST-olni a szervernek</li>
            <li>Ha 'success' üzenettel tér vissza (200 OK), csak akkor történik meg a POST metódus</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Firebase-en létrejött egy 'tasks' dokumentum, egy kulcs a dokumentumhoz, amiben megtaláljuk a POST-olt adatot
    </li>
    <pre>
      tasks (kollekció)
      └── -OC2inGEgSNtiDrp6T9q (dokumentum azonosító)
          ├── date: "2024-12-01"
          ├── description: "This is it."
          ├── name: "New task"
          ├── priority: "critical"
          ├── status: "open"
          └── user: "Joe Iron"
    </pre>
    <li>A POST method-nak van egy harmadik, opcionális argomentuma is
      <ul>
        <li>Header-t tudunk beállítani</li>
        <pre>
          this._http.post&#60; &#123; name: string }>('https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json', form.value, &#123;headers: &#123;myHeader: 'hi-there'}})
            .subscribe(&#123;
              next: (val) => console.log(val)
            });

            OR

            const headers = new HttpHeaders(
              &#123; 'My-Header': 'hi-there' }
            );
            this._http.post&#60; &#123; name: string }>('https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json', form.value, &#123; headers })
            .subscribe(&#123;
              next: (val) => console.log(val)
            });
        </pre>
        <li>Megjegyzés
          <ul>
            <li>Ebben a formában nem ment fel a header</li>
            <pre>
              const headers = new HttpHeaders(
                &#123; myHeader: 'hi-there' } // myHeader --> My-Header
              );
            </pre>
          </ul>
        </li>
        <li>Több header is beállítható; őket vesszővel szükséges elválasztani</li>
        <pre>
          const headers = new HttpHeaders(
            &#123; 'My-Header': 'hi-there', 'My-Header-2': 'greatings' }
          );
        </pre>
      </ul>
    </li>
    <li>Egy adott kollekcióban (pl.: tasks) a dokumentum kulcsai egyediek lesznek
      <ul>
        <li>A kulcs egyedisége csak az adott kollekción belül garantált</li>
      </ul>
    </li>
    <pre>
      tasks
      ├── -OC2inGEgSNtiDrp6T9q
      │   ├── date: "2024-12-01"
      │   ├── description: "This is it."
      │   ├── name: "New task"
      │   ├── priority: "critical"
      │   ├── status: "open"
      │   └── user: "Joe Iron"
      ├── -OC2oB2FhZJx1hrmU0KZ
      │   ├── date: "2024-11-30"
      │   ├── description: "Don't worry about it."
      │   ├── name: "Leisure task"
      │   ├── priority: "low"
      │   ├── status: "open"
      │   └── user: "Michael Golf"
      └── -OC2p6CWxLRmG4L-YAjD
          ├── date: "2024-11-04"
          ├── description: "-"
          ├── name: "Task 2"
          └── priority: "medium"
    </pre>
  </ul>
  <br>
  <h5 #httpclientget data-anchor="httpclientget">GET</h5>
  <ul>
    <li>GET request-tel tudjuk megvalósítani az adatok fetch-elését</li>
    <li>Ugyanúgy, mint POST-nál, HTTPClient példényra van szükségünk</li>
    <li>Ezen metódus esetében csak az első argomentum kötelező</li>
    <li>Az endpoint-unk ezesetben az alábbi</li>
    <pre>
      https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json // a kollekciónk neve az URL vége
    </pre>
    <li>A tasks JSON adatot fog visszaadni, ezért szükséges a kiterjesztés a végére </li>
    <li>A GET metódus második, opcionális paramétere a headers</li>
    <li>Szintén Observable-t fogunk visszakapni
      <ul>
        <li>Kizárólag Subscriber esetén megy ki a kérés</li>
        <li>A szerver általi response-t a subscribe metódus első callback function-jében kapjuk meg</li>
      </ul>
    </li>
    <li>Alapvetően a dashboard komponens inicializálásánál szeretnénk lekérni az adatokat
      <ul>
        <li>Emiatt a függvényünket az OnInit lifecycle hookban hívjuk meg</li>
      </ul>
    </li>
    <pre>
      <b>// dashboard.component.ts</b>
      ngOnInit(): void &#123;
        this.getTasks();
      }

      private getTasks() &#123; // semelyik más osztály sem hívhatja meg, mert private
        this._http.get&#60; &#123; [key: string]: Task }>('https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json')
          .subscribe(&#123;
            next: (response) => console.log(response)
          })
      }

      // response
      &#123;
        "-OC2inGEgSNtiDrp6T9q": &#123;
          "date": "2024-12-01",
          "description": "This is it.",
          "name": "New task",
          "priority": "critical",
          "status": "open",
          "user": "Joe Iron"
        },
        "-OC2oB2FhZJx1hrmU0KZ": &#123;
          "date": "2024-11-30",
          "description": "Don't worry about it.",
          "name": "Leisure task",
          "priority": "low",
          "status": "open",
          "user": "Michael Golf"
        },
        "-OC2p6CWxLRmG4L-YAjD": &#123;
          "date": "2024-11-04",
          "description": "-",
          "name": "Task 2",
          "priority": "medium",
          "status": "in progress",
          "user": "Kate Johns"
        }
      }      

      <b>// Task.ts</b>
      export class Task &#123;
        constructor(
            public name: string,
            public description: string,
            public user: string,
            public date: string,
            public priority: string,
            public status: string,
            public id?: string) &#123; // az id opcionális
        }
    }
    </pre>
    <li>Ezt az adatot fel kell dolgoznunk
      <ul>
        <li>Tömböt készítünk belőle úgy, hogy kiegészítettük a típusdefiníciónkat (Task) egy opcionális id kulccsal, és
          a dokumentum azonosító kerül bele értékként</li>
        <pre>
            <b>// response</b>
            &#123;
              "-OC2inGEgSNtiDrp6T9q": &#123;
                "date": "2024-12-01",
                "description": "This is it.",
                "name": "New task",
                "priority": "critical",
                "status": "open",
                "user": "Joe Iron"
              },
              ...
            }

            <b>// transformation</b>
            [
            &#123;
                "id": "-OC2inGEgSNtiDrp6T9q",
                "date": "2024-12-01",
                "description": "This is it.",
                "name": "New task",
                "priority": "critical",
                "status": "open",
                "user": "Joe Iron"
              },
              ...
            ]
          </pre>
      </ul>
    </li>
    <pre>
      <b>// dashboard.component.html</b>
      &#60;div class="refresh"> // frissítés gomb
        &#60;i *ngIf="!isLoading" class="bi bi-arrow-clockwise fs-3" (click)="getTasks()">&#60;/i>
        &#60;div *ngIf="isLoading" class="spinner-border spinner-border-sm" role="status"
            style="width: 26.5px; height: 26.5px;">
            &#60;span class="sr-only">&#60;/span>
        &#60;/div>
      &#60;/div>

      &#60;div class="cards">
        &#60;div *ngIf="!firebaseTasks.length">No tasks&#60;/div>
        &#60;div *ngFor="let task of firebaseTasks" class="card">
            &#60;div class="card-body">
                &#60;h5 class="card-title">&#123; &#123; task.name }}&#60;/h5>
                &#60;div class="card-text">
                    &#60;div>User: &#123; &#123; task.user }}&#60;/div>
                    &#60;div>Priority: &#123; &#123; task.priority }}&#60;/div>
                    &#60;div>Status: &#123; &#123; task.status }}&#60;/div>
                &#60;/div>
                &#60;div class="icons mt-3">
                    &#60;a>
                        &#60;i class="bi bi-info-circle">&#60;/i>
                    &#60;/a>
                    &#60;a>
                        &#60;i class="bi bi-pencil-square">&#60;/i>
                    &#60;/a>
                    &#60;a>
                        &#60;i class="bi bi-trash">&#60;/i>
                    &#60;/a>
                &#60;/div>
            &#60;/div>
        &#60;/div>
      &#60;/div>

      <b>// dashboard.component.ts</b>
      firebaseTasks: Task[] = [];
      isLoading: boolean = false; // frissítés funkció

      createTask(form: NgForm) &#123;
        this.isLoading = true; // frissítés funkció
        ...
      }

      // private getTasks() &#123; // semelyik más osztály sem hívhatja meg, és template-ben sem használható
      getTasks() &#123;
      this.isLoading = true; // frissítés funkció
        this._http.get&#60; &#123; [key: string]: Task }>('https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json')
          .pipe(
            map(data => &#123;
              let transformedData: Task[] = []
              Object.entries(data).forEach(([key, task]) => &#123;
                console.log(key, task);
                transformedData.push(&#123; id: key, ...task });
              });
              return transformedData;
            })
          )
          .subscribe(&#123;
            next: (tasks) => &#123;
              this.firebaseTasks = tasks;
              this.isLoading = false; // frissítés funkció
            }
          });
    
        /* private getTasks() &#123; // ugyanúgy jó megoldás, csak a fenti RxJS
          this._http.get&#60; &#123; [key: string]: Task }>('https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json')
            .subscribe(&#123;
              next: (response) => &#123;
                Object.entries(response).forEach(([key, task]) => &#123;
                  console.log(key, task);
                  this.firebaseTasks.push(&#123; id: key, ...task });
                })
              }
            })
        } */
      }
    </pre>
    <li>A frissítés gombbal újra lekérhető az adatbázis tartalma, illetve új task felvitele után frissül a táblánk</li>
    <li>A prioritások vizuálisan is nmegjelennek</li>
    <pre>
      &#60;div *ngFor="let task of firebaseTasks" class="card" [ngClass]="'priority-' + task.priority">
        ...
      &#60;/div>

      .card &#123;
        border-left: 5px solid rgba(0, 0, 0, 0.176);

        &.priority-low &#123;
            border-left-color: rgb(20, 175, 0);
        }

        &.priority-medium &#123;
            border-left-color: rgb(218, 231, 49);
        }

        &.priority-high &#123;
            border-left-color: rgb(222, 115, 0);
        }

        &.priority-critical &#123;
            border-left-color: rgb(193, 3, 3);
        }
      }
    </pre>
  </ul>
  <br>
  <h5 #next id="httpclientdelete" data-anchor="httpclientdelete">DELETE</h5>
  <ul>
    <li>A táblázatban lévő kártyákon lévő kuka gombbal törölni szeretnénk az adott task-ot
      <ul>
        <li>Törléshez mindig szükséges valamilyen azonosító</li>
        <li>A tasks kollekcióban meg kell találnunk a dokumentum azonosítót, amit az id kulcs alatt tárolunk</li>
        <li>A DELETE metódust használjuk ez alkalommal
          <ul>
            <li>Az első, és egyetlen kötelező argomentuma az URL</li>
          </ul>
        </li>
        <li>A törlés URL-je az alábbi
          <ul>
            <li>Az adatbázis / kollekció neve / dokumentum azonosító / .json</li>
            <li>A dokumentum, amit törölni szeretnénk, JSON formátumú, ezért szükséges a kiterjesztés a végére</li>
          </ul>
        </li>
        <pre>
          `https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks/$&#123;id}.json`
        </pre>
        <li>A DELETE method megintcsak Observable-t ad vissza nekünk, így fel kell rá iratkoznunk, hogy lefutton az API
          <ul>
            <li>A szervertől kapott válasz - az esetek döntő többségében törlésnél - null</li>
          </ul>
        </li>
        <pre>
          <b>// dashboard.component.ts</b>
          deleteTask(id: string | undefined) &#123; // szükséges az undefined, mert a Task classban az id optional parameter
            console.log(id);
            this.isLoading = true;
            this._http.delete(`https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks/$&#123;id}.json`)
              .subscribe(&#123;
                next: (response) => &#123; 
                  this.getTasks();
                  this.isLoading = false;
                }
              })
          }
        </pre>
      </ul>
    </li>
    <li>Nézzük meg, hogyan törölhetünk egyszerre több dokumentumot az adatbázisból
      <ul>
        <li>Firebase-ben a null-ra állított értékű dokumentum azonosítók törlődnek
          <ul>
            <li>Ehhez a PATCH metódust használjuk</li>
            <li>Egyébként csak ciklikusan meghívva tudnánk törölni egyszerre több dokumentumot a DELETE segítségével
            </li>
          </ul>
        </li>
        <pre>
          <b>// dashboard.compnent.html</b>
          &#60;div *ngFor="let task of firebaseTasks" class="card" [ngClass]="'priority-' + task.priority">
            &#60;div class="card-body">
                ...
                &#60;div class="actions mt-3">
                    &#60;div>
                        &#60;div class="form-check">
                            &#60;input #checkbox class="form-check-input" type="checkbox" value=""
                                [id]="'select' + task?.id" (change)="onChangeSelectedCards($event, task.id)">
                            &#60;label class="form-check-label" [for]="'select' + task?.id">
                                &#123; &#123;checkbox.checked ? 'Selected' : 'Select'}}
                            &#60;/label>
                        &#60;/div>
                    &#60;/div>
                    &#60;div class="icons">
                        &#60;i class="bi bi-info-circle">&#60;/i>
                        &#60;i class="bi bi-pencil-square">&#60;/i>
                        &#60;i class="bi bi-trash" (click)="deleteTask(task?.id)">&#60;/i>
                    &#60;/div>
                &#60;/div>
            &#60;/div>
          &#60;/div>

          <b>// dashboard.compnent.ts</b>
          onChangeSelectedCards(event: any, id: string | undefined) &#123;
            if (this.selectedTaskIDs.includes(id)) &#123;
              this.selectedTaskIDs.splice(this.selectedTaskIDs.indexOf(id), 1);
              return;
            }
        
            this.selectedTaskIDs.push(id);
          }
        
          deleteAllSelectedTask() &#123;
            this.isLoading = true;
        
            const updates: &#123; [key: string]: null } = &#123;};
            this.selectedTaskIDs.forEach(id => updates[id] = null);
        
            this._http.patch('https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json', updates)
              .subscribe((resp) => &#123; // resp-ben visszakapjuk az id-kat
                this.getTasks();
                this.isLoading = false;
              });
          }
        </pre>
      </ul>
    </li>
    <li>A teljes kollekció törlése is lehetséges
      <ul>
        <li>A UI-ban erre szándékosan nincs gomb</li>
      </ul>
    </li>
    <pre>
      this._http.delete(`https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json).
        subscribe(); // csak feliratkozunk, amúgy sem ad vissza semmi response-t, de így elmegy az API kérés
    </pre>
  </ul>
  <br>
  <h5 #httpservice data-anchor="httpservice">HTTP service</h5>
  <ul>
    <li>A HTTP request-eket service-ek illik / szokás elhelyezni
      <ul>
        <li>A komponens osztályban is működik, de inkább a UI logika helyezkedik el benne
          <ul>
            <li>UI logika igen, business logika nem</li>
          </ul>
        </li>
        <li>A dashboard komponensünk így jobban áttekinthető is lesz</li>
      </ul>
    </li>
    <li>Az alábbi a kiindulási alapunk
      <ul>
        <li>Bárhol használható, köszönhetően a dekorátornak</li>
        <li>HTTPClient beinjektálva</li>
      </ul>
    </li>
    <pre>
      <b>// api.service.ts</b>
      @Injectable(&#123;
        providedIn: 'root'
      })
    
      export class ApiService &#123;
        private _http: HttpClient = inject(HttpClient);
    
        private tasksSubject = new BehaviorSubject&#60;Task[]>([]); // Tárolja az aktuális adatokat
        tasks$ = this.tasksSubject.asObservable(); // Observable a feliratkozáshoz
    
        createTask(task: Task) &#123;
            const headers = new HttpHeaders(
                &#123; 'My-Header': 'hi-there' }
            );
            this._http.post&#60; &#123; name: string }>('https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json',
                task, &#123; headers })
                .subscribe(() => &#123;
                    this.refreshTasks();
                });
        }
    
        deleteTask(id: string | undefined) &#123; // szükséges az undefined, mert a Task classban az id optional parameter
            this._http.delete(`https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks/$&#123;id}.json`)
                .subscribe(() => &#123;
                    this.refreshTasks();
                });
        }
    
        deleteAllSelectedTask(selectedTasks: string[]) &#123;
            const updates: &#123; [key: string]: null } = &#123;};
            selectedTasks.forEach(id => updates[id] = null);
    
            this._http.patch('https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json', updates)
                .subscribe(() => &#123;
                    this.refreshTasks();
                });
        }
    
        getTasks(): Observable&#60;Task[]> &#123;
            return this._http.get&#60;&#123; [key: string]: Task }>('https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json') // Observable-t ad visszs
                .pipe(
                    map(data => &#123; // marad Observable, csak átalakítottuk az adatszerkezetet
                        let transformedData: Task[] = []
                        Object.entries(data).forEach(([key, task]) => &#123;
                            transformedData.push(&#123; id: key, ...task });
                        });
                        return transformedData;
                    })
                )
        }
    
        refreshTasks() &#123;
            this.getTasks().subscribe(tasks => &#123;
                this.tasksSubject.next(tasks); // Frissítjük a BehaviorSubject értékét
            });
        }
      }
    </pre>
    <li>A dashboard komponens ngOnInit életciklusában feliratkozunk az api service tasks$ Observable-jére
      <ul>
        <li>Ez biztosítja, hogy bármikor, amikor a tasks$ Observable frissül, megkapjuk a frissített értékeket / task
          listát</li>
        <li>Feliratkozás után meghívjuk a komponensünk refreshTasks() függvényét, ami elindíja a loading-ot, és meghívja
          a service-ben található - ugyancsak - refreshTask() függvényt
          <ul>
            <li>A service ezen függvénye feliratkozik a getTasks() method-ra, aminek a visszatérési értéke egy
              Observable, és befrissíti a tasksSubject (BehaviorSubject) értékét</li>
          </ul>
        </li>
      </ul>
    </li>
    <li></li>
  </ul>
  <br>
  <h5 #httpclientput data-anchor="httpclientput">PUT</h5>
  <ul>
    <li>Létrehoztuk a kódot, ami betölti az Bootstrap accordion-ba a már az adatbázisban létező dokumentumot
      <ul>
        <li>Ehhez a kártyákon lévő ceruza ikonra kell kattintani</li>
      </ul>
    </li>
    <pre>
      <b>// navi.module.ts</b>
      @NgModule(&#123;
        ...
        imports: [
          ...
          NgbCollapseModule // template például az [(ngbCollapse)] direktíva használatát engedélyezi
        ],
        ...
      })
      <b>// dashboard.component.html</b>
      &#60;div class="accordion" id="accordionExample">
        &#60;div class="accordion-item">
            &#60;h2 class="accordion-header" id="headingTwo">
                &#60;button class="accordion-button collapsed" [ngClass]="&#123;'collapsed': isCollapsed}" type="button"
                    (click)="collapse.toggle()">
                    &#123; &#123; isEdit ? 'Update task (PUT)' : 'New task (POST)' }}
                &#60;/button>
            &#60;/h2>
            &#60;div #collapse="ngbCollapse" [(ngbCollapse)]="isCollapsed" id="collapseTwo"
                class="accordion-collapse collapse" aria-labelledby="headingTwo"
                data-bs-parent="#accordionExample" data-bs-parent="#accordionExample">
                &#60;form #taskForm="ngForm" class="accordion-body"
                    (ngSubmit)="isEdit ? updateTask(taskForm.value) : createTask(taskForm.value)">
                    ...
                    &#60;input type="hidden" class="form-control" name="id" ngModel>
                    ...
                &#60;/form>
            &#60;/div>
         &#60;/div>
      &#60;/div>

      &#60;button *ngIf="isEdit" class="btn btn-warning ms-3" type="button" (click)="cancelUpdate()">Cancel&#60;/button>

      &#60;div *ngFor="let task of firebaseTasks" class="card" [ngClass]="'priority-' + task.priority">
        ...
        &#60;div class="icons">
          ...
          &#60;i class="bi bi-pencil-square" (click)="onEditTask(task)">&#60;/i>
          ...
        &#60;/div>
      &#60;/div>
      
      <b>// dashboard.component.ts</b>
      isEdit: boolean = false;
      isCollapsed: boolean = true;

      createTask(form: Task) &#123;
        this._api.createTask(form);
        this.isCollapsed = true;
      }

      onEditTask(task: Task) &#123;
        this.isCollapsed = false;
        this.isEdit = true;
    
        Object.keys(task).forEach((key, value) => &#123;
          this.taskForm.form.patchValue(task);
        });
    
        this.taskData['priority'] = task['priority'];
        this.taskData['status'] = task['status'];
      }
    
      updateTask(form: Task) &#123;
        
        TODO

        this.isCollapsed = true;
        this.isEdit = false;
      }

      cancelUpdate() &#123;
        this.taskForm.reset();
        this.taskData = &#123;};
        this.isCollapsed = true;
        this.isEdit = false;
      }
    </pre>
    <li>Bekerült a template-be, a form-ba egy új hidden mező, az id, hogy könnyebben fel lehessen küldeni az értéket a
      szerver felé
      <ul>
        <li>Ugyanakkor ezzel a lépéssel a Firebase felé egy id property is megy, ami minden alkalommal, amikor
          létrehozunk egy dokumentumot, üres string-ként lesz jelen
          <ul>
            <li>Emiatt a fetch-elésnél változtatásra van szükség, hogy az üres string ne írja felül az id-t</li>
            <pre>
              transformedData.push(&#123; id: key, ...task }); // a task-ban lévő &#123;id: ''} felülírja az értékkel rendelkező id-t

              &#8595; &#8595; &#8595; &#8595; &#8595;

              transformedData.push(&#123; ...task,  id: key }); // az id-val írjuk felül az üres stringer
            </pre>
          </ul>
        </li>
      </ul>
    </li>
    <li>Szerkesztéskor lenyílik az accordion, és a header-ben lévő felirat is megváltozik
      <ul>
        <li>Valamint a mentés gombra nem a createTask, hanem az updateTask függvény fut le</li>
        <li>Szerkesztés esetén a Cancel gombbal reset-elhetjük a form-ot, és bezárhatjuk az accordion-t</li>
      </ul>
    </li>
    <li>Annak érdekében, hogy egy rekordot frissítsünk, a PUT metódust használjuk
      <ul>
        <li>Két kötelező argomentuma van
          <ol>
            <li>URL</li>
            <li>Adat, amit felküldünk</li>
          </ol>
        </li>
        <li>Observable-t ad vissza</li>
      </ul>
    </li>
    <li>Amennyiben elkészítettük a GET, POST, DELETE, és PUT metódusokat, úgy az applikációnkból CRUD műveleteket tudunk
      végrehajtani az adatbázis felé
      <ol>
        <li>Create - Új adat létrehozása</li>
        <li>Read - Adat lekérdezése, megjelenítése</li>
        <li>Update - Létező adat módosítása</li>
        <li>Delete - Adat eltávolítása</li>
      </ol>
    </li>
    <pre>
      <b>// api.service.ts</b>
      @Injectable(&#123;
        providedIn: 'root'
      })
    
      export class ApiService &#123;
        private _http: HttpClient = inject(HttpClient);
        private firebaseURL = environment.firebaseURL
    
        private tasksSubject = new BehaviorSubject&#60;Task[]>([]); // Tárolja az aktuális adatokat
        tasks$ = this.tasksSubject.asObservable(); // Observable a feliratkozáshoz
    
        refreshTasks(): void &#123;
            this.getTasks().subscribe(&#123;
                next: (tasks) => &#123;
                    this.tasksSubject.next(tasks); // Frissítjük a BehaviorSubject értékét
                },
                /* error: (error) => &#123;
                    console.error('Error fetching tasks', error); // Hibakezelés
                } */ 
            });
        }
    
        getTasks(): Observable&#60;Task[]> &#123;
            return this._http.get&#60; &#123; [key: string]: Task }>(`$&#123;this.firebaseURL}.json`).pipe(
                map(data => &#123; // marad Observable, csak átalakítottuk az adatszerkezetet
                    if (!data) &#123;
                        return []; // Ha nincs adat, üres tömb
                    };
                    let transformedData: any[] = [];
                    Object.entries(data).forEach(([key, task]) => &#123;
                        transformedData.push(&#123; ...task, id: key }); // &#123;id: ''} felülírása id: key-vel
                    });
                    return transformedData;
                })
            );
        }
    
        createTask(task: Task) &#123;
            const headers = new HttpHeaders(
                &#123; 'My-Header': 'hi-there' }
            );
            return this._http.post&#60;&#123; name: string }>(`$&#123;this.firebaseURL}.json`, task, &#123; headers }).pipe(
                tap(() => &#123;
                    this.refreshTasks();
                })
            );
        }
    
        deleteTask(id: string | undefined) &#123; // szükséges az undefined, mert a Task classban az id optional parameter
            return this._http.delete(`$&#123;this.firebaseURL}/$&#123;id}.json`).pipe(
                tap(() => &#123;
                    this.refreshTasks();
                })
            );
        }
    
        deleteAllSelectedTask(selectedTasks: string[]) &#123;
            const updates: &#123; [key: string]: null } = &#123;};
            selectedTasks.forEach(id => updates[id] = null);
    
            return this._http.patch(`$&#123;this.firebaseURL}.json`, updates).pipe(
                tap(() => &#123;
                    this.refreshTasks();
                })
            );
        }
    
        updataTask(data: Task) &#123;
            const &#123; id } = data; // objektum destrokturálás
            return this._http.put(`$&#123;this.firebaseURL}/$&#123;id}.json`, data).pipe(
                tap(() => &#123;
                    this.refreshTasks();
                })
            );
        }
      }

      <b>// dashboard.component.ts</b>
      ngOnInit(): void &#123;
        this._api.tasks$.subscribe(&#123;
          next: (tasks) => &#123;
            this.firebaseTasks = tasks;
          }
        });
    
        this.getTasks();
      }
    
      getTasks() &#123; // semelyik más osztály sem hívhatja meg, mert private
        this._api.getTasks().subscribe(&#123;
          next: (val) => &#123;
            this.firebaseTasks = val;
            console.log('createTask: ', val);
            this.onSetDefaultState();
          }
        });
      }
    
      createTask(form: Task) &#123;
        this._api.createTask(form).subscribe(&#123;
          next: (val) => &#123;
            console.log('createTask: ', val);
            this.onSetDefaultState();
          }
        });
      }
    
      deleteTask(id: string | undefined) &#123; // szükséges az undefined, mert a Task classban az id optional parameter
        this._api.deleteTask(id).subscribe(&#123;
          next: (val) => &#123;
            console.log('deleteAllSeledeleteTaskctedTask: ', val);
            this.onSetDefaultState();
          }
        });
      }
    
      deleteAllSelectedTask() &#123;
        this._api.deleteAllSelectedTask(this.selectedTaskIDs).subscribe(&#123;
          next: (val) => &#123;
            console.log('deleteAllSelectedTask: ', val);
            this.onSetDefaultState();
          }
        });
      }
    
      updateTask(form: Task) &#123;
        this._api.updataTask(form).subscribe(&#123;
          next: (val) => &#123;
            console.log('updateTask: ', val);
            this.onSetDefaultState();
          }
        });
      }

      onSetDefaultState() &#123;
        this.taskForm.reset();
        this.taskData = &#123;};
        this.isCollapsed = true;
        this.isEdit = false;
        this.selectedTaskIDs = [];
      }
    </pre>
    <li>Nem egy ideálisan megírt, ideálisan működő api</li>
  </ul>
  <br>
  <h5 #httperror data-anchor="httperror">HTTP error</h5>
  <ul>
    <li>Firebase-en a teszt üzemmódban bárki olvashat az adatbázisból, és írhat bele
      <ul>
        <li>Rule-ok szabályozzák</li>
        <pre>
            &#123;
              "rules": &#123;
                ".read": "now &#60; 1734476400000",  // 2024-12-18
                ".write": "now &#60; 1734476400000",  // 2024-12-18
              }
            }
          </pre>
        <li>Amennyiben a jelenlegi dátum/időpont timestamp-je kisebb, mint a megadott, a kifejezés true-val tér vissza
        </li>
        <li>False-ra állítva bármelyiket, hibát fogunk kapni</li>
      </ul>
    </li>
    <li>Ha bármilyen hiba adódik, egyelőre csak az isLoading miatt láthatjuk, hogy a spinner nem tűnik el</li>
    <li>Az API hibásoknál rendre Observable-t kapunk vissza, és a subscribe második callback függvényében kapjuk vissza
      az esetleges hibát</li>
    <pre>
      <b>// Error message</b>
      &#123;
        "error": &#123;
          "error": "Permission denied"
        },
        "headers": &#123;
          "normalizedNames": &#123;},
          "lazyUpdate": null,
          "lazyInit": "ƒ"
        },
        "message": "Http failure response for https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json: 401 Unauthorized",
        "name": "HttpErrorResponse",
        "ok": false,
        "status": 401,
        "statusText": "Unauthorized",
        "url": "https://angular-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json"
      }
    </pre>
    <li>
      <ul>
        <li><strong>error</strong>: Az API által visszaküldött hibaüzenet</li>
        <li><strong>headers</strong>: A válaszhoz tartozó HTTP header-ök</li>
        <li><strong>message</strong>: A felhasználó számára olvasható hibaüzenet, amely a hibát, és az URL-t tartalmazza
        </li>
        <li><strong>name</strong>: A hiba típusa (HttpErrorResponse).</li>
        <li><strong>ok</strong>: A válasz sikerességét jelző flag (hiba esetén false)</li>
        <li><strong>status</strong>: HTTP állapotkód</li>
        <li><strong>statusText</strong>: Az állapotkód szöveges leírása</li>
        <li><strong>url</strong>: HTTP request API végpont URL</li>
      </ul>

    </li>
    <pre>
        <b>// navi.module.ts</b>
        @NgModule(&#123;
          ...
          imports: [
            ...
            NgbToastModule
          ],
          ...
        })

        <b>// dashboard.component.html</b>
        &#60;div *ngIf="showToast" class="toast-container">
          &#60;ngb-toast [autohide]="true" [delay]="5000" (hidden)="showToast = false" [class]="'toast-style'">
            &#123; &#123; errorMessage }}
          &#60;/ngb-toast>
        &#60;/div>

        <b>// dashboard.component.html</b>
        showToast: boolean = false;
        errorMessage: string | null = null;

        getTasks() &#123;
          this._api.getTasks().subscribe(&#123;
            next: (val) => &#123;
              this.firebaseTasks = val;
              this.onSetDefaultState();
            },
            error: (err) => &#123;
              this.showToast = true; // megjelenítjük a toast-ot
              this.isLoading = false; // eltűntetjük a loading-ot
              this.errorMessage = this.setErrorMessage(err.status); // saját hibaüzenetet adunk vissza
            }
          });

          setErrorMessage(status: number): string &#123;
            const messages: &#123; [key: number]: string } = &#123;
              401: 'You do not have permission to perform the action',
            };
        
            return messages[status] || 'Error';
          }
        }
    </pre>
    <li>Tehát az egyik módja a hibák kezelésének, hogy a subscribe metódusnak átadjuk az error handle callback függvényt
    </li>
    <li>Az olyan API hívások esetében, ahol az api.service-ben iratkozunk fel a request-re, nem tudunk a komponensünkben
      hibaüzenetet kezelni
      <ul>
        <li>Ebben az esetben át kell adnunk a szervizből a komponensnek a hibaüzenetet</li>
      </ul>
    </li>
    <li>Amennyiben készítünk egy Subjectet, amin keresztül a komponens felé közöljük a hibaüzeneteket, arra feliratkozva
      a komponensben is értesülünk a hibákról
      <ul>
        <li>Az alábbi példában a szervizben iratkoztunk fel a HTTP requestre</li>
        <li>A setErrorMessage függvénybe praktikusan átkerült a toast megjelenítése, és a loading eltűntetése, hiszen
          ezeket minden hibánál el szükséges végezni</li>
      </ul>
    </li>
    <pre>
        <b>// api.service.ts</b>
        errorSubject$: Subject&#60;HttpErrorResponse> = new Subject&#60;HttpErrorResponse>();

          createTask(task: Task) &#123;
            console.log('CREATE');
            const headers = new HttpHeaders(
              &#123; 'My-Header': 'hi-there' }
            );
            this._http.post&#60; &#123; name: string }>(`$&#123;this.firebaseURL}.json`, task, &#123; headers })
                .subscribe(&#123;
                    next: (val) => &#123;
                        this.refreshTasks();
                    },
                    error: (err) => &#123;
                        this.errorSubject$.next(err);
                    }
                });
        }

        <b>// dashboard.component.html</b>
        subscriptions: Subscription[] = [];

        ngOnInit(): void &#123;
          ...
          this._api.errorSubject$.subscribe(
            next: (val: HttpErrorResponse) => &#123;
              this.errorMessage = this.setErrorMessage(val.status);
            }
          });

          this.subscriptions = [...this.subscriptions, errorSub, tasksSub];
          ...
        }

        createTask(form: Task) &#123;
          this._api.createTask(form);
        }

        setErrorMessage(status: number): string &#123;
          const messages: &#123; [key: number]: string } = &#123;
            401: 'You do not have permission to perform the action',
          };
      
          this.showToast = true;
          this.isLoading = false;
      
          return messages[status] || 'Error';
        }

        ngOnDestroy() &#123;
          this.subscriptions.forEach(sub => &#123;
            sub.unsubscribe();
          })
        }
      </pre>
    <li>Mindig jó practice explicit módon leiratkozni a Subscription-ökről
      <ul>
        <li>Még akkor is, ha a dashboard komponensben a destroy előtt automatikusan megtörténik az
          _api.errorSubject$-ről való leiratkozás</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #catcherror data-anchor="catcherror">CatchError</h5>
  <ul>
    <li>A logError függvény HTTP kérést küld a szerver felé, hogy kollekcióba írja az error üzenetet</li>
    <li>A getErrors függvény pedig lekérdezi az összes eddigi hibát</li>
    <pre>
      <b>// logging.service.ts</b>
      @Injectable(&#123;
        providedIn: 'root'
      })
    
      export class LoggingService &#123;
        private firebaseUrl = environment.firebaseURL;
        private _http: HttpClient = inject(HttpClient);
    
        logError(error: &#123; statusCode: number, errorMessage: string, dataTime: Date }) &#123;
            this._http.post(`$&#123;this.firebaseUrl}.json`, error).subscribe();
        }
    
        fetchError() &#123;
            this._http.get(`$&#123;this.firebaseUrl}.json`).subscribe(&#123;
                next: (val) => &#123;
                    console.log(val);
                }
            });
        }
      }
    </pre>
    <li>A getTasks függvényben a map mellett egy másik operátort is használunk
      <ul>
        <li>catchError: callback függvényt fogad, amiben benne van a hiba objektum</li>
        <li>A throwError Observable-t ad vissza, ami error üzenetet fog kibocsátani, mint adat</li>
      </ul>
    </li>
    <li>Alább az api szerviz és a komponens közti kommunikációt látható</li>
    <pre>
      <b>// api.service.ts</b>
      export class ApiService &#123;
        private firebaseURL = environment.firebaseURL;
    
        private _http: HttpClient = inject(HttpClient);
        private _loggingService: LoggingService = inject(LoggingService);
    
        private tasksSubject = new BehaviorSubject&#60;Task[]>([]); // tárolja az aktuális adatokat, elkülönítve a szerviz belső logikáját
        tasks$ = this.tasksSubject.asObservable(); // Observable, amire fel lehet iratkozni a komponens
    
        private apiStateSubject = new BehaviorSubject&#60;ApiState>(&#123; isLoading: false });
        apiState$ = this.apiStateSubject.asObservable();
    
        getTasks() &#123;
            this._http.get&#60; &#123; [key: string]: Task }>(`$&#123;this.firebaseURL}.json`)
                .pipe(
                    map(data => this.transformFirebaseData(data)),
                    catchError((error) => this.errorHandler(error)) // megfogja a hibát az Observable láncban
                )
                .subscribe(&#123;
                    next: (val) => &#123;
                        this.tasksSubject.next(val);
                        this.apiStateSubject.next(&#123;
                            isLoading: false,
                            success: true
                        });
                    },
                    error: (err) => this.statusHandler(err) // a throwError által visszaadott Observable itt érhető el
                });
        }
    
        createTask(task: Task) &#123;
            const headers = new HttpHeaders(
                &#123; 'My-Header': 'hi-there' }
            );
            this._http.post&#60; &#123; name: string }>(`https://angulars-api-c8412-default-rtdb.europe-west1.firebasedatabase.app/tasks.json`, task, &#123; headers })
                .pipe(
                    catchError((error) => this.errorHandler(error)) // megfogja a hibát az Observable láncban
                )
                .subscribe(&#123;
                    next: (val) => this.getTasks(), // hibamentesség esetén frissítjük a task listát
                    error: (err) => this.statusHandler(err) // a throwError által visszaadott Observable itt érhető el
                });
        }
    
        deleteTask(id: string | undefined) &#123; // szükséges az undefined, mert a Task classban az id optional parameter
            this._http.delete(`$&#123;this.firebaseURL}/$&#123;id}.json`)
                .pipe(
                    catchError((error) => this.errorHandler(error)) // megfogja a hibát az Observable láncban
                )
                .subscribe(&#123;
                    next: (val) => this.getTasks(), // hibamentesség esetén frissítjük a task listát
                    error: (err) => this.statusHandler(err) // a throwError által visszaadott Observable itt érhető el
                });
        }
    
        deleteAllSelectedTask(selectedTasks: string[]) &#123;
            const updates: &#123; [key: string]: null } = &#123;};
            selectedTasks.forEach(id => updates[id] = null);
    
            return this._http.patch(`$&#123;this.firebaseURL}.json`, updates)
                .pipe(
                    catchError((error) => this.errorHandler(error)) // megfogja a hibát az Observable láncban
                )
                .subscribe(&#123;
                    next: (val) => this.getTasks(), // hibamentesség esetén frissítjük a task listát
                    error: (err) => this.statusHandler(err) // a throwError által visszaadott Observable itt érhető el
                });
        }
    
        updataTask(data: Task) &#123;
            const &#123; id } = data; // objektum destruktorálás
            return this._http.put(`$&#123;this.firebaseURL}/$&#123;id}.json`, data)
                .pipe(
                    catchError((error) => this.errorHandler(error)) // megfogja a hibát az Observable láncban
                )
                .subscribe(&#123;
                    next: (val) => this.getTasks(), // hibamentesség esetén frissítjük a task listát
                    error: (err) => this.statusHandler(err) // a throwError által visszaadott Observable itt érhető el
                });
        }
    
        transformFirebaseData(data: &#123; [key: string]: Task }) &#123;
            if (!data) &#123;
                return []; // Ha nincs adat, üres tömb
            };
            let transformedData: any[] = [];
            Object.entries(data).forEach(([key, task]) => &#123;
                transformedData.push(&#123; ...task, id: key }); // &#123;id: ''} felülírása id: key-vel
            });
            return transformedData;
        }
    
        private errorHandler(error: HttpErrorResponse) &#123; // csak ebben az osztályban érhető el
            this._loggingService.logError(&#123; // logging service által a Firebase log kollekciójába ír
                statusCode: error.status,
                errorMessage: error.message,
                dataTime: new Date
            });
            return throwError(() => error); // Observable-t adunk vissza
        }
    
        private statusHandler(error: HttpErrorResponse) &#123;
            this.apiStateSubject.next(&#123;
                isLoading: false,
                error: error.status,
                success: error.ok
            });
        }
      }

      <b>// dashboard.component.ts</b>
      export class DashboardComponent implements OnInit, OnDestroy &#123;
        @ViewChild('taskForm') taskForm!: NgForm;
      
        private _http: HttpClient = inject(HttpClient);
        private _api: ApiService = inject(ApiService);
      
      
        firebaseTasks: Task[] = [];
        priorityAndDropdownValues: any = &#123;};
        selectedTaskIDs: any[] = [];
      
        isLoading: boolean = true;
        isEdit: boolean = false;
        isCollapsed: boolean = true;
        showToast: boolean = false;
      
        errorMessage: string | null = null;
      
        subscriptions: Subscription[] = [];
      
        ngOnInit(): void &#123;
          const tasksSub = this._api.tasks$.subscribe(&#123;
            next: (tasks) => &#123;
              this.firebaseTasks = tasks;
            }
          });
          
          const apiStateSub = this._api.apiState$.subscribe(&#123; // ha bármilyen API hívásnál sikeresen lefut, itt értesülünk róla
            next: (val) => &#123;
              this.isLoading = val.isLoading;
              this.errorMessage = val.error ? this.setErrorMessage(val.error) : null;
            }
          });
      
          this.subscriptions = [...this.subscriptions, tasksSub, apiStateSub];
      
          this.getTasks();
        }
      
        getTasks() &#123;
          this.isLoading = true;
          this._api.getTasks();
        }
      
        createTask(form: Task) &#123;
          this.isLoading = true;
          this._api.createTask(form);
          this.onSetDefaultState(); // nyitott az accordion, így mindent alaphelyzetbe állítunk
        }
      
        deleteTask(id: string | undefined) &#123; // szükséges az undefined, mert a Task classban az id optional parameter
          this.isLoading = true;
          this._api.deleteTask(id);
        }
      
        deleteAllSelectedTask() &#123;
          this.isLoading = true;
          this._api.deleteAllSelectedTask(this.selectedTaskIDs);
        }
      
        updateTask(form: Task) &#123;
          this.isLoading = true;
          this._api.updataTask(form);
          this.onSetDefaultState(); // nyitott az accordion, így mindent alaphelyzetbe állítunk
        }
      
        onDropdownChange(column: string, value: string) &#123;
          this.taskForm.form.patchValue(&#123; [column]: value }); // FormControl értékadás programatikusan
          this.priorityAndDropdownValues[column] = value; // a gombon megjelenő kiválasztott értéket biztosítja
        }
      
        onChangeSelectedCards(event: any, id: string | undefined) &#123;
          if (this.selectedTaskIDs.includes(id)) &#123;
            this.selectedTaskIDs.splice(this.selectedTaskIDs.indexOf(id), 1);
            return;
          }
      
          this.selectedTaskIDs.push(id);
        }
      
        onEditTask(task: Task) &#123;
          this.isCollapsed = false;
          this.isEdit = true;
      
          Object.keys(task).forEach((key, value) => &#123;
            this.taskForm.form.patchValue(task);
          });
      
          this.priorityAndDropdownValues['priority'] = task['priority'];
          this.priorityAndDropdownValues['status'] = task['status'];
        }
      
        onSetDefaultState() &#123;
          this.taskForm.reset();
          this.priorityAndDropdownValues = &#123;};
          this.isCollapsed = true;
          this.isEdit = false;
          this.selectedTaskIDs = [];
        }
      
        setErrorMessage(status: number): string &#123;
          const messages: &#123; [key: number]: string } = &#123;
            401: `$&#123;status} - You do not have permission to perform the action`,
            404: `$&#123;status} - Client request could not be found`,
          };
      
          this.showToast = true;
      
          return messages[status] || 'Error';
        }
      
        ngOnDestroy() &#123;
          this.subscriptions.forEach(sub => &#123;
            sub.unsubscribe();
          })
        }
      }      
    </pre>
  </ul>
  <br>
  <h5 #getsinglerecord data-anchor="getsinglerecord">GET single record</h5>
  <ul>
    <pre>
      <b>// navi-routing.module.ts</b>
      const routes: Routes = [
        ...
        &#123; path: 'dashboard/:id', component: TaskComponent, outlet: 'http' },
        ...
      ];

      <b>// api.service.ts</b>
      export class ApiService &#123;
        ...
        private taskSubject = new BehaviorSubject&#60;Task>(&#123;} as Task); // tárolja az aktuális adatot, elkülönítve a szerviz belső logikáját
        task$ = this.taskSubject.asObservable(); // Observable, amire fel lehet iratkozni a komponens
        ...
        getTask(id: string | undefined) &#123;
          this._http.get(`$&#123;this.firebaseURL}/$&#123;id}.json`)
              .pipe(
                  catchError((error) => this.errorHandler(error)) // megfogja a hibát az Observable láncban
              )
              .subscribe(&#123;
                  next: (val) => this.taskSubject.next(val as Task),
                  error: (err) => this.statusHandler(err) // a throwError által visszaadott Observable itt érhető el
              });
        }
      }

      <b>// dashboard.component.html</b>
      &#60;div *ngFor="let task of firebaseTasks" class="card" [ngClass]="'priority-' + task.priority">
        &#60;div class="card-body">
            &#60;router-outlet *ngIf="selectedTaskDetailsID && selectedTaskDetailsID == task.id" name="http">&#60;/router-outlet>
            &#60;ng-container *ngIf="selectedTaskDetailsID != task.id">
              ...
              &#60;i class="bi bi-info-circle" [routerLink]="[&#123; outlets: &#123; http: ['dashboard', task.id] } }]">&#60;/i>
            &#60;/ng-container>
        &#60;/div>
      &#60;/div>

      <b>// dashboard.component.ts</b>
      export class DashboardComponent implements OnInit, OnDestroy &#123;
        private _router: Router = inject(Router);
        private _activeRoute: ActivatedRoute = inject(ActivatedRoute);
        ...
        selectedTaskDetailsID: string = '';
        ...
        constructor() &#123;
          this._router.events
            .pipe(filter(event => event instanceof NavigationEnd))
            .subscribe(() => &#123;
              this.checkForIdParam();
            });
      
            this.checkForIdParam();
        }
        ...
        getTask(id: string | undefined) &#123;
          this._api.getTask(id);
        }
        ...
        checkForIdParam() &#123;
          const httpRoute = this._activeRoute.children.find(child => child.outlet === 'http');
      
          if (httpRoute) &#123;
            httpRoute.paramMap.subscribe(params => &#123;
              const id = params.get('id');
              if (id) &#123;
                this.selectedTaskDetailsID = params.get('id') || '';
              } else &#123;
                this.selectedTaskDetailsID = '';
              }
            });
          } else &#123;
            this.selectedTaskDetailsID = '';
          }
        }
      }

      <b>// task.component.html</b>
      <small><b>Name: </b>&#123; &#123;taskDetails.name}}</small>
      <small><b>User: </b>&#123; &#123;taskDetails.user}}</small>
      <small><b>Date: </b>&#123; &#123;taskDetails.date}}</small>
      <small><b>Priority: </b>&#123; &#123;taskDetails.priority}}</small>
      <small><b>Status: </b>&#123; &#123;taskDetails.status}}</small>
      <button [routerLink]="['/', 'angular']" class="btn btn-sm btn-dark">Back</button>

      <b>// task.component.ts</b>
      export class TaskComponent implements OnInit &#123;
        private _activeRoute: ActivatedRoute = inject(ActivatedRoute);
        private _api: ApiService = inject(ApiService);
      
        taskID: string = '';
        taskDetails: Task = &#123;} as Task;
      
        constructor() &#123;
          this.taskID = this._activeRoute.snapshot.url[1].path;
      
          this._api.task$.subscribe(&#123;
            next: (val) => this.taskDetails = val
          })
        }
      
        ngOnInit(): void &#123;
          this._api.getTask(this.taskID);
        }
      }

    </pre>
    <li>A megfelelő ikonra kattintva elugrunk az 'angular/(http:dashboard/:id)' outlet route-ra</li>
    <li>A dashboard komponensben feliratkozunk a router event-ek közül a 'NavigationEnd'-re
      <ul>
        <li>Ilyenkor, és az oldalra érkezéskor lefuttatjuk a checkForIdParam függvényt
          <ul>
            <li>Megkeresi, hogy szerepel-e a child route outlet-ek között 'http'</li>
            <li>Amennyiben igen, feliratkozik rá, és a param-ok közül kiszedi az id-t, amit el is rakunk a
              'selectedTaskDetailsID' változóba
              <ul>
                <li>Ez alapján fogjuk tudni, hogy melyik id-jú task-unk részleteire vagyun kíváncsiak, és jelenítjük meg
                  az adott kártyán azokat</li>
              </ul>
            </li>
            <li>Abban az esetben, ha nincs http a child outlet nevünkben, a 'selectedTaskDetailsID' változót üres
              stringgel tesszük egyelővé</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Mindeközben a task komponensünkben kiszelektáljuk a route outlet-ben lévő id-t, feliratkozunk az api
      szervizünkben lévő task$ Subject-re, és az OnInit életciklusban meghívjuk a getTask API call-t</li>
  </ul>
  <br>
  <h5 #httpheaders data-anchor="httpheaders">HTTP headers</h5>
  <ul>
    <li>A Header létrehozásának egyik módja, hogy meghívjuk a HttpHeaders konstruktorát
      <ul>
        <li>Objektumot adunk át neki, amiben meghatározzuk a property-ket</li>
        <pre>
            new HttpHeaders(&#123;
              property1: "value1",
              property2: "value2"
            })
        </pre>
      </ul>
    </li>
    <li>Másik módja, hogy a HttpHeaders példányán meghívjuk a set / append metódust
      <ul>
        <li>Két paramétert fogad
          <ol>
            <li>Header név (key)</li>
            <li>Érték</li>
          </ol>
        </li>
        <pre>
          let headers = new HttpHeaders();
          headers = headers.append('content-type', 'application/json'); // új példány
          headers = headers.append('access-control-allow-origin', '*'); // új példány
          
          let headers = new HttpHeaders();
          headers = headers.set('content-type', 'application/json'); // új példány
          headers = headers.set('access-control-allow-origin', '*'); // új példány
          
          this._http.get(`$&#123;this.firebaseURL}/$&#123;id}.json`, &#123; headers })...
        </pre>
        <li>Nagyon fontos megjegyezni, hogy a HttpHeaders 'immutable' (változtathatatlan)
          <ul>
            <li>Minden egyes művelet, amely módosítani próbálja, nem az eredeti objektumot módosítja, hanem egy új
              példányt hoz létre, amely tartalmazza a módosításokat</li>
            <li>Mindig el kell mentened a visszatérő új példányt</li>
          </ul>
        </li>
        <li>Mi a különbség a set és az appent method között?
          <ul>
            <li>A set metódus, ha már beállítottunk egy header-t, és a későbbiek folyamán beállítunk egy másikat, akkor
              felülírja a korábbi header-t/header-öket</li>
            <li>Az append hozzáilleszti a korábbi header-höz/header-ökhöz az újat</li>
            <pre>
              <b>// set</b>
              let headers = new HttpHeaders();
              headers = headers.append('content-type', 'application/json');
              headers = headers.append('content-type', 'text/html');

              Content-Type: text/html

              <b>// append</b>
              let headers = new HttpHeaders();
              headers = headers.append('content-type', 'application/json');
              headers = headers.append('content-type', 'text/html');

              Content-Type: application/json_text/html
            </pre>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #sendingquerystring data-anchor="sendingquerystring">Sending query string</h5>
  <ul>
    <li>Query string-gel is tudunk a request-tel együtt adatot küldeni</li>
    <li>Az URL után ?-lel indítjuk a query stringet
      <ul>
        <li>Kulcs-érték párokat tudunk megadni</li>
        <li>& jellel több query stringet is megadhatunk</li>
      </ul>
    </li>
    <li>Az adatbázisban akár több szár, több ezer rekordunk is lehet
      <ul>
        <li>Query string-gel lehet implementálni a paginációt</li>
        <li>Egy oldalon van például 10 tételünk</li>
        <pre>
          this._http.get&#60; &#123; [key: string]: Task }>(`$&#123;this.firebaseURL}.json?page=1&item=10`)...
        </pre>
        <li>Meg lehet mondani a szervernek, hogy az első oldalról tíz tétel kérünk</li>
        <li>Az oldalak item-számai a következőképp alakulnak
          <ol>
            <li>Page 1: Item 1-10</li>
            <li>Page 2: Item 11-20</li>
            <li>Page 3: Item 21-30</li>
            ...
          </ol>
        </li>
      </ul>
    </li>
    <li>Extra adatot küldünk az URL-lel</li>
    <li>Egy másik módja a query stringek küldésének a set metódus használata
      <ul>
        <li>HttpParam-ot hozunk létre
          <ul>
            <li>Szintén immutable</li>
            <pre>
              ...
              let params = new HttpParams();
              params = params.set('page', 2);
              params = params.set('item', 10);

              this._http.get(`$&#123;this.firebaseURL}/$&#123;id}.json`, &#123; headers, params })...
            </pre>
            <li>Az utolsó anonymous object-ben átadható</li>
          </ul>
        </li>
        <li>A query param neve mindenképp string érték</li>
      </ul>
    </li>
    <li>A request payload-jában mindkét esetben láthatjuk a query string-eket</li>
  </ul>
  <br>
  <h5 #observableresponseandresponsetype data-anchor="observableresponseandresponsetype">
    Observable response and response type</h5>
  <ul>
    <li>Bármilyen metódussal fordulunk a szerver felé, valamilyen választ fogunk kapni
      <ul>
        <li>Alapértelmezetten a HTTPClient esetében nem a response objektumot, hanem a response body-t kapjuk meg
          <ul>
            <li>Az objektumból ki van már bontva a body</li>
          </ul>
        </li>
        <li>Például a GET-nél, második paraméternek, ahol opcionálisan megadhatjuk a header-öket, param-okat, olyan,
          mintha szerepelne egy observe kulcs is, body kulccsal
          <ul>
            <li>Mint utolsó argomentuma a get függvénynek, egy anonymous objektumban</li>
          </ul>
        </li>
        <pre>
            this._http.get&#60; &#123; [key: string]: Task }>(`$&#123;this.firebaseURL}.json?page=1&item=10`, &#123;observe: 'body'})...
        </pre>
        <li>A body-t response-ra változtatva megkapjuk a teljes választ</li>
        <pre>
          this._http.get&#60; &#123; [key: string]: Task }>(`$&#123;this.firebaseURL}.json?page=1&item=10`, &#123;observe: 'response'})...
        
          &#123;
            body: *tasks array*
            headers: ...
            ok: true
            status: 200
            statusText: "OK"
            type: 4
            url: ...
          }
        </pre>
        <li>A type azt jelöli, hogy milyen típusú event történt
          <ul>
            <li>type = 0; HTTPEventType.Sent</li>
            <li>type = 4; HTTPEventType.Response</li>
          </ul>
        </li>
        <li>Az utolsó érték, amire állítható, az az events</li>
        <pre>
          this._http.get&#60; &#123; [key: string]: Task }>(`$&#123;this.firebaseURL}.json?page=1&item=10`, &#123;observe: 'events'}...
        </pre>
        <li>Tegyük fel, hogy szeretnénk a usernek egy toaster-t mutatni, amikor a request-et elküldte a szerver felé
        </li>
        <pre>
          getTask(id: string | undefined) &#123;
            this._http.get(`$&#123;this.firebaseURL}/$&#123;id}.json`, &#123; observe: 'events' })
                .pipe(
                    tap( (event) => &#123;
                        if (event.type === HTTPEventType.Sent) &#123;
                          // toaster logika
                        }
                    }),
                    catchError((error) => this.errorHandler(error)) // megfogja a hibát az Observable láncban
                )
                .subscribe(&#123;
                    next: (val) => this.taskSubject.next(val as Task),
                    error: (err) => this.statusHandler(err) // a throwError által visszaadott Observable itt érhető el
                });
          }
        </pre>
        <li>Szintén opcionális paraméternek beállíthatjuk a ResponseType-ot</li>
        <ul>
          <li>json esetében automatikusan javascript objektummá konvertálódik a válasz (általában erre van szükség)</li>
          <li>json esetében string-ként kapjuk meg a választ</li>
          <li>blob is lehet, amennyiben fájlt várunk, mint válasz</li>
        </ul>
        <pre>
        this._http.get&#60; &#123; [key: string]: Task }>(`$&#123;this.firebaseURL}.json?page=1&item=10`, &#123;observe: 'body', responseType: 'json'})...
        </pre>
      </ul>
    </li>
    <li>Az observe property-vel mélyebben hozzáférhetünk a HTTP válaszhoz</li>
  </ul>
  <br>
  <h5 #interceptors data-anchor="interceptors">Interceptors</h5>
  <ul>
    <li>Az Angular HTTPClient támogatja</li>
    <li>Az applikáció és a szerver között foglal helyet</li>
    <li>Segítségével módosíthatunk a request-en, mielőtt kiküldenénk a szervernek</li>
    <li>A szerver felől beérkező választ is módosíthatjuk</li>
    <li>Ugyanazon a helyen csípi el a be-, és a kimenő adatokat</li>
    <li>Kiválóan használható header-ök hozzáadására, vagy bejövő válaszok logolására
      <ul>
        <li>A leggyakoribb felhasználása az autorizációs header-ök hozzáadása minden request-hez</li>
        <li>Hozzáadhatjuk minden kéréshez, de praktikusabb egy helyen kezelni</li>
        <li>A hibákat ugyanazon a helyen elkaphatjuk, és akár el is tárolhatjuk</li>
      </ul>
    </li>
    <li>A kimenő, és a bejövő request-eket először nem a másik fél kapja meg (szerver, vagy a kliens), hanem az
      Interceptor
      <ul>
        <li>Több Interceptort is bevethetünk egy irányba</li>
        <li>A next metódussal tudjuk továbbítani a kérést</li>
      </ul>
    </li>
    <li>Interceptor esetében nincs szükség a szervizünkben az @Injectable dekorátorra
      <ul>
        <li>Interceptor készítésekor a service class implementálja a HttpInterceptor interface-t</li>
        <pre>
          export class AuthInterceptorService implements HttpInterceptor &#123;
            intercept(req: HttpRequest&#60;any>, next: HttpHandler): Observable&#60;HttpEvent&#60;any>> &#123;
                return next.handle(req); // itt csak visszaadjuk a érkező requestet módosítás nélkül
            }
          }
        </pre>
      </ul>
    <li>Az implementálás miatt muszáj az intercept metódust létrehozni
      <ul>
        <li>Két paramétert fogad
          <ol>
            <li>req (request objektum)
              <ul>
                <li>A request-et minden kérés esetében használni szeretnénk, így a típusát any-re állítjuk</li>
                <li>Immutable</li>
              </ul>
            </li>
            <li>next
              <ul>
                <li>HttpHandler a típusa</li>
              </ul>
            </li>
          </ol>
        </li>
      </ul>
    </li>
    <li>A megfelelő modulban provide-olni szükséges
      <ul>
        <li>Speciális típusú injection token-t kell használnunk</li>
        <pre>
          @NgModule(&#123;
            ...
            providers: [
              ...
              AuthInterceptorService // hibás
            ]
          })
        </pre>
        <li>Nem használhatjuk az Interceptor osztály nevét (AuthInterceptorService)</li>
        <pre>
          @NgModule(&#123;
            ...
            providers: [
              ...
              &#123; provide: HTTP_INTERCEPTORS, useClass: AuthInterceptorService, multi: true },
            ]
          })
        </pre>
        <li>A multi property-t beállítottuk true-ra
          <ul>
            <li>Több interceptorunk is lehet</li>
            <li>Minden Interceptor-nak ugyanaz lesz a token key-je</li>
            <li>Nem akarjuk felülírni a korábbi Interceptor-t újabbal</li>
            <li>Így lehet több provider-ünk ugyanazzal az injection token-nel</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Akárhányszor egy új kérés történik az applikációnkban, az Angular futtatni fogja a regisztrált Interceptor-t, és
      lefuttatja az intercept metódusban lévő logikát</li>
    <li>A return next.handle() függvény futtatása kihagyhatatlan lépés
      <ul>
        <li>Ellenkező esetben a request nem fog eljutni a következő lépcsőig, legyen az egy másik Interceptor, vagy a
          szerver</li>
      </ul>
    </li>
    <li>A request objektum immutable
      <ul>
        <li>Az eredeti HttpRequest objektumot nem lehet közvetlenül módosítani</li>
        <li>Hasonlóan az HttpHeaders-hez, ha egy Interceptor módosítani akarja a kérést, akkor új példányt kell
          létrehoznia a request objektumból, amely tartalmazza a módosításokat</li>
        <li>A módosításhoz klónozzuk az objektumot, és azt módosítjuk, valamint adjuk majd oda a next függvénynek</li>
        <li>A clone függvénynek megadhatjuk egy objektumban, hogy mit szeretnénk módosítani</li>
        <pre>
          export class AuthInterceptorService implements HttpInterceptor &#123;
            intercept(req: HttpRequest&#60;any>, next: HttpHandler): Observable&#60;HttpEvent&#60;any>> &#123;
                const modifiedRequest = req.clone(&#123; headers: req.headers.append('Auth', 'ok') }); // az eredeti header-öknöz hozzáadunk még egyet
                return next.handle(req);
            }
        }
        </pre>
        <li>A clone header-höz hozzáadtunk egy auth fejlécet</li>
      </ul>
    </li>
    <li>A válaszokat szintén manipulálhatjuk
      <ul>
        <li>Mivel nem használunk más Interceptort, azért a 'next.handle(modifiedRequest)' adja vissza a response-t,
          Observable formában</li>
        <li>RxJS segítségével hozzá tudunk férni a HttpEvent Observable-höz (amit deklaráltunk is, mint a függvény
          visszatérési értéke)</li>
        <pre>
          return next.handle(modifiedRequest)
            .pipe(
                tap((event) => &#123;
                    if (event.type === HttpEventType.Response) &#123;
                        console.log('resp: ', event); // a body-ban van az adat, amit a szervertől visszakapunk
                    }
                })
            );
        </pre>
        <li>map(), filter(), vagy egyéb operátorokkal manipulálni lehet a kapott adatot</li>
      </ul>
    </li>
    <li>Hozzunk létre még egy Interceptort, hogy lássuk, miképp működnek, ha többet használunk
      <ul>
        <li></li>
        <pre>
          @NgModule(&#123;
            ...
            providers: [
              ...
              &#123; provide: HTTP_INTERCEPTORS, useClass: AuthInterceptorService, multi: true },
              &#123; provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptorService, multi: true }
            ]
          })
        </pre>
        <li>Mindkét service ugyanazt a provider-t / injection token-t használja, ezért a multi true
          <ul>
            <li>Nem akarjuk felülírni az előző service-t az újjal</li>
            <li>A providers tömbben lévő sorrend határozza meg, hogy milyen sorrendben fognak lefutni az Interceptor-ok
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <pre>
      <b>// auth-intterceptor.service.ts</b>
      intercept(req: HttpRequest&#60;any>, next: HttpHandler): Observable&#60;HttpEvent&#60;any>> &#123; // a next.handle(modifiedRequest) adja vissza az Observable-t
        // console.log('auth: ', req);
        // const modifiedRequest = req.clone(&#123; headers: req.headers.append('auth', 'ok') }); // az eredeti header-öknöz hozzáadunk még egyet
        const modifiedRequest = req.clone(); // az eredeti header-öknöz hozzáadunk még egyet
        return next.handle(modifiedRequest)
            .pipe(
                tap((event) => &#123;
                    if (event.type === HttpEventType.Response) &#123;
                        // console.log('resp: ', event); // a body-ban van az adat, amit a szervertől visszakapunk
                    }
                })
            );
      }
    </pre>
  </ul>
  <br>
  <h5 #realworldapi data-anchor="realworldapi">Real world API</h5>
  <ul>
    <pre>
      protected doRequest(method, url, data, confirm = false): Observable&#60;any> &#123;

        const httpOptions = &#123;
          headers: &#123;
            'Content-Type': 'application/json',
            'X-API-KEY': this.httpOptions.headers.get('X-API-KEY'),
            'X-LOCALE': this.httpOptions.headers.get('X-LOCALE'),
            'X-TIMEZONE': this.httpOptions.headers.get('X-TIMEZONE'),
            'X-Confirm': confirm ? '1' : '0',
          }
        };
    
        switch (method) &#123;
          case 'get':
            return this.http.get(url, httpOptions).pipe(
              catchError((e, o) => &#123;
                return this.errorHandler(e);
              }),
              catchError((e, o) => &#123;
                return this.confirmHandler(e, method, url, data);
              }),
              map((x: any) => x.data));
          case 'delete':
            return this.http.delete(url, httpOptions).pipe(
              catchError((e, o) => &#123;
                return this.errorHandler(e);
              }),
              catchError((e, o) => &#123;
                return this.confirmHandler(e, method, url, data);
              }),
              map((x: any) => x.data));
          case 'put':
            return this.http.put(url, data, httpOptions).pipe(
              catchError((e, o) => &#123;
                return this.errorHandler(e);
              }),
              catchError((e, o) => &#123;
                return this.confirmHandler(e, method, url, data);
              }),
              map((x: any) => x.data));
          case 'post':
            return this.http.post(url, data, httpOptions).pipe(
              catchError((e, o) => &#123;
                return this.errorHandler(e);
              }),
              catchError((e, o) => &#123;
                return this.confirmHandler(e, method, url, data);
              }),
              map((x: any) => x.data));
          default:
        }
        return new Observable();
      }
    </pre>
    <li>doRequest
      <ul>
        <li>Az elején megtörténik a fejléc beállítás</li>
        <li>method: A HTTP metódus típusa (get, post, put, delete)</li>
        <li>url: Az API végpont URL-je</li>
        <li>data: A post és put metódusokkal elküldendő adat</li>
        <li>confirm: Egy logikai érték, amely meghatározza, hogy kell-e megerősítést kérni a kérés végrehajtásához</li>
        <li>A HTTPClient kéréseihez két catchError operátor van hozzáadva a hibák kezelésére</li>
        <li>Amennyiben nem történt hiba, a map operátorral a kapott adat data mezőjét adjuk tovább csak</li>
        <li>Abban az esetben, ha olyan metódust hívunk meg, amire nincs "esetünk", egy üres Observable-lel térünk vissza
        </li>
      </ul>
    </li>
    <pre>
      private errorHandler(error: any) &#123;
        if (error.status === 401) &#123;
          this.setToken('');
          this.router.navigate(['auth']);
    
          if (error.status == 409) &#123;
            return throwError(error);
          }
    
          this.toastMessage.new('error', null, error.error.error.message);
        }
    
        this.contentIsloading.loading.next(false);
    
        return throwError(error);
      }
    </pre>
    <li>errorHandler
      <ul>
        <li>Kezeli a hibás HTTP válaszokat</li>
      </ul>
    </li>
    <pre>
      private confirmHandler(e, method, apiUrl, data) &#123;
        if (e.status === 409) &#123;
          return new Observable((sub) => &#123;
            this.confirm.confirm(&#123;
              message: e.error.error.msg,
              acceptLabel: this.lang.transform('Yes'),
              rejectLabel: this.lang.transform('No'),
              header: e.error.error.title,
              accept: () => &#123;
                this.doRequest(method, apiUrl, data, true).subscribe(ret => &#123;
                  this.contentIsloading.loading.next(true);
                  sub.next(&#123;data: ret});
                  sub.complete();
                });
              },
              reject: () => &#123;
                sub.error(e);
                sub.complete();
              }
            });
          });
        } else &#123;
          return throwError(e);
        }
      }
    </pre>
    <li>ConfirmHandler
      <ul>
        <li>Amennyiben 409-es státusz érkezik, megerősítést kér a felhasználótól</li>
        <li>Egy Observable-t hoz létre, amely a felhasználói válaszra vár</li>
        <li>A megerősítés elfogadás esetén újraküldi a kérést, és az eredményt továbbítja a feliratkozóknak</li>
        <li>Elutasítás esetén a hibát jelzi a feliratkozóknak </li>
      </ul>
    </li>
    <pre>
      public getPages(e): Observable&#60;any> &#123;
        return this.doRequest('get', `$&#123;this.baseUrl}page/?event=$&#123;JSON.stringify(e)}`, null);
      }
    
      public getPage(id): Observable&#60;any> &#123;
        return this.doRequest('get', `$&#123;this.baseUrl}page/$&#123;id}/`, null);
      }
    
      public savePage(model): Observable&#60;any> &#123;
        return this.doRequest('post', `$&#123;this.baseUrl}page/$&#123;model.PageID || 0}/`, model);
      }
    
      public deletePage(id): Observable&#60;any> &#123;
        return this.doRequest('delete', `$&#123;this.baseUrl}page/$&#123;id}/`, null);
      }
    </pre>
    <li>API calls
      <ul>
        <li>A különféle komponensekből ezekkel a függvényekkel indítjuk el az API hívásokat</li>
      </ul>
    </li>
    <br>
    <li>A folyamat
      <ul>
        <pre>
          this._apiService.getPage(5).subscribe((pageData) => &#123;
            console.log(pageData);
          });
        </pre>
        <li>Meghívjuk valamelyik komponensből a kívánt függvényt</li>
        <li>A metódus get, az id 5, data nincs, tehát null</li>
        <pre>
          public getPage(id): Observable&#60;any> &#123;
            return this.doRequest('get', `$&#123;this.baseUrl}page/$&#123;id}/`, null);
          }
        </pre>
        <li>Ennek hatására lefut a doRequest függvényünk</li>
        <li>A header összeállítása után a 'get' case-be futunk bele</li>
        <pre>
          case 'get':
            return this.http.get(url, httpOptions).pipe(
              catchError((e) => this.errorHandler(e)),
              catchError((e) => this.confirmHandler(e, method, url, data)),
              map((x: any) => x.data)
            );
        </pre>
        <li>A válasz vagy sikeres lesz...
          <ul>
            <li>A válasz .data kulcs tartalmát visszaadja a feliratkozónak (a komponens subscribe callbackje)</li>
          </ul>
        </li>
        <li>...vagy hibaüzenettel tér vissza
          <ul>
            <li>Először az errorHandler, majd a confirmHandler metódus fut le</li>
          </ul>
        </li>
        <li>A throwError használata azt jelenti, hogy a hibát nem "oldjuk meg", hanem "továbbadjuk" a láncban
          <ul>
            <li>Az errorHandler függvényben továbbadjuk a következő catchError-nak a hibát</li>
            <pre>
              return throwError(error);
            </pre>
          </ul>
        </li>
        <li>A hibát megkapja a confirmHandler, ami csak akkor foglalkozik vele, ha 409-es, amennyiben nem az, akkor
          továbbadja azt, mivel throwError-ral tér vissza
          <ul>
            <li>Ezt követően a Subscriber kapja meb a hibát, és - akár - tudja kezelni</li>
            <pre>
              this._apiService.getPage(5).subscribe(&#123;
                next: (data) => console.log(data),
                error: (err) => console.error('Error in component:', err),
                complete: () => console.log('Request completed')
              });              
            </pre>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #httpclientexample data-anchor="httpclientexample">Firebase example</h5>
  <app-navi [tempSwitcher]="'http'"></app-navi>
</div>

<div>
  <h3 #authentication data-anchor="authentication">Authentication</h3>
  <ul>
    <li>Ahhoz, hogy egy felhasználó authentikálni tudjon, első lépésként regisztrálnia szükséges, aztán pedig
      bejelentkeznie
      <ul>
        <li>Utóbbit credetial-ökkel tudja megtenni</li>
      </ul>
    </li>
    <li>Bejelentkezéskor egy POST requestet küld a user a szerver felé
      <ul>
        <li>A credential-öket a request body-ban küldi el</li>
        <li>A validáció szerver oldalon történik</li>
        <li>Ezt nem lehet megtenni a kliens oldalon, mert az Angular JavaScript-et futtat a böngészőben, és ez a kód
          bárki számára olvsható a böngésző developer tooljával</li>
      </ul>
    </li>
    <li>A szerver válaszként, ha valid a credetial, token-t küld a kliensek
      <ul>
        <li>JSON Web Token (JWT)
          <ul>
            <li>Encoded string (kódolt szöveg)</li>
            <li>Titkosított vagy aláírt szöveges formátumú adategység</li>
            <li>Leggyakrabban hitelesítéshez és adatok biztonságos átviteléhez használnak webes környezetben</li>
            <li>Három részből áll (ponttal elválasztva), mindegyik Base64Url formátumban van kódolva
              <ol>
                <li>Header: Azonosítja a token típusát és az aláírás algoritmusát
                  <ul>
                    <li>A token típusát (JWT) és az aláírás algoritmusát (pl. HS256) határozza meg.</li>
                    <pre>
                      &#123;
                        "alg": "HS256",
                        "typ": "JWT"
                      }
                    </pre>
                  </ul>
                </li>
                <li>Payload: Tartalmazza a tokenben tárolt adatokat (pl. felhasználóazonosító, jogosultságok)
                  <ul>
                    <li>Tartalmazhat lejárati időt, user ID-t, user nevet</li>
                    <pre>
                      &#123;
                        "sub": "1234567890",
                        "name": "John Doe",
                        "admin": true
                      }
                    </pre>
                  </ul>
                </li>
                <li>Signature: Ellenőrző kód, amely biztosítja a token hitelességét
                  <ul>
                    <li>Titkos kulcs, a fejléc és a payload kombinációjából készül az aláírás</li>
                    <pre>
                      HMACSHA256(
                        base64UrlEncode(header) + "." + base64UrlEncode(payload),
                        secret
                      )
                    </pre>
                  </ul>
                </li>
              </ol>
            </li>
            <pre>
              eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
            </pre>
          </ul>
        </li>
        <li>Unique a kliens számára</li>
        <li>Minden alkalommal, amikor a felhasználó belép, másik tokent kap</li>
        <li>Authorizációt lehet vele végezni</li>
        <li>A szerver el tudja dönteni, hogy az érkező token valid, vagy sem</li>
        <li>A kliens eltárolja a token-t
          <ul>
            <li>Pl. a localStorage-ban</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A kliensnek, ha védett tartalomhoz kíván hozzáférni, el kell küldenie a token-jét a requestben
      <ul>
        <li>Mivel a szerver generálta a token-t, így ellenőrizni is tudja</li>
      </ul>
    </li>
    <li>A Firebase Realtime adatbázisának Rules fülén állítsuk át a hozzáférést
      <ul>
        <li>Mostantól csak authentikált felhasználók olvashatják, és írhatják az adatbázist</li>
        <pre>
          &#123;
            "rules": &#123;
              ".read": "auth != null",
              ".write": "auth != null",
            }
          }
        </pre>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #loginsignupform data-anchor="loginsignupform">Login / signup form</h5>
  <ul>
    <pre>
      <b>// navi-routing.module.ts</b>
      const routes: Routes = [
        &#123; path: 'dashboard/:id', component: TaskComponent, outlet: 'http' },
        &#123; path: 'dashboard/login', component: AuthloginComponent, outlet: 'auth' }, // login oldal, ami a task lista felett jelenik meg
      ];

      <b>// dashboard.component.html</b>
      &#60;header>
        &#60;div class="title">My Website&#60;/div>
        &#16;nav>
            &#60;button [routerLink]="['/', 'angular']" (click)="naviHelper = false">Home&#60;/button>
            &#60;button>Contact&#60;/button>
            &#60;button [routerLink]="[&#123; outlets: &#123; auth: ['dashboard', 'login'] } }]"
                (click)="naviHelper = !naviHelper">Login&#60;/button>
        &#60;/nav>
      &#60;/header>
      ...
      &#60;div *ngIf="naviHelper" class="rounded-border"> // szükséges az ngIf, különben jelen routing-gal nem jelenik meg a komponens
        &#60;router-outlet name="auth">&#60;/router-outlet>
      &#60;/div>
      ...

      <b>// dashboard.component.ts</b>
      naviHelper: boolean = false;

      constructor() &#123;
        ...
        this._router.url.includes('auth:dashboard') ? this.naviHelper = true : this.naviHelper = false; // ha szerelep az url-ben, akkor a konstruktorban igazzá tesszük az értéket
      }
      ...

      <b>// authlogin.component.html</b>
      &#60;div style="text-align: right;">
        &#60;div class="btn-group">
            &#60;button class="btn btn-primary" [class.active]="userSignedUp" (click)="userSignedUp = !userSignedUp">
                Sign in&#60;/button>
            &#60;button class="btn btn-primary" [class.active]="!userSignedUp" (click)="userSignedUp = !userSignedUp">
                Sign up&#60;/button>
        &#60;/div>
      &#60;/div>
    
      &#60;form #loginForm="ngForm" (ngSubmit)="submitForm(loginForm)">
        &#60;h5>&#123; &#123;userSignedUp ? 'Sign in' : 'Sign up'}}&#60;/h5>
        &#60;div class="input-group mb-3">
            &#60;span class="input-group-text" id="basic-addon1">Username&#60;/span>
            &#60;input type="text" class="form-control" name="email" aria-label="Email address" aria-describedby="basic-addon1"
                ngModel email required>
        &#60;/div>
        &#60;div class="input-group mb-3">
            &#60;span class="input-group-text" id="basic-addon2">Password&#60;/span>
            &#60;input type="text" class="form-control" name="password" aria-label="Password" aria-describedby="basic-addon2"
                ngModel minlength="8" required>
        &#60;/div>
        &#60;div style="text-align: right;">
            &#60;button type="button" class="btn btn-outline-primary" [disabled]="loginForm.invalid" type="submit">
              &#123; &#123;userSignedUp ? 'Login' : 'Register'}}
            &#60;/button>
        &#60;/div>
      &#60;/form>

      <b>// authlogin.component.ts</b>
      export class AuthloginComponent &#123;
        userSignedUp = true;
      
        submitForm(form: NgForm) &#123;
          console.log(form.value);
          form.reset();
        }
      }
    </pre>
    <li>A fenti kód a kiindulási alapunk
      <ul>
        <li>A login oldalunk a task lista felett fog megjelenni</li>
        <li>A login ablakban lehetőségünk van a regisztráció, és a bejelentkezés között váltani</li>
        <li>Létrehoztunk egy Template Driver Form-ot
          <ul>
            <li>Mindkét input mezője kötelező</li>
            <li>Az email mezőn az email attribútum is szerepel, így történik emailre validáció</li>
            <li>A jelszó mező kapott egy minlength=8 tulajdonságot, így legalább 8 karaktert kell beleírni</li>
          </ul>
        </li>
        <li>A regisztráció/belépés gomb egyelőre csak logol, és kinullázza a form-ot</li>
      </ul>
    </li>
    <li>A Firebase Authentication részében ebgedélyezésre került az Email/Password</li>
    <li>A következő lépés, hogy Sign up requestet küldjünk a Firebase felé
      <ul>
        <pre>
          onSignUp(email: string, password: string): Observable&#60;AuthFirebaseResponse> &#123;
            return this._http.post&#60;AuthFirebaseResponse>(
                `https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=$&#123;this.firebaseAPIKey}`,
                &#123; email, password, returnSecureToken: true }
            );
          }
        </pre>
        <li>Observable-t kapunk, amit visszaadunk a függvény meghívójának (Subscriber)</li>
        <li>Létrehoztuk a 'AuthFirebaseResponse' interface-t, ami leírja a szervertől kapott választ</li>
        <li>A returnSecureToken-nek a dokumentáció szerint true-nak kell lennie</li>
        <li>A custom header miatt, amit az Interceptor csatol a HTTP requesthez, CORS policy error-t kapunk, így ki
          szükséges venni a kódból</li>
      </ul>
    </li>
    <pre>
      <b>// auth-firebase.service.ts</b>
      @Injectable(&#123; providedIn: 'root' })

      export class AuthFirebaseService &#123;
          firebaseAPIKey = environment.firebaseAPIKey;
          private _http: HttpClient = inject(HttpClient);

          onSignUp(email: string, password: string): Observable&#60;AuthFirebaseResponse | string> &#123; // error esetén a handleError Observable&#60;string>-et ad vissza
            return this._http.post&#60;AuthFirebaseResponse>(
                `https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=$&#123;this.firebaseAPIKey}`,
                &#123; email, password, returnSecureToken: true }
            ).pipe(
              catchError((err) => &#123;
                return this.handleError(err.error.error.message);
              })
            );
          }

          onSignIn(email: string, password: string): Observable&#60;AuthFirebaseResponse | string> &#123; // error esetén a handleError Observable&#60;string>-et ad vissza
            return this._http.post&#60;AuthFirebaseResponse>(
              `https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=$&#123;this.firebaseAPIKey}`,
              &#123; email, password, returnSecureToken: true }
            ).pipe(
              catchError((err) => &#123;
                return this.handleError(err.error.error.message);
              })
            );
          }

        handleError(error: string): Observable&#123;any> &#123;  // string lesz az errorMessages[error] is
          const errorMessages: &#123; [key: string]: string } = &#123;
              EMAIL_NOT_FOUND: 'Invalid email address. Please try again.',
              INVALID_PASSWORD: 'Invalid password. Please try again.',
              USER_DISABLED: 'Your account has been disabled.',
              EMAIL_EXISTS: 'Email address already registered.',
              OPERATION_NOT_ALLOWED: 'This operation is not allowed.',
              TOO_MANY_ATTEMPTS_TRY_LATER: 'Too many attempts. Try again later.'
              INVALID_LOGIN_CREDENTIALS: 'Invalid email address. Please try again.'
          }
  
          return throwError(() => errorMessages[error] || 'Unknown error');
          // return throwError( () => new Error(errorMessages[error] || 'Unknown error')); // a subscribe error ágában a .message kulcs alatt van a hibaüzenet
          // a new Error(errorMessages[error] || 'Unknown error') esetében Observable&#60;Error || string> a függvény visszatérési értéke 
        }

      <b>// AuthFirebaseResponse.ts</b>
        export interface AuthFirebaseResponse &#123;
          idToken: string;
          email: string;
          refreshToken: string;
          expiresIn: string;
          localId: string;
          kind: string;
          registered?: boolean; // optional property, csak bejelentkezésnél kapjuk meg
        }

      <b>// authlogin.component.html</b>
      &#60;form #loginForm="ngForm" [loading]="isLoading" (ngSubmit)="submitForm(loginForm)"> // loading direktíva került a formra
        ...
      &#60;/form>
      

      <b>// authlogin.component.ts</b>
      submitForm(form: NgForm) &#123;
        if (this.userSignedUp) &#123;
          this._authFirebase.onSignIn(form.value.email, form.value.password).subscribe(&#123;
            next: (val) => &#123;
              console.log('SignUp: ', val);
              this.isLoading = false;
            },
            error: (err) => this.onErrorHappens(err);
            }
        } else &#123;
          this._authFirebase.onSignUp(form.value.email, form.value.password).subscribe(&#123;
            next: (val) => &#123;
              console.log('SignUp: ', val);
              this.isLoading = false;
            },
            error: (err) => this.onErrorHappens(err);
          })
        }
        form.reset();
      }

      onErrorHappens(errorMessage: string) &#123;
        this.isLoading = false;
        this.showToast = true;
        this.errorMessage = errorMessage;
      }

      <b>// loading.directive.ts</b>
      @Directive(&#123;
        selector: '[loading]'
      })

      export class LoadingDirective implements OnChanges &#123;
        @Input('loading') isLoading: boolean = false;
    
        private spinnerContainer: HTMLDivElement;
        private spinner: HTMLDivElement;
    
        constructor(private el: ElementRef, private renderer: Renderer2) &#123;
            this.spinnerContainer = this.renderer.createElement('div');
            this.renderer.setStyle(this.spinnerContainer, 'position', 'absolute');
            this.renderer.setStyle(this.spinnerContainer, 'top', '50%');
            this.renderer.setStyle(this.spinnerContainer, 'left', '50%');
            this.renderer.setStyle(this.spinnerContainer, 'transform', 'translate(-50%, -50%)');
            this.renderer.setStyle(this.spinnerContainer, 'z-index', '999');
    
            this.spinner = this.renderer.createElement('div');
            this.renderer.addClass(this.spinner, 'spinner-border');
            this.spinner = this.spinnerContainer.appendChild(this.spinner);
        }
    
        ngOnChanges(): void &#123;
            if (this.isLoading) &#123;
                this.showSpinner();
            } else &#123;
                this.hideSpinner();
            }
        }
    
        private showSpinner(): void &#123;
            this.renderer.setStyle(this.el.nativeElement, 'position', 'relative');
            this.renderer.appendChild(this.el.nativeElement, this.spinnerContainer);
        }
    
        private hideSpinner(): void &#123;
            this.renderer.removeChild(this.el.nativeElement, this.spinnerContainer);
        }
      }    
    </pre>
    <li>A hibakezelés a service-ben történik
      <ul>
        <li>A catchError elkapja a hibát, és throwError-ral Observable-t adunk tovább a komponens felé</li>
        <li>Mindeközben a hibaüzenetet az 'errorHandler' függvénnyel generáljuk. ami hibát is dob
          (Observable&#60;string>)</li>
      </ul>
    </li>
    <li>Érdemes lehet a throwError-t visszahelyezni az onSignUp és onSignIn függvényekbe, mert úgy nincs szükség arra,
      hogy a két függvény kimenetének típusa Observable&#60;string> is lehessen, és ebben az esetben a komponensben sem
      szükséges kezelni külön, hogy string típus is lehet, nem utolsó sorban pedig egységesebb az errorHandler feladata
    </li>
    <li>A következőkben átalakítjuk a komponensben a függvényhívásokat úgy, hogy ha Observable érkezik az api
      szerviztől, akkor azt változóban tároljuk</li>
    <pre>
      <b>// authlogin.component.ts</b>
      authObservable$: Observable&#60;AuthFirebaseResponse> = new Observable&#60;AuthFirebaseResponse>;

      submitForm(form: NgForm) &#123;
        this.isLoading = true;
        if (this.userSignedUp) &#123;
          this.authObservable$ = this._authFirebase.onSignIn(form.value.email, form.value.password)
        } else &#123;
          this.authObservable$ = this._authFirebase.onSignUp(form.value.email, form.value.password)
        }
        form.reset();
      }
    </pre>
  </ul>
  <br>
  <h5 #createuserfromresponsedata data-anchor="createuserfromresponsedata">Create user from response data</h5>
  <ul>
    <li>Létrehozunk a felhasználók számára egy model-t
      <ul>
        <pre>
          <b>// AuthFirebaseUser.ts</b>
          export class AuthFirebaseUser &#123;
            constructor(
                public id: string,
                public email: string,
                private _token: string, // nem tesszük elérhetővé osztályon kívül
                private _expiresIn: Date // nem tesszük elérhetővé osztályon kívül
            ) &#123; }
        
            get token() &#123;
                if (!this._expiresIn || this._expiresIn < new Date()) &#123;
                    return null;
                }
                return this._token;
            }
        
            /* set token(value: string) &#123; // nem kívánunk ilyen opciót, ezért van kikommentezve
                if (!value) &#123;
                  // logika
                }
                this._token = value;
            } */
          }
        </pre>
        <li>A konstruktorban megadott property-kből, mivel access modifier van előttük, lokális változók jönnek létre
          automatikusan</li>
        <li>A _token-t használni szeretnénk az appunkban, de nem akarjuk megváltoztatni
          <ul>
            <li>Ha public lenne a _token, bárhonnan elérhető lehetne alkalmazásszerte</li>
          </ul>
        </li>
        <li>getter-rel elérhető tesszük a _token-t osztályon kívülről is
          <ul>
            <li>Tulajdonképpen prperty-t hozunk létre a get kulcsszóval</li>
            <li>get property, elérhető class-on kívül, de nem módosítható</li>
            <li>A token property-vel elérhető a _token privát változó</li>
            <li>Ha az _expiresIn property nem létezik, vagy kisebb, mint a aktuális idő (tehát lejárt), akkor null-lal
              térünk vissza
              <ul>
                <li>Ellenkező esetben pedig a _token-nel</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Ez után az auth firebase service-ben el szeretnénk érni, hogy amikor egy új felhasználó regisztrál, vagy egy
          létező felhasználó bejelentkezik, készüljön egy új AuthFirebaseUser, amit megkapunk a SignUp, vagy SignIn
          request-kor
          <ul>
            <li>SignUp eseménykor nem szükséges külön még be is jelentkezni, bejelentkeztetjük a user-t</li>
            <li>Csak, ha lejár a token (JSON Web Token / JWT), vagy kijelentkezik a felhasználó, utána szükséges a
              bejelentkezés</li>
            <li>Továbbá, a bejelentkezett felhasználó elérhető kell, hogy legyen a teljes alkalmazásban
              <ul>
                <li>Bárhonnan elérhetőnek kell lennie az adatainak</li>
              </ul>
            </li>
          </ul>
        </li>
        <pre>
          <b>// auth-firebase.service.ts</b>
          ...
          firebaseUser$: Subject&#60;AuthFirebaseUser> = new Subject&#60;AuthFirebaseUser>(); // AuthFirebaseUser típust fog kibocsátani a Subject

          onSignUp(email: string, password: string): Observable&#60;AuthFirebaseResponse> &#123; // error esetén a handleError Observable&#60;string>-et ad vissza
            return this._http.post&#60;AuthFirebaseResponse>(
                `https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=$&#123;this.firebaseAPIKey}`,
                &#123; email, password, returnSecureToken: true }
            ).pipe(
                tap((response) => &#123;
                    this.handleUser(response);
                }),
                catchError((err) => &#123;
                    return throwError(() => (this.handleError(err.error.error.message)));
                })
            );
          }
    
          onSignIn(email: string, password: string): Observable&#60;AuthFirebaseResponse> &#123; // error esetén a handleError Observable&#60;string>-et ad vissza
              return this._http.post&#60;AuthFirebaseResponse>(
                  `https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=$&#123;this.firebaseAPIKey}`,
                  &#123; email, password, returnSecureToken: true }
              ).pipe(
                  tap((response) => &#123;
                      this.handleUser(response);
                  }),
                  catchError((err) => &#123;
                      return throwError(() => (this.handleError(err.error.error.message)));
                  })
              );
          }
      
          handleUser(resp: AuthFirebaseResponse) &#123;
              const expireDate = new Date().getTime() + (+resp.expiresIn * 1000); // a response.expiresIn string, a + jellel számmá konvertáltuk, és mivel ms-ban van megadva, ezért megszoroztuk ezerrel
              const expires = new Date(expireDate); // a számot dátummá alakítottuk
              const user = new AuthFirebaseUser(resp.localId, resp.email, resp.idToken, expires);
              this.firebaseUser$.next(user);
          }
          ...
        </pre>
        <li>A tap operátorral hozzáférünk a response-hoz
          <ul>
            <li>A válasz módosítása nélkül tudunk logikát futtatni az operátoron belül</li>
            <li>Jelen esetben az AuthFirebaseUser osztály meghívásával új felhasználót szeretnénk készíteni</li>
            <li>A lejárat beállítását követően létrehozzuk az új felhaszálót az appunkban</li>
            <li>Ezt követően a firebaseUser$ Subject segítségével értesítünk minden feliratkozót, hogy létezik az appban
              felhasználó</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #dinamicmenulinks data-anchor="dinamicmenulinks">Dynamic menu links</h5>
  <ul>
    <li>Ha belépés után redirect-elni szeretnénk a felhasználót, azt 2 helyen is megtehetjük
      <ol>
        <li>Authlogin komponensben
          <ul>
            <li>Az authObservable$ next callback függvényében</li>
          </ul>
        </li>
        <li>AuthFirebase szervizben
          <ul>
            <li>onSignUp és onSignIn függvényekben</li>
          </ul>
        </li>
      </ol>
    </li>
    <li>Mindkét megközelítés helyes
      <ul>
        <li>Mivel UI-jal kapcsolatos, ezért valamivel logikusabb lehet a komponens class-ban elhelyezni</li>
        <li>A response megérkezésekor navigálunk</li>
        <pre>
          this.authObservable$.subscribe(&#123;
            next: (val) => &#123;
              this._router.navigate(['/', 'angular']);
            },
            error: (err) => &#123; }
          });
        </pre>
      </ul>
    </li>
    <li>Módosítsuk a kódot úgy, hogy amennyiben van bejelentkezett felhasználó, a login gomb logout feliratú legyen,
      illetve az egyéb menü gombok se látszódjanak, csak bejelentkezés után
      <ul>
        <li>Az AuthFirebase szervizünkben létrehoztunk korábban egy firebaseUser$ Subject-et, ami user objektumot bocsát
          ki
          <ul>
            <li>Ebben az objektumban elérhető a JWT</li>
            <li>Abban az esetben, ha valóban szerepel JWT az objektumban, és nincs lejárva, a felhasználó be van
              jelentkezve</li>
          </ul>
        </li>
        <pre>
          <b>// dashboard.component.html</b>
          &#60;nav [ngSwitch]="firebaseUserIsLoggedIn">
            &#60;ng-container *ngSwitchCase="false">
                &#60;button [routerLink]="['/', 'angular']" (click)="naviHelper = false">Home&#60;/button>
                &#60;button>Contact&#60;/button>
                &#60;button [routerLink]="[&#123; outlets: &#123; auth: ['dashboard', 'login'] } }]"
                    (click)="naviHelper = !naviHelper">Login&#60;/button>
            &#60;/ng-container>
            &#60;ng-container *ngSwitchCase="true">
                &#60;button>Logout&#60;/button>
            &#60;/ng-container>
          &#60;/nav>

          <b>// dashboard.component.ts</b>
          private _authFirebaseService: AuthFirebaseService = inject(AuthFirebaseService);
          firebaseUserIsLoggedIn: boolean = false;

          ngOnInit(): void &#123;
            this._authFirebaseService.firebaseUser$.subscribe(&#123;
              next: (user: AuthFirebaseUser) => &#123;
                this.firebaseUserIsLoggedIn = user ? true : false; // a lejárat token ellenőrzése még nem történik meg 
              }
            });
            this.subscriptions = [...this.subscriptions, tasksSub, apiStateSub, authFirebaseUserSub]; // good practice
          }
          
          ngOnDestroy() &#123;
            this.subscriptions.forEach(sub => &#123;
              sub.unsubscribe();
            })
          }
        </pre>
        <li>Akármikor a firebaseUser$ értéket bocsát ki, a dashboard komponensünkben értesülni fogunk róla, mivel
          feliratkoztunk a Subject-re</li>
        <li>Ne felejtsük el, hogy újraindítva az alkalmazást, a user objektumunk elveszik</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #sendingtokenwithrequests data-anchor="sendingtokenwithrequests">Sending token with requests</h5>
  <ul>
    <li>Firebase Realtime Database Rules
      <ul>
        <pre>
          &#123;
            "rules": &#123;
              ".read": "auth != null",
              ".write": "auth != null",
            }
          }
        </pre>
        <li>Jelenleg be van állítva az adatbázis szabályai között, hogy csakis kizárólag authentikált felhasználók
          olvashatják, és írhatják az adatbázist</li>
      </ul>
    </li>
    <li>Annak ellenére, hogy már be tudunk jelentkezni az Angular applikációnkba, a szerver még nem tud róla, hogy
      rendelkezünk tőle származó token-nel
      <ul>
        <li>A request-ekben meg kell mondanunk, hogy egy authentikált felhasználó küldi a kéréseket</li>
        <li>Vissza kell küldenünk az access token-t a szervernek minden(!) requestben</li>
      </ul>
    </li>
    <li>Az api szervizben szeretnénk elérni az authfirebase szervizben lévő firebaseUser$ Subject-et
      <ul>
        <li>AuthFirebaseUser objektumot bocsát ki</li>
        <li>Ebből az objektumból van szükségünk a JWT-re</li>
        <li>A gond az, hogy az alkalmazás újraindításával kiürül a Subject (null-t emit-ál)</li>
        <pre>
          <b>// api.service.ts</b>
          private _authFirebaseService: AuthFirebaseService = inject(AuthFirebaseService);

          getTasks() &#123;
            this._authFirebaseService.firebaseUser$.subscribe(&#123;
                next: (val) => &#123;  // le fog futni a callback function, amikor újonnan emit-ált adatot kapunk a Subject-től
                    console.log(val);
                }
            })
            this._http.get&#60; &#123; [key: string]: Task }>(`$&#123;this.firebaseURL}.json?page=1&item=10`, &#123; observe: 'body', responseType: 'json' })
                .pipe(
                    map(data => this.transformFirebaseData(data)),
                    catchError((error) => this.errorHandler(error)) // megfogja a hibát az Observable láncban
                )
                .subscribe(&#123;
                    next: (val) => &#123;
                        this.tasksSubject.next(val);
                        this.apiStateSubject.next(&#123;
                            isLoading: false,
                            success: true
                        });
                    },
                    error: (err) => this.statusHandler(err) // a throwError által visszaadott Observable itt érhető el
                });
            }
        </pre>
        <li>A firebaseUser$ előbb bocsátotta ki magából az első adatcsomagot az alkalmazás betöltését követően, mint
          hogy az api service-ben feliratkoztunk volna rá
          <ul>
            <li>Csak az újonnan kibocsátott adatokhoz férünk már hozzá</li>
            <li>Márpedig szükségünk van a korábban emit-ált user adatra</li>
            <li>E végett az auth firebase service-ben a Subject helyett használhatunk BehaviorSubject-et</li>
            <pre>
              <b>// apii.service.ts</b>
              firebaseUser$: BehaviorSubject&#60;AuthFirebaseUser | null> = new BehaviorSubject&#60;AuthFirebaseUser | null>(null); // kezdetben null-t, majd AuthFirebaseUser típust fog kibocsátani a BehaviorSubject

              <b>// dashboard.component.ts</b>
              getTasks() &#123;
                const authFirebaseUserSub = this._authFirebaseService.firebaseUser$.subscribe(&#123;
                  next: (user: AuthFirebaseUser | null) => &#123; // null is lehet
                    this.firebaseUserIsLoggedIn = user ? true : false; // a lejárat token ellenőrzése még nem történik meg 
                  }
                }).unsubscribe();

              this._http.get&#60; &#123; [key: string]: Task }>(`$&#123;this.firebaseURL}.json?page=1&item=10`, &#123; observe: 'body', responseType: 'json' })
                .pipe(
                    map(data => this.transformFirebaseData(data)),
                    catchError((error) => this.errorHandler(error)) // megfogja a hibát az Observable láncban
                )
                .subscribe(&#123;
                    next: (val) => &#123;
                        this.tasksSubject.next(val);
                        this.apiStateSubject.next(&#123;
                            isLoading: false,
                            success: true
                        });
                    },
                    error: (err) => this.statusHandler(err) // a throwError által visszaadott Observable itt érhető el
                });
              }
            </pre>
            <li>Kizárólag annyi a különbség, hogy az új feliratkozók megkapják a legutóbb kibocsátott értéket</li>
            <li>Azután, hogy megkaptuk az authFirebaseUser objektumot, már nincs szükségünk a feliratkozásra, csak
              használni szeretnénk a kapott adatot, ezért leiratkozunk róla
              <ul>
                <li>Egy másik féle, RxJS megoldás lehet a take operátor használata</li>
                <pre>
                  this._authFirebaseService.firebaseUser$
                    .pipe(
                        take(1)
                    )
                    .subscribe(&#123;
                        next: (val) => &#123;  // le fog futni a callback function, amikor újonnan emit-ált adatot kapunk a Subject-től
                            console.log(val);
                        }
                    });
                </pre>
                <li>Ebben az esetben megkapjuk az utoljára kibocsátott értékét az Observable-nek (Subject-nek),
                  elvégződik az automatikus leiratkozás</li>
              </ul>
            </li>
            <li>A getTasks függvényből Observable-lel szeretnénk visszatérni, ami a response adatot tartalmazza
              <ul>
                <li>Amennyiben a firebaseUser$-re való feliratkozásban helyezzük el a HTTP kérést, nem fogunk
                  tudni Observable-t visszaadni</li>
                <li>exhaustMap operátort fogunk használni
                  <ul>
                    <li>Megvárja az első Observable-t</li>
                    <li>A take operátor user objektumot ad vissza, ez lesz a take eredménye</li>
                    <li>Az exhaustMap pedig egy új Observable-t képes visszaadni</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>A firebaseUser$ által adott objektumból a tokent ki kell bonttani
              <ul>
                <li>A Firebase az 'auth' query paraméterben fogadja a tokeneket</li>
              </ul>
            </li>
            <pre>
              <b>before</b>
              getTasks() &#123;
                this._http.get&#60; &#123; [key: string]: Task }>(`$&#123;this.firebaseURL}.json?page=1&item=10`, &#123; observe: 'body', responseType: 'json' })
                    .pipe(
                        map(data => this.transformFirebaseData(data)),
                        catchError((error) => this.errorHandler(error)) // megfogja a hibát az Observable láncban
                    )
                    .subscribe(&#123;
                        next: (val) => &#123;
                            this.tasksSubject.next(val);
                            this.apiStateSubject.next(&#123;
                                isLoading: false,
                                success: true
                            });
                        },
                        error: (err) => this.statusHandler(err) // a throwError által visszaadott Observable itt érhető el
                    });
              }

              <b>after</b>
              getTasks() &#123;
                this._authFirebaseService.firebaseUser$
                    .pipe(
                        take(1),
                        exhaustMap(user => &#123;
                        return this._http.get&#60; &#123; [key: string]: Task }>(`$&#123;this.firebaseURL}.json`, &#123; params: new HttpParams().set('auth', user?.token || '') }) // mivel a user.token lehet null is, és a param csak string | number | boolean, ezért a || üres string

                        }),
                        map(data => this.transformFirebaseData(data)),
                        catchError((error) => this.errorHandler(error)) // megfogja a hibát az Observable láncban
                    )
                    .subscribe(&#123;
                        next: (val) => &#123;
                            this.tasksSubject.next(val);
                            this.apiStateSubject.next(&#123;
                                isLoading: false,
                                success: true
                            });
                        },
                        error: (err) => this.statusHandler(err) // a throwError által visszaadott Observable itt érhető el
                    });
                }
            </pre>
            <li>Before: <ul>
                <li>Közvetlenül egy HTTP kérést hajt végre a szerver felé</li>
                <li>Nem történik felhasználói hitelesítés</li>
              </ul>
            </li>
            <li>After: <ul>
                <li>Reactive programming</li>
                <li>A HTTP kérést megelőzi a user token beszerzése</li>
                <li>Az exhaustMap megvárja, hogy a firebaseUser$ kibocsásson egy értéket
                  <ul>
                    <li>Nem indít el új kérést addig, amíg az első be nem fejeződik</li>
                    <li>Biztosítja, hogy egy időben csak egy HTTP-kérés fusson</li>
                  </ul>
                </li>
                <li>Az alkalmazás csak akkor indít HTTP kérést, ha rendelkezik a felhasználói tokennel</li>
              </ul>
            </li>
            <li>Bejelentkezést követően, ha ráfrissítünk a listára, megérkeznek a taskok</li>
          </ul>
        </li>
        <li>Az alkalmazás ezen pontján még csak a task listát tudjuk lekérni az adatbázisból</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #sendingtokenwithinterceptor data-anchor="sendingtokenwithinterceptor">Sending token with interceptor</h5>
  <ul>
    <li>Megtehetnénk, hogy a getTasks-hoz hasonlóan mindegyik request-nél külön megírjuk az auth query string
      hozzáadását a kéréshez, de jelen esetben Interceptor-t fogunk alkalmazni
      <ul>
        <li>Tulajdonképpen létezik már egy AuthInterceptorService osztályunk, ezt tudjuk is használni</li>

        <li>Amikor feliratkozunk a firebaseUser$ BehaviorSubject-re, megkapjuk a legutóbb kibocsátott értékét</li>
        <li>A take operátor legszerzi a legutóbbi értéket, és leiratkozik az Observable-ről (Subject-ről), ahogy
          megkapjuk az értéket
          <ul>
            <li>Valamint Observable-lel tér vissza</li>
          </ul>
        </li>
        <li>Az exhaustMap a user objekumot kapja meg</li>
        <pre>
          <b>// auth-interceptor.service.ts</b>
          export class AuthInterceptorService implements HttpInterceptor &#123;
            private _authFirebaseService: AuthFirebaseService = inject(AuthFirebaseService);
        
            intercept(req: HttpRequest&#60;any>, next: HttpHandler): Observable&#60;HttpEvent&#60;any>> &#123; // a next.handle(modifiedRequest) adja vissza az Observable-t
                return this._authFirebaseService.firebaseUser$
                    .pipe(
                        take(1),
                        exhaustMap((user: AuthFirebaseUser | null) => &#123;
                            if (!user) &#123;
                              return next.handle(req); // amennyiben nincs user (null), az eredeti request fog kiküldésre kerülni
                            }
                            const modifiedRequest = req.clone(&#123;
                                params: new HttpParams().set('auth', user?.token || '')
                            });
                            return next.handle(modifiedRequest);
                        })
                    );
            }
          }

          <b>// api.service.ts</b>
          getTasks() &#123;
            this._http.get&#60; &#123; [key: string]: Task }>(`$&#123;this.firebaseURL}.json`)
                .pipe(
                    map(data => this.transformFirebaseData(data)),
                    catchError((error) => this.errorHandler(error)) // megfogja a hibát az Observable láncban
                )
                .subscribe(&#123;
                    next: (val) => &#123;
                        this.tasksSubject.next(val);
                        this.apiStateSubject.next(&#123;
                            isLoading: false,
                            success: true
                        });
                    },
                    error: (err) => this.statusHandler(err) // a throwError által visszaadott Observable itt érhető el
                });
            }
        </pre>
        <li>Minden HTTP kérés, amelyet az alkalmazás küld, átmegy az interceptoron</li>
        <li>Az interceptorhoz injektálva van a AuthFirebaseService, amely hozzáférést biztosít az firebaseUser$
          BehaviorSubject-hez, ami a tokent-t user tokent tartalmazza</li>
        <li>Az intercept metódus a HTTP kérés előtt fut le
          <ol>
            <li>req: a HTTP kérés, amit módosítani szeretnénk</li>
            <li>next: egy HttpHandler, amely a módosított kérés továbbításáért felelős</li>
          </ol>
        </li>
        <li>Reactive programozást alkalmazunk
          <ul>
            <li>A take(1) operátor biztosítja, hogy a stream csak egyszer adjon értéket, és utána leálljon
              <ul>
                <li>Mivel a BehaviorSubject egy folyamatosan figyelhető Observable, minden token-változást kibocsát, így
                  explicit limitálni kellett az áramlást (pl. take(1)), hogy csak a legfrissebb értéket használjuk a
                  kéréshez</li>
                <li>HTTP kérés előtt le fogja kérni a felhasználót, és nem fogja folyamatosan figyelni</li>
              </ul>
            </li>
            <li>Az exhaustMap operátor segítségével biztosítjuk, hogy ha az firebaseUser$ frissül, az értékét
              felhasználjuk
              a HTTP kérés módosításához
              <ul>
                <li>Célja, hogy ha egyszer már van egy aktív HTTP kérés (pl. egy előző kérés válaszára várunk), akkor ne
                  kezdjünk el újabb HTTP kérés indítását</li>
                <li>A HTTP kérés csak akkor folytatódik, ha van érvényes user, és token</li>
              </ul>
            </li>
            <li>Az HttpRequest objektumot nem lehet közvetlenül módosítani, mivel az immutábilis
              <ul>
                <li>A req.clone() metódust használjuk, hogy létrehozzunk egy másolatot a kéréstől, majd hozzáadjuk a
                  szükséges auth paramétert</li>
              </ul>
            </li>
            <li>Az első return az Observable-t adja vissza, amit az interceptornak kell feldolgoznia, a második return
              az új, módosított HTTP kérést adja vissza, amely szintén egy Observable, amit az HttpHandler kezel</li>
            <li>Nincs explicit feliratkozás a firebaseUser$ Subject-re
              <ul>
                <li>Ha már van egy operátor, amely az adatfolyamot feldolgozza (pl. az exhaustMap) az automatikusan
                  kezeli a feliratkozást az Observable-re</li>
                <li>A take(1), és az exhaustMap operátorok automatikusan feliratkoznak rá a firebaseUser$
                  BehaviorSubject-re</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Az Interceptor hatására az api service-ben nincs szükség sem a take(1), sem az exhhaustMap operátor
          használatára, mert az Interceptor gondoskodik
          <ul>
            <li></li>
            <li>Miután az interceptor elvégezte a feladatát, a getTasks() metódusban az HttpClient.get() hívása már
              tartalmazza a megfelelő tokent</li>
            <li>Az api szervizben lévő Observable lánc kizárólag a válasz feldolgozására koncentrál (pl. map,
              catchError), és nem kell külön foglalkoznia a felhasználói tokennel</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #nelogoutxt data-anchor="logout">Logout</h5>
  <ul>
    <li></li>
    <pre>
      <b>// auth-firebase.service.ts</b>
      onLogout() &#123;
        this.firebaseUser$.next(null);
      }

      <b>// authlogin.component.html</b>
      &#60;button (click)="logout()">Logout&#60;/button>

      <b>// authlogin.component.ts</b>
      logout() &#123;
        this._authFirebaseService.onLogout();
        this.onSetDefaultState();
        this.firebaseTasks = [];
        this.naviHelper = false;
        this._router.navigate(['/', 'angular']);
      }
    </pre>
    <li>Kiküldünk a firebaseUser$ Subject-tel egy null értéket, ezzel minden feliratkozó megkapja, hogy nincs user</li>
    <li>Az alkalmazás felépítése miatt egyéb logikákat is le kell futtattni a logout függvényben</li>
  </ul>
  <br>
  <h5 #autologin data-anchor="autologin">Auto login</h5>
  <ul>
    <li>Egyelőre az alkalmazás újraindítását követően újra és újra be kell jelentkeznünk</li>
    <li>Szeretnénk a usert bejelentkezve tartani oldalfrissítést követően is</li>
    <li>Frissítésnél a teljes alkalmazás újraindul
      <ul>
        <li>Minden kód lefut újra</li>
        <li>Az auth-firebase szeervizben lévő firebaseUser$ Subject felveszi a kezdeti állapotát (null)</li>
        <li>Az eddigi logika, hogy amennyiben a user = null, kiléptetjük a felhasználót</li>
        <li>Memóriában tároljuk az alkalmazás állapotát, ami újraindításnál törlődik, majd minden változó újra létrejön,
          kezdeti értékkel</li>
        <li>Valamilyen tárba szükséges menteni az adatokat</li>
        <li>A browser fut a program, így a készülék fájljaihoz nem férünk hozzá</li>
        <li>Viszont dolgozhatunk cookie-kkal, és a böngésző local storage-ával</li>
      </ul>
    </li>
    <li>El fogjuk tárolni a tokenünket a localStorage-ba
      <ul>
        <li>Az auth-firebase service-ben történik meg a bejelentkezés</li>
        <pre>
          handleUser(resp: AuthFirebaseResponse) &#123;
            const expireDate = new Date().getTime() + (+resp.expiresIn * 1000); // a response.expiresIn string, a + jellel számmá konvertáltuk, és mivel ms-ban van megadva, ezért megszoroztuk ezerrel
            const expires = new Date(expireDate); // a számot dátummá alakítottuk
            const user = new AuthFirebaseUser(resp.localId, resp.email, resp.idToken, expires);
            this.firebaseUser$.next(user);
    
            localStorage.setItem('user', JSON.stringify(user));
          }
        </pre>
        <li>A localStorage-ba írás a set metódussal történik
          <ul>
            <li>Két paramétert vár, egy kulcs nevet, és egy értéket</li>
            <li>Csakis kizárólag string értéket adhatunk oda neki, így a user objektumot át kell, hogy alakítsuk
              string-é</li>
            <li>A DevTools-ban az Application fülön, a Local storage alatt találhatjuk meg a tárolt kulcs-érték párokat
            </li>
          </ul>
        </li>
        <li>Jöhet a kiolvasás, és az automatikus beléptetés megoldása
          <ul>
            <pre>
              <b>// auth-firebase.service.ts</b>
              autoLogin() &#123;
                const user = JSON.parse(localStorage.getItem('user') || 'null');
                // const user = JSON.parse(localStorage.getItem('user') ?? 'null');
                // const user = JSON.parse(localStorage.getItem('user')!); // ha biztoosak vagyunk abban, hogy lesz értéke (itt nem)
        
                if (!user) &#123;
                    return;
                }
        
                const loggedInUser = new AuthFirebaseUser(user.email, user.id, user._token, user._expiresIn);

                if (loggedInUser.token) &#123;
                  this.firebaseUser$.next(loggedInUser);
                }
              }
            </pre>
            <li>Az új függvényünkben kiolvassuk a localStorage-ban tárolt user kulcs értékét, és persze string-ből
              visszaalakítjuk objektummá</li>
            <li>Amennyiben nincs tárolt user kulcsunk a localStorage-ben, a JSON.parse() a 'null' string-ből null-t
              készít</li>
            <li>Ha pedig null értéket vesz fel a user, csak visszatérünk a függvényből</li>
            <li>Ellenkező esetben létrehozunk egy új AuthFirebaseUser-t</li>
            <li>Majd megnézzük, hogy a loggedInUser-nek van-e / érvényes-e a tokenje
              <ul>
                <li>Ha a getter (token) property-ben az _expiresIn változó lejárt, vagy nem is létezik, null értéket
                  fogunk kapni a token meghívására</li>
                <li>Ellenkező esetben megkapjuk a tokent, és értesítjük az összes feliratkozót, hogy bejelentkezett
                  felhasználónk van az applikációban</li>
              </ul>
            </li>
            <pre>
              <b>// AuthFirebaseUser.ts // reminder</b>
              export class AuthFirebaseUser &#123;
                constructor(
                    public id: string,
                    public email: string,
                    private _token: string, // nem tesszük elérhetővé osztályon kívül
                    private _expiresIn: Date // nem tesszük elérhetővé osztályon kívül
                ) &#123; }
            
                get token() &#123;
                    if (!this._expiresIn || this._expiresIn &#60; new Date()) &#123;
                        return null;
                    }
                    return this._token;
                }
              }
            </pre>
            <li>Az alkalmazás belépési pontjánál érdemes is meghívni ezt az autoLogin() függvényt
              <ul>
                <li>Mivel jelen appban a navi modulban vagyunk, így a navi.component.ts-ből hívjuk meg ezt a függvényt
                </li>
                <pre>
                  <b>// navi.component.ts</b>
                  ngOnInit(): void &#123;
                    ...
                    this._authFirebaseService.autoLogin();
                  }
                </pre>
              </ul>
            </li>
          </ul>
        </li>
        <li>Mindezzel elértük, hogy amíg le nem jár a token-ünk, be leszünk jelentkezve, hiszen kijelentkezést követően
          nem törlődik a localStorage user adata
          <ul>
            <li>A localStorage user kulcsának törlését követően természetesen "kiléptünk" az alkalmazásból</li>
            <li>Erre még megoldást kell találni</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #autologout data-anchor="autologout">Auto logout</h5>
  <ul>
    <li>A localStorage.clear() metódus a teljes localStorage tartalmát törli
      <ul>
        <li>Mi csak a user kulcsot szeretnénk kiszedni</li>
      </ul>
    </li>
    <li>Egyrészt azt szeretnénk, hogy ha a user kijelentkezik, akkor eltávolítsuk a user datát a storage-ból
      <ul>
        <li>Ezt a kijeletkezés logikánknál tudjuk megtenni</li>
        <pre>
          <b>// dashboard.component.ts</b>
          logout() &#123;
            this._authFirebaseService.onLogout();
            this.onSetDefaultState();
            this.firebaseTasks = [];
            this.naviHelper = false;
            this._router.navigate(['/', 'angular']);
            localStorage.removeItem('user');
          }
        </pre>
      </ul>
    </li>
    <li>Másrészt ügyelnünk kell a lejárt tokenre
      <ul>
        <pre>
          <b>// auth-firebase.service.ts</b>
          private _tokenExpireTimer: ReturnType&#60;typeof setTimeout> | null = null;

          ...

          handleUser(resp: AuthFirebaseResponse) &#123; // lefut a bejelentkezéskor, és a regisztrációkor is
            const expireDate = new Date().getTime() + (+resp.expiresIn * 1000); // a response.expiresIn string, a + jellel számmá konvertáltuk, és mivel ms-ban van megadva, ezért megszoroztuk ezerrel
            const expires = new Date(expireDate); // a számot dátummá alakítottuk
            const user = new AuthFirebaseUser(resp.localId, resp.email, resp.idToken, expires);
            this.firebaseUser$.next(user);
    
            localStorage.setItem('user', JSON.stringify(user));
            this.autoLogout(+resp.expiresIn * 1000); // elindítjuk a timert
          }

          ...

          autoLogin() &#123;
            const user = JSON.parse(localStorage.getItem('user') || 'null');
            // const user = JSON.parse(localStorage.getItem('user') ?? 'null');
            // const user = JSON.parse(localStorage.getItem('user')!); // ha biztoosak vagyunk abban, hogy lesz értéke (itt nem)
    
            if (!user) &#123;
                return;
            }
    
            const loggedInUser = new AuthFirebaseUser(user.email, user.id, user._token, user._expiresIn);
    
            if (loggedInUser.token) &#123;
                this.firebaseUser$.next(loggedInUser);
                const expirationDate = new Date(user._expiresIn); // string-et Date típusra alakítjuk át
                const timerInteger = expirationDate.getTime() - new Date().getTime();
                this.autoLogout(timerInteger);
            }
          }

          autoLogout(expireTime: number) &#123;
            this._tokenExpireTimer = setTimeout(() => &#123;
                this.onLogout();
            }, expireTime)
          }

          <b>// dashboard.compomnent.ts</b>
          const authFirebaseUserSub = this._authFirebaseService.firebaseUser$.subscribe(&#123;
            next: (user: AuthFirebaseUser | null) => &#123;
              this.firebaseUserIsLoggedIn = user ? true : false; // a lejárat token ellenőrzése még nem történik meg
              this.firebaseTasks = user ? this.firebaseTasks : []; // kiürítjük a task tömböt
            }
          })
        </pre>
        <li>A timer-t le szükséges állítani, a a felhasználó maga lépett ki, hogy ne fusson tovább a háttérben
          feleslegesen
          <ul>
            <li>Amennyiben ezt nem tesszük meg, kétszer léptetjük ki a usert</li>
          </ul>
        </li>
        <li>A timert kinullázzuk, amikor a user kilép</li>
        <li>Ha nem tartalmaz a property timert, nem kell kitörölnünk</li>
        <li>Az autoLogout függvényt is meg kell hívnunk
          <ul>
            <li>Minden alkalommal, amikor új felhasználó jelentkezik be az app-ba, vagyis amikor a firebaseUser$
              BehaviorSubject adatot emit-ál</li>
            <li>Amikor bejelentkezünk, vagy regisztrálunk, meghívjuk</li>
          </ul>
        </li>
        <li>Az időt numberként, milliszekundumban adjuk tovább, mivel a setTimeout függvényt is ebben kell beállítani
        </li>
        <li>Az autoLogin-ben szintén új usert emit-álunk, így ott is meghívjuk a timert
          <ul>
            <li>Ebben a függvényünkben, amikor kiszedjük a localStorage-ből a usert, az _expiresIn értékünk DateTime
              típusú</li>
            <li>A getTime metódussal timestamp-et kapunk</li>
            <li>A jövőbeli időből kivonjuk a jelenlegi időt</li>
          </ul>
        </li>
        <li>Az expireTime lejárta után a megadott callback (this.onLogout) automatikusan végrehajtódik, amely
          kijelentkezteti a felhasználót</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #canactivaterouterguard data-anchor="canactivaterouterguard">canActivate router guard</h5>
  <ul>
    <li>A felhasználó direktben is beírhatja azt az URL-t, amihez alapvetően csak bejelentkezés után kívánunk
      hozzáférést biztosítani
      <ul>
        <li>Ennek kiküszöbölése érdekében használhatjuk a canActivate route guard-ot</li>
        <li>Engedélyezhetjük, vagy tilthatjuk, hogy a felhasználó hozzáférjen egy adott route-hoz</li>
      </ul>
    </li>
    <li>Alapvetően a task listához való hozzáférést kellene blokkolnunk, de az alkalmazás felépítéséből adódóan a
      Contact oldalhoz vezető route-ra fogjuk rárakni a guard-ot</li>
    <pre>
      <b>// auth-firebase-guard.ts</b>
      export const AuthFirebaseGuard: CanActivateFn =
        (route: ActivatedRouteSnapshot, state: RouterStateSnapshot):
          boolean | UrlTree | Promise&#60;boolean | UrlTree> | Observable&#60;boolean | UrlTree> => &#123;
          const authFirebaseService: AuthFirebaseService = inject(AuthFirebaseService);
          const router: Router = inject(Router);

          return authFirebaseService.firebaseUser$.pipe( // a kapott / módosított Observable-t adjuk vissza
              take(1),
              map((user: AuthFirebaseUser | null): boolean | UrlTree => &#123; // átalakítjuk az Observable-t, és return-nek tovább adjuk 
                  if (!!user) &#123; // ha nincs user, ez az ág lép életbe
                      return true; // boolean-nel térünk vissza
                  } else &#123;
                      return router.createUrlTree(['/angular']); // UrlTree-val térünk vissza
                  }
              })
          )
      
      <b>// navi-routing.module.ts</b>
      &#123; path: 'dashboard/contact', component: AuthcontactComponent, outlet: 'auth', canActivate: [AuthFirebaseGuard] },
    </pre>
    <li>A 'AuthFirebaseGuard' függvényünkben feliratkozunk a firebaseUser$ BehaviourSubject-re
      <ul>
        <li>Minden alkalommal, amikor a firebaseUser$ adatot emit-ál, megkapja a guard</li>
        <li>A legutóbb kibocsátott értékre vagyunk kíváncsiak, amit tartalmazott a Subject, a jövőbeliekre nem (memory
          leak), így leiratkozunk róla, hiszen route váltáskor érdekel minket, hogy van-e user-ünk, és ez a függvény
          minden route váltáskor le fog futni az adott route esetében</li>
        <li>Pontosan erre kiváló a take(1) operátor, ami egy adatfolyam érkezése után automatikusan leiratkozik az
          Observablre-ről</li>
      </ul>
    </li>
    <li>A canActivate route guard a következő típusokat adhatja vissza
      <ol>
        <li>boolean</li>
        <li>UlrTree
          <ul>
            <li>Annyit tesz, hogy visszaadhatunk egy URL-t, ahová a felhasználót redirect-elni szeretnénk</li>
          </ul>
        </li>
        <li>Promise&#60;boolean | UrlTree></li>
        <li>Observable&#60;boolean | UrlTree></li>
      </ol>
    </li>
    <li>A függvény az ActivatedRouteSnapshot, és a RouterStateSnapshot paramétert kapja meg</li>
    <li>User megléte esetén boolean értékkel (true), hiánya esetében pedig UrlTree-vel térünk vissza</li>
    <li>A map operátor miatt Observable lesz a visszatérési érték</li>
  </ul>
  <br>
  <h5 #authenticationexample data-anchor="authenticationexample">Example</h5>
  <app-navi [tempSwitcher]="'http'"></app-navi>
</div>

<div>
  <h3 #ajax data-anchor="ajax">AJAX</h3>
  <ul>
    <li>Az Angularnak van erre egy dedikált eszköze, a HTTPSClient</li>
    <li>Az AJAX kéréseket a vanilla JS fetch függvényével fogjuk megvalósítani
      <ul>
        <li>fetch() function GET method-jával kell kérést küldenünk</li>
        <li>fetch('https://kodbazis.hu/api/cimek');</li>
        <li>A komponens indulásakor akarjuk futtatni, amihez az ngOnInit életciklus method-ot kell igénybe
          vennünk
        </li>
        <li>Implementálni kell a classba az OnInit-et, majd az ngOnInit method-ot használni
          <ul>
            <li>
              <pre>
                                export class AppComponent implements OnInit &#123;
                              &#125;

                                ngOnInit() &#123;
                              &#125;
                              </pre>
            </li>
            <li>Egyszeri alkalommal fut le benne a kód, amikor a komponens elindul</li>
          </ul>
        </li>
        <li>A fetch() függvény Promise alapon működik
          <ul>
            <li>
              <pre>
                              fetch('https://kodbazis.hu/api/cimek')
                                .then(res => res)
                                .then(data => &#123;
                                console.log(data);
                                return data.json();
                                &#125;)
                                .then(content => &#123;
                                console.log(content);
                                &#125;)
                                .catch(error => &#123;
                                console.error('Hiba történt:', error);
                                &#125;);
                            </pre>
            </li>
            <li>A Promise csak egyszer olvasható, így ahhoz, hogy a Response-t logoljuk, az első then()
              blokkban tovább kell adnunk a választ, majd a második then() blokkban ki tudjuk logolni a
              Response objektumot, majd tovább kell adnunk a kiparsolt JSON adatot, hogy hozzájussunk a
              címekhez
            </li>
            <li>Amennyiben a Response-t nem szeretnénk megtekinteni, az alábbi kód a helyes
              <ul>
                <li>
                  <pre>
                                        fetch("https://kodbazis.hu/api/cimek")
                                            .then(res => res.json())
                                            .then(content => &#123;
                                              console.log(content);
                                        &#125;)
                                    </pre>
                </li>
              </ul>
            </li>
            <li>A catch() blokk hibakezelést valósít meg</li>
          </ul>
        </li>
        <li>Ha nem adunk meg az 'elems' változónak típust, de értékeket igen, akkor a Typescript úgynevezett
          'Type Inference' nevű technikával kitalálja a tömb típusát
          <ul>
            <li>
              <pre>elems = ['A', 'B', 'C'];</pre>
            </li>
            <li>Az értékből levezeti, hogy mi az adott változó típusa</li>
            <li>Erre megoldás lehet, hogy megadjuk a típust
              <ul>
                <li>elems: string[] = [];</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Az egyes elemek szerver oldali törlését az alábbi módon oldjuk meg
          <ul>
            <li>
              <pre>
                                removeAPIelem(index: number) &#123;
                                    fetch('https://kodbazis.hu/api/cimek/' + index, &#123;method: 'DELETE'&#125;)
                              .then(() => &#123;
                              this.getContent();
                              &#125;);
                              &#125;
                            </pre>
            </li>
            <li>A törlés után lekérdezzük újra a listát</li>
            <li>A then() miatt biztosak lehetünk abban, hogy a getContent() csak akkor fog lefutni, ha
              megérdekett a szerverről a válasz (helyes lesz az időbeli sorrendiség)
            </li>
          </ul>
        </li>
        <li>Új elem létrehozásához a POST method-ot kell használnunk
          <ul>
            <li>
              <pre>
                                fetch('https://kodbazis.hu/api/cimek', &#123;
                              method: 'POST',
                              body: JSON.stringify(newElem)
                                &#125;)
                                  .then(()) => &#123;
                              this.getContent();
                                &#125;);
                            </pre>
            </li>
            <li>Az új elem JSON encode-olva utazik a szerver felé (JSON.stringify)
              <ul>
                <li>Ha encode-olt JSON-t szeretnénk dekódolni, azt a JSON.parse() függvénnyel tehetjük
                  meg
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Töltési idő közben a lista helyett megjeleníthetünk egy egyedi képernyőt
          <ul>
            <li>
              <pre>
                                &#60;ng-container *ngIf="isLoading; else list"&#62;
                                    &#60;div&#62;
                                      LOADING
                                    &#60;/div&#62;
                                &#60;/ng-container&#62;
                            </pre>
              <ul>
                <li>A list ID-t el kell helyeznünk a lista elemre (#list)</li>
                <li>Létre kell hoznunk egy állapotváltozót, amiben tároljuk, hogy a töltés éppen
                  folyamatban van-e
                </li>
                <li>Amennyiben sikeres, és sikertelen lekérés esetén is false-ra szeretnénk állítani az
                  isLoading változót, úgy a then() ágak után létrehozhatunk egy finally() ágat
                  <ul>
                    <li>
                      <pre>
                                                fetch('https://kodbazis.hu/api/cimek')
                                                      .then(res => res)
                                                      .then(data => &#123;
                                              console.log(data);
                                              return data.json();
                                                      &#125;)
                                                      .then(content => &#123;
                                              console.log(content);
                                              this.elems = content;
                                                      &#125;)
                                                      .catch(error => &#123;
                                              console.error('Hiba történt:', error);
                                                      &#125;)
                                                      .finally(() => &#123;
                                              this.isLoading = false;
                                                &#125;);
                                            </pre>
                    </li>
                    <li>A finally() ág mindenképp le fog futni</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Mivel DELETE-nél, és POST-nál is meghívjuk a GET-et, így nem szükséges külön a then()
              blokkokban az isLoading változót false-ra állítani, hiszen a GET híváskor amúgy is meg fog
              történni
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #reactive data-anchor="reactive">Reaktive thinking</h3>
  <ul>
    <li>Az operations menüpontban látható az eredeti (procedurális), és az új kód (reaktív)</li>
    <li>Procedurális
      <ul>
        <li>Jelentése: előrehaladó</li>
        <li>Például a törlés úgy néz ki, hogy gombkattintás eseményre futtatunk funkcionalitást, ahol is a metódus
          megkapja azon elem indexét, amit törölni szeretnénk, és a függvény futásakor sorról sorra hajtódnak végre a
          műveletek
        </li>
        <li>A procedurális rendszerek ismérve, hogy sorról sorra hajtunk végre kódot</li>
        <li>A JS engine természetes control flow-ját használjuk fel</li>
      </ul>
    </li>
    <li>Reaktív
      <ul>
        <li>Az alapelv az, hogy a program elemei reagálnak az adatok és események változásaira</li>
        <li>Ahelyett, hogy az adatokat és az állapotot manuálisan kezelnénk, a reaktív programozás lehetővé teszi a
          program számára, hogy automatikusan frissítse magát, amikor az adatok megváltoznak
        </li>
        <li>Nem az engine természetes control flow-ját használjuk fel</li>
        <li>Control flow: Azon mechanizmusokat jelenti, amelyek irányítják, hogy a kód hogyan fut le lépésről lépésre
        </li>
        <li>Reaktív programozásnál csőrendszerek létrehozásával definiáljuk a mi saját flow-nkat</li>
        <li>A csőrendszer résztvevői előre definiálva vannak, még mielőtt a futás megindulna</li>
        <li>Azért lesz reakív a rendszer, mert van egy kiindulási pont, és a futás során egymás után automatikusan
          működésbe lépnek más-más egységek
        </li>
        <li>Nem RxJS specifikus, de praktikus vele megvalósítani</li>
        <li>RxJS-ben definiált csőrendszert ágyazunk Angular kontextusba</li>
        <li>Az Observable esetében, ha egy dobozt képzelünk el, akkor annak nincs bemenete (feliratkozunk rá), viszont
          az RxJS-en belül nekünk olyan konstrukcióra van szükségünk, aminek bemenete is van (adatot adunk neki)
        </li>
        <li>Ezt a konstrukciót Subject-nek nevezik
          <ul>
            <li>Reaktív alapelvkor nem Subject-ekkel dolgozunk, amik nem maguktól generálják ki az értéket, hanem
              manuálisan működtethetők
            </li>
            <li>A csőrendszerek előállításának alapja</li>
            <li>A csőrendszer összes csődarabkája valójában egy Subject, amikre fel vagyunk iratkozva</li>
            <li>refresh$
              <pre>
                refresh$ = new Subject().pipe(
                  tap(() => &#123;
                              this.isLoadingReactive = true;
                  &#125;),
                  switchMap(() => this.http.get('https://kodbazis.hu/api/cimek')),
                  tap((response) => &#123;
                              console.log('http: ', response);
                  &#125;)
                );
              </pre>
              <ul>
                <li>Observable, létezik rajta a pipe() method</li>
                <li>A tap-pel nem bántjuk az adatfolyamot, csak mellékhatást generálunk</li>
                <li>Újratöltéskor azt szeretnénk, hogy a loading legyen true értékű</li>
                <li>A 'this.http.get()' egy Observable-lel tér vissza, ami a választ bocsátja ki adatcsomagként, aztán
                  completed állapotba kerül
                </li>
                <li>Amíg nincs Observer-je, addig nem áramlik benne adat</li>
                <li>A kövegkező lépés, hogy le akarjuk kérni az elemeket szerver oldalról
                  <ul>
                    <li>
                    <li>Ahelyett, hogy az RxJS beépített ajax() függvényét használnánk, az Angular beépített, dedikált
                      eszközét, a HTTPClient-et vesszük igénybe
                    </li>
                    <li>Ehhez dependency injectiont kell végeznünk</li>
                    <pre>
                      constructor(private http: HttpClient) &#123;
                                        &#125;
                    </pre>
                    <li>Az osztály contructor-on keresztül kap egy objektumot, amit ő belül tud használni</li>
                    <li>Más Angularos beépített eszközökhöz is így lehet hozzájutni</li>
                    <li>A private kulcsszó egy typescriptes rövidítés
                      <ul>
                        <li>Tulajdonképpen egy property (mint a "class-ra globális változók"), ami be-set-elődik
                          futási
                          időben a dependency injection régén
                          <ul>
                            <li>Így nézne ki private nélkül</li>
                            <pre>
                              http;

                              constructor(http: HttpClient) &#123;
                                this.http = http;
                              &#125;
                            </pre>
                          </ul>
                          <pre></pre>
                        </li>
                        <li>Mivel property lett, ezért tudunk rá hivatkozni az összes többi property-ben, és
                          methodokban
                        </li>
                        <li>A HTTPClient-et modul szinten is aktiválni kell, azaz be kell importálni a module.ts-ben a
                          HTTPClientModule-t, azért, hogy a modulban lévő komponensek használni tudják
                        </li>
                      </ul>
                    </li>
                    <li>
                      <pre>
                        this.refresh$.subscribe();
                      </pre>
                      <ul>
                        <li>Ez így kevés, mert ahhoz, hogy a Subscriber adatcsomaghoz jusson, ahhoz a new Subject-nek
                          kell kibocsátania adatot
                        </li>
                        <li>Csak akkor történik meg, ha mi manuálisan adatot adunk át a next() függvény meghívásával
                        </li>
                        <li>A Subject visszatér egy Observable-lel, ami egy belső hiba az Observable-ök és a Subjectek
                          belső megvalósításában (típusváltás történik)
                        </li>
                        <li>Így nem tudjuk ráhívni a subscribe() függvényre a next-et, ezért egy kisebb trükköt kell
                          alkalmaznunk
                          <ul>
                            <li>
                              <pre>
                                this.refresh$.subscribe();
                                // @ts-ignore
                                this.refresh$.next();
                              </pre>
                            </li>
                            <li>A // @ts-ignore a Typescript compilernek szól, figyelmen kívül hagyja a következő sort
                            </li>
                            <li>Közel sem best-practice, de néha elkerülhetetlen</li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>Tehát:
                  <ul>
                    <li>
                      <pre>
                        refresh$ = new Subject().pipe(
                          tap(() => &#123;
                            this.isLoadingReactive = true;
                          &#125;),
                          switchMap(() => this.http.get('https://kodbazis.hu/api/cimek')),
                          catchError((err) => of([])),
                          tap((response) => &#123;
                            this.isLoadingReactive = false;
                            this.elemsReactive = response as string[];
                            console.log('http: ', response);
                          &#125;)
                        );

                        constructor(private http: HttpClient) &#123;
                                              &#125;

                        ngOnInit() &#123;
                              this.refresh$.subscribe();
                              // @ts-ignore
                              this.refresh$.next();
                        &#125;
                      </pre>
                      <ul>
                        <li>Init-kor feliratkoztunk a csődarabkára, beledobtunk egy adatot (üres string), emiatt
                          lefutott a külső Observable, switchMap() segítségével a belsőből megérkezik az adat, amit
                          kilogolunk a tap()-ben
                        </li>
                        <li>Ahhoz, hogy a Typescript elfogadja a következőt 'this.elemsReactive = response', ismét
                          trükkhöz kell folyamodnunk
                          <ul>
                            <li>Ezt kétféleképpen tehetjük meg</li>
                            <pre>
                                tap((response: any) => &#123;
                                  this.elemsReactive = response;
                                &#125;
                              </pre>
                            <pre>
                              tap((response) => &#123;
                                  this.elemsReactive = response as string[];
                                &#125;
                            </pre>
                          </ul>
                        </li>
                        <li>Hibakezelést is tudunk végezni a csőrendszerben
                          <ul>
                            <li>
                              <pre>
                                catchError((err) => of([])),

                                // OR

                                catchError((err) => &#123;
                                  return of([]);
                                &#125;
                              </pre>
                            </li>
                            <li>Egy function-t kell átadni neki, ami paraméterként megkapja a hibát, ami a
                              csőrendszerben előtte bárhol felmerült
                            </li>
                            <li>Egy új Observable-lel kell visszatérni, amiből, ha érkezik adatcsomag, azt kapja meg a
                              következő operátor, és a next function is
                            </li>
                            <li>Érdemes olyan Observable-t létrehozni, aminek a típusa egybevág azzal, ami alapból
                              érkezett volna (ami jelen esetünkben egy tömb)
                            </li>
                            <li>Az of() egy creation operátor, amivel a gyorsan és könnyen lehet Observable-t
                              létrehozni
                            </li>
                            <li>Amennyiben egy üres tömböt rakunk bele, akkor hibától függetlenül egy tömb érkezik a
                              catchError operátor alatti tap() operátorba, így a működés rendben tud folytatódni
                            </li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>delete$
              <pre>

                delete$ = new Subject().pipe(
                  tap(() => &#123;
                              this.isLoadingReactive = true;
                  &#125;),
                  switchMap(index => this.http.delete(`https://kodbazis.hu/api/cimek/$&#123;index&#125;`)),
                  tap( () => &#123;
                      // @ts-ignore
                      this.refresh$.next("");
                    &#125;
                  )
                );

                ngOnInit() &#123; // ngOnInit helyett
                  this.refresh$.subscribe();
                  this.delete$.subscribe();
                  // @ts-ignore
                  this.refresh$.next();
                &#123;

                removeElemReactive(index: number) &#123;
                  // @ts-ignore
                  this.delete$.next(index);
                &#125;
              </pre>
              <ul>
                <li>A delete Observable-re OnInit-ben feliratkozunk, és gombnyomásra next()-elünk rá az index adattal
                </li>
                <li>A pipe()-ban ezúttal delete methoddal hívjuk meg a HTTPClient-et</li>
                <li>A végén mellékhatásként next-elünk a refresh$-re</li>
              </ul>
            </li>
            <li>create$
              <ul>
                <li>
                  <pre>

                    create$ = new Subject().pipe(
                      tap(() => &#123;
                                      this.isLoadingReactive = true;
                      &#125;),
                      switchMap((input) => this.http.post(`https://kodbazis.hu/api/cimek`, &#123;cim: input&#125;)),
                      tap(() => &#123;
                                      // @ts-ignore
                                      this.refresh$.next("");
                        &#125;
                      )
                    )
                  </pre>
                </li>
                <li>A HTTPClient a request body-t (POST) második paraméterként várja</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>async pipe és a BehaviorSubject
      <ul>
        <li>Az Operationsnél az elems property-t és az isLoading property-t átalakítjuk Subject-ekké</li>
        <li>Az összes isLoadingReactive értéket át kell írnunk
          <ul>
            <li>
              <pre>
                this.isLoadingReactive$.next(false);
                // OR
                this.isLoadingReactive$.next(true);
              </pre>
            </li>
            <li>Nem ütközünk ezúttal Typescript errorba (nem kell @ts-ignore-t használni), mivel a Subject-ünk
              megmarad
              Subject, nem vált át Observable-re, mivel nem írtunk a Subject mögé pipe-ot
            </li>
            <li>Az elemsReactive változót szintén módosítjuk
              <ul>
                <li>
                  <pre>
                    elemsReactive$ = new Subject();
                    ...
                    this.elemsReactive$.next(response);
                  </pre>
                </li>
              </ul>
            </li>
            <li>Az eddigi változtatások után a sablonban hibát kapunk
              <ul>
                <li>Az Observable által kibocsátott adatcsomagot kell lekezelnünk a sablonban</li>
                <li>Erre való az async pipe</li>
                <li>Így közvetlenül a sablonból iratkozunk fel, tehát minden adat, amit az Observable kibocsát, a
                  sablonban fogja végezni a pályafutását
                </li>
                <li>Meg kell keresni a legkülső értéket, ahol a scope-ban használva van, körbe burkolni egy
                  konténerrel
                  (gyakorlatilag bármilyen elemmel körbe burkolható),
                  <ul>
                    <li>
                      <pre>
                        ...
                        &#60;ng-container *ngIf="elemsReactive$ | async as elemsReactive"&#62;
                          ...
                        &#60;/ng-container&#62;
                      </pre>
                    </li>
                    <li>A struktúrális direktívában (*ngIf) hivatkozunk az Observable-re, az async pipe-pal
                      feliratkozunk rá, az as után pedig a változó következik, amit a sablonban ezek után használunk
                    </li>
                    <li>Ezen a ponton még Typescript hibára futunk, mert a Typescript nem tudja, hogy az
                      elemsReactive$
                      tömböt fog kibocsátani
                      <ul>
                        <li>Ennek kiküszöbölésére a Subject-et explicit típussal kell ellátni</li>
                        <pre>
                          elemsReactive$: Subject&#60;string[]&#60; = new Subject();
                          // Meg kell hagyni a következőt
                          this.elemsReactive$.next(response as string[]);
                        </pre>
                      </ul>
                    </li>
                    <li>Előfordulhat async pipe használatakor, amikor egy sablondarab feltételesen van megjelenítve,
                      hogy az egyik feliratkozás korábban megy végbe, mint a másik, így hiába iratkoztunk fel, mégsem
                      jelenik meg a tartalom, nem jelennek meg az elemek
                      <ul>
                        <li>Az ilyen működés kiküszöbölésére való a BehaviourSubject()</li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>BehaviourSubject()
          <ul>
            <li>Nagyon hasonló, mint a Subject()</li>
            <li>Különbség, hogy szolgáltathatunk neki egy kiinduló értéket, és ő ezt az értéket azon nyomban
              kibocsájtja, amint feliratkozik rá valaki
            </li>
            <pre>
              elemsReactive$: BehaviorSubject&#60;string[]&#60; = new BehaviorSubject&#60;string[]&#62;([]);
            </pre>
            <li>Továbbá folyamatosan megjegyzi az utolsó értéket, és amikor új feliratkozó érkezik, szintén azonnal
              elküldi ezt az értéket
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Leiratkozás az adatfolyamokról
      <ul>
        <li>Az Angular úgy működik, hogy amikor egy komponens működése véget ér, attól függetlenül a feliratkozások
          életben maradnak
        </li>
        <li>Az életben hagyott feliratkozások miatt memory leak-ek keletkezhetnek</li>
        <li>A sablonban történő feliratkozásokat ez a probléma nem érinti, mivel az Angular a leiratkozásokat
          automatikusan elvégzi
        </li>
        <li>Leiratkozáshoz hozzá kell jutnunk a Subscription objektumhoz
          <ul>
            <li>Praktikus, ha az összes Subscriptiont egy tömbben kezeljük</li>
            <pre>
              subscriptions: Subscription[] = [];

              const refreshSub = this.refresh$.subscribe();
              const deleteSub = this.delete$.subscribe();
              const createSub = this.create$.subscribe();

              this.subscriptions = [...this.subscriptions, refreshSub, deleteSub, createSub];
            </pre>
            <li>A subscriptions property folyamatosan elérhető a komponens működése során</li>
            <li>Az úgynevezett OnDestroy életciklusban is elérhető
              <ul>
                <li>Ez az életciklus method a komponens inaktiválódásakor fut le</li>
                <li>Tipikusan takarító jellegű műveletek végzendők el</li>
                <li>Implementálni kell a class-ba
                  <ul>
                    <li>
                      <pre>
                        export class OperationsComponent implements OnDestroy &#123;

                        &#125;
                      </pre>
                    </li>
                  </ul>
                </li>
                <li>Végül a komponens inaktiválódásakor leiratkozunk az összes Subscription-ről
                  <ul>
                    <li>
                      <pre>
                        ngOnDestroy() &#123;
                        for (let subscription of this.subscriptions) &#123;
                            subscription.unsubscribe();
                          &#125;
                        &#125;
                      </pre>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Egyben a reaktív kód
      <ul>
        <li>HTML
          <pre>
            &#60;div&#62;
                &#60;small&#62;REAKTÍV&#60;/small&#62;
                &#60;ng-container *ngIf="elemsReactive$ | async as elemsReactive"&#62;
                  &#60;ng-container *ngIf="isLoadingReactive$ | async; else listAlt"&#62;
                    &#60;div&#62;LOADING&#60;/div&#62;
                  &#60;/ng-container&#62;

                  &#60;ng-template #listAlt&#62;
                    &#60;div&#62;
                      &#60;h4 *ngIf="elemsReactive.length &#62; 0; else noElemsReactive"&#62;Jelenleg &#123; &#123; elemsReactive.length &#125; &#125;
                        elem létezik&#60;/h4&#62;
                      &#60;span&#62;
                        &#60;button [disabled]="true"&#62;
                          API delete
                        &#60;/button&#62;
                      &#60;/span&#62;
                    &#60;/div&#62;

                    &#60;div *ngFor=" let elem of elemsReactive; let last=last; let i=index"&#62;
                      &#60;span&#62;
                        &#123; &#123; i + 1 &#125; &#125;. &#123; &#123; elem &#125; &#125;
                      &#60;/span&#62;
                      &#60;span class="trash" (click)="removeElemReactive(i)"&#62;&#60;/span&#62;
                      &#60;hr *ngIf="!last"&#62;
                    &#60;/div&#62;

                    &#60;form *ngIf="elems.length &#60; 5; else elemsLengthReachedMaxReactive"
                          (submit)="newElemReactive($event)"&#62;
                      &#60;input #formInput name="title" value="" ngModel placeholder="New elem"&#62;
                      &#60;button type="submit" [disabled]="formInput.value === ''"&#62;Send&#60;/button&#62;
                    &#60;/form&#62;
                  &#60;/ng-template&#62;
                &#60;/ng-container&#62;
              &#60;/div&#62;
          </pre>
        </li>
        <li>TS
          <pre>
                elemsReactive$: BehaviorSubject&#60;string[]&#62; = new BehaviorSubject&#60;string[]&#62;([]);
                isLoadingReactive$ = new Subject();

                refresh$ = new Subject().pipe(
                  tap(() => &#123;
                              this.isLoadingReactive = true;
                  &#125;),
                  switchMap(() => this.http.get('https://kodbazis.hu/api/cimek')),
                  catchError((err) => of([])),
                  tap((response) => &#123;
                              this.isLoadingReactive = false;
                              this.elemsReactive = response as string[];
                              console.log('http: ', response);
                  &#125;)
                );

                delete$ = new Subject().pipe(
                  tap(() => &#123;
                              this.isLoadingReactive = true;
                  &#125;),
                  switchMap(index => this.http.delete(`https://kodbazis.hu/api/cimek/$&#123;index&#125;`)),
                  tap(() => &#123;
                              // @ts-ignore
                              this.refresh$.next("");
                    &#125;
                  )
                );

                create$ = new Subject().pipe(
                  tap(() => &#123;
                              this.isLoadingReactive = true;
                  &#125;),
                  switchMap((input) => this.http.post(`https://kodbazis.hu/api/cimek`, &#123;cim: input&#125;)),
                  tap(() => &#123;
                              // @ts-ignore
                              this.refresh$.next("");
                    &#125;
                  )
                )

                subscriptions: Subscription[] = [];

                constructor(private http: HttpClient) &#123;
                &#125;

                ngOnInit() &#123;
                  const refreshSub = this.refresh$.subscribe();
                  const deleteSub = this.delete$.subscribe();
                  const createSub = this.create$.subscribe();
                  this.subscriptions = [...this.subscriptions, refreshSub, deleteSub, createSub];
                  // @ts-ignore
                  this.refresh$.next();
                &#125;

                removeElemReactive(index: number) &#123;
                  // @ts-ignore
                  this.delete$.next(index);
                &#125;

                newElemReactive(e: any) &#123;
                  e.preventDefault();
                  const newValue = e.target.elements.title.value;
                  // @ts-ignore
                  this.create$.next(newValue);
                &#125;

                ngOnDestroy() &#123;
                  for (let subscription of this.subscriptions) &#123;
                    subscription.unsubscribe();
                  &#125;
                &#125;
              </pre>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #reactiveform data-anchor="reactiveform">Form (Reactive)</h3>
  <ul>
    <li>Form validációra az Angularban két eszköztár is rendelkezésre áll:
      <ol>
        <li>Template driven forms</li>
        <li>Reactive forms
          <ul>
            <li>Ez utóbbival fogunk most foglalkozni, mert ezt átlátva a másik sokkal egyszerűbb</li>
            <li>Előnyei:
              <ul>
                <li>A form struktúrája a kontrollerben definiált</li>
                <li>Dinamikus FormControl-ok létrehozása egyszerűbb</li>
                <li>Könnyebb a Unit Test</li>
              </ul>
            </li>
          </ul>
        </li>
      </ol>
    </li>
    <li>Mindekettő ugyanakkor való</li>
    <li>Különbségek a kód megírásában van:
      <ul>
        <li>Template driven forms
          <ul>
            <li>A sablonba kerül a logika</li>
          </ul>
        </li>
        <li>Reactive forms
          <ul>
            <li>A kód lényegi része a controller rétegbe kerül, oda kerül az egyes input mezőkkel kapcsolatos
              validációs logika
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Reaktív form megvalósítása: // SPA-ban elérhető
      <ul>
        <li>Először is létre kell hoznunk egy FormGroup objektumot
          <pre>
            export class ReactiveformComponent &#123;
              profileForm = new FormGroup(&#123;});
                firstName: new FormControl('teszt'),
              constructor() &#123;
              }
            }
          </pre>
          <ul>
            <li>A FormGroup tulajdonképpen reprezentálja az egész formot</li>
            <li>Kulcs érték párok formájában itt tudjuk megadni a FormControl-okat
              <ul>
                <li>A kulcsok szabadon megválaszthatók</li>
                <li>A 'teszt' az adott input mező alapértelmezett értéke</li>
                <li>A FormControl vár a contructor-án keresztül különféle értékeket</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Ezt követően a template-ben el kell helyezni a formot:
          <ul>
            <li>
              <pre>
                &#60;div class="row px-3 w-100">
                  &#60;form [formGroup]="profileForm" class="col-12">
                    &#60;h2>Alapadatok&#60;/h2>
                    &#60;label class="w-100">
                      Keresztnév:
                      &#60;input type="text" [formControlName]="'firstName'"/>
                    &#60;/label>
                    ...
                  &#60;/form>
                &#60;/div>
              </pre>
            </li>
            <li>Az input mező a name attribútum helyett formControlName-et kap</li>
            <li></li>
          </ul>
        </li>
        <li>Validator:
          <ul>
            <li>Megannyi létezik belőle, az Angular Forms szolgáltatja</li>
            <li>A FormControl-nak második paraméterként megadható
              <ul>
                <li>
                  <pre>
                    profileForm = new FormGroup(&#60;
                      firstName: new FormControl('teszt', Validators.required),
                    });
                  </pre>
                </li>
              </ul>
            </li>
            <li>A felhasználótól egyértelműen azt várja, hogy megadja az adott mező értékét</li>
            <li>Egyszerre több validátort tömb formájában szükséges megadni
              <ul>
                <li>
                  <pre>
                    profileForm = new FormGroup(&#60;
                      firstName: new FormControl("", [
                        Validators.required,
                        Validators.maxLength(20)
                      ]),
                    });
                  </pre>
                </li>
              </ul>
            </li>
            <li>A változásokra való reakció ezzel még nem biztosított</li>
            <li>A FormControl és az egész FormGroup állapottal rendelkező objektum
              <ul>
                <li>Belső állapotukat folyamatosan változtatgatják</li>
                <li>Ha mondjuk túllépjük a 'firstName' esetében a 20 karaktert, a hiba ténye regisztrációra kerül a
                  FormControlban, de ezt ki kell vezetni a template-be
                </li>
              </ul>
            </li>
            <li>Kivezetés a UI-ra:
              <ul>
                <li>A FormGroup valueChanges (Observable) eseményére lehet reagálni</li>
                <li>
                  <pre>
                    ngOnInit(): void &#60;
                      this.profileForm.valueChanges.subscribe(change => &#60;
                        console.log(change);
                      });
                    }
                  </pre>
                  <ul>
                    <li>Minden változásnál/vagy karakterleütésnél kapunk egy újabb adatcsomagot</li>
                    <li>&#123;firstName: 'h'}</li>
                  </ul>
                </li>
                <li>A FormGroup egy komplex objektum
                  <pre>
                    &#123;
                      "controls": &#123;
                        "firstName": "FormControl"
                      },
                      "errors": null,
                      "pristine": false,
                      "status": "VALID",
                      "statusChanges": &#123;
                        "closed": false,
                        "currentObservers": [],
                        "observers": [],
                        "isStopped": false,
                        "hasError": false
                      },
                      "touched": true,
                      "value": &#123;
                        "firstName": "teszt1"
                      },
                      "valueChanges": &#123;
                        "closed": false,
                        "currentObservers": [1],
                        "observers": [1],
                        "isStopped": false,
                        "hasError": false
                      },
                      "_composedAsyncValidatorFn": null,
                      "_composedValidatorFn": null,
                      "_hasOwnPendingAsyncValidator": false,
                      "_onCollectionChange": "Function (reference)",
                      "_onDisabledChange": "Function (reference)",
                      "_parent": null,
                      "_pendingDirty": false,
                      "_pendingTouched": false,
                      "_rawAsyncValidators": null,
                      "_rawValidators": null
                    }
                  </pre>
                  <ul>
                    <li>Számon vannak tartva a control-ok</li>
                    <li>pristine: true esetében a form még érintetlen</li>
                    <li>A FormControl is egy komplex objektum
                      <pre>
                        &#123;
                        "defaultValue": null,
                        "errors": null,
                        "pristine": false,
                        "status": "VALID",
                        "statusChanges": &#123;
                          "closed": false,
                          "currentObservers": [],
                          "observers": [],
                          "isStopped": false,
                          "hasError": false
                        },
                        "touched": true,
                        "value": "teszta",
                        "valueChanges": &#123;
                          "closed": false,
                          "currentObservers": [],
                          "observers": [],
                          "isStopped": false,
                          "hasError": false
                        },
                        "_composedAsyncValidatorFn": null,
                        "_composedValidatorFn": "(control) => &#123;}",
                        "_hasOwnPendingAsyncValidator": false,
                        "_onChange": ["ƒ"],
                        "_onCollectionChange": "() => &#123;}",
                        "_onDisabledChange": ["ƒ"],
                        "_parent": &#123;
                          "_pendingDirty": false,
                          "_hasOwnPendingAsyncValidator": false,
                          "_pendingTouched": false,
                          "_parent": null,
                          "_onCollectionChange": "() => &#123;}"
                        },
                        "_pendingChange": false,
                        "_pendingDirty": true,
                        "_pendingTouched": true,
                        "_pendingValue": "teszta",
                        "_rawAsyncValidators": null,
                        "_rawValidators": ["ƒ", "ƒ"]
                      }
                      </pre>
                    </li>
                  </ul>
                </li>
                <li>A FormGroup get() methodját szokás használni
                  <ul>
                    <li>
                      <pre>
                         console.log((this.profileForm.get("firstName") as FormControl).errors); //  as FormControl --> Type Assertion
                      </pre>
                      <ul>
                        <li>Túllépve a 20 karaktert:
                          <ul>
                            <li>maxlength: &#123;requiredLength: 20, actualLength: 21}</li>
                            <li>A hibával kapcsolatos részleteket is tartalmazza, mit várunk el, és mi a valóság</li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>A FormControl lehet akár egy másik FormGroup is, vagy akár egy FormArray</li>
                <li>Ha egy required mezőből kitörlünk mindent, akkor &#123;required: true} értéket kapunk a get()
                  methoddal
                </li>
                <li>Egy lehetséges megoldása annak, hogy a template-ben megjelenítsük a hibákat:
                  <ul>
                    <li>
                      <pre>
                        &#60;small *ngIf="getError('firstName', 'required')" style="color: #9d2626">
                          Keresztnév megadása kötelező
                        &#60;/small>
                        &#60;small *ngIf="getError('firstName', 'maxlength') as err" style="color: #9d2626"> // A getError() visszatérési értékét eltesszük egy változóba!
                          Max karakterszám &#123; &#123; err.requiredLength }}, a beírt: &#123; &#123; err.actualLength }}
                        &#60;/small>
                      </pre>
                      <pre>
                        ngOnInit(): void &#123;
                          this.profileForm.valueChanges.subscribe(change => &#123;
                              this.getError("firstName", "maxlength");
                            });
                        }

                        getError(path: string, errorName: string) &#123;
                                              return (this.profileForm.get(path) as FormControl).errors?.[errorName];
                        }
                      </pre>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Hogyan tudjuk elkerülni, hogy az oldal betöltődésekor ne legyen tele a form kapásból hibával?
          <ul>
            <li>A getError() függvényt kell átalakítanunk:
              <pre>
                getError(path: string, errorName: string) &#123;
                  const formControl = (this.profileForm.get(path) as FormControl);

                  console.log('getError: ', (this.profileForm.get(path) as FormControl).errors?.[errorName]);

                  if (formControl.untouched && formControl.pristine) &#123;
                    return;
                  }

                  return formControl.errors?.[errorName];
                }
              </pre>
            </li>
            <li>Amennyiben az untouched és a pristine is true, akkor undefined értéket kap a függvény meghívója
              <ul>
                <li>FormControl property-k, mindkettő true értékkel inicializálódik</li>
                <li>Az untouched akkor állítódik false-ra, ha az input mezőre blur esemény történik</li>
                <li>A pristine akkor állítódik false-ra, ha a felhasználó beleír valamilyen értéket a mezőbe</li>
              </ul>
            </li>
            <li>Létezik egy "ellenpólusa" is az untouched / pristine párosnak:
              <ul>
                <li>
                  <pre>
                    if (!formControl.touched && !formControl.dirty) &#123;
                      return;
                    }
                  </pre>
                </li>
                <li>Ugyanazt az eredményt adja, de nem best practice negálva logikát írni</li>
                <li>untouched <> touched / pristine <> dirty</li>
              </ul>
            </li>
            <li>Némileg talán elegánsabb megoldás a hibák kiírására:
              <pre>
                &#60;label class="">
                  Életkor:
                  &#60;input type="number" min="1" max="99" [formControlName]="'age'"/>
                  &#60;small *ngIf="profileForm.get('age')?.errors?.['required'] && profileForm.get('age')?.touched" style="color: #9d2626">
                    Életkor megadása kötelező
                  &#60;/small>
                  &#60;small
                    *ngIf="profileForm.get('age')?.touched && (profileForm.get('age')?.errors?.['min'] || profileForm.get('age')?.errors?.['max'])"
                    style="color: #9d2626">
                    Hiba! 1-99 elfogadott!
                  &#60;/small>
                &#60;/label>
              </pre>
            </li>
            <li>Amennyiben kettő, vagy több mezőre ugyanazok a validátorok érvényesek, használhatjuk a compose()
              függvényt:
              <pre>
                nameValidator = Validators.compose([
                  Validators.required,
                  Validators.minLength(0),
                  Validators.maxLength(100),
                ]);

                profileForm = new FormGroup(&#123;
                              firstName: new FormControl('', this.nameValidator),
                              lastName: new FormControl('', this.nameValidator),
                              age: new FormControl(null, [
                                Validators.min(1),
                                Validators.max(99),
                                Validators.required,
                              ])
                });
              </pre>
            </li>
            <li>A getError() függvény meghívása nélkül is ki lehet írni 'maxlength' hibaértékeket
              <pre>
                &#60;small
                  *ngIf="profileForm.get('lastName')?.touched && profileForm.get('lastName')?.errors?.['maxlength']"
                  style="color: #9d2626">
                  Max karakterszám &#123; &#123; profileForm.get('lastName')?.errors?.['maxlength']?.['requiredLength'] }}, a
                  beírt: &#123; &#123; profileForm.get('lastName')?.errors?.['maxlength']?.['actualLength'] }}
                &#60;/small>
              </pre>
            </li>
          </ul>
        </li>
        <li>Saját validátor létrehozása:
          <ul>
            <li>Egy range validátort szükséges deklarálnunk a @Component fölé</li>
            <pre>
              function rangeValidator(min: number, max: number): ValidatorFn &#123;
                return (control) => &#123;
                  console.log(control);
                  return null;
                };
              }

              profileForm = new FormGroup(&#123;
                age: new FormControl(20, [
                  Validators.required,
                  rangeValidator(18, 100)
                ]),
              });
            </pre>
            <li>A rangeValidator visszatérési értéke egy ValidatorFn (validator function) típusú érték</li>
            <li>Tehát a függvényből függvénnyel tér vissza</li>
            <li>A validatorFn megkapja futásidőben az egész FormControlt, a függvényben kiszedhetjük az értéket, és
              kiértékelhetjük, és visszatérhetünk a validátorból null-lal (= nincs hiba), vagy az error objektummal
            </li>
            <li>A 'control'-ból könnyen kinyerhető az érték</li>
            <li>A value kulcsa alatt találjuk</li>
            <li>
              <pre>
                function rangeValidator(min: number, max: number): ValidatorFn &#123;
                  return (control) => &#123;
                    if (control.value >= min && control.value <= max) &#123;
                                return null;
                    }
                    return &#123;
                       range: &#123;
                        min: min,
                        max: max,
                        actual: control.value,
                      }
                    };
                  };
                }
              </pre>
              <ul>
                <li>Amennyiben a FormGroupban beállított min és max közé esik a bevitt érték (vagy egyenlő
                  valamelyikkel), akkor null-lal térünk vissza, azaz nincs hiba
                </li>
                <pre>
                  &#60;label class=""> Életkor:
                    &#60;input type="number" [formControlName]="'age'"/>
                    &#60;small *ngIf="profileForm.get('age')?.errors?.['required'] && profileForm.get('age')?.touched">
                      Életkor megadása kötelező
                    &#60;/small>
                    &#60;small
                      *ngIf="profileForm.get('age')?.errors?.['range'] && !profileForm.get('age')?.errors?.['required']">
                      Minimum &#123; &#123; profileForm.get('age')?.errors?.['range']?.['min'] }}, maximum &#123; &#123; profileForm.get('age')?.errors?.['range']?.['max'] }}! Aktuális: &#123; &#123; profileForm.get('age')?.errors?.['range']?.['actual'] }}
                  &#60;/small>
                  &#60;/label>
                </pre>
                <li></li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Async validátor:
          <ul>
            <li>A FormControlnak mindig a 2. paramétere a szinkron, és 3. paramétere az aszinkron validátor</li>
            <li>Ha az adott FormControlnál nincsen szinkron validátorunk, akkor null-t kell adni második paraméternek
            </li>
            <li>Az aszionkron validátor is paraméterezhető</li>
            <li>A HTTPClientet adjuk oda az email validátornak</li>
            <li>Ebben az esetben a függvény AsyncValidatorFn-nel tér vissza (aszinkron validátor függvény)</li>
            <li>A függvény bemenetként kap egy controlt, és visszatér egy Observable of object-tel, vagy Observable of
              null-lal
            </li>
            <li>get() method-dal megszólítjuk az URL-t, és query param-ba email kulcs alatt beírhatjuk a control-ból
              kiszedett értéket
            </li>
            <li>200-as státusz küód esetén a response-t map operátorral leképezhetjük null értékre</li>
            <li>Ha hibát kapunk, akkor a catchError ág megfogja, amiben of()-fal létrehozunk egy Observable-t, ami
              &#123;reserved: true} objektumot eredményez, majd complete() állapotba fut
            </li>
            <li>Megfelelünk a custom validátornak, vagy visszatérünk egy Observable of null-lal, vagy egy Observable
              of object-tel
            </li>
            <pre>
              function emailReservedAsyncValidator(http: HttpClient): AsyncValidatorFn &#123;
                return (control) => &#123;
                  return http.get("https://kodbazis.hu/api/is-email-taken", &#123;
                            params: &#123;
                      email: control.value
                    }
                  }).pipe(
                    map(() => null),
                    catchError(() => of(&#123;
                            reserved: true
                    }))
                  );
                }
              }

              profileForm = new FormGroup(&#123;
                mail: new FormControl("", Validators.required, emailReservedAsyncValidator(this.http)),
              });

              &#60;label class="">
                Email:
                &#60;input type="text" [formControlName]="'mail'"/>
                &#60;small *ngIf="profileForm.get('mail')?.errors?.['reserved']" style="color: #9d2626">Foglalt email cím!&#60;/small>
                &#60;small *ngIf="profileForm.get('mail')?.errors?.['required'] && profileForm.get('mail')?.touched"
                       style="color: #9d2626">
                  Kötelező mező!
                &#60;/small>
                &#60;div>teszt@invalid.com&#60;/div>
                &#60;div>profileForm.get('mail')?.errors | json: &#123; &#123; profileForm.get('mail')?.errors | json }}&#60;/div>
                &#60;/label>
            </pre>
            <li>Nem praktikus, hogy minden karakterleütéskor kimegy egy szerver oldali kérés
              <ul>
                <li>Erre megoldás lehet az RxJS könyvár segítségül hívása</li>
                <pre>
                  function emailReservedAsyncValidator(http: HttpClient): AsyncValidatorFn &#123;
                    return (control) => &#123;  // Külső függvény visszatérési értéke, mivel aszinkron validátor függvénnyel kell visszatérnünk
                      return control.valueChanges.pipe(  // Belső függvény visszatérési értéke (egy Observable); Az AsyncValidatorFn-nek mindig egy Observable&#60;any>-t kell visszaadnia, amely vagy egy hibát tartalmazó objektumot, vagy null-t ad vissza, ha nincs hiba
                        debounceTime(500),
                        switchMap(() => http.get("https://kodbazis.hu/api/is-email-taken", &#123;
                                    params: &#123;
                            email: control.value
                          }
                        })),
                        map(() => null),
                        catchError(() => of(&#123;
                                    reserved: true
                        }))
                      );
                    }
                  }
                </pre>
                <li>A függvény visszatérési típusa egy aszinkron validátor függvény (AsyncValidatorFn), amelyet
                  Angular űrlapoknál használnak
                </li>
                <li>A validátor egy FormControl-t kap, ami az adott űrlap mezőjét reprezentálja</li>
                <li>A control.valueChanges egy observable, amely kibocsát egy új értéket minden alkalommal, amikor a
                  mező értéke megváltozik
                </li>
                <li>Ezzel a validátor mindig akkor indul el, amikor a felhasználó megváltoztatja a beviteli mező
                  tartalmát
                </li>
                <li>Az observable nem fog kibocsátani új értéket minden egyes karakterre, csak akkor, ha az input 500
                  ms-ig nem változik
                </li>
                <li>A switchMap() operátor használatával az aktuális control.value alapján egy új HTTP kérés indul el
                </li>
                <li>A switchMap gondoskodik arról, hogy ha közben új érték érkezik a control.valueChanges-re, a régi
                  HTTP kérés megszakad, és csak az utolsó értékkel indul új kérés
                </li>
                <li>Így mindig a legfrissebb inputot ellenőrzi a szerver</li>
                <li>Ha a HTTP kérés sikeres, a map(() => null) kifejezés fut le, ami azt jelenti, hogy
                  nincs hiba, és a validátor eredménye null lesz
                </li>
                <li>Ez azt jelenti, hogy az e-mail cím nem foglalt, és a validáció sikeres
                </li>
                <li>Ha hiba történik (például a szerver visszaad egy hibát), a catchError ágban az of(&#123; reserved:
                  true }) visszatér egy objektummal, amely a reserved: true értéket tartalmazza
                </li>
                <li>Ez azt jelenti, hogy az e-mail cím foglalt, és a validátor hibát fog jelezni</li>
                <li>A catchError elkapja a hibát, és of() segítségével egy új observable-t hoz létre, amely visszaad
                  egy objektumot
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A következő lépésben egy select inputot töltünk fel adatokkal, majd validálunk:
          <ul>
            <li>A select-et feltöltjük option-ökkel
              <pre>
                positionOptions$: Observable&#60;any> = this.http.get('https://kodbazis.hu/api/positions') as Observable<&#123;
                  id: number,
                  name: string
                }[]>
              </pre>
              <ul>
                <li>Mivel Observable, ezért fel kell rá iratkoznunk, különben nem generál adatcsomagot</li>
                <li>Megtehetjük a kontrollerben is, de a template-ben is:
                  <pre>
                    &#60;label>
                      Beosztás:
                      &#60;select *ngIf="positionOptions$ | async as ops; else loading">
                        &#60;option *ngFor="let op of ops" [value]="op.id">&#123; &#123; op.name }}&#60;/option>
                      &#60;/select>
                      &#60;ng-template #loading>
                        &#60;div class="loader">&#60;/div>
                      &#60;/ng-template>
                    &#60;/label>
                  </pre>
                </li>
                <li>Ezen túl bekerült egy spinner, ami addig van jelen, amíg az aszinkron művelet le nem fut</li>
              </ul>
            </li>
            <li>Validációt például az alábbi módon készíthetünk:
              <pre>
                position: new FormControl(1, selectValidator(2)),

                function selectValidator(id: number): ValidatorFn &#123;
                  return (control) => &#123;
                      console.log(control);
                      if (control.value == id) &#123;
                        return null;
                      }
                      return &#123;
                        valid: false,
                      }
                    }
                  }

                &#60;small *ngIf="profileForm.get('position')?.errors" style="color: #9d2626">Helytelen érték&#60;/small>
              </pre>
            </li>
            <li>
              Rádió gombok:
              <ul>
                <li>
                  <pre>
                    gender: new FormControl('female', checkboxValidator('nonbi')),

                    function checkboxValidator(gender: string): ValidatorFn &#123;
                      return (control) => &#123;
                        if (control.value === gender) &#123;
                                        return &#123;
                            errorText: 'Nem biológiai nemet választottál!'
                          }
                        }
                        return null;
                      }
                    }

                    &#60;div>
                      Biológiai nem:
                      &#60;br>
                      &#60;label class="">
                        Nő
                        &#60;input type="radio" [value]="'female'" [formControlName]="'gender'"/>
                      &#60;/label>
                      &#60;label class="">
                        Férfi
                        &#60;input type="radio" [value]="'male'" [formControlName]="'gender'"/>
                      &#60;/label>
                      &#60;label class="">
                        Nem bináris
                        &#60;input type="radio" [value]="'nonbi'" [formControlName]="'gender'"/>
                      &#60;/label>
                      &#60;small *ngIf="profileForm.get('gender')?.errors"
                             style="color: #9d2626">
                        &#123; &#123; profileForm.get('gender')?.errors?.['errorText'] }}
                    &#60;/small>
                    &#60;/div>
                  </pre>
                </li>
              </ul>
            </li>
            <li>Amennyiben logikailag több mezőt is össze akarunk csoportosítani, arra is van lehetőségünk
              <pre>
                &#60;div [formGroupName]="'address'">
                  &#60;h3>Cím&#60;/h3>

                  &#60;label class="">
                    Utca:
                    &#60;input type="text" [formControlName]="'street'"/>
                  &#60;/label>

                  &#60;label class="">
                    Város:
                    &#60;input type="text" [formControlName]="'city'"/>
                  &#60;/label>

                  &#60;label class="">
                    Irányítószám:
                    &#60;input type="number" [formControlName]="'zip'"/>
                  &#60;/label>
                &#60;/div>

                profileForm = new FormGroup(&#123;
                  address: new FormGroup(&#123;
                    street: new FormControl('', Validators.required),
                    city: new FormControl('', Validators.required),
                    zip: new FormControl('', [
                      Validators.required,
                      rangeValidator(1000, 9999)
                    ]),
                  })
                });

                this.profileForm.valueChanges.subscribe(change => &#123;
                  console.log('change: ', change);
                });

                // A console.log() eredménye:

                &#123;
                  address:  &#123;
                    street: '',
                    city: '',
                    zip: ''
                  }
                  age: 20,
                  firstName: "a",
                  gender: "female"
                  lastName: ""
                  mail: ""
                  position: 1
                }
              </pre>
              <ul>
                <li>A FormGroup-on belül egy újabb Formgroup-ot szükséges létrehozni</li>
                <li>A template-ben jelezni kell, hogy egy FormGroupba tartoznak, amellett, hogy kapnak
                  FormControlName-et
                </li>
                <li>Itt is használhatjuk a range validátort
                  <pre>
                    function rangeValidator(min: number, max: number): ValidatorFn &#123;
                      return (control) => &#123;
                        if (control.value >= min && control.value <= max) &#123;
                                        return null;
                        }
                        return &#123;
                                        range: &#123;
                            min: min,
                            max: max,
                            actual: control.value,
                          }
                        };
                      };
                    }
                  </pre>
                </li>
                <li>Kizárólag az irányítószámot tekintve az alábbi szerint alakul a hibakezelés:
                  <pre>
                    &#60;label class="">
                      Irányítószám:
                      &#60;input type="number" [formControlName]="'zip'"/>
                      &#60;small *ngIf="profileForm.get('address.zip')?.touched && profileForm.get('address.zip')?.errors?.['required']"
                             style="color: #9d2626">Kötelező mező!&#60;/small>
                      &#60;div>
                        &#60;small
                          *ngIf="profileForm.get('address.zip')?.errors?.['range'] && !profileForm.get('address.zip')?.errors?.['required']"
                          style="color: #9d2626">
                          Minimum: &#123; &#123; profileForm.get('address.zip')?.errors?.['range']?.['min'] }} /
                          Maximum: &#123; &#123; profileForm.get('address.zip')?.errors?.['range']?.['max'] }} /
                          Aktuális: &#123; &#123; profileForm.get('address.zip')?.errors?.['range']?.['actual'] }} érték
                        &#60;/small>
                      &#60;/div>
                      &#60;div>profileForm.get('address.zip')?.errors:&#60;/div>
                      &#60;div>&#123; &#123; profileForm.get('address.zip')?.errors | json }}&#60;/div>
                      &#60;/label>
                  </pre>
                </li>
              </ul>
            </li>
            <li>A dinamikusan, futási időben bővíthető mezők esetén úgynevezett FormArray-t használunk
              <ul>
                <li>
                  <pre>
                    profileForm = new FormGroup(&#123;
                      skills: new FormArray([
                        new FormControl('10 ujjas gépelés'),
                        new FormControl('8 ujjas gépelés'),
                      ], null)
                    });

                    addNewSkill() &#123;
                      (this.profileForm.get('skills') as FormArray).push(new FormControl('', Validators.required));
                    }

                    deleteSkill(index: number) &#123;
                      // ((this.profileForm.get('skills') as FormArray).controls as FormControl[]).splice(index); // Ugyanazt csinálja
                      (this.profileForm.get('skills') as FormArray).removeAt(index);
                    }

                    &#60;div>
                      &#60;h3>Készségek&#60;/h3>
                    &#60;button type="button" (click)="addNewSkill()">+ Új hozzáadása/button>

                    &#60;div [formArrayName]="'skills'">
                        &#60;div>
                          &#60;div>Függvény nélkül&#60;/div>
                          &#60;div *ngFor="let skill of skillsArray; let i = index;">
                            &#123; &#123; i + 1 }}: &#60;input [value]="skill?.value" [formControlName]="i">
                            &#60;span (click)="deleteSkill(i)">&#x274c;&#60;/span>
                            &#60;div>
                              &#60;small *ngIf="skill.errors?.['required'] && skill.touched">Kötelező mező!&#60;/small>
                            &#60;/div>
                          &#60;/div>
                        &#60;/div>
                      &#60;/div>
                    &#60;/div>
                  </pre>
                </li>
                <li>Bemenetként a FormArray egy tömbnyi FormControl-t vár</li>
                <li>Itt nem FormGroup, hanem FormArray fogja össze az egy egységhez tartozó mezőket</li>
                <li>A FormArray abban tér el a FormGroup-tól, hogy utóbbinál kulcsok alapján lépünk be a kisebb
                  egységbe, amíg az arraynál index alapján tesszük mindezt
                </li>
                <li>A fenti kódban látható, hogy miképp lehet hozzáadni, és törölni a FormArrayból, valamint, hogy
                  hogyan jeleníthetjük meg a sablonban az error-okat
                </li>
              </ul>
            </li>
            <li>Az utolsó, amit megnézünk, a checkbox validálása:
              <ul>
                <li>
                  <pre>
                    profileForm = new FormGroup(&#123;
                      isAccepted: new FormControl(false)
                    });
                  </pre>
                </li>
              </ul>
            </li>
            <li>Azt azeretnénk utolsó sorban elérni, hogy ne minden change-re történjen hibaellenőrzés, hanem csak
              akkor, amikor a submit gombot megnyomja a felhasználó:
              <ul>
                <li>Egy form-ot nem csak submit gond megnyomásával, hanem akár az enter gombbal is el lehet küldeni
                </li>
                <li>Ezért nem a submit gombra kerül rá, mint click event a form küldés</li>
                <li>A &#60;form> tag-ra szükséges rakni egy (ngSubmit) inputot</li>
                <li>Az adatcsomag tipikusan egy szerver oldali kérés body-jába kerül be</li>
                <li>Azt, hogy a form minden mezője ki van-e töltve, helyesen van-e kitöltve, a valid kulcs alatt
                  találjuk
                </li>
                <li>A submitoláskor, küldés előtt érdemes minden mezőt touched-ra állítani, ilyen módon elérhetjük
                  azt,
                  hogy minden hibaüzenet megjelenjen az oldalon
                </li>
                <li>
                  <pre>
                    &#60;form [formGroup]="profileForm" class="col-8" (ngSubmit)="onSubmit()">
                      ...
                      &#60;button type="submit">Küldés&#60;/button>
                    &#60;/form>

                    onSubmit() &#123;
                    console.log('onSubmit / profileForm: ', this.profileForm);

                    this.profileForm.markAllAsTouched();

                    if (this.profileForm.valid) &#123;
                        return;
                      }
                    }
                  </pre>
                </li>
              </ul>
            </li>
            <li>FormBuilder
              <ul>
                <li>Zavaró lehet a szemnek a sok new FormControl
                  <pre>
                    profileForm = new FormGroup(&#123;
                    firstName: new FormControl('', this.nameValidator),
                    lastName: new FormControl('', this.nameValidator),
                    age: new FormControl(20, [
                      Validators.required,
                      rangeValidator(18, 100)
                    ]),
                    mail: new FormControl('', Validators.required, emailReservedAsyncValidator(this.http)),
                    position: new FormControl(1, selectValidator(2)),
                    gender: new FormControl('female', checkboxValidator('nonbi')),
                    address: new FormGroup(&#123;
                        street: new FormControl('', Validators.required),
                        city: new FormControl('', Validators.required),
                        zip: new FormControl('', [
                          Validators.required,
                          rangeValidator(1000, 9999)
                        ]),
                      }),
                      skills: new FormArray([
                        new FormControl('10 ujjas gépelés'),
                        new FormControl('8 ujjas gépelés'),
                      ], null),
                      isAccepted: new FormControl(false)
                    });
                  </pre>
                </li>
                <li>Ennek egyszerűsítése végett a dependency injection-ök közé felvehetjük a FormBuilder-t</li>
                <li>Nagyban leegyszerűsödik:
                  <pre>
                    simplerProfileForm = this.formBuilder.group(&#123;
                    firstName: ['', this.nameValidator],
                    lastName: ['', this.nameValidator],
                    age: [20, [
                      Validators.required,
                      rangeValidator(18, 100)
                    ]],
                    mail: ['', Validators.required, emailReservedAsyncValidator(this.http)],
                    position: [1, selectValidator(2)],
                    gender: ['female', checkboxValidator('nonbi')],
                    address: this.formBuilder.group(&#123;
                        street: ['', Validators.required],
                        city: ['', Validators.required],
                        zip: ['', [
                          Validators.required,
                          rangeValidator(1000, 9999)
                        ]],
                      }),
                      skills: this.formBuilder.array([
                        ['10 ujjas gépelés'],
                        ['8 ujjas gépelés'],
                      ], null),
                      isAccepted: [false]
                    });
                  </pre>
                </li>
                <li>FormControl esetében az első tömbelem a kezdeti érték, a második a szinkron validátor, a harmadik
                  az aszinkron validátor
                </li>
              </ul>
            </li>
            <li>Fontos, hogy amikor feliratkozunk egy Observable-re, akkor tulajdonképpen egy Subscription object
              kerül a kezünkbe, aminek a segítségével le tudunk iratkozni róla
              <ul>
                <li>Egy típusra több feliratkozás is szokott születni</li>
                <li>Ezért érdemes egy Subscription tömböt létrehozni, amibe elrakjuk a feliratkozásokat, hogy aztán
                  majd az onDestroyban forEach-el le tudjunk róluk iratkozni
                  <pre>
                    constructor() &#123;
                      subscriptions: Subscription[] = [];
                    }

                    ngOnInit() &#123;
                    const profileFormValueChangeSubscription = this.profileForm.valueChanges.subscribe(change => &#123;
                      this.getError("firstName", "maxlength");
                    });

                    this.subscriptions = [...this.subscriptions, profileFormValueChangeSubscription];
                    }

                    ngOnDestroy &#123;
                      this.subscriptions.forEach(sub => &#123;
                        sub.unsubscribe();
                      });
                    }
                  </pre>
                </li>
                <li>Ezzel elkerülhetőek a memóriaszivárgások (Memory Leak), tehát nem fog hallgatózni valami egy már
                  lecsatlakozott komponensben
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #templatedrivenform data-anchor="templatedrivenform">Form (Template Driven)</h3>
  <ul>
    <li>Template driven forms:
      <ul>
        <li>A klasszikus HTML form elküldési újratölti az oldalt</li>
        <li>Single Page Application esetében ez nem az elvárt működés</li>
        <li>Az app újraindításának elkerülése végett használhatunk Template Driven Form-ot, vagy Reactive Form-ot,
          amik megkönnyítik a form-ok kezelését
        </li>
        <li>Előnyei:
          <ul>
            <li>A kontrollerben csak egy kevés kódot kell írni (Innen ered a neve)</li>
            <li>Egyszerűbb megérteni, elkezdeni vele dolgozni</li>
          </ul>
        </li>
        <li>Hátrányai
          <ul>
            <li>Futásidőben nehezebb dinamikusan FormControl-t hozzáadni</li>
            <li>A Unit Test kihívásokkal teli</li>
          </ul>
        </li>
        <li>Ahhoz, hogy formokkal dolgozzunk Angularban, be kell importálni a FormsModule-t</li>
        <li>A kiindulási alapunknak semmi köze sincs az Angularhoz
          <pre>
            &#60;form action="#" method="post" class="form">
              ...
            &#60;/form>
          </pre>
        </li>
        <li>Ahhoz, hogy a szerver felé irányuló kérés ne okozzon page-load-ot, az action és method attribútumot el
          kell távolítanunk
        </li>
        <li>A Submit gomb típusának 'submit'-nak kell lennie</li>
        <li>Amikor elsubmitoljuk a form-ot, akkor egy eventet fogunk emittálni (ngSubmit)
          <pre>
            &#60;form class="form" (ngSubmit)="submit()">
              ...
            &#60;/form>
          </pre>
        </li>
        <li>KAmennyiben a submit függvénynek átadjuk a form referenciáját:
          <pre>
            &#60;form #registrationForm class="form" (ngSubmit)="submit(registrationForm)">
              ...
            &#60;/form>

            submit(form: HTMLFormElement) &#123;
              console.log('submitted: ', form);
            }
          </pre>
          <ul>
            <li>#registrationForm: Template Reference Variable</li>
            <li>Natív HTML form DOM elemre hivatkozik</li>
            <li>Nem erre lesz szükségünk</li>
          </ul>
        </li>
        <li>A formot, mint Javascript object-et szeretnénk megkapni:
          <pre>
            &#60;form #registrationForm="ngForm" class="form" (ngSubmit)="submit(registrationForm)">
              ...
            &#60;/form>

            submit(form: NgForm) &#123;
              console.log('submitted: ', form);
            }
          </pre>
          <ul>
            <li>Az ngForm egy direktíva</li>
            <li>Ez a direktíva teszi a form-ot Template Driven Form-má</li>
            <li>Nem szükséges explicite definiálnunk az ngForm-ot ahhoz, hogy Template Driven Formot kapjunk</li>
            <li>Onnantól kezdve, hogy beimportáltuk a FormsModule-t, az Angular látni fogja ezt a form-ot</li>
            <li>Az ngForm az adott formunkhoz egy referenciát fog tartalmazni</li>
            <li>A template-ben az ngForm használatával a submit függvénynek átadott paraméter típusa immáron nem
              HTMLFormElement, hanem egy NgForm típusú objektum
              <ul>
                <li>Rengeteg propertyt tartalmaz ez az objektum, ami ahhoz szükséges, hogy dolgozhassunk a form-mal
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Létrehozunk egy @ViewChild-ot:
          <ul>
            <li>@ViewChild(): Dekorátor</li>
            <li>ViewChild segítségével hozzáférhetünk egy elemhez, vagy komponenshez a templateből</li>
            <li>A @ViewChild()-nak paramétert is adunk, mégpedig a Template Reference Variable-t</li>
            <li>Innentől kezdve nem szükséges a submit paraméterekén a registrationForm-t átadni:
              <pre>
                &#60;form #registrationForm="ngForm" class="form" (ngSubmit)="submit()">
                  ...
                &#60;/form>

                @ViewChild('registrationForm') form: NgForm;

                submit() &#123;
                  console.log('submitted: ', this.form);
                }
              </pre>
              <ul>
                <li>A TypeScript szigorúan megköveteli, hogy a változók vagy inicializálva legyenek a deklaráció
                  során, így a form-nak kezdeti értéket kellene adnunk
                </li>
                <li>Amennyiben ezt nem szeretnénk megtenni, akkor 3 opció áll rendelkezésünkre:
                  <ol>
                    <li>A szigorú megkövetelés kikapcsolása
                      <pre>
                        "compilerOptions": &#123;
                          "strict": false,
                        }
                      </pre>
                    </li>
                    <li>Non-null assertion operator hásználata
                      <pre>
                        @ViewChild('registrationForm') form!: NgForm;
                      </pre>
                      <ul>
                        <li>Ezzel lehet jelezni a TypeScript-nek, hogy biztosan értéket fog kapni, nem lesz null vagy
                          undefined
                        </li>
                      </ul>
                    </li>
                    <li>Explicit megengedjük a változónak, hogy undefined is lehessen
                      <pre>
                        @ViewChild('registrationForm') form: NgForm | undefined;
                      </pre>
                    </li>
                  </ol>
                </li>
                <li>
                </li>
              </ul>
            </li>
            <li>Tehát a @ViewChild dekorátorral hozzáférünk a Template Reference Variable-höz, ami a form element
              referenciáját tartalmazza Javascript objektum formában
            </li>
            <li>Ha hozzá szeretnénk férni a FormControl-okhoz:
              <ul>
                <li>Az objektum controls és value property-jei lehetnek számunkra érdekesek</li>
                <li>Ehhez minden input mezőt el kell látni name attribútummal</li>
                <li>A nevek alapján történik a FormControlok létrehozása az NgForm objektumban</li>
                <li>Minden egyes beviteli mezőhöz hozzá kell adnunk az ngModel direktívát
                  <ul>
                    <li>Nem Two-way Data Binging-ot használunk</li>
                    <li>Így mondjuk meg, hogy az adott elem egy control-ja a formnak</li>
                    <li>A form objektumunkban innentől kezdve megtalálhatóak a controls kulcs alatt a FormControlok
                      (FormControl típusok)
                    </li>
                    <li>A value kulcs alatt pedig az egyes mezők aktuális értékeit láthatjuk</li>
                  </ul>
                </li>
                <li>Az egyes FormControl-oknak immáron láthatjuk az összes tulajdonságát</li>
              </ul>
            </li>
            <li>Ha hozzá akarunk férni az értékekhez, kétféleképpen is megtehetjük:
              <ol>
                <li>A Form objektum value kulcsa segítségével // this.form.value['firstname']</li>
                <li>A Form objektum controls kulcsa segítségével // this.form.controls['firstname'].value</li>
              </ol>
            </li>
            <li>Alapból minden mező valid értéke true</li>
            <li>Egy form akkor tekinthető touched-nak, ha bármelyik control mezője "focused", azaz a user már
              belekattintott
            </li>
            <li>Amennyiben a touched property-je true-ra vált, értelemszerűen az untouched pedig false-ra
              <ul>
                <li>Erre alapozva akár dinamikusan CSS-t is írhatunk
                  <pre>[ngClass]="&#123;'form-shadow': registrationForm.touched }"</pre>
                </li>
              </ul>
            </li>
            <li>Ugyanezek vonatkoznak a beviteli, avagy FormControl típusú mezőkre</li>
            <li>A form akkor kerül dirty állapotba, ha bármelyik control mezőjének megváltozott at értéke, és ugyanez
              igaz az adott FormControl típusú mezőre is
            </li>
            <li>Tehát, ha egy akár egyetlen beviteli mező is dirty lesz, a form dirty property-je true értéket vesz fel
            </li>
            <li>Disable-re lehet állítani a form összes mezőjét:
              <pre>
                ngAfterViewInit() &#123;
                  setTimeout(() => &#123;
                    this.form.control.disable();
                  }, 0);
                }
              </pre>
            </li>
            <li>Amennyiben bármelyik FormControl mező valid property-je false, úgy a form valid property-je is</li>
            <li>Validáció:
              <ul>
                <li>Ha bármelyik FormControl invalid, akkor a teljes form invalid lesz ("valid": false, "invalid":
                  true)
                </li>
                <li>A 'required' attribútummal érhetjük el, hogy a mezők kötelezően kitöltendők legyenek</li>
                <li>A required validátor csak azt nézi meg, hogy az adott control-ban van-e érték</li>
                <li>Ahhoz, hogy egy email field invalid legyen úgy, hogy nem valid email címet írtunk be, az 'email'
                  attribútumot szükséges használnunk
                  <pre>
                    &#60;input type="email" name="email" placeholder="Email" ngModel required email/>
                  </pre>
                </li>
                <li>Ahhoz, hogy a form submit gombját disable-re állítsuk egészen addig, amíg a form nem lesz valid, a
                  form referencia objektumához kell folyamodnunk (#registrationForm)
                  <pre>
                    &#60;input type="submit" value="Submit" class="submit-btn" [disabled]="registrationForm.invalid">
                  </pre>
                </li>
                <li>Egy mezei input field required attribútummal ('ng-invalid'), a kezdeti értékhez képest változatlan
                  értékkel ('ng-pristine'), belekattintatlanul ('ng-untouched') a következő CSS class-okat
                  tartalmazza:
                  <ul>
                    <li>ng-untouched ng-pristine ng-invalid</li>
                    <li>Belekattintva a mezőbe az ng-untouched ng-touched-ra vált</li>
                    <li>Beleírva a mezőbe az ng-pristine ng-dirty-re vált</li>
                    <li>Beleírva a mezőbe az ng-invalid ng-valid-ra vált</li>
                    <li>Létre lehet hozni akár CSS szabályt arra, hogy kötelező mező esetében, ha már
                      belekattintottunk, annak legyen látszata, hogy ki is kellene tölteni
                      <pre>
                        input.ng-invalid.ng-touched &#123;
                        border: red 2px solid;
                        }
                      </pre>
                    </li>
                  </ul>
                </li>
                <li>Amennyiben hibaüzenetet szeretnénk megjeleníteni a kötelező mező alatt, azt legalább két módon
                  megtehetjük:
                  <ol>
                    <li>A form Template Reference Variable-jére hivatkozva
                      <pre>
                        &#60;small *ngIf="registrationForm.controls['firstname'].touched && registrationForm.controls['firstname'].invalid">
                          First name is a required field!
                        &#60;/small>
                      </pre>
                    </li>
                    <li>Az adott FormControl mezőjére hivatkozva, szintén Template Reference Variable-lel
                      <pre>
                        &#60;input #firstname="ngModel" type="text" name="firstname" placeholder="First Name" ngModel required/>

                        &#60;small *ngIf="firstname.touched && firstname.invalid">
                          First name is a required field!
                        &#60;/small>
                      </pre>
                      <ul>
                        <li>Mint azt a formnál is láthattuk a #firstname="ngModel"-lel elérjük, hogy az ngModel az
                          input
                          element referenciáját tartalmazza, Javascript objektum formájában
                        </li>
                      </ul>
                    </li>
                  </ol>
                </li>
                <li>Az alábbi példában radio inputokkal dolgozunk, némi trükkel a harmadik opció nem elfogadható, és
                  ezen opció kiválasztásakor invaliddá is válik a form, valamint egy hibaüzenet is megjelenik
                  <pre>
                    &#60;div class="gender-box">
                      &#60;h3>Gender&#60;/h3>
                        &#60;div class="gender-option">
                          &#60;ng-container *ngFor="let go of genderOptions; let islast = last">
                            &#60;div>
                              &#60;input type="radio" [id]="go.id" name="gender" ngModel [value]="go.value" #radio="ngModel"
                                     [required]="go.value !== 'male' && go.value !== 'female'"
                                     (change)="go.value !== 'male' && go.value !== 'female' ? registrationForm.control.setErrors(&#123;'error': true}) : null">
                              &#60;label [for]="go.id">&#123; &#123; go.label }}/label>
                            &#60;/div>
                            &#60;small *ngIf="islast && radio.touched && radio.value === 'nosay'">
                              Please select male or female!
                            &#60;/small>
                          &#60;/ng-container>
                      &#60;/div>
                    &#60;/div>

                    genderOptions: any[] = [
                      &#123;id: 'check-male', label: 'male', value: 'male'},
                      &#123;id: 'check-female', label: 'female', value: 'female'},
                      &#123;id: 'check-other', label: 'prefer not to say', value: 'nosay'},
                    ];
                  </pre>
                </li>
                <li>Two-way Data Binding is megoldható a formban
                  <ul>
                    <li>Ennek megvalósítása érdekében a már meglévő ngModel direktívánkat egészítjük ki
                      <pre>
                        &#60;input #firstname="ngModel" type="text" name="firstname" placeholder="First Name" ngModel required/>

                        &#8595; &#8595; &#8595; &#8595; &#8595;

                        &#60;input #firstname="ngModel" type="text" name="firstname" placeholder="First Name" [(ngModel)]="firstName" required/>

                        firstName: string = '';
                      </pre>
                    </li>
                  </ul>
                </li>
                <li>Csoportosítani is lehet a FormControlokat
                  <ul>
                    <li>A FormGroup tulajdonképpen több FormControl, ami tartalmazhat akár FormGroup-ot is</li>
                    <li>Az ngModelGroup direktívával csoportosíthatjuk őket</li>
                    <li>Az összetartozó control-okat menedzselhetjük</li>
                    <li>A form objektumban a controls kulcs alá rendeződnek be alapértelmezetten a FormControl mezők
                    </li>
                    <li>A form objektumban a value kulcs alá pedig bekerülnek a FormControl mezők kitöltött
                      értékei
                    </li>
                    <li>A csoportosítandó mezőket összefogó HTML-tagre ngModelGroup direktívát teszünk
                      <pre>
                          &#60;div class="input-box address" ngModelGroup="address">
                            ...
                          &#60;/div>
                      </pre>
                      <ul>
                        <li>A form controljai közé bekerül az address, ami egy FormGroup típus</li>
                        <li>Ugyanaz vonatkozik rá, mint a Form-ra, amennyiben bármelyik mezőjébe belekattintunk,
                          touched lesz a group, és amennyiben akár egyetlen mezője is invalid, az egész group invalid
                          lesz
                        </li>
                        <li>Amennyiben pedig a group invalid, úgy a formunk is az lesz</li>
                      </ul>
                    </li>
                    <li>
                      Ha a group alá csak akkor akarunk kiírni hibát, ha a group érvénytelen, és már megérintették azt
                      az egyetlen mezőt, ami kötelező:
                      <pre>
                        &#60;small *ngIf="addr.invalid && addr.control?.controls?.['street1']?.touched">
                          Address FormGroup is invalid! Street address is missing!
                        &#60;/small>
                      </pre>
                    </li>
                  </ul>
                </li>
                <li>setValue() és patchValue()
                  <ul>
                    <li>Bármikor, amikor gombot használunk form-on belül, a gomb default type-ja submit, ezért
                      szükséges megadni neki manuálisan, hogy button
                    </li>
                    <li>A felhasználónév mezőbe szeretnénk 3 inputból adatot generálni; a generálás gombja csak akkor
                      aktiválódik, amennyiben ezt a 3 fieldet kitöltöttük (firstName, lastName, DateOfBirth), valamint
                      hibát dobunk, ha a user már belekattintott a mezőbe, de nem töltötte ki
                      <pre>
                        &#60;div class="input-box">
                          &#60;input #username="ngModel" type="text" name="username" placeholder="username" ngModel required/>
                          &#60;button type="button" (click)="generateUsername()"
                                  [disabled]="!firstName || ! lastName || !dob">
                            Create a Username
                          &#60;/button>
                          &#60;span>Required: firstName + lastName + Date of Birth&#60;/span>
                          &#60;small *ngIf="username.invalid && username.touched">Username is a required field!&#60;/small>
                        &#60;/div>

                        @ViewChild('registrationForm') form!: NgForm;

                        generateUsername() &#123;
                          let uname = this.firstName.slice(0, 3).toLowerCase() + this.lastName.slice(0, 3).toLowerCase() + (new Date(this.dob)).getFullYear();
                          //  let uname = (this.firstName.slice(0, 3) + this.lastName.slice(0, 3) + (new Date(this.dob)).getFullYear()).toLowerCase(); // Így egy fokkal rövidebb.
                          this.form.controls['username'].setValue(uname);
                        }
                      </pre>
                      <ul>
                        <li>A 3 mező mindegyike Two-way Binding-gal át van vezetve a kontrollerbe</li>
                        <li>A setValue() függvénnyel beállítjuk a megfelelő mező értékét</li>
                        <li>A 'this.form.value.username' felülírása a felhasználónévhez tartozó FormControl-ban nem
                          okoz változást, így az input mező tartalma sem változik meg
                        </li>
                        <li>A 'this.form.controls['username'].value' pedig egy Read-only property</li>
                        <li>A setValue() method a FormControl, FormGroup, és FormArray update-jére szolgál</li>
                        <li>Amennyiben a 'this.form.form.setValue(&#123;})' függvényt hívjuk meg, úgy a Form
                          value-jában lévő összes elemet oda kell adni a függvénynek, objektum formájában
                        </li>
                        <li>Ha ezirányból közelítjük meg a feladatot, és form-nak szeretnénk értéket beállítani, nem
                          pedig egy FormControl-nak, akkor az alábbi megoldással élhetünk:
                          <pre>
                            generateUsername() &#123;
                              let uname = this.firstName.slice(0, 3).toLowerCase() + this.lastName.slice(0, 3).toLowerCase() + (new Date(this.dob)).getFullYear();
                              this.form.form.patchValue(&#123;'username': uname});
                            }
                          </pre>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>A form resetelése egészen egyszerűen tud megtörténni:
                  <pre>
                    submit() &#123;
                      this.form.reset();
                    }
                  </pre>
                  <ul>
                    <li>Amikor a form resetelésre kerül, akkor az összes FormControl állapota megváltozik, minden mező
                      kitöltetlen lesz
                    </li>
                    <li>A form reset után beállíthatunk default értékeket
                      <pre>
                        this.form.form.patchValue(&#123;
                          gender: 'male',
                          address: &#123;country: 'Japan'}
                        });
                      </pre>
                    </li>
                  </ul>
                </li>
                <li>A formban kitöltött értékeket a form objektum value kulcsa alól tudjuk kiszedni</li>
                <li>Tömbök kezelésére is van lehetőségünk, és használhatunk akár TrackBy-t is
                  <pre>
                    &#60;div class="input-box" ngModelGroup="phoneNumbers">
                      &#60;div *ngFor="let phoneNumber of phoneNumbers; trackBy: tracker">
                        &#60;input type="text" [(ngModel)]="phoneNumber.value" name="&#123; &#123;phoneNumber.id}}"/>
                        &#60;span (click)="removePhoneNumber(phoneNumber.id)">&#10006;&#60;/span>
                      &#60;/div>
                    &#60;/div>
                    &#60;button type="button" (click)="addPhoneNumber()">Add phone number&#60;/button>

                    protected tracker = (index: number, value: any) => value.id;

                    addPhoneNumber() &#123;
                      const lastID = this.phoneNumbers[this.phoneNumbers.length - 1].id;
                      this.phoneNumbers = [...this.phoneNumbers, &#123;id: lastID, value: ''}]; // Új referenciát adunk
                    }

                    removePhoneNumber(phoneID: string) &#123;
                      const removeIndex = this.phoneNumbers.findIndex(phonenumber => phonenumber.id == phoneID);
                      this.phoneNumbers.splice(removeIndex, 1);
                    }
                  </pre>
                </li>
                <li>Checkbox-ok működése:
                  <pre>
                    &#60;div class="column">
                      &#60;input id="checkbox" type="checkbox" name="checkbox"/ ngModel>
                      &#60;label for="checkbox">Agreement&#60;/label>
                    &#60;/div>
                  </pre>
                  <ul>
                    <li>Az input name attribútumával megtörténik a FormControl létrehozása</li>
                    <li>Az ngModel direktívát szükséges haszálnunk</li>
                    <li>Ha alapértelmezetten false-ra szeretnénk állítani (null helyett), akkor az ngModel-be be kell
                      helyeznünk egy false booleant ([ngModel]="isAgreed")
                    </li>
                    <li>Kötelezővé tehetjük egy required attribútummal</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Teljes elkészült kód:
          <pre style="max-height: 500px;">
            &#60;section class="container" [ngClass]="&#123;'form-shadow': registrationForm.touched }">
              &#60;header>Registration Form&#60;/header>

              &#60;form #registrationForm="ngForm" class="form" (ngSubmit)="submit()">
                &#60;div class="column">
                  &#60;div class="input-box">
                    &#60;input #firstname="ngModel" type="text" name="firstname" placeholder="First Name"
                           [(ngModel)]="firstName" required/>
                    &#60;small *ngIf="firstname.touched && firstname.invalid">
                      First name is a required field!
                    &#60;/small>
                  &#60;/div>

                  &#60;div class="input-box">
                    &#60;input type="text" name="lastname" placeholder="Last Name" [(ngModel)]="lastName" required/>
                  &#60;/div>
                &#60;/div>

                &#60;div class="input-box">
                  &#60;input type="email" name="email" placeholder="Email" [(ngModel)]="email" required email/>
                &#60;/div>

                &#60;div class="column">
                  &#60;div class="input-box">
                    &#60;input type="number" name="phonenumber" placeholder="Phone Number" ngModel/>
                  &#60;/div>
                  &#60;div class="input-box">
                    &#60;input #tempbod="ngModel" type="date" name="date" placeholder="Date of Birth" [(ngModel)]="dob"/>
                  &#60;/div>
                &#60;/div>

                &#60;div class="input-box">
                  &#60;input #username="ngModel" type="text" name="username" placeholder="username" ngModel required/>
                  &#60;button type="button" (click)="generateUsername()"
                          [disabled]="!firstName || ! lastName || !dob">
                    Create a Username
                  &#60;/button>
                  &#60;span>Required: firstName + lastName + Date of Birth&#60;/span>
                  &#60;small *ngIf="username.invalid && username.touched">Username is a required field!&#60;/small>
                &#60;/div>

                &#60;div class="gender-box">
                  &#60;h3>Gender&#60;/h3>
                  &#60;div class="gender-option">
                    &#60;ng-container *ngFor="let go of genderOptions; let islast = last">
                      &#60;div>
                        &#60;input type="radio" [id]="go.id" name="gender" ngModel [value]="go.value" #radio="ngModel"
                               [required]="go.value !== 'male' && go.value !== 'female'"
                               (change)="go.value !== 'male' && go.value !== 'female' ? registrationForm.control.setErrors(&#123;'error': true}) : null">
                        &#60;label [for]="go.id">&#123; &#123; go.label }}&#60;/label>
                      &#60;/div>
                      &#60;small *ngIf="islast && radio.touched && radio.value === 'nosay'">
                        Please select male or female!
                      &#60;/small>
                    &#60;/ng-container>
                  &#60;/div>
                &#60;/div>

                &#60;div #addr=ngModelGroup class="input-box address" ngModelGroup="address">
                  &#60;label>Address&#60;/label>
                  &#60;input type="text" name="street1" placeholder="Street address" ngModel required/>
                  &#60;input type="text" name="street2" placeholder="Street address line 2" ngModel/>
                  &#60;div class="column">
                    &#60;div class="select-box">
                      &#60;select name="country" ngModel>
                        &#60;option hidden>Country&#60;/option>
                        &#60;option>America&#60;/option>
                        &#60;option>Japan&#60;/option>
                        &#60;option>India&#60;/option>
                        &#60;option>Nepal&#60;/option>
                      &#60;/select>
                    &#60;/div>
                    &#60;input type="text" name="city" placeholder="City" ngModel/>
                  &#60;/div>
                  &#60;div class="column">
                    &#60;input type="text" name="region" placeholder="Region" ngModel/>
                    &#60;input type="number" name="postalcode" placeholder="Postal code" ngModel/>
                  &#60;/div>
                &#60;/div>
                &#60;small *ngIf="addr.invalid && addr.control?.controls?.['street1']?.touched">
                  Address FormGroup is invalid! Street address is missing!
                &#60;/small>

                &#60;div class="input-box" ngModelGroup="phoneNumbers">
                  Phone numbers:
                  &#60;div *ngFor="let phoneNumber of phoneNumbers; trackBy: tracker"
                       style="display: flex; align-items: center;">
                    &#60;input type="text" [(ngModel)]="phoneNumber.value" name="&#123; &#123; phoneNumber.id}}"/> &#123; &#123; phoneNumber.id }}
                    &#60;span style="color: #9d2626; cursor: pointer" (click)="removePhoneNumber(phoneNumber.id)">&#10006;&#60;/span>
                  &#60;/div>
                &#60;/div>
                &#60;button type="button" (click)="addPhoneNumber()">Add phone number&#60;/button>

                &#60;div class="column">
                  &#60;input id="checkbox" type="checkbox" name="checkbox" [ngModel]="isAgreed" required/>
                  &#60;label for="checkbox">Agreement&#60;/label>
                &#60;/div>

                &#60;input type="submit" value="Submit" class="submit-btn" [disabled]="registrationForm.invalid">
                &#60;input type="submit" value="Submit (always active)" class="submit-btn">
              &#60;/form>
            &#60;/section>

            export class TemplatedrivenformComponent implements AfterViewInit &#123;
              @ViewChild('registrationForm') form!: NgForm;
              @ViewChild('addr') addressGroup!: any;

              firstName: string = 'Thomas Mosdoni';
              lastName: string = '';
              dob: string = '';
              email: string = '';
              isAgreed: boolean = false;

              genderOptions: any[] = [
                &#123;id: 'check-male', label: 'male', value: 'male'},
                &#123;id: 'check-female', label: 'female', value: 'female'},
                &#123;id: 'check-other', label: 'prefer not to say', value: 'nosay'},
              ];

              phoneNumbers: any[] = [
                &#123;id: 1, value: '+36501234567'},
              ];

              ngAfterViewInit() &#123;
                setTimeout(() => &#123;
                        // this.form.control.disable();
                }, 0);
              }

              protected tracker = (index: number, value: any) => value.id;

              addPhoneNumber() &#123;
                const lastID = this.phoneNumbers[this.phoneNumbers.length - 1].id;
                this.phoneNumbers = [...this.phoneNumbers, &#123;id: lastID, value: ''}]; // Új referenciát adunk
              }

              removePhoneNumber(phoneID: string) &#123;
                const removeIndex = this.phoneNumbers.findIndex(phonenumber => phonenumber.id == phoneID);
                this.phoneNumbers.splice(removeIndex, 1);
              }

              generateUsername() &#123;
                let uname = (this.firstName.slice(0, 3) + this.lastName.slice(0, 3) + (new Date(this.dob)).getFullYear()).toLowerCase();
                // this.form.controls['username'].setValue(uname);
                this.form.form.patchValue(&#123;'username': uname});
              }

              submit() &#123;
                console.log('submitted: ', this.form);
                console.log('address: ', this.addressGroup);
                // this.form.reset();
                this.form.form.patchValue(&#123;
                  gender: 'male',
                  address: &#123;country: 'Japan'}
                  });
              }

              protected readonly Number = Number;
            }
          </pre>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #simpleapp data-anchor="simpleapp">Simple app</h3>
  <ul>
    <li>A Google Chrome Angular DevTools egy nagyon hasznos bővítménye, amiben nyomon követhetjük, az egyes
      komponenseket, és azok State-jét
    </li>
    <li>Angular app létrehozásához az első lépés, hogy telepíteni kell a nodejs-t
      <ul>
        <li>Parancssorban a 'node -v' paranccsal ellenőrizhetjük, hogy a telepítés sikeres volt-e</li>
        <li>Az 'npm -v' paranccsal az npm program verzióját lehet ellenőrizni, ami a nodejs-sel települt</li>
      </ul>
    </li>
    <li>A következő lépés, hogy telepítenünk kell az Angular CLI-t (Command Line Interface)
      <ul>
        <li>Ezen keresztül lehet az Angular fejlesztés végezhető, kódot lehet vele generálni, fejlesztői
          környezetet indítani
        </li>
        <li>Globális npm package-ként kell feltelepítenünk: 'npm i -g @angular/cli'</li>
        <li>Ezek után az ng programon keresztül tudjuk a CLI-t használni
          <ul>
            <li>Az 'ng version' paranccsal lehet a verziót ellenőrizni</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A projekt inicializálása az 'ng new &#60;projektnév&#62;' paranccsal történik
      <ul>
        <li>Létrejön egy alapok mappa, és az összes Angularos forrásfájl ebbe kerül</li>
        <li>A parancs lefutása előtt meg kell adnunk, hogy akarunk-e kliens oldali útvonalválasztót</li>
        <li>A stíluslapok formátumára is rákérdez</li>
      </ul>
    </li>
    <li>Ha belépünk az alapok mappába, akkor az 'ng serve --open' / 'ng s --open' paranccsal elindíthatjuk a
      fejlesztői környezetünket
      <ul>
        <li>Az 'ng serve' paranccsal lokálisan indítunk el egy DEV szervert</li>
        <li>A létrehozott bundle-ök beinjektálódnak script tagként az index.html-be. (Kivéve a stílusokat, ami link
          tagba kerül, mint "stylesheet")
          <ul>
            <li>ng build-et követően, az alapértelmezetten dist mappában létrehozott index.html-ben láthatjuk is
              <ul>
                <li>runtime.js
                  <ul>
                    <li>Felelős az Angular alkalmazás betöltési folyamatának kezeléséért</li>
                    <li>A különböző modulok betöltéséhez szükséges futásidejű információkat tartalmazza</li>
                  </ul>
                </li>
                <li>polyfills.js
                  <ul>
                    <li>Esetleges pótlólagos funkciók a nagyobb kompatibilitás érdekében, hogy az Angular alkalmazás
                      modern
                      JavaScript funkciókat is használni tudjon olyan böngészőkben, amelyek esetleg nem támogatják
                      teljes
                      mértékben ezeket a funkciókat
                    </li>
                  </ul>
                </li>
                <li>main.js
                  <ul>
                    <li>Az Angular alkalmazás belépési pontja</li>
                    <li>Az alkalmazás logikáját és felhasználói interfészét tartalmazza</li>
                  </ul>
                </li>
                <li>vendor.js
                  <ul>
                    <li>Azokat a külső könyvtárakat tartalmazza, amelyek nem a saját alkalmazásodhoz tartoznak, hanem a
                      harmadik féltől származó (third-party) modulokat, mint például az Angular maga, az RxJS, vagy más
                      npm-en keresztül telepített függőségek
                    </li>
                    <li>Ha nincsenek third-party könyvtárak, akkor optimalizációs célból beolvas a main.ts-be</li>
                  </ul>
                </li>
                <li>styles.css
                  <ul>
                    <li>A globális stílusok a build folyamat során egy különálló CSS fájlba kerülnek</li>
                    <li>Az Angular a komponensek saját stílusait inline módon beilleszti a JavaScript fájlokba, majd
                      ezek a stílusok dinamikusan kerülnek be a dokumentum fejlécébe &#60;style> tagek formájában,
                      amikor az adott komponens renderelődik a DOM-ban
                    </li>
                    <li>A forráskódban styles.js-t láthatunk
                      <ul>
                        <li>A css fájl "becsomagolásra", és JS fájllá konvertálásra kerül, majd injektálódik a kódba
                        </li>
                      </ul>
                    </li>
                    <li>Buildelt verzió esetében optimalizálási célból különálló CSS fájlokat használ a jobb
                      teljesítmény, és gyorsabb betöltés érdekében
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A '--open' megnyitja az appot a böngészőben automatikusan, amikor lebuildelődött</li>
        <li>A DEV szerverre azért van szükség, mert az Angularos forrásfájlokat nem Javascript, hanem Typescript
          nyelven, és ez utóbbit a böngésző nem tudja értelmezni, ezért szükség van a forrásfájlok
          átfordítására Typescriptről Javascriptre,
        </li>
        <li>A DEV szerver azt csinálja, hogy bármikor, amikor változtatunk valamit egy fájlon, akkor az
          átfordítást automatikusan elvégzi
        </li>
        <li>A DEV szerver azt is megcsinálja, hogy az ES6-os modulokat (amik szintén nem futnának alapból a
          böngészőben) összecsomagolja egyetlen egy Javascriptes bundle-lé, és úgy futtatja a böngészőben
        </li>
        <li>A DEV szerver információkat nyújt az esetlegesen előforduló hibákról is</li>
      </ul>
    </li>
    <li>Az npm install --global global switch-e azt mondja meg, hogy globálisan telepítünk egy csomagot, ha pedig
      nincs ott a switch, akkor csak az adott projektbe installáljuk az adott csomagot
    </li>
    <li>Az npm csomagkezelő 5.0-ás verziójától a --save funkcionalitás (azaz, hogy a csomag bekerül a package.json-be)
      automatikus, így nem kell külön kiírni
    </li>
    <li>Csomagot törölni az npm uninstall *packageName* paranccsal tudunk</li>
    <li>A --save-dev kapcsolót akkor érdemes használni, ha egy csomagra csakis kizárólag developer környezetben van
      szükségünk
    </li>
    <li>Az Angular inicializáláskor egy komponenst generál ki automatikusan, az app komponenst
      <ul>
        <li>Az alkalmazásunk belépési pontjaként szolgál</li>
      </ul>
    </li>
    <li>Angularban külön fájlt szentelünk a kontrollernek (app.component.ts), és a templatenek (app.component.html)
      is
      <ul>
        <li>Bármelyikre rámentünk, a build folyamat automatikusan le fog futni</li>
      </ul>
    </li>
    <li>Angularra az jellemző, hogy az összes komponens class deklarációval van létrehozva
      <ul>
        <li>
          <pre>
                        export class AppComponent &#123;
                      isBoxGrabbed: boolean = false;
                      xPosition: number = 0;
                      yPosition: number = 0;
                        &#125;
                    </pre>
        </li>
        <li>A kontroller részt a deklaráción belül lehet létrehozni</li>
        <li>A State változók propertyk ebben a classban</li>
        <li>A következő lépés, hogy a State változót fel akarjuk használni a sablonban, tartalomgeneráláshoz
        </li>
        <li>
          <pre>
                        &#60;div class="box"
                             [ngClass]="isBoxGrabbed ? 'grabbed' : 'not-grabbed'"
                             (mousedown)="isBoxGrabbed = true"
                             (mouseup)="isBoxGrabbed = false"
                             (mousemove)="isGrabbed($event)"&#62;
                          &#60;h5>grabit&#60;/h5&#62;
                        &#60;/div&#62;
                    </pre>
          <ul>
            <li>A 'box' class jelen esetben statikus, a 'grabbed' és 'not-grabbed' pedig dinamikus, tehát
              futásidőben változhat
            </li>
            <li>A dinamikus classokat az [ngClass] direktívával lehet betáplálni</li>
            <li>A sablonunkba a State-ből kiolvasott értéket írjuk be az [ngStyle] direktívával
              <ul>
                <li>Objektum formájában felsoroljuk a stílusokat</li>
              </ul>
            </li>
            <li>Mindenféle interakció nélkül az isBoxGrabbed false, így a 'not-grabbed' css class kerül a
              template-be
            </li>
            <li>Arra van szükség, hogy egy action-re reagáljunk, amire State változtatást végzünk
              <ul>
                <li>Ezt megtehetjük methoddal</li>
                <pre>
                                    &#60;div class="box"
                                        [ngClass]="isBoxGrabbed ? 'grabbed' : 'not-grabbed'"
                                        [ngStyle]="&#123;
                  'position': 'absolute',
                  'left.px': xPozicio,
                  'top.px': yPozicio
                                          &#125;"
                                         (mousedown)="dobozDragStart()"
                                         (mouseup)="dobozDragVege()"&#62;
                                      &#60;h5>grabit&#60;/h5&#62;
                                    &#60;/div&#62;

                                    /* dobozDragStart() &#123;
                  this.isBoxGrabbed = true;
                                    &#125; */

                                    /* dobozDragVege() &#123; //
                                        this.isBoxGrabbed = false;
                                    &#125; */

                                    toggleGrab() &#123;
                  this.isBoxGrabbed = !this.isBoxGrabbed;
                                    &#125;

                                    isGrabbed(event: any) &#123;
                  if (this.isBoxGrabbed) &#123;
                                          this.xPosition = event.clientX;
                                          this.yPosition = event.clientY;
                                        &#125;
                                    &#125;
                                </pre>
              </ul>
            </li>
            <li>Az isGrabbed() függvény megkapja paraméternek az event-et</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div>
  <h3 #spa data-anchor="spa">Single Page App</h3>
  <ul>
    <li>A tradícionális weboldallal szemben linkre kattintáskor nem történik tényleges oldal letöltés, csak az Angular
      beköt egy komponens hierarchiát, ami különféle vizuális hatásokkal jár a UI-on
    </li>
    <li>Minden információ áramlás az első oldal letöltést követően AJAX kérés formájában történik
      <ul>
        <li>Nem kapunk új HTML tartalmat szerver oldalról, csak valamilyen formátumú adatcsomagot</li>
      </ul>
    </li>
    <li>Onnan ismerni meg a Single Page App-ot, hogy csak az első oldal letöltésekoz érkezik HTML dokumentum
      <ul>
        <li>Majd elindul az Angular alkalmazás, és benne az útvonal választó is</li>
        <li>Minden további kérés AJAX kérést követően érkezik</li>
      </ul>
    </li>
    <li>Amikor a felhasználó átnavigál egy oldalra, akkor az Angular aktiválja a megfelelő komponens hierarchiát</li>
    <li>Ha egy új projektet routinggal hozunk létre, akkor az app mappába generálódik egy app-routing.module.ts fájl
      <ul>
        <li>Útvonal-komponens párosítások sokaságát tudunk itt megadni</li>
        <li>Kezdetben nincs útvonal regisztrálva
          <ul>
            <pre>
            const routes: Routes[] = &#123; &#125;
          </pre>
            <li>Objektumokat kell elhelyezni benne</li>
            <li>Két kulcs-érték párral kell rendelkezzen (path és component)</li>
            <li>Az üres path megegyezik a root-tal (path: '' = path: '/')
              <ul>
                <li>A '/'-re sosincs szükség, az Angularban ezt nem kell kiírni (path: '/list')</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>A kezdeti tartalom az app.component.html-ben lévő &#60;router-outlet&#62;&#60;/router-outlet&#62; végett
          jelenik meg
          <ul>
            <li>Az Angular az adott komponensek tartalmát ide fogja generálni</li>
            <li>Dinamikusan fog változni</li>
            <li>Ami ezen kívül van, az statikus, nem változik</li>
            <li>Tehát az app komponens mindig életben van, és van ez a dinamikusan változó része</li>
            <li>Statikus tartalom lehet, ami minden oldalon ugyanúgy megmarad, például egy navigációs sáv, vagy egy
              footer
            </li>
            <li>Az útvonal függvényében változó tartalmat praktikusan a fix elemek közé szokás elhelyezni</li>
          </ul>
        </li>
        <li>Az útvonalak közti váltogatáshoz meg kell látogatnunk a sablonunkat, és RouterLinket elhelyezni benne
          <ul>
            <li>Bármilyen elementre ráaggatható</li>
            <li>SEO szempontokból viszont érdemes &#60;a&#62; tag-ekre aggatni</li>
            <li>href attribútum helyett [RouterLink] input adatot adunk meg</li>
            <li>Értékkénk tömb írandó bele</li>
            <li>A tömb elemei az URL szegmensek</li>
            <li>A főoldalra az alábbi módon navigálunk
              <ul>
                <li>
                  <pre>
                    &#60;a [routerLink]="['/']"&#62;&#60;/a&#62;
                  </pre>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Többféleképpen is le tudjuk tölteni az adatot
          <ul>
            <li>Reaktívak
              <pre>
                // Reaktív megvalósítás switchMap()-pel

                albumsReactive$: BehaviorSubject&#60;any&#62; = new BehaviorSubject&#60;any&#62;([]);

                // Az albumsReactive$-ra next-elve elindul a lekérés
                get$ = this.albumsReactive$.pipe(
                  tap((albumsReactive$defaultValue) => &#123;
                              console.log('albumsReactive$defaultValue: ', albumsReactive$defaultValue);
                              // Nem piszkáljuk az adatfolyamot, csak a BehaviorSubject kezdeti értékét kiírjuk.
                              // Itt még felhasználhatjuk a BehaviorSubject kezdeti értékét
                  &#125;),
                  switchMap(() => this.http.get('https://jsonplaceholder.typicode.com/albums')),
                  catchError(err => of([])),
                  tap(data => &#123;
                              console.log('data: ', data);
                              // this.albumsReactive$.next(data); // Végtelen ciklusba kerülünk
                  &#125;)
                )

                // Reaktív megvalósítás switchMap()-pel 2
                // Létrehozunk egy Subject-et, ami az adatfolyam indítója lesz
                subject$ = new Subject&#60;void&#62;();

                // `get$` Observable, ami az adatfolyamot kezel
                get2$ = this.subject$.pipe(
                  switchMap(() =>
                    this.http.get&#60;any[]&#62;('https://jsonplaceholder.typicode.com/albums').pipe(
                      catchError(err => &#123;
                                console.error('Fetch error: ', err);
                                return of([]); // Hiba esetén üres tömböt ad vissza
                      &#125;)
                    )
                  ),
                  tap(data => &#123;
                                console.log('Get 2 result: ', data);
                                this.albumsReactive$.next(data as any[]);
                  &#125;)
                );

                this.get$.subscribe();
                /* this.get2$.subscribe( // Deprecated
                  data => &#123;
                            console.log('!!!!! Received data !!!!! ', data);
                  &#125;,
                  error => &#123;
                            console.error('Received error: ', error);
                  &#125;,
                  () => &#123;
                            console.log('Observable completed');
                  &#125;
                ); */
                this.get2$.subscribe();

                this.subject$.next();

                &#60;div *ngIf="albumsReactive$ | async as albums"&#62;
                  &#60;pre>&#123; &#123; albums | json &#125; &#125;&#60;/pre&#62;
                &#60;/div&#62;
              </pre>
            </li>
            <li>Fetch
              <pre>
                // Fetch API használata (Vanilla JS)

                fetch('https://jsonplaceholder.typicode.com/albums') // Promise&#60;response&#62;
                  .then(response => response.json())// Promise&#60;any&#62;
                  .then(data => &#123; // data: Album[] - az API válasza, JSON-né alakított válasz
                    console.log('Fetch data: ', data);
                  &#125;)
                  .catch(error => &#123; // error: Error - hiba esetén
                    console.error('Fetch error: ', error);
                  &#125;)
                  .finally(() => &#123; // Finally: a Promise befejeződött
                    console.log('Fetch operation completed');
                  &#125;);
              </pre>
            </li>
            <li>Angular HTTPClient
              <pre>
                const albums = this.http.get&#60;any&#62;('https://jsonplaceholder.typicode.com/albums').pipe( // Az albums egy Subscription
                  tap(data => &#123; // data: Album[] - az API válasza
                    console.log('Data: ', data);
                  &#125;),
                  catchError(err => &#123; // err: HttpErrorResponse - hiba esetén
                    console.error('Error: ', err);
                    return of([]);
                  &#125;)
                ).subscribe(
                  response => &#123; // response: Album[] - az API válasza
                    console.log('Response: ', response);
                  &#125;,
                  error => &#123; // error: HttpErrorResponse - hiba esetén
                    console.error('Error: ', error);
                  &#125;,
                  () => &#123; // Complete: az Observable befejeződött
                    console.log('Observable completed');
                  &#125;
                );
              </pre>
            </li>
            <li>RxJS AJAX
              <pre>
                // RxJS ajax használata

                ajax(&#123; // Az `ajax` metódus visszaad egy Observable-t, amely egy HTTP válasz objektumot tartalmaz
                  method: 'GET',
                  url: 'https://jsonplaceholder.typicode.com/albums',
                &#125;).pipe(
                  tap(response => &#123; // response: HttpResponse - az adatot tartalmazó HTTP válasz objektum
                    console.log('AJAX: ', response.response); // response.response: Album[]
                  &#125;)
                ).subscribe( // Deprecated!
                  (data: any) => &#123; // data: AjaxResponse - az API válasza
                    console.log('Albums 1:', data.response);
                  &#125;,
                  error => &#123; // error: Error - hiba esetén
                    console.error('Error: ', error);
                  &#125;,
                  () => &#123; // Complete: az Observable befejeződött
                    console.log('Observable completed');
                  &#125;
                );
              </pre>
            </li>
            <li>RxJS AJAX getJSON()
              <pre>
                // RxJS ajax getJSON metódus használata

                ajax.getJSON('https://jsonplaceholder.typicode.com/albums').pipe( // `getJSON` metódus visszaad egy Observable-t, amely a JSON adatot közvetlenül tartalmazza
                  tap(data => &#123; // data: Album[] - az API válasza
                    console.log('AJAX getJSON: ', data);
                  &#125;)
                ).subscribe( // Deprecated!
                  data => &#123; // data: Album[] - az API válasza
                    console.log('Albums:', data);
                  &#125;,
                  error => &#123; // error: Error - hiba esetén
                    console.error('Error: ', error);
                  &#125;,
                  () => &#123; // Complete: az Observable befejeződött
                    console.log('Observable completed');
                  &#125;
                );
              </pre>
            </li>
          </ul>
        </li>
        <li>Amennyiben egy komponens a komponens egy item-jébe szeretnénk navigálni, ahhoz három dolgot kell tennünk
          <ul>
            <li>Létrehozni egy útvonalat az adott item-nek
              <pre>&#123;path: 'list/:id', component: ItemComponent&#125;</pre>
            </li>
            <li>A template-ben beállítani a routerLink inputot
              <pre>
                &#60;div *ngIf="albumsReactive$ | async as albums"&#62;
                  &#60;div *ngFor="let album of albums"&#62;
                    &#60;h3>&#123; &#123; album.id &#125; &#125;&#60;/h3&#62;
                    &#60;a [routerLink]="[album.id]"&#62;&#123; &#123; album.title &#125; &#125;&#60;/a&#62;
                  &#60;/div&#62;
                &#60;/div&#62;
              </pre>
            </li>
            <li>Az item componentben használni az ActivatedRoute dependency injection-t
              <pre>
                constructor(private aRouter: ActivatedRoute) &#123;
                  aRouter.params.subscribe(param => &#123;

                  &#125;);
                &#125;
              </pre>
            </li>
          </ul>
        </li>
        <li>Az item komponensben letöltjük a képeket, majd kiírjuk az eredményt
          <pre>
            constructor(private aRoute: ActivatedRoute, private route: Router) &#123;
              aRoute.params.subscribe(params => &#123;
                this.albumID = params['id'];
                fetch(`https://jsonplaceholder.typicode.com/photos?albumId=$&#123;this.albumID}`)
                  .then(res => res.json())
                  .then((photos: Photo[]) => &#123; // A Photo-knak létrehoztunk egy interface-t
                      if (!photos.length) &#123;
                      this.route.navigate(['..'], &#123;relativeTo: aRoute}); // Amennyiben pl. a user saját maga ír be az url-be nem létező albumID-t, úgy nem kap képeket, és visszadobjuk a listára
                    }
                    this.photos = photos;
                  })
              });
            }
          </pre>
          <pre>
            &#60;div style="display: inline-block">
              &#60;ng-container *ngFor="let p of photos">
                &#60;a [href]="p.url" [target]="'_blank'" style="display: inline-block; margin: 0 5px 5px 0; line-height: 0">
                  &#60;img [src]="p.thumbnailUrl" alt="" width="100px" height="100px">
                &#60;/a>
              &#60;/ng-container>
            &#60;/div>
          </pre>
        </li>
        <li>A routerben használhatunk úgynevezett "wild card"-ot, ami arra hivatott, hogy amennyiben a felhasználó nem
          létező oldalra menne, megadhatjuk, hogy hova redirect-eljük a felhasználót
          <pre>
            &#123;path: '**', component: FrontPageComponent},
          </pre>
          <ul>
            <li>Gyakran erre létre szokás hozni egy külön komponenst</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <app-navi [tempSwitcher]="'spa'"></app-navi>
  <br>
</div>

<div>
  <h3 #unittest data-anchor="unittest">Unit test</h3>
  <ul>
    <li>Alapértelmezetten az index.html-ben találjuk az app-root tag-et, ami az app komponenst rendereli</li>
    <li>Az app.module.ts nem része az app komponensnek</li>
  </ul>
</div>

<div>
  <h3 #deploying data-anchor="deploying">Deploying</h3>
  <h5 #environmentvariables data-anchor="environmentvariables">Environment variables</h5>
  <ul>
    <li>A korábbi Angular verziókban az src mappán belül, az environment mappában volt fellelhető 2 fájl a környezeti
      változók megadására
      <ol>
        <li>environment.ts</li>
        <li>environment.prod.ts</li>
      </ol>
      <pre>
        <b>// angular.json</b>
        "production": &#123;
          "fileReplacements": [
            &#123;
              "replace": "src/environments/environment.ts",
              "with": "src/environments/environment.prod.ts"
            }
          ],
        }
      </pre>
    </li>
    <li>Angular 16-ban például már manuálisan kell létrehozni ezeket a fájlokat
      <ul>
        <li>ng g environments
          <ol>
            <li>environment.development.ts
              <ul>
                <li>Development</li>
              </ul>
            </li>
            <li>environment.ts
              <ul>
                <li>Production</li>
              </ul>
            </li>
          </ol>
        </li>
      </ul>
    </li>
    <li>Előfordul, hogy az adatbázis eltér development és production esetében, és ezek a szerverek különböző
      credential-öket használnak
      <ul>
        <li>Ezek az adatok elmenthetők az environment fájlokba</li>
        <pre>
          <b>// environment.development.ts</b>
          export const environment = &#123;
            firebaseAPIKey = 'abcderfghijkl123456789'
          }

          <b>// environment.ts</b>
          export const environment = &#123;
            firebaseAPIKey = 'abcderfghijkl123456789'
          }

          <b>// usage</b>
          import &#123; environment } from "src/environments/environment.development";

          export class ExampleClass &#123;
            private firebaseAPIKey = environment.firebaseAPIKey;
          }
        </pre>
      </ul>
    </li>
    <li>Ugyan az importálás során az environment.development fájlt adtuk meg, de ha production build-et készítünk, az
      Angular automatikusan a production environment-ből szedi ki az értékeket
      <ul>
        <pre>
          <b>// angular.json</b>
          "development": &#123;
          "fileReplacements": [
                &#123;
                  "replace": "src/environments/environment.ts",
                  "with": "src/environments/environment.development.ts"
                }
              ],
            }
        </pre>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #generatebundlesforproduction data-anchor="generatebundlesforproduction">Generate bundles for production</h5>
  <ul>
    <li>A kompiláláshoz, és a development szerver futtatásához az ng serve parancsot használtuk
      <ul>
        <li>Legenerálja a bundle file-kat</li>
        <li>Live developement szervert indít</li>
        <li>Nem írja ki a fájlokat a lemezre, hanem csak a memóriában tárolja őket, és onna futtatja</li>
        <li>Lokális, gyors, iteratív környezet kialakítására való</li>
        <li>A source fájlok változásait detektálja
          <ul>
            <li>Automatikusan rebuildel, és újratölti az appot a böngészőben</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Amint a fejlesztés elkészült, a teljesítmény javítás megtörtént, és végbement az átfogó tesztelés, az app készen
      áll a production deployment-re
      <ul>
        <li>Build-elni szükséges az Angular applikációnkat, ami során bundle fájlok jönnek létre</li>
        <li>ng build
          <ul>
            <li>A typescript kódot javascript kóddá alakítja</li>
            <li>A HTML template-ekből optimalizált JS kód lesz </li>
            <li>Lemezre írás történik, alapértelmezetten a dist mappába</li>
            <li>Az index.html tartalmazza a bundle script fájlok behivatkozását</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>A fájlokat egy statikus hosting szerverre helyezhetjük</li>
  </ul>
</div>

<div>
  <h3 #standalonecomponents data-anchor="standalonecomponents">Standalone components</h3>
  <ul>
    <li>Angular 14 óta létezik</li>
    <li>Angular 17-től már automatikusan standalone komponens jön létre</li>
    <li>Ezidáig, ha új komponenst, direktívát, pipe-ot, szerviz hoztunk létre, module osztályban deklarálnunk kellett,
      hogy az Angular tudjon a létezésükről
      <ul>
        <li>A modulokat úgyszintén deklarálni szükséges szülő modulban</li>
        <li>Sok boilerplate kódot írunk
          <ul>
            <li>Sablon vagy ismétlődő kódrészlet</li>
          </ul>
        </li>
        <li>Ha elfelejtjük a deklarációt, elcrashel(het) az appunk</li>
        <li>A standalone komponensek erre nyújtanak megoldást</li>
      </ul>
    </li>
    <li>Standalone komponens
      <ul>
        <li>Speciális típusú komponens</li>
        <li>Nem szükséges deklarálni module class-ban</li>
        <li>Leegyszerűsíti a fejlesztést, és kiküszöböli az NgModule használatát</li>
        <li>NgModule-ban deklarált osztályok mellettt is használható</li>
        <li>Innentől kezdve nem igaz, hogy az applikációnak legalább egy modullal kell rendelkeznie</li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #creatingstandalonecomponents data-anchor="creatingstandalonecomponents">Creating standalone components</h5>
  <ul>
    <li>Adott egy szabványos komponensünk (app-details), amit át szeretnénk konvertálni standalone komponensé
      <ul>
        <li>A Component dekorátorban, a metadata objektumban standalone kulcs értékének megadhatjuk, hogy true</li>
        <li>Alapértelmezés szerint false</li>
        <li>Innentől kezdve a komponens használható más komponensekben anélkül, hogy deklarálnánk az NgModule-ban</li>
        <li>Ezzel együtt tájékoztatnunk kell az Angulart ennek a standalone komponensnek a létezéséről</li>
        <li>Amennyiben a deklarációból nem vesszük ki a komponenst, hibát kapunk</li>
        <pre>
          Component DetailsComponent is standalone, and cannot be declared in an NgModule
        </pre>
        <li>Tehát a deklarációban nem maradhat benne a komponens</li>
        <li>Ha az app-details komponens szelektorát használjuk más komponensben, akkor azon komponens Component
          dekorátorában be szükséges importálnunk a DetailsComponent-et</li>
        <pre>
            @Component(&#123;
              selector: 'app-standalone',
              templateUrl: './standalone.component.html',
              styleUrls: ['./standalone.component.scss'],
              imports: [DetailsComponent]
            })
        </pre>
        <li>Jelen projektben nevesített router-outlet-en keresztül jelenik meg az app-details, így külön komponens
          importálásra nem volt szükség</li>
        <li>Ugyanakkor, ha használjuk az imports kulcsot a dekorátor meta objektumában (ahogy feljebb), hibát kapunk
        </li>
        <pre>
          NG2010: 'imports' is only valid on a component that is standalone.
        </pre>
        <li>Az imports-ot csak standalone komponensben használhatunk
          <ul>
            <li>Abban az esetben, ha az app-standalone komponens is standalone, nincs probléma</li>
            <li>De jelen helyzetben más megoldást kell találnunk</li>
          </ul>
        </li>
        <li>A standalone komponensek használhatók a szabványos komponensek mellett
          <ul>
            <li>NgModule-ban kombinálhatóak</li>
            <li>A declarations kulcs alatt már nem adható meg (mert standalone)</li>
            <li>Ugyanakkor beimportálható</li>
          </ul>
        </li>
        <li>Ezek után azt tapasztalhatjuk, hogy a custom színező direktívánk nem működik
          <ul>
            <li>Használjuk a standalone komponensben</li>
            <li>Mivel az app-details komponenst importáltuk, és az imports kulcs alatt szerepel a SharedModule is,
              amiben a direktívánk van, a DetailsComponent-nek nincs hozzéférése a changeToGreen direktívához</li>
            <pre>
                <b>// navi.module.ts</b>
                @NgModule(&#123;
                  ...
                  imports: [
                    ...
                    SharedModule,
                    DetailsComponent
                  ],
                  ...
                })
              </pre>
            <li>Ebben a szkenárióban nincs hozzáférése a standalone komponensünknek a SharedModule-ban lévő exportokhoz
            </li>
            <li>Két megoldás van arra, hogy működjön a direktíva a standalone komponensen belül
              <ol>
                <li>Átkonvertálhatjuk a direktívás standalone direktívává
                  <ul>
                    <li>Bármelyik standalone komponensben beimportálhatóvá válik</li>
                  </ul>
                </li>
                <li>Beimportáljuk a details komponensünkbe
                  <ul>
                    <li>A SharedModule-t szükséges beimportálnunk, mert az exportálja a direktívát</li>
                    <pre>
                      <b>// details.component.ts</b>
                      @Component(&#123;
                        selector: 'app-details',
                        templateUrl: './details.component.html',
                        styleUrls: ['./details.component.scss'],
                        standalone: true,
                        imports: [SharedModule]
                      })
                    </pre>
                    <li>Amit exportál a SharedModule, elérhető lesz a DetailsComponent-ben</li>
                  </ul>
                </li>
              </ol>
            </li>
            <li>Ha a changeToGreen direktívát csakis kizárólag ebben a standalone komponensben használjuk, sehol máshol
              az alkalmazásunkban, akkor a SharedModule-t nem szükséges NgModule-ban importálnunk, mivel már
              beimportáltuk a details komponensbe, ahol használni akarjuk</li>
          </ul>
        </li>
        <li>A cél az, hogy az NgModule-ba ne kelljen komponenseket felvennünk
          <ul>
            <li>Azzal, hogy a navi modulba importáltuk a standalone komponensünket, ez a cél nem teljesült</li>
            <li>Sőt, összességében még több kódot kellett írnunk
              <ul>
                <li>Az NgModule-ba, és a komponens dekorátorba is importáltunk</li>
              </ul>
            </li>
            <li>Ezen a ponton egyelőre nem sikerült kiaknázni a standalone komponens előnyeit</li>
            <li>Ha minden komponensünk standalone lenne, akkor tudnánk megszabadulni az NgModule használatától</li>
            <li>Addig a pontig, amíg akár egyetlen szabványos komponensünk van, kénytelenek vagyunk használni az
              NgModule-t</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #creatingstandalonedirective data-anchor="creatingstandalonedirective">Creating standalone directive</h5>
  <ul>
    <li>A direktívát át kell konvertálni standalone direktívává</li>
    <pre>
      <b>// change-to-green.directive.ts</b>
      @Directive(&#123;
        selector: '[changeToGreen]',
        standalone: true
      })
    </pre>
    <li>Ezen a ponton túl semmilyen NgModule dekorátorban sem szabad használni
      <ul>
        <li>A SharedModule már nem importálja, nem exportálja</li>
      </ul>
    </li>
    <li>A DetailsComponent-nek így már nincs hozzáférése a direktívához</li>
    <li>A standalone komponensben más standalone elemek beimportálhatók</li>
    <pre>
      @Component(&#123;
        selector: 'app-details',
        templateUrl: './details.component.html',
        styleUrls: ['./details.component.scss'],
        standalone: true,
        imports: [ChangeToGreenDirective] // NgModule-ban nem szerepelhet
      })
    </pre>
  </ul>
  <br>
  <h5 #standalonerootcomponent data-anchor="standalonerootcomponent">Standalone root component</h5>
  <ul>
    <li>Az AppComponent esetében extra műveletre is szükség lesz, hogy standalone-osítsuk</li>
    <pre>
      @Component(&#123;
        selector: 'app-root',
        templateUrl: './app.component.html',
        styleUrls: ['./app.component.scss'],
        standalone: true
      })
    </pre>
    <li>Első lépésként megadjuk a dekorátorban a standalone kulcsot true értékkel</li>
    <li>Második lépésként az app.module.ts fájl NgModule dekorátorának declarations tömbjéből eltávolítjuk az
      AppComponent-et</li>
    <li>Végül tudatnunk kell az Angular-t az app komponens létezéséről</li>
    <pre>
      <b>// app.module.ts</b>
      @NgModule(&#123;
        declarations: [],
        imports: [
          // BrowserModule, // elhagyjuk
          // AppComponent // elhagyjuk
        ],
        providers: [],
        // bootstrap: [AppComponent] // elhagyjuk
        bootstrap: []
      })
      export class AppModule &#123;
      }
    </pre>
    <li>Az importok közé nem kell az AppComponentt, illetve nem használhatjuk bootstrap-elésre sem
      <ul>
        <li>Standalone komponens nem adható meg a bootstrap tömbbe</li>
      </ul>
    </li>
    <li>Ezen túl pedig a main.ts fájlban is változtatást kell végrehajtani</li>
    <pre>
      <b>// main.ts</b>
      platformBrowserDynamic().bootstrapModule(AppModule)
        .catch(err => console.error(err));

        ↓↓↓↓↓

        bootstrapApplication(AppComponent);
    </pre>
    <li>Az app modul helyett direkt módon az app komponenst töltjük meg</li>
    <li>A bootstrapApplication függvény automatikusan elérhetővé teszi a BrowserModule-t, ezért azt sem szükséges
      importálnunk</li>
    <li>A végeredmény jól látható, miszerint nem maradt semmi az NgModule dekorátorban</li>
    <pre>
      <pre>
        <b>// app.module.ts</b>
        @NgModule(&#123;
          declarations: [],
          imports: [],
          providers: [],
          bootstrap: []
        })
        export class AppModule &#123;
        }
      </pre>
    <li>Le is törölhető</li>
    <li>Ezen a módon mindenhonnan eltávolíthatóak a modul-ok (NgModule)</li>
    </pre>
  </ul>
  <br>
  <h5 #servicesinstandalonecomponents data-anchor="servicesinstandalonecomponents">Services in standalone components
  </h5>
  <ul>
    <li>A teljes applikációban elérhető a service
      <ul>
        <li>Minden komponens, minden direktíva a service-nek ugyanazt a példányát kapja meg</li>
        <pre>
          @Injectable(&#123;
            providedIn: 'root'
          })
        </pre>
      </ul>
    </li>
    <li>Megadható komponens szinten a service
      <ul>
        <li>Akármikor injektálásra kerül egy ActionService az AppComponent-be, mindig ugyanazt a példányt kapja meg az
          összes gyerek komponens</li>
        <pre>
          @Component (&#123;
            selector: 'app-root', 
            templateurl: ''./app.component.html',
            styleUrls: ['./app-component,css'],
            providers: [ActionService]
          })
        </pre>
      </ul>
    </li>
    <li>Valamely, a fában lévő gyerek komponensben felülírhatjuk a szerviz instanciát
      <ul>
        <li>Ebben az esetben az AppComponent kap egy példányt, de - a lenti példa szerint - a HomeComponent egy másik
          példányt fog megkapni</li>
        <pre>
          @Component(&#123;
            selector: 'app-details',
            templateUrl: './details.component.html',
            styleUrls: ['./details.component.scss'],
            providers: [ActionService]
          })
        </pre>
      </ul>
    </li>
    <li>Module szinten is tudunk service-t provide-olni
      <ul>
        <li>Minden direktíva, komponens ugyanazt a példányt fogja megkapni
          <ul>
            <li>Az adott modul összes komponense és az azokhoz tartozó gyerekkomponensek ugyanazt a példányt kapják meg
            </li>
            <li>Más modulok és komponensek (amelyek nem részei ennek a modulnak) nem férnek hozzá ehhez a példányhoz,
              hacsak nem importálják az adott modult</li>
          </ul>
        </li>
      </ul>
    </li>
    <br>
    <li>Standalone komponens esetében nincs modulunk, nem tudunk modul szinten provide-olni
      <ul>
        <li>Marad egyrészt a providedIn property</li>
        <li>Vagy a main.ts fájlban, amikor bootstrap-eljük az AppComponent-et, mintt root komponenst, megadhatunk egy
          második argomentumot
          <ul>
            <li>Objektum</li>
            <li>Provide-olhatjuk a szervizeinket</li>
            <pre>
              <b>// main.ts</b>
              bootstrapApplication(AppComponent, &#123;
                providers: [
                  ArtionService
                ]
              });
            </pre>
            <li>Egyenlő azzal, mintha NgModule-ból provide-olnánk service-t</li>
            <li>E módon minden komponensben, direktívában ugyanaz a service class példány lesz elérhető</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h5 #routingandlazyloadingwithstandalonecomponents data-anchor="routingandlazyloadingwithstandalonecomponents">
    Routing and lazy loading with stand alone components
  </h5>
  <ul>
    <li>Tételezzük fel az alábbiakat
      <ul>
        <li>Így néznek ki a jelenleg számunkra fontosabb fájlok</li>
        <pre>
          <b>// app-routing.ts</b>
          export const APP_ROUTES: Route[] = [ // exportáljuk a változót, és Routes helyett Route class tömbött használunk
            &#123;path: '', component: HomeComponent},
            &#123;path: 'about', loadComponent: () => import(./about/about.component).then(comp => comp.AboutComponent)},
            &#123;path: 'list', loadChildren: () => import(./list/list-routing).then(mod => mod.LIST_ROUTES)},
          ]

          /* @NgModule(&#123; teljes standalone app-nál nincs module class
            imports: [RouterModule.forRoot(routes)],
            exports: [AppRoutingModule]
          })
          export class AppRoutingModule &#123;
          } */ 

          <b>// list-routing.ts</b>
          export const LIST_ROUTES: Route[] = [ // export, és nem Routes típusú, mint szokás szerint
            &#123;path: '', component: ListComponent},
            &#123;path: 'item', component: ItemComponent},
          ]

          /* @NgModule(&#123; // nem szükséges, csak exportáljuk a route-okat
            imports: [RouterModule.forChild(routes)],
            exports: [ListRoutingModule] // ezt a module-t importáltuk lazy loading-hoz
          })
          export class ListRoutingModule &#123;
          } */

          <b>// main.ts</b>
          bootstrapApplication(AppComponent, &#123;
            providers: [
              ArtionService,
              provideRouter(APP_ROUTES) // az app-routing route-jairól tájékoztatja az Angular-t
            ]
          });

          <b>// app.component.html</b>
          &#60;header>
            &#60;nav>
              &#60;ul>
                &#60;li>&#60;a [routerLink]="'/'">Home&#60;/a>&#60;/li>
                &#60;li>&#60;a [routerLink]="'/about'">About&#60;/a>&#60;/li>
                &#60;li>&#60;a [routerLink]="'/list'">List&#60;/a>&#60;/li>
              &#60;/ul>
            &#60;/nav>
          &#60;/header>

          &#60;main>
            &#60;router-outlet>&#60;/router-outlet>
          &#60;/main>

          <b>// app.component.ts</b>
          @Component (&#123;
            standalone: true,
            imports: [HomeComponent, RouterModule], // itt importáljuk a RouterModule-t
            selector: 'app-root',
            templateUrl: './app.component.html',
            styleUrls: ['./app.component.css'],
          })
          export class AppComponent &#123; }

          <b>// about.component.ts</b>
          @Component(&#123;
            standalone: true,
            selector: 'app-about' ,
            templateUrl: './about.component.html'
          export class AboutComponent &#123; }

          <b>// item.component.ts</b>
          @Component(&#123;
            standalone: true,
            selector: 'app-item' ,
            templateUrl: './item.component.html'
          export class ItemComponent &#123; }

          <b>// list.component.ts</b>
          @Component(&#123;
            standalone: true,
            selector: 'app-list' ,
            templateUrl: './list.component.html'
          export class ListComponent &#123; }

          <b>// list.module.ts</b> // akkor lenne rá szükség, ha a lista nem standalone komponens lenne
          /* @NgModule(&#123;
            declarations: [ListComponent],
            imports: [RouterModule],
            selector: 'app-list',
            standalone: true
          })

          export class ListModule &#123; } */
        </pre>
      </ul>
    </li>
    <li>Az alkalmazás indítása a bootstrapApplication segítségével történik (Standalone API)</li>
    <li>Lazy loadinggal töltjük be a list modult</li>
    <li>Egyáltalán nincs app modulunk</li>
    <li>A lazy loading standalone komponenseknél is működik</li>
    <li>Standalone komponenssé konvertálás után nincs szükség route-beli change-ekre</li>
    <li>Az importProvidersFrom(AppRoutingModule) biztosítja, hogy az AppRoutingModule szolgáltatásai és útvonalai
      elérhetőek legyenek az alkalmazásban</li>
    <li>Komponens lazy módon való betöltéséhez a loadComponent kulcsot szükséges használni
      <ul>
        <li>Ezt a szintaxist a standalone komponensekkel együtt mutatták be</li>
        <li>Szabványos komponenst így nem lehet betölteni</li>
      </ul>
    </li>
    <li>Az eredmény kevesebb boilerplate kód</li>
    <li>Az app-routing.module.ts-től is sikerült megszabadulni</li>
  </ul>
</div>